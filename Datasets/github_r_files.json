{
    "Extremes.R": "### =========================================================================\n### The pmax(), pmin(), pmax.int() and pmin.int() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on 'na.rm'.\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\n### setGeneric() cannot be used on \"max\" and \"min\":\n###   > setGeneric(\"max\", signature=\"...\")\n###   Error in setGeneric(\"max\", signature = \"...\") : \n###     \u2018max\u2019 is a primitive function;  methods can be defined, but the\n###   generic function is implicit, and cannot be changed.\n#setGeneric(\"max\", signature=\"...\")\n#setGeneric(\"min\", signature=\"...\")\n\nsetGeneric(\"pmax\", signature=\"...\")\n\nsetGeneric(\"pmin\", signature=\"...\")\n\nsetGeneric(\"pmax.int\", signature=\"...\")\n\nsetGeneric(\"pmin.int\", signature=\"...\")\n\n",
    "IQR.R": "### =========================================================================\n### The IQR() generic\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"IQR\", signature=\"x\")\n",
    "Ontology.R": "### =========================================================================\n### The Ontology() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"Ontology\", function(object) standardGeneric(\"Ontology\"))\n\n",
    "S3-classes-as-S4-classes.R": "### =========================================================================\n### S3 classes as S4 classes\n### -------------------------------------------------------------------------\n###\n### We register some old-style (aka S3) classes as formally defined (aka S4)\n### classes. This allows S4 methods defined in Bioconductor packages to use\n### them in their signatures. Note that dispatch still works without this\n### registration but causes 'R CMD INSTALL' to (gently) complain.\n\n### connection class and subclasses\n.connectionClasses <- c(\"file\", \"url\", \"gzfile\", \"bzfile\", \"unz\", \"pipe\",\n                        \"fifo\", \"sockconn\", \"terminal\", \"textConnection\",\n                        \"gzcon\")\napply(cbind(.connectionClasses, \"connection\"), 1, setOldClass,\n      where = environment())\n\nsetClassUnion(\"character_OR_connection\", c(\"character\", \"connection\"))\n\n### others\nsetOldClass(\"AsIs\")\n\n#setOldClass(\"xtabs\", \"table\")  # this seems to cause problems when installing\n                                # IRanges:\n                                # Warning: replacing previous import\n                                # \u2018.__C__table\u2019 when loading \u2018BiocGenerics\u2019\n\nsetOldClass(\"dist\")\n\n",
    "annotation.R": "### =========================================================================\n### The annotation() and `annotation<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"annotation\", \n    function(object, ...) standardGeneric(\"annotation\")\n)\n\nsetGeneric(\"annotation<-\", \n    function(object, ..., value) standardGeneric(\"annotation<-\")\n)\n\n",
    "aperm.R": "### =========================================================================\n### The aperm() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::aperm is an S3 generic.\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('a', 'perm'). Here we set dispatch on\n### the 1st arg (the 'a' arg) only!\n\nsetGeneric(\"aperm\", signature=\"a\")\n\n",
    "append.R": "### =========================================================================\n### The append() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('x', 'values', 'after'). Here we set\n### dispatch on the first two args (the 'x' and 'values' args) only!\n\nsetGeneric(\"append\", signature=c(\"x\", \"values\"))\n\n",
    "as.data.frame.R": "### =========================================================================\n### The as.data.frame() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::as.data.frame is an S3 generic.\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"as.data.frame\", signature=\"x\")\n\n",
    "as.list.R": "### =========================================================================\n### The as.list() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::as.list is an S3 generic.\n\nsetGeneric(\"as.list\")\n\n",
    "as.vector.R": "### =========================================================================\n### The as.vector() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('x', 'mode'). Here we set dispatch on\n### the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"as.vector\", signature=\"x\")\n\n",
    "boxplot.R": "### =========================================================================\n### The boxplot() generic\n### -------------------------------------------------------------------------\n###\n### Note that graphics::boxplot is an S3 generic.\n\nsetGeneric(\"boxplot\")\n\n",
    "cbind.R": "### =========================================================================\n### The cbind() and rbind() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on 'deparse.level'.\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"cbind\", signature=\"...\")\n\nsetGeneric(\"rbind\", signature=\"...\")\n\n",
    "combine.R": "### =========================================================================\n### The combine() generic\n### -------------------------------------------------------------------------\n###\n### A \"combine\" default method + methods for some standard types are\n### also provided.\n###\n\nsetGeneric(\"combine\",\n    function(x, y, ...)\n    {\n        if (length(list(...)) > 0L) {\n            combine(x, do.call(combine, list(y, ...)))\n        } else {\n            standardGeneric(\"combine\")\n        }\n    }\n)\n\nsetMethod(\"combine\", c(\"ANY\", \"missing\"), function(x, y, ...) x)\n\nsetMethod(\"combine\", c(\"data.frame\", \"data.frame\"),\n    function(x, y, ...)\n    {\n        if (all(dim(x) == 0L) && all(dim(y) == 0L))\n                return(x)\n        else if (all(dim(x) == 0L)) return(y)\n        else if (all(dim(y) == 0L)) return(x)\n\n        uniqueRows <- unique(c(row.names(x), row.names(y)))\n        uniqueCols <- unique(c(names(x), names(y)))\n        sharedCols <- intersect(names(x), names(y))\n\n        ## check possible to combine\n        alleq <- function(x, y) {\n            res <- all.equal(x, y, check.attributes=FALSE)\n            if (!is.logical(res)) {\n                warning(res)\n                FALSE\n            } else TRUE\n        }\n        sharedRows <- intersect(row.names(x), row.names(y))\n        ok <- sapply(sharedCols,\n            function(nm) {\n                if (!all(class(x[[nm]]) == class(y[[nm]])))\n                    return(FALSE)\n                switch(class(x[[nm]])[[1L]],\n                       factor={\n                           if (!alleq(levels(x[[nm]]), levels(y[[nm]]))) {\n                               warning(\"data frame column '\", nm,\n                                       \"' levels not all.equal\",\n                                       call.=FALSE)\n                               TRUE\n                           } else if (!alleq(x[sharedRows, nm, drop=FALSE],\n                                             y[sharedRows, nm, drop=FALSE])) {\n                               warning(\"data frame column '\", nm,\n                                       \"' shared rows not all equal\",\n                                       call.=FALSE)\n                               FALSE\n                           } else TRUE\n                       },\n                       ## ordered and non-factor columns need to\n                       ## satisfy the following identity; it seems\n                       ## possible that ordered could be treated\n                       ## differently, but these have not been\n                       ## encountered.\n                       ordered=,\n                       if (!alleq(x[sharedRows, nm, drop=FALSE],\n                                  y[sharedRows, nm, drop=FALSE])) {\n                           warning(\"data frame column '\", nm,\n                                   \"' shared rows not all equal\")\n                           FALSE\n                       } else TRUE)\n              })\n        if (!all(ok))\n            stop(\"data.frames contain conflicting data:\",\n                 \"\\n\\tnon-conforming colname(s): \",\n                 paste(sharedCols[!ok], collapse=\", \"))\n\n        ## x or y with zero rows -- make palatable to merge, but drop\n        ## before return\n        if (length(uniqueRows) == 0L) {\n            x <- x[\"tmp\",,drop=FALSE]\n            y <- y[\"tmp\",,drop=FALSE]\n        } else if (nrow(x) == 0L) {\n            x <- x[row.names(y),,drop=FALSE]\n            row.names(x) <- row.names(y)\n        } else if (nrow(y) == 0L) {\n            y <- y[row.names(x),,drop=FALSE]\n            row.names(y) <- row.names(x)\n        }\n\n        ## make colnames of merged data robust\n        if (length(uniqueCols) > 0L)\n            extLength <- max(nchar(sub(\".*\\\\.\", \"\", uniqueCols))) + 1L\n        else extLength <- 1L\n        extX <- paste(c(\".\", rep(\"x\", extLength)), collapse=\"\")\n        extY <- paste(c(\".\", rep(\"y\", extLength)), collapse=\"\")\n        z <- merge(x, y, by=\"row.names\", all=TRUE, suffixes=c(extX, extY))\n\n        ## shared cols\n        for (nm in sharedCols) {\n            nmx <- paste(nm, extX, sep=\"\")\n            nmy <- paste(nm, extY, sep=\"\")\n            z[[nm]] <-\n              switch(class(z[[nmx]])[[1]],\n                     AsIs=I(ifelse(is.na(z[[nmx]]), z[[nmy]], z[[nmx]])),\n                     factor={\n                         col <- ifelse(is.na(z[[nmx]]),\n                                       as.character(z[[nmy]]),\n                                       as.character(z[[nmx]]))\n                         if (!identical(levels(z[[nmx]]), levels(z[[nmy]])))\n                             factor(col)\n                         else\n                             factor(col, levels=levels(z[[nmx]]))\n                     },\n                     {\n                         col <- ifelse(is.na(z[[nmx]]), z[[nmy]], z[[nmx]])\n                         class(col) <- class(z[[nmx]])\n                         col\n                     })\n        }\n\n        ## tidy\n        row.names(z) <- if (is.integer(attr(x, \"row.names\")) &&\n                            is.integer(attr(y, \"row.names\")))\n                            as.integer(z$Row.names)\n                        else\n                            z$Row.names\n        z$Row.names <- NULL\n        z[uniqueRows, uniqueCols, drop=FALSE]\n    }\n)\n\nsetMethod(\"combine\", c(\"matrix\", \"matrix\"),\n    function(x, y, ...)\n    {\n        if (length(y) == 0L)\n            return(x)\n        else if (length(x) == 0L)\n            return(y)\n        if (mode(x) != mode(y))\n            stop(\"matrix modes \", mode(x), \", \", mode(y), \" differ\")\n        if (typeof(x) != typeof(y))\n            warning(\"matrix typeof \", typeof(x), \", \", typeof(y), \" differ\")\n        xdim <- dimnames(x)\n        ydim <- dimnames(y)\n        if (is.null(xdim) || is.null(ydim) ||\n            any(sapply(xdim, is.null)) ||\n            any(sapply(ydim, is.null)))\n            stop(\"matricies must have dimnames for 'combine'\")\n        sharedRows <- intersect(xdim[[1L]], ydim[[1L]])\n        sharedCols <- intersect(xdim[[2L]], ydim[[2L]])\n        ok <- all.equal(x[sharedRows, sharedCols], y[sharedRows, sharedCols])\n        if (!isTRUE(ok))\n            stop(\"matrix shared row and column elements differ: \", ok)\n        unionRows <- union(xdim[[1L]], ydim[[1L]])\n        unionCols <- union(xdim[[2L]], ydim[[2L]])\n\n        m <- matrix(new(class(as.vector(x))),\n                    nrow=length(unionRows), ncol=length(unionCols),\n                    dimnames=list(unionRows, unionCols))\n        m[rownames(x), colnames(x)] <- x\n        m[rownames(y), colnames(y)] <- y\n        m\n    }\n)\n\n",
    "containsOutOfMemoryData.R": "### =========================================================================\n### The containsOutOfMemoryData() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"containsOutOfMemoryData\",\n    function(object) standardGeneric(\"containsOutOfMemoryData\")\n)\n\n.S4_object_contains_out_of_memory_data <- function(object)\n{\n    slot_names <- slotNames(class(object))\n    for (name in slot_names) {\n        if (containsOutOfMemoryData(slot(object, name)))\n            return(TRUE)\n    }\n    FALSE\n}\n\n.list_contains_out_of_memory_data <- function(object)\n{\n    for (x in object) {\n        if (containsOutOfMemoryData(x))\n            return(TRUE)\n    }\n    FALSE\n}\n\n.environment_contains_out_of_memory_data <- function(object)\n{\n    for (name in names(object)) {\n        if (containsOutOfMemoryData(object[[name]]))\n            return(TRUE)\n    }\n    FALSE\n}\n\nsetMethod(\"containsOutOfMemoryData\", \"ANY\",\n    function(object)\n    {\n        if (isS4(object))\n            return(.S4_object_contains_out_of_memory_data(object))\n        FALSE\n    }\n)\n\nsetMethod(\"containsOutOfMemoryData\", \"list\",\n    .list_contains_out_of_memory_data\n)\n\nsetMethod(\"containsOutOfMemoryData\", \"environment\",\n    .environment_contains_out_of_memory_data\n)\n\nsetClass(\"OutOfMemoryObject\", representation(\"VIRTUAL\"))\n\nsetMethod(\"containsOutOfMemoryData\", \"OutOfMemoryObject\",\n    function(object) TRUE\n)\n\n",
    "dbconn.R": "### =========================================================================\n### The dbconn() and dbfile() generics\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"dbconn\", function(x) standardGeneric(\"dbconn\"))\n\nsetGeneric(\"dbfile\", function(x) standardGeneric(\"dbfile\"))\n",
    "density.R": "### =========================================================================\n### The density() generic\n### -------------------------------------------------------------------------\n###\n### Note that stats::density is an S3 generic.\n\nsetGeneric(\"density\")\n\n",
    "dge.R": "# Currently, these are for DESeq and DEXSeq. Could be extended to a more general\n#  infrastructure for count datasets.\nsetGeneric(\"counts\",        function(object, ...)        standardGeneric(\"counts\"))\nsetGeneric(\"counts<-\",      function(object, ..., value) standardGeneric(\"counts<-\"))\nsetGeneric(\"dispTable\",     function(object, ...)        standardGeneric(\"dispTable\"))\nsetGeneric(\"dispTable<-\",   function(object, ..., value) standardGeneric(\"dispTable<-\"))\nsetGeneric(\"sizeFactors\",   function(object, ...)        standardGeneric(\"sizeFactors\"))\nsetGeneric(\"sizeFactors<-\", function(object, ..., value) standardGeneric(\"sizeFactors<-\"))\n\nsetGeneric(\"conditions\",    function(object, ...)        standardGeneric(\"conditions\"))\nsetGeneric(\"conditions<-\",  function(object, ..., value) standardGeneric(\"conditions<-\"))\nsetGeneric(\"design\",        function(object, ...)        standardGeneric(\"design\"))\nsetGeneric(\"design<-\",      function(object, ..., value) standardGeneric(\"design<-\"))\n\nsetGeneric(\"estimateSizeFactors\", function(object, ...) standardGeneric(\"estimateSizeFactors\"))\nsetGeneric(\"estimateDispersions\", function(object, ...) standardGeneric(\"estimateDispersions\"))\nsetGeneric(\"plotDispEsts\", function(object, ...) standardGeneric(\"plotDispEsts\"))\n\n",
    "dims.R": "### =========================================================================\n### The dims(), nrows() and ncols() generics\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"dims\", signature=\"x\",\n    function(x, use.names=TRUE) standardGeneric(\"dims\")\n)\n\nsetGeneric(\"nrows\", signature=\"x\",\n    function(x, use.names=TRUE) standardGeneric(\"nrows\")\n)\n\nsetGeneric(\"ncols\", signature=\"x\",\n    function(x, use.names=TRUE) standardGeneric(\"ncols\")\n)\n\n",
    "do.call.R": "### =========================================================================\n### The do.call() generic\n### -------------------------------------------------------------------------\n\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st and 2nd args only!\n\nsetGeneric(\"do.call\", signature=c(\"what\", \"args\"))\n\n",
    "duplicated.R": "### =========================================================================\n### The duplicated() and anyDuplicated() generics\n### -------------------------------------------------------------------------\n###\n### Note that base::duplicated and base::anyDuplicated are S3 generics.\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on ('x', 'incomparables'). Here we set\n### dispatch on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"duplicated\", signature=\"x\")\n\nsetGeneric(\"anyDuplicated\", signature=\"x\")\n\n",
    "eval.R": "### =========================================================================\n### The eval() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the first two args (the 'expr' and 'envir' args) only!\n\nsetGeneric(\"eval\", signature=c(\"expr\", \"envir\"),\n    function(expr, envir=parent.frame(),\n                   enclos=if (is.list(envir) || is.pairlist(envir))\n                          parent.frame() else baseenv())\n    {\n        force(envir)\n        force(enclos)\n        standardGeneric(\"eval\")\n    }\n)\n\nevalq <- function(expr, envir = parent.frame(),\n                  enclos = if (is.list(envir) || is.pairlist(envir))\n                  parent.frame() else baseenv())\n  eval(substitute(expr), envir, enclos)\n",
    "fileName.R": "### =========================================================================\n### The fileName() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"fileName\", function(object, ...) standardGeneric(\"fileName\"))\n\n",
    "format.R": "### =========================================================================\n### The format() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::format is an S3 generic.\n\nsetGeneric(\"format\")\n\n### The base package doesn't define a specific format() method for list\n### objects and format.default() does a poor job on a list:\n###\n###   > format(list(1:10))\n###   [1] \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10\"\n###   > library(IRanges)\n###   > format(list(IRanges(1, 8:9)))\n###   Error in h(simpleError(msg, call)) :\n###     error in evaluating the argument 'obj' in selecting a method for\n###     function 'unname': IRanges objects don't support [[, as.list(),\n###     lapply(), or unlist() at the moment\n###\n### OTOH format.AsIs() does a good job with lists:\n###\n###   > format.AsIs(list(1:10))\n###   [1] \"1, 2, 3,....\"\n###   > format.AsIs(list(IRanges(1, 8:9)))\n###   [1] \"1-8, 1-9\"\n###\n### So we define a format() **S3** method for list objects that does that.\nformat.list <- base::format.AsIs\n\n",
    "funprog.R": "### =========================================================================\n### The Reduce(), Filter(), Find(), Map() and Position() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the 2nd arg (the 'x' or '...' arg) only!\n\nsetGeneric(\"Reduce\", signature=\"x\")\n\nsetGeneric(\"Filter\", signature=\"x\")\n\nsetGeneric(\"Find\", signature=\"x\")\n\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\nsetGeneric(\"Map\", signature=\"...\")\n\nsetGeneric(\"Position\", signature=\"x\")\n\n",
    "get.R": "### =========================================================================\n### The get() and mget() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the first 3 args ('x', 'pos', 'envir') for get(), and on the\n### first 2 args ('x', 'envir') for mget().\n\nsetGeneric(\"get\", signature=c(\"x\", \"pos\", \"envir\"))\n\nsetGeneric(\"mget\", signature=c(\"x\", \"envir\"))\n\n",
    "grep.R": "### =========================================================================\n### The grep() and grepl() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the first 2 args ('pattern', 'x').\n\nsetGeneric(\"grep\", signature = c(\"pattern\", \"x\"))\n\nsetGeneric(\"grepl\", signature = c(\"pattern\", \"x\"))\n",
    "image.R": "### =========================================================================\n### The image() generic\n### -------------------------------------------------------------------------\n###\n### Note that graphics::image is an S3 generic.\n\nsetGeneric(\"image\")\n\n",
    "is.unsorted.R": "### =========================================================================\n### The is.unsorted() generic\n### -------------------------------------------------------------------------\n\n### base::is.unsorted() doesn't have the ellipsis. We add it to the generic\n### function defined below so methods can support additional arguments (e.g.\n### the 'ignore.strand' argument for the method for GenomicRanges objects).\n\n.is.unsorted.useAsDefault <- function(x, na.rm=FALSE, strictly=FALSE, ...)\n    base::is.unsorted(x, na.rm=na.rm, strictly=strictly, ...)\n\nsetGeneric(\"is.unsorted\", signature=\"x\",\n    function(x, na.rm=FALSE, strictly=FALSE, ...)\n        standardGeneric(\"is.unsorted\"),\n    useAsDefault=.is.unsorted.useAsDefault\n)\n\n",
    "lapply.R": "### =========================================================================\n### The lapply() and sapply() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the 1st arg (the 'X' arg) only!\n\nsetGeneric(\"lapply\", signature=\"X\")\n\nsetGeneric(\"sapply\", signature=\"X\")\n\n",
    "longForm.R": "### =========================================================================\n### The longForm() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"longForm\",\n    function(object, ...) standardGeneric(\"longForm\")\n)\n\n",
    "mad.R": "### =========================================================================\n### The mad() generic\n### -------------------------------------------------------------------------\n###\n### Dispatches only on 'x'\n###\n\nsetGeneric(\"mad\", signature=\"x\")\n",
    "mapply.R": "### =========================================================================\n### The mapply() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 2nd arg (the '...' arg) only!\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"mapply\", signature=\"...\")\n\n",
    "match.R": "### =========================================================================\n### The match() generic\n### -------------------------------------------------------------------------\n###\n### base::match() doesn't have the ... argument. We add it to the generic\n### function defined here. We also set dispatch on the first two args (the\n### 'x' and 'table' args) only!\n\n.match.useAsDefault <-\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n        base::match(x, table, nomatch=nomatch, incomparables=incomparables, ...)\n\nsetGeneric(\"match\", signature=c(\"x\", \"table\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n        standardGeneric(\"match\"),\n    useAsDefault=.match.useAsDefault\n)\n\nsetGeneric(\"%in%\", function(x, table) standardGeneric(\"%in%\"))\n\n",
    "mean.R": "### -------------------------------------------------------------------------\n### The mean() generic\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"mean\")\n",
    "normalize.R": "### =========================================================================\n### The normalize() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"normalize\",\n    function(object, ...) standardGeneric(\"normalize\")\n)\n\n",
    "normarg-utils.R": "### =========================================================================\n### Utility functions for checking/fixing user-supplied arguments\n### -------------------------------------------------------------------------\n\n### NOTE: The stuff in this file (not exported) is a copy/paste of some of\n### the functions in S4Vectors but it doesn't really belong to BiocGenerics.\n### It seems that the only reason for having it duplicated here is that it's\n### used by the stuff in the update-utils.R file. However the stuff in\n### update-utils.R doesn't really belong to BiocGenerics either!\n###\n### TODO: This stuff would need to be moved to a more appropriate place (when\n### we have one), and then we should get rid of the duplication between the\n### functions below and the same functions in S4Vectors.\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### For checking only.\n###\n\nisTRUEorFALSE <- function(x)\n{\n  is.logical(x) && length(x) == 1L && !is.na(x)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Handling variadic calls\n###\n\nextraArgsAsList <- function(.valid.argnames, ...)\n{\n  args <- list(...)\n  argnames <- names(args)\n  if (length(args) != 0L\n      && (is.null(argnames) || any(argnames %in% c(\"\", NA))))\n    stop(\"all extra arguments must be named\")\n  if (!is.null(.valid.argnames) && !all(argnames %in% .valid.argnames))\n    stop(\"valid extra argument names are \",\n         paste(\"'\", .valid.argnames, \"'\", sep=\"\", collapse=\", \"))\n  if (anyDuplicated(argnames))\n    stop(\"argument names must be unique\")\n  args\n}\n",
    "nrow.R": "### =========================================================================\n### The nrow(), ncol(), NROW() and NCOL() generics\n### -------------------------------------------------------------------------\n\n### The corresponding functions are standard functions defined in the base\n### package.\n\nsetGeneric(\"nrow\")\nsetGeneric(\"ncol\")\nsetGeneric(\"NROW\")\nsetGeneric(\"NCOL\")\n\n",
    "order.R": "### =========================================================================\n### The order() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('na.last', 'decreasing', 'method').\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"order\", signature=\"...\")\n\n",
    "organism_species.R": "### =========================================================================\n### The organism(), `organism<-`(), species(), and `species<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"organism\", function(object) standardGeneric(\"organism\"))\n\nsetGeneric(\"organism<-\", signature=\"object\",\n    function(object, value) standardGeneric(\"organism<-\")\n)\n\nsetGeneric(\"species\", function(object) standardGeneric(\"species\"))\n\nsetGeneric(\"species<-\", signature=\"object\",\n    function(object, value) standardGeneric(\"species<-\")\n)\n\n",
    "paste.R": "### =========================================================================\n### The paste() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('sep', 'collapse').\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"paste\", signature=\"...\")\n\n",
    "paste2.R": "### =========================================================================\n### The paste2() generic and add_prefix()/add_suffix() wrappers\n### -------------------------------------------------------------------------\n###\n\n\n### A binary paste0() that follows the same rules as arithmetic operations\n### (+, *, etc...) for recycling and propagation of names, dimensions, and\n### dimnames.\n### Recycling: The longer argument wins i.e. the shorter argument is\n### recycled to the length of the longer with a warning if the length of the\n### latter is not a multiple of the length of the former. Exception: if one\n### of the two arguments has length 0 then no recycling is performed and a\n### zero-length vector is returned.\n### Name propagation: The longer argument also wins. If the 2 arguments\n### have the same length then the names on the first argument are propagated,\n### if any. Otherwise the names on the second argument are propagated, if\n### any.\nsetGeneric(\"paste2\", function(x, y) standardGeneric(\"paste2\"))\n\n.paste2_vector_vector <- function(x, y)\n{\n    stopifnot(is.character(x), is.character(y))\n\n    x_len <- length(x)\n    y_len <- length(y)\n\n    ## Zero-length case.\n    if (x_len == 0L) {\n        if (y_len == 0L && is.null(names(x)))\n            names(x) <- names(y)  # NULL or character(0)\n        return(x)\n    }\n    if (y_len == 0L)\n        return(y)\n\n    ## Non zero-length case.\n    ans <- paste0(x, y)\n    warn_msg <- c(\"longer object length is not a \",\n                  \"multiple of shorter object length\")\n    if (x_len > y_len) {\n        if (x_len %% y_len != 0L)\n            warning(warn_msg)\n        ans_names <- names(x)\n    } else if (x_len < y_len) {\n        if (y_len %% x_len != 0L)\n            warning(warn_msg)\n        ans_names <- names(y)\n    } else {\n        ans_names <- names(x)\n        if (is.null(ans_names))\n            ans_names <- names(y)\n    }\n    setNames(ans, ans_names)\n}\n\n### Returns an array of same dimensions and dimnames as 'x' **except** when\n### length(y) == 0 and length(x) != 0.\n.paste2_array_vector <- function(x, y, switch=FALSE)\n{\n    stopifnot(is.array(x), is.character(y))\n\n    x_len <- length(x)\n    y_len <- length(y)\n\n    ## Zero-length case.\n    if (x_len == 0L) {\n        if (storage.mode(x) != \"character\")\n            storage.mode(x) <- \"character\"\n        return(x)\n    }\n    if (y_len == 0L)\n        return(y)  # only case where we don't return an array\n\n    ## Non zero-length case.\n    if (y_len > x_len)\n        stop(\"non-array object is longer than array object\")\n    ans <- if (switch) paste0(y, x) else paste0(x, y)\n    warn_msg <- c(\"longer object length is not a \",\n                  \"multiple of shorter object length\")\n    if (x_len %% y_len != 0L)\n        warning(warn_msg)\n    dim(ans) <- dim(x)\n    dimnames(ans) <- dimnames(x)\n    ans\n}\n\n.paste2_array_array <- function(x, y)\n{\n    stopifnot(is.array(x), is.array(y))\n\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!(length(x_dim) == length(y_dim) && all(x_dim == y_dim)))\n        stop(\"non-conformable arrays\")\n\n    x_len <- length(x)  # same as length(y)\n\n    ## Zero-length case.\n    if (x_len == 0L) {\n        if (storage.mode(x) != \"character\")\n            storage.mode(x) <- \"character\"\n        if (is.null(dimnames(x)))\n            dimnames(x) <- dimnames(y)\n        return(x)\n    }\n\n    ## Non zero-length case.\n    ans <- paste0(x, y)\n    dim(ans) <- x_dim\n    ans_dimnames <- dimnames(x)\n    if (is.null(ans_dimnames))\n        ans_dimnames <- dimnames(y)\n    dimnames(ans) <- ans_dimnames\n    ans\n}\n\nsetMethod(\"paste2\", c(\"ANY\", \"ANY\"),\n    function(x, y)\n    {\n        ## Turn both arguments into character vectors.\n        if (!is.character(x))\n            x <- setNames(as.character(x), names(x))\n        if (!is.character(y))\n            y <- setNames(as.character(y), names(y))\n        .paste2_vector_vector(x, y)\n    }\n)\n\nsetMethod(\"paste2\", c(\"array\", \"ANY\"),\n    function(x, y)\n    {\n        if (!is.character(y))\n            y <- setNames(as.character(y), names(y))\n        .paste2_array_vector(x, y)\n    }\n)\n\nsetMethod(\"paste2\", c(\"ANY\", \"array\"),\n    function(x, y)\n    {\n        if (!is.character(x))\n            x <- setNames(as.character(x), names(x))\n        .paste2_array_vector(y, x, switch=TRUE)\n    }\n)\n\nsetMethod(\"paste2\", c(\"array\", \"array\"),\n    function(x, y) .paste2_array_array(x, y)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### add_prefix(), add_suffix()\n###\n\nadd_prefix <- function(x, prefix=\"\") paste2(prefix, x)\n\nadd_suffix <- function(x, suffix=\"\") paste2(x, suffix)\n\n",
    "path.R": "### =========================================================================\n### The path(), basename(), and dirname() getters/setters\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### path() getter and setter\n###\n\nsetGeneric(\"path\", function(object, ...) standardGeneric(\"path\"))\nsetGeneric(\"path<-\", signature=\"object\",\n    function(object, ..., value) standardGeneric(\"path<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### basename() and dirname() getters and setters\n###\n### The basename() and dirname() functions defined in the base package\n### only take 1 argument. We add the ... argument to the generic functions\n### defined here so they can be called with additional arguments.\n###\n\n.basename.useAsDefault <- function(path, ...) base::basename(path, ...)\nsetGeneric(\"basename\",\n    function(path, ...) standardGeneric(\"basename\"),\n    useAsDefault=.basename.useAsDefault\n)\nsetGeneric(\"basename<-\", signature=\"path\",\n    function(path, ..., value) standardGeneric(\"basename<-\")\n)\n\n.dirname.useAsDefault <- function(path, ...) base::dirname(path, ...)\nsetGeneric(\"dirname\",\n    function(path, ...) standardGeneric(\"dirname\"),\n    useAsDefault=.dirname.useAsDefault\n)\nsetGeneric(\"dirname<-\", signature=\"path\",\n    function(path, ..., value) standardGeneric(\"dirname<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default basename() and dirname() getters\n###\n### The purpose of these methods is to make the basename() and dirname()\n### getters work out-of-the-box on any object for which the path()\n### getter works.\n###\n\nsetMethod(\"basename\", \"ANY\",\n    function(path, ...)\n    {\n        ## If 'path' inherits from character (e.g. 'path' is a glue object\n        ## as returned by something like 'glue::glue(\"some/path\")'), we must\n        ## return 'base::basename(path)'.\n        ## See https://github.com/Bioconductor/BiocGenerics/issues/10\n        if (is.character(path) || !is.object(path)) {\n            ## We intentionally pass ... to cause failure if additional\n            ## arguments were supplied.\n            base::basename(path, ...)\n        } else {\n            base::basename(path(path, ...))\n        }\n    }\n)\n\nsetMethod(\"dirname\", \"ANY\",\n    function(path, ...)\n    {\n        ## If 'path' inherits from character (e.g. 'path' is a glue object\n        ## as returned by something like 'glue::glue(\"some/path\")'), we must\n        ## return 'base::dirname(path)'.\n        if (is.character(path) || !is.object(path)) {\n            ## We intentionally pass ... to cause failure if additional\n            ## arguments were supplied.\n            base::dirname(path, ...)\n        } else {\n            base::dirname(path(path, ...))\n        }\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default basename() and dirname() setters\n###\n### The purpose of these replacement methods is to make the basename() and\n### dirname() setters work out-of-the-box on any object for which the path()\n### getter and setter work.\n###\n\nsetReplaceMethod(\"basename\", \"character\",\n    function(path, ..., value)\n    {\n        if (length(list(...)) != 0L) {\n            dots <- match.call(expand.dots=FALSE)[[3L]]\n            stop(unused_arguments_msg(dots))\n        }\n        path_len <- length(path)\n        path <- setNames(file.path(dirname(path), value), names(path))\n        if (length(path) != path_len)\n            stop(\"number of supplied basenames is incompatible \",\n                 \"with number of paths\")\n        path\n    }\n)\n\nsetReplaceMethod(\"basename\", \"ANY\",\n    function(path, ..., value)\n    {\n        ppath <- path(path)\n        basename(ppath, ...) <- value\n        path(path) <- ppath\n        path\n    }\n)\n\nsetReplaceMethod(\"dirname\", \"character\",\n    function(path, ..., value)\n    {\n        if (length(list(...)) != 0L) {\n            dots <- match.call(expand.dots=FALSE)[[3L]]\n            stop(unused_arguments_msg(dots))\n        }\n        path_len <- length(path)\n        path <- setNames(file.path(value, basename(path)), names(path))\n        if (length(path) != path_len)\n            stop(\"number of supplied dirnames is incompatible \",\n                 \"with number of paths\")\n        path\n    }\n)\n\nsetReplaceMethod(\"dirname\", \"ANY\",\n    function(path, ..., value)\n    {\n        ppath <- path(path)\n        dirname(ppath, ...) <- value\n        path(path) <- ppath\n        path\n    }\n)\n\n",
    "plotMA.R": "setGeneric(\"plotMA\", function(object, ...) {\n    standardGeneric(\"plotMA\")\n})\n\nsetMethod(\"plotMA\", signature=\"ANY\", \n  definition = function(object, ...) {\n     msg = sprintf(\"Error from the generic function 'plotMA' defined in package 'BiocGenerics': no S4 method definition for argument '%s' of class '%s' was found. Did you perhaps mean calling the function 'plotMA' from another package, e.g. 'limma'? In that case, please use the syntax 'limma::plotMA'.\",\n         deparse(substitute(object)), class(object))\n     stop(msg)\n })\n",
    "plotPCA.R": "setGeneric(\"plotPCA\", function(object, ...) {\n    standardGeneric(\"plotPCA\")\n})\n",
    "rank.R": "### =========================================================================\n### The rank() generic\n### -------------------------------------------------------------------------\n###\n\n### base::rank() doesn't have the ellipsis. We add it to the generic\n### function defined below so methods can support additional arguments (e.g.\n### the 'ignore.strand' argument for the method for GenomicRanges objects).\n\n.is.rank.useAsDefault <- function(x, na.last=TRUE,\n    ties.method=c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"), ...)\n{\n    base::rank(x, na.last=na.last, ties.method=ties.method, ...)\n}\n\nsetGeneric(\"rank\", signature=\"x\",\n    function(x, na.last=TRUE,\n        ties.method=c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"), ...)\n        standardGeneric(\"rank\"),\n    useAsDefault=.is.rank.useAsDefault\n)\n\n",
    "relist.R": "### =========================================================================\n### The relist() generic\n### -------------------------------------------------------------------------\n###\n### Note that utils::relist is an S3 generic.\n\nsetGeneric(\"relist\")\n\n",
    "rep.R": "### =========================================================================\n### The rep.int() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"rep.int\")\n\n",
    "replaceSlots.R": "### =========================================================================\n### Efficient multiple slots replacement of an S4 object\n### -------------------------------------------------------------------------\n###\n### From a caller point of views, replacement of the slots should feel atomic\n### i.e. the object gets validated only after all the slots have been replaced.\n###\n### NOTE: The stuff in this file (not exported) doesn't really belong to\n### BiocGenerics.\n###\n### TODO: This stuff would need to be moved to a more appropriate place (when\n### we have one).\n###\n\nunsafe_replaceSlots <- function(object, ..., .slotList=list())\n{\n    ## This function is no longer 'unsafe', in that it does not do\n    ## in-place modification via `slot<-()`; see\n    ## https://github.com/Bioconductor/BiocGenerics/pull/1\n    slots <- c(list(...), .slotList)\n    slots_names <- names(slots)\n    ## This is too slow. See further down for a much faster way to check\n    ## that the supplied slots exist.\n    #invalid_idx <- which(!(slots_names %in% slotNames(object)))\n    #if (length(invalid_idx) != 0L) {\n    #    in1string <- paste0(slots_names[invalid_idx], collapse=\", \")\n    #    stop(wmsg(\"invalid slot(s) for \", class(object), \" instance: \",\n    #              in1string))\n    #}\n    for (i in seq_along(slots)) {\n        slot_name <- slots_names[[i]]\n        if (slot_name == \"mcols\")\n            slot_name <- \"elementMetadata\"\n        ## Even if we won't make any use of 'old_slot_val', this is a very\n        ## efficient way to check that the supplied slot exists.\n        ## We need to check this because the slot() setter won't raise an error\n        ## in case of invalid slot name when used with 'check=FALSE'. It will\n        ## silently be a no-op!\n        old_slot_val <- slot(object, slot_name) # check slot existence\n        slot_val <- slots[[i]]\n        ## Too risky! identical() is not reliable enough e.g. with objects\n        ## that contain external pointers. For example, DNAStringSet(\"A\")\n        ## and DNAStringSet(\"T\") are considered to be identical! identical()\n        ## would first need to be fixed.\n        #if (identical(old_slot_val, slot_val))\n        #    next\n        slot(object, slot_name, check=FALSE) <- slot_val\n    }\n    object\n}\n\n### replaceSlots() is essentially a more efficient initialize(), especially\n### when called with 'check=FALSE'.\nreplaceSlots <- function(object, ..., check=TRUE)\n{\n    if (!isTRUEorFALSE(check)) \n        stop(\"'check' must be TRUE or FALSE\")\n    object <- unsafe_replaceSlots(object, ...)\n    if (check)\n        validObject(object)\n    object\n}\n\n",
    "residuals.R": "### =========================================================================\n### The residuals() generic\n### -------------------------------------------------------------------------\n###\n### Note that stats::residuals is an S3 generic.\n\nsetGeneric(\"residuals\")\n\n",
    "row_colnames.R": "### =========================================================================\n### The rownames() and colnames() generics\n### -------------------------------------------------------------------------\n###\n\n### Dispatch on the 1st arg (the 'x' arg) only!\nsetGeneric(\"rownames\", signature=\"x\")\n\nsetGeneric(\"rownames<-\")\n\n### Dispatch on the 1st arg (the 'x' arg) only!\nsetGeneric(\"colnames\", signature=\"x\")\n\nsetGeneric(\"colnames<-\")\n\n",
    "saveRDS.R": "### =========================================================================\n### The saveRDS() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic\n### in package \"base\" would dispatch on all its argument ('object', 'file',\n### 'ascii', etc...). Here we set dispatch on the 1st arg (the 'object' arg)\n### only!\n\nsetGeneric(\"saveRDS\", signature=\"object\")\n\n### Note that this overwrites base::saveRDS()!\nsetMethod(\"saveRDS\", \"ANY\",\n    function(object, file=\"\", ascii=FALSE, version=NULL,\n             compress=TRUE, refhook=NULL)\n    {\n        ## Only a warning for now. Should we make this an error?\n        if (containsOutOfMemoryData(object))\n            warning(\"Object contains out-of-memory data so cannot be \",\n                    \"serialized reliably.\\n  See '?containsOutOfMemoryData'.\")\n        base::saveRDS(object, file=file, ascii=ascii, version=version,\n                      compress=compress, refhook=refhook)\n    }\n)\n\n",
    "score.R": "### =========================================================================\n### The score() and `score<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"score\", function(x, ...) standardGeneric(\"score\"))\n\nsetGeneric(\"score<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"score<-\")\n)\n\n",
    "setops.R": "### =========================================================================\n### The union(), intersect(), setdiff(), and setequal() generics\n### -------------------------------------------------------------------------\n###\n### The default methods are defined in CRAN package generics.\n\nsetGeneric(\"union\",\n    function(x, y, ...) standardGeneric(\"union\"),\n    useAsDefault=generics::union\n)\n\nsetGeneric(\"intersect\",\n    function(x, y, ...) standardGeneric(\"intersect\"),\n    useAsDefault=generics::intersect\n\n)\n\nsetGeneric(\"setdiff\",\n    function(x, y, ...) standardGeneric(\"setdiff\"),\n    useAsDefault=generics::setdiff\n)\n\nsetGeneric(\"setequal\",\n    function(x, y, ...) standardGeneric(\"setequal\"),\n    useAsDefault=generics::setequal\n)\n\n",
    "sort.R": "### =========================================================================\n### The sort() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::sort is an S3 generic.\n###\n### Need to explicitly define this generic otherwise the implicit generic\n### in package \"base\" would dispatch on ('x', 'decreasing'). Here we set\n### dispatch on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"sort\", signature=\"x\")\n\n",
    "start.R": "### =========================================================================\n### The start(), end(), width(), and pos() generic getters and setters\n### -------------------------------------------------------------------------\n###\n### Note that stats::start and stats::end are S3 generics.\n###\n\nsetGeneric(\"start\")\n\nsetGeneric(\"start<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"start<-\")\n)\n\nsetGeneric(\"end\")\n\nsetGeneric(\"end<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"end<-\")\n)\n\nsetGeneric(\"width\", function(x) standardGeneric(\"width\"))\n\nsetGeneric(\"width<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"width<-\")\n)\n\n### No pos() setter for now.\nsetGeneric(\"pos\", function(x) standardGeneric(\"pos\"))\n\n",
    "strand.R": "### =========================================================================\n### The strand() and `strand<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"strand\", function(x, ...) standardGeneric(\"strand\"))\n\nsetGeneric(\"strand<-\", function(x, ..., value) standardGeneric(\"strand<-\"))\n\nunstrand <- function(x)\n{\n    strand(x) <- \"*\"\n    x\n}\n\nsetGeneric(\"invertStrand\", function(x) standardGeneric(\"invertStrand\"))\n\nsetMethod(\"invertStrand\", \"ANY\",\n    function(x)\n    {\n        strand(x) <- invertStrand(strand(x))\n        x\n    }\n)\n\n",
    "subset.R": "### =========================================================================\n### The subset() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::subset is an S3 generic.\n\nsetGeneric(\"subset\")\n\n",
    "t.R": "### =========================================================================\n### The t() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::t is an S3 generic.\n\nsetGeneric(\"t\")\n",
    "table.R": "### =========================================================================\n### The table() generic\n### -------------------------------------------------------------------------\n\n### base::table() has a broken signature (list.names() is a function\n### defined *inside* the body of base::table() so the default value for the\n### 'dnn' arg is an expression that cannot be evaluated *outside* the\n### base::table environment, this is poor design), we cannot keep all the\n### extra arguments in the table() generic (those extra arguments are ugly\n### and nobody uses them anyway).\n#setGeneric(\"table\", signature=\"...\",\n#    function(..., exclude = if (useNA == \"no\") c(NA, NaN),\n#                  useNA = c(\"no\", \"ifany\", \"always\"),\n#                  dnn = list.names(...),\n#                  deparse.level = 1)\n#        standardGeneric(\"table\")\n#)\n\n### So we use this instead.\n\n.table.useAsDefault <- function(...) base::table(...)\n\nsetGeneric(\"table\", signature=\"...\",\n    function(...) standardGeneric(\"table\"),\n    useAsDefault=.table.useAsDefault\n)\n\n",
    "tapply.R": "### =========================================================================\n### The tapply() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st and 2nd args only!\n\nsetGeneric(\"tapply\", signature=c(\"X\", \"INDEX\"))\n\n",
    "testPackage.R": "### \n\npackageRoot <- function(path)\n{\n    hasDescription <- function(path) {\n        file.exists(file.path(path, \"DESCRIPTION\"))\n    }\n    isRoot <- function(path) {\n        identical(path, dirname(path))\n    }\n    while (!hasDescription(path) && !isRoot(path)) {\n        path <- dirname(path)\n    }\n    if (isRoot(path)) {\n        NULL\n    } else {\n        path\n    }\n}\n\npackageInfo <- function(path)\n{\n    as.data.frame(read.dcf(file.path(path, \"DESCRIPTION\")),\n                  stringsAsFactors=FALSE)\n}\n\ntestPackage <- function(pkgname = NULL,\n                        subdir=\"unitTests\",\n                        pattern=\"^test_.*\\\\.R$\",\n                        path = getwd())\n{\n    .failure_details <- function(result) {\n        res <- result[[1L]]\n        if (res$nFail > 0 || res$nErr > 0) {\n            Filter(function(x) length(x) > 0,\n                   lapply(res$sourceFileResults,\n                          function(fileRes) {\n                              names(Filter(function(x) x$kind != \"success\",\n                                           fileRes))\n                          }))\n        } else list()\n    }\n\n    if (is.null(pkgname)) {\n        root <- packageRoot(path)\n        if (is.null(root))\n            stop(\"could not infer package root directory\")\n\n        pkgname0 <- packageInfo(root)$Package\n        if (is.null(pkgname)) {\n            pkgname <- pkgname0\n        } else if (!identical(pkgname, pkgname0)) {\n            stop(\"'pkgname' and inferred DESCRIPTION 'Package' differ\")\n        }\n    } else {\n        root <- system.file(package=pkgname)\n    }\n\n    library(pkgname, character.only = TRUE, quietly=TRUE)\n\n    dir <- file.path(root, subdir)\n    if (!file.exists(dir)) {            # try inst/subdir\n        dir <- file.path(root, \"inst\", subdir)\n    }\n    if (!file.exists(dir)) {\n        stop(\"unable to find unit tests, no subdir \", sQuote(subdir))\n    }\n\n    ## If we only load RUnit's namespace without attaching the package to\n    ## the search path, then many tests in many packages will fail with\n    ## errors like: could not find function \"checkIdentical\"\n    #if (!requireNamespace(\"RUnit\", quietly=TRUE))\n    #    stop(\"Couldn't load the RUnit package. You need to \",\n    #         \"install it before\\n  you can use testPackage().\")\n    library(\"RUnit\", quietly=TRUE)\n    RUnit_opts <- getOption(\"RUnit\", list())\n    RUnit_opts$verbose <- 0L\n    RUnit_opts$silent <- TRUE\n    RUnit_opts$verbose_fail_msg <- TRUE\n    oopt <- options(RUnit = RUnit_opts)\n    on.exit(options(oopt))\n    suite <- RUnit::defineTestSuite(name=paste(pkgname, \"RUnit Tests\"),\n                                    dirs=dir,\n                                    testFileRegexp=pattern,\n                                    rngKind=\"default\",\n                                    rngNormalKind=\"default\")\n    result <- RUnit::runTestSuite(suite)\n    cat(\"\\n\\n\")\n    RUnit::printTextProtocol(result, showDetails=FALSE)\n    if (length(details <- .failure_details(result)) > 0) {\n        cat(\"\\nTest files with failing tests\\n\")\n        for (i in seq_along(details)) {\n            cat(\"\\n  \", basename(names(details)[[i]]), \"\\n\")\n            for (j in seq_along(details[[i]])) {\n                cat(\"    \", details[[i]][[j]], \"\\n\")\n            }\n        }\n        cat(\"\\n\\n\")\n        stop(\"unit tests failed for package \", pkgname)\n    }\n    result\n}\n",
    "toTable.R": "### =========================================================================\n### The toTable() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"toTable\", function(x, ...) standardGeneric(\"toTable\"))\n\n",
    "type.R": "### =========================================================================\n### The type() getter and setter\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getter\n###\n\nsetGeneric(\"type\", function(x) standardGeneric(\"type\"))\n\nsetMethod(\"type\", \"vector\", function(x) typeof(x))\n\nsetMethod(\"type\", \"array\", function(x) typeof(x))\n\nsetMethod(\"type\", \"factor\", function(x) \"character\")\n\n### NOT exported but used in S4Arrays.\n### Return a list with one list element per column in data frame 'x', with\n### the exception that a length-1 list is returned when 'x' has zero column.\n### All the list elements in the returned list are guaranteed to be ordinary\n### vectors (atomic or list) of length 0.\n### Note that:\n### - extract_data_frame_slice0() works on a data.frame object only if\n###   as.vector() can be applied to all its columns.\n### - Additionally, extract_data_frame_slice0() would also work out-of-the-box\n###   on any data-frame-like object granted that the object supports\n###   x[0L, , drop=FALSE]. This includes DataFrame, data.table, and\n###   tibble (tbl_df) objects.\nextract_data_frame_slice0 <- function(x)\n{\n    if (ncol(x) == 0L)\n        return(list(logical(0)))\n    x0 <- x[0L, , drop=FALSE]\n    ## Apply as.vector() on each column to turn them into ordinary vectors.\n    ## In particular this will turn columns that are factors into character\n    ## vectors, and columns that are Rle objects into atomic vectors of the\n    ## corresponding types.\n    ## Note that as.vector() is not guaranteed to work on all columns. For\n    ## example 'x' could be a data.frame or DataFrame object where some\n    ## columns are S4 objects that don't support as.vector(), in which\n    ## case 'type(x)' will fail.\n    lapply(x0, as.vector)\n}\n\n.get_data_frame_type <- function(x)\n{\n    slice0 <- extract_data_frame_slice0(x)\n    type(unlist(slice0, recursive=FALSE, use.names=FALSE))\n}\n\nsetMethod(\"type\", \"data.frame\", .get_data_frame_type)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setter\n###\n\nsetGeneric(\"type<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"type<-\")\n)\n\nsetReplaceMethod(\"type\", \"vector\",\n    function(x, value) `storage.mode<-`(x, value=value)\n)\n\nsetReplaceMethod(\"type\", \"array\",\n    function(x, value) `storage.mode<-`(x, value=value)\n)\n\n",
    "unique.R": "### =========================================================================\n### The unique() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('x', 'incomparables'). Here we set\n### dispatch on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"unique\", signature=\"x\")\n\n",
    "unlist.R": "### =========================================================================\n### The unlist() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"unlist\", signature=\"x\")\n\n",
    "unsplit.R": "### =========================================================================\n### The unsplit() generic\n### -------------------------------------------------------------------------\n###\n### unsplit should not dispatch on 'drop'\n\nsetGeneric(\"unsplit\",\n           function (value, f, drop = FALSE) standardGeneric(\"unsplit\"),\n           signature=c(\"value\", \"f\"))\n\n",
    "updateObject.R": "### =========================================================================\n### The updateObject() generic and related utilities\n### -------------------------------------------------------------------------\n###\n### An \"updateObject\" default method + methods for some standard types are\n### also provided.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Utilities.\n###\n\nupdateObjectFrom_errf <- function(..., verbose=FALSE) {\n    function(err) {\n        if (verbose)\n            message(..., \":\\n    \", conditionMessage(err),\n                    \"\\n    trying next method...\")\n        NULL\n    }\n}\n\ngetObjectSlots <- function(object)  # object, rather than class defn, slots\n{\n    if (!is.object(object) || isVirtualClass(class(object)[[1L]]))\n        return(NULL)\n    value <- attributes(object)\n    value$class <- NULL\n    if (is(object, \"vector\")) {\n        .Data <- as.vector(object)\n        attr(.Data, \"class\") <- NULL\n        attrNames <- c(\"comment\", \"dim\", \"dimnames\",\n                       \"names\", \"row.names\", \"tsp\")\n        for (nm in names(value)[names(value) %in% attrNames])\n            attr(.Data, nm) <- value[[nm]]\n        value <- value[!names(value) %in% attrNames]\n        value$.Data <- .Data\n    }\n    value\n}\n\nupdateObjectFromSlots <- function(object, objclass=class(object)[[1L]],\n                                  ..., verbose=FALSE)\n{\n    if (is(object, \"environment\")) {\n        if (verbose)\n            message(\"returning original object of class 'environment'\")\n        return(object)\n    }\n    classSlots <- slotNames(objclass)\n    if (is.null(classSlots)) {\n        if (verbose)\n            message(\"definition of '\", objclass, \"' has no slots; \",\n                    \"returning original object\")\n        return(object)\n    }\n    if (verbose)\n        message(\"updateObjectFromSlots(object = '\", class(object)[[1L]],\n                \"' class = '\", objclass, \"')\")\n    objectSlots <- getObjectSlots(object)\n    ## de-mangle and remove NULL\n    nulls <- sapply(names(objectSlots),\n                    function(slt) is.null(slot(object, slt)))\n    objectSlots[nulls] <- NULL\n    joint <- intersect(names(objectSlots), classSlots)\n    toUpdate <- joint[joint!=\".Data\"]\n    objectSlots[toUpdate] <- lapply(objectSlots[toUpdate],\n                                    updateObject, ..., verbose=verbose)\n    toDrop <- which(!names(objectSlots) %in% classSlots)\n    if (length(toDrop) > 0L) {\n        warning(\"dropping slot(s) '\",\n                paste(names(objectSlots)[toDrop], collapse=\"', '\"),\n                \"' from object = '\", class(object)[[1L]], \"'\")\n        objectSlots <- objectSlots[-toDrop]\n    }\n    ## ad-hoc methods for creating new instances\n    res <- NULL\n    if (is.null(res)) {\n        if (verbose)\n            message(\"heuristic updateObjectFromSlots, method 1\")\n        res <- tryCatch({\n                   do.call(new, c(objclass, objectSlots[joint]))\n               }, error=updateObjectFrom_errf(\n                      \"'new(\\\"\", objclass, \"\\\", ...)' from slots failed\",\n                      verbose=verbose))\n    }\n    if (is.null(res)) {\n        if (verbose)\n            message(\"heuristic updateObjectFromSlots, method 2\")\n        res <- tryCatch({\n                   obj <- do.call(new, list(objclass))\n                   for (slt in joint)\n                       slot(obj, slt) <- updateObject(objectSlots[[slt]],\n                                                      ..., verbose=verbose)\n                   obj\n               }, error=updateObjectFrom_errf(\n                      \"failed to add slots to 'new(\\\"\", objclass, \"\\\", ...)'\",\n                      verbose=verbose))\n    }\n    if (is.null(res))\n        stop(\"could not updateObject to class '\", objclass, \"'\",\n             \"\\nconsider defining an 'updateObject' method for class '\",\n             class(object)[[1L]], \"'\")\n    res\n}\n\ngetObjectFields <- function(object)\n{\n    value <- object$.refClassDef@fieldClasses\n    for (field in names(value))\n        value[[field]] <- object$field(field)\n    value\n}\n\nupdateObjectFromFields <-\n    function(object, objclass=class(object)[[1L]], ..., verbose=FALSE)\n{\n    if (verbose)\n        message(\"updateObjectFromFields(object = '\", class(object)[[1L]],\n                \"' objclass = '\", objclass, \"')\")\n\n    classFields <- names(getRefClass(objclass)$fields())\n    if (is.null(classFields)) {\n        if (verbose)\n            message(\"definition of '\", objclass, \"' has no fields; \",\n                    \"regurning original object\")\n        return(object)\n    }\n\n    objectFields <- getObjectFields(object)\n\n    toUpdate <- joint <- intersect(names(objectFields), classFields)\n    objectFields[toUpdate] <-\n        lapply(objectFields[toUpdate], updateObject, ..., verbose=verbose)\n    toDrop <- which(!names(objectFields) %in% classFields)\n    if (length(toDrop) > 0L) {\n        warning(\"dropping fields(s) '\",\n                paste(names(objectFields)[toDrop], collapse=\"', '\"),\n                \"' from object = '\", class(object)[[1L]], \"'\")\n        objectFields <- objectFields[-toDrop]\n    }\n\n        ## ad-hoc methods for creating new instances\n\n    if (verbose)\n        message(\"heuristic updateObjectFromFields, method 1\")\n    res <- tryCatch({\n        do.call(new, c(objclass, objectFields[joint]))\n    }, error = updateObjectFrom_errf(\n           \"'new(\\\"\", objclass, \"\\\", ...' from slots failed\",\n           verbose=verbose)\n    )\n\n    if (is.null(res))\n        stop(\"could not updateObject to class '\", objclass, \"'\",\n             \"\\nconsider defining an 'updateObject' method for class '\",\n             class(object)[[1L]], \"'\")\n    res\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### attach_classdef_and_updateobjdef_pkgs()\n###\n\n### Known invalid packages found in 'attr(class(x), \"package\")' as of\n### Nov 17, 2021.\n.KNOWN_INVALID_CLASSDEF_PKGS <- c(\n  ## For some serialized S4 instances in the hubs 'attr(class(x), \"package\")'\n  ## is set to \".GlobalEnv\"! This is the case for example for CellMapperList\n  ## instances EH170 to EH175 in ExperimentHub. Not sure how that's allowed\n  ## but let's just deal with it.\n    \".GlobalEnv\",\n  ## SimResults class (e.g.\n  ## \"iCOBRA/inst/extdata/cobradata_example_simres.Rdata\") is defined in the\n  ## benchmarkR package which is not part of CRAN or Bioconductor (GitHub-only\n  ## package).\n    \"benchmarkR\",\n  ## The galgo.Obj class (e.g. \"GSgalgoR/inst/extdata/results/final_1.rda\")\n  ## used to be defined in galgoR but this package no longer exists (has\n  ## been renamed GSgalgoR).\n    \"galgoR\",\n  ## The MutationFeatureData class (e.g.\n  ## decompTumor2Sig/inst/extdata/Nik-Zainal_PMID_22608084-pmsignature-G.Rdata)\n  ## is defined in the pmsignature package which is not part of CRAN or\n  ## Bioconductor (GitHub-only package).\n    \"pmsignature\",\n  ## The QCStats class (e.g. \"arrayMvout/inst/simpleaffy/afxsubQC.rda\")\n  ## was defined in simpleaffy which got removed in BioC 3.13.\n    \"simpleaffy\",\n  ## The YAQCStats class (e.g. \"qcmetrics/inst/extdata/yqc.rda\")\n  ## was defined in yaqcaffy which got removed in BioC 3.14.\n    \"yaqcaffy\"\n)\n\n### A wrapper around attachNamespace() that tries to attach the package only\n### if it's not already attached.\n.attach_namespace <- function(pkg)\n{\n    if (!(paste0(\"package:\", pkg) %in% search())) {\n        suppressMessages(suppressWarnings(suppressPackageStartupMessages(\n            attachNamespace(pkg)\n        )))\n    }\n}\n\n### For some unclear reasons, updateObject(x) will fail sometimes if the\n### package where class(x) is defined (\"classdef\" pkg) is loaded but not\n### attached, or if the package where the updateObject() method for objects\n### of class class(x) is defined (\"updateobjdef\" pkg) is loaded but not\n### attached.\n### This happens for example if 'x' is of class enrichResult (the enrichResult\n### class is defined in the DOSE package) and if the DOSE package was\n### indirectly loaded with library(TimiRGeN).\n### This helper function will make sure that the \"classdef\" and \"updateobjdef\"\n### packages gets attached.\n### NOT exported but used in the updateObject package (in addition to being\n### used in the updateObject() generic function below).\nattach_classdef_and_updateobjdef_pkgs <- function(x_class)\n{\n    classdef_pkg <- attr(x_class, \"package\")\n    if (is.null(classdef_pkg) || classdef_pkg %in% .KNOWN_INVALID_CLASSDEF_PKGS)\n        return()\n    .attach_namespace(classdef_pkg)\n    updateobjdef <- selectMethod(updateObject, x_class)\n    updateobjdef_pkg <- environmentName(environment(updateobjdef))\n    if (updateobjdef_pkg == \"R_GlobalEnv\")\n        return()\n    .attach_namespace(updateobjdef_pkg)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### TODO: Would be cleaner if 'check' was a formal argument.\nsetGeneric(\"updateObject\", signature=\"object\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (!isTRUEorFALSE(verbose))\n            stop(\"'verbose' must be TRUE or FALSE\")\n        if (isTRUE(getOption(\"updateObject.can.attach.packages\"))) {\n            ## We silently try to **attach** (loading is not enough) the\n            ## packages where class(object) and\n            ## selectMethod(updateObject, class(object)) are defined.\n            ## This increases the chances of success of updateObject(object).\n            ## See attach_classdef_and_updateobjdef_pkgs() above for the\n            ## details.\n            ## Note that we don't do this by default, only if global\n            ## option \"updateObject.can.attach.packages\" is set to TRUE.\n            ## Problem with doing this by default (i.e. for regular use of\n            ## updateObject()) is that many packages call updateObject()\n            ## internally e.g. analyzeSNPhood() in the SNPhood package calls\n            ## the estimateSizeFactors() method for DESeqDataSet objects,\n            ## which in turn calls updateObject(). As a result, calling\n            ## analyzeSNPhood() will attach DESeq2 to the search path if\n            ## it's not already attached. Which is not good. See\n            ## https://stat.ethz.ch/pipermail/bioc-devel/2023-October/020024.html\n            ## for the full story.\n            ## Generally speaking, package functionalities should not have\n            ## the side effect of altering the search path.\n            ## The one place where we actually set global option\n            ## \"updateObject.can.attach.packages\" to TRUE is in\n            ## updateObject:::.update_object().\n            try(attach_classdef_and_updateobjdef_pkgs(class(object)),\n                silent=TRUE)\n        }\n        result <- standardGeneric(\"updateObject\")\n        check <- list(...)$check\n        if (is.null(check)) {\n            check <- TRUE\n        } else if (!isTRUEorFALSE(check)) {\n            stop(\"'check' must be TRUE or FALSE\")\n        }\n        if (check) {\n            if (verbose)\n                message(\"[updateObject] Validating the updated object ... \",\n                        appendLF=FALSE)\n            validObject(result)\n            if (verbose)\n                message(\"OK\")\n        }\n        result\n    }\n)\n\nsetMethod(\"updateObject\", \"ANY\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object=\\\"ANY\\\") default for object \",\n                    \"of class '\", class(object)[[1L]], \"'\")\n        if (length(getObjectSlots(object)) > 0L &&\n            !any(class(object) %in% c(\"data.frame\", \"factor\")))\n        {\n            updateObjectFromSlots(object, ..., verbose=verbose)\n        } else {\n            object\n        }\n    }\n)\n\nsetMethod(\"updateObject\", \"list\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object = 'list')\")\n        if (\"class\" %in% names(attributes(object)))\n            callNextMethod() # old-style S4\n        else {\n            result <- lapply(object, updateObject, ..., verbose=verbose)\n            attributes(result) <- attributes(object)\n            result\n        }\n    }\n)\n\nsetMethod(\"updateObject\", \"environment\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object = 'environment')\")\n        envLocked <- environmentIsLocked(object)\n        if (verbose) {\n            if (envLocked)\n                warning(\"updateObject duplicating locked environment\")\n            else\n                warning(\"updateObject modifying environment\")\n        }\n        env <- if (envLocked) new.env() else object\n        lapply(ls(object, all.names=TRUE),\n               function(elt) {    # side-effect!\n                   bindingLocked <- bindingIsLocked(elt, object)\n                   if (!envLocked && bindingLocked)\n                       stop(\"updateObject object = 'environment' \",\n                            \"cannot modify locked binding '\", elt, \"'\")\n                   else {\n                       env[[elt]] <<- updateObject(object[[elt]],\n                                                   ..., verbose=verbose)\n                       if (bindingLocked) lockBinding(elt, env)\n                   }\n                   NULL\n               })\n        attributes(env) <- attributes(object)\n        if (envLocked)\n            lockEnvironment(env)\n        env\n    }\n)\n\nsetMethod(\"updateObject\", \"formula\",\n    function(object, ..., verbose=FALSE)\n{\n    if (verbose)\n        ## object@.Environment could be too general, e.g,. R_GlobalEnv\n        message(\"updateObject(object = 'formula'); ignoring .Environment\")\n    object\n})\n\nsetMethod(\"updateObject\", \"envRefClass\",\n    function(object, ..., verbose=FALSE)\n{\n    msg <- sprintf(\"updateObject(object= '%s')\", class(object)[[1L]])\n    if (verbose)\n        message(msg)\n    updateObjectFromFields(object, ..., verbose=verbose)\n})\n",
    "utils.R": "### =========================================================================\n### Miscellaneous low-level utils\n### -------------------------------------------------------------------------\n###\n\n### Like toString() but also injects names(x) in the returned string.\n### For example with:\n###   x <- alist(b = 99, 98:96, zz)\n### to_string(x) returns:\n###   \"b = 99, 98:96, zz\"\nto_string <- function(x)\n{\n    x_names <- names(x)\n    x <- as.character(x)\n    if (!is.null(x_names)) {\n        x_names <- paste0(x_names, ifelse(x_names == \"\", \"\", \" = \"))\n        x <- paste0(x_names, x)\n    }\n    paste(x, collapse=\", \")\n}\n\nunused_arguments_msg <- function(dots)\n{\n    msg <- \"unused argument\"\n    if (length(dots) >= 2L)\n        msg <- c(msg, \"s\")\n    c(msg, \" (\", to_string(dots), \")\")\n}\n\n",
    "var.R": "### =========================================================================\n### The var() and sd() generics\n### -------------------------------------------------------------------------\n###\n### Dispatches only on 'x' (and 'y' for var)\n###\n\nsetGeneric(\"var\", signature=c(\"x\", \"y\"))\n\nsetGeneric(\"sd\", signature=\"x\")\n",
    "weights.R": "### =========================================================================\n### The weights() generic\n### -------------------------------------------------------------------------\n###\n### Note that stats::weights is an S3 generic.\n\nsetGeneric(\"weights\")\n\n",
    "which.R": "### =========================================================================\n### The which() generic\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"which\")\n\n",
    "which.min.R": "### =========================================================================\n### The which.min() and which.max() generics\n### -------------------------------------------------------------------------\n###\n### Michael, June 2016 (commit 860cce0ec85b94ebca190802be95e61c4f469d6b):\n###\n### The default methods (defined in the base package) only take 1 argument.\n### We add the ... argument to the generic functions defined here so they\n### can be called with an arbitrary number of effective arguments. This was\n### motivated by the desire to optionally return global subscripts from\n### methods on List.\n### These generics are slated to be internalized in base R. When that\n### happens, these calls will effectively be no-ops.\n\n.which.min.useAsDefault <- function(x, ...) base::which.min(x, ...)\n.which.max.useAsDefault <- function(x, ...) base::which.max(x, ...)\n\nsetGeneric(\"which.min\",\n    function(x, ...) standardGeneric(\"which.min\"),\n    useAsDefault=.which.min.useAsDefault\n)\n\nsetGeneric(\"which.max\",\n    function(x, ...) standardGeneric(\"which.max\"),\n    useAsDefault=.which.max.useAsDefault\n)\n\n",
    "xtabs.R": "### =========================================================================\n### The xtabs() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"stats\" would dispatch on all its arguments. Here we set dispatch\n### on the 2nd arg (the 'data' arg) only!\n\nsetGeneric(\"xtabs\", signature=\"data\")\n\n",
    "zzz.R": ".test <- function() testPackage(\"BiocGenerics\")\n\n"
}