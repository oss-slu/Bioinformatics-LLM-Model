{
    "BiocGenerics": {
        "Extremes.R": "### =========================================================================\n### The pmax(), pmin(), pmax.int() and pmin.int() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on 'na.rm'.\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\n### setGeneric() cannot be used on \"max\" and \"min\":\n###   > setGeneric(\"max\", signature=\"...\")\n###   Error in setGeneric(\"max\", signature = \"...\") : \n###     ‘max’ is a primitive function;  methods can be defined, but the\n###   generic function is implicit, and cannot be changed.\n#setGeneric(\"max\", signature=\"...\")\n#setGeneric(\"min\", signature=\"...\")\n\nsetGeneric(\"pmax\", signature=\"...\")\n\nsetGeneric(\"pmin\", signature=\"...\")\n\nsetGeneric(\"pmax.int\", signature=\"...\")\n\nsetGeneric(\"pmin.int\", signature=\"...\")\n\n",
        "IQR.R": "### =========================================================================\n### The IQR() generic\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"IQR\", signature=\"x\")\n",
        "Ontology.R": "### =========================================================================\n### The Ontology() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"Ontology\", function(object) standardGeneric(\"Ontology\"))\n\n",
        "S3-classes-as-S4-classes.R": "### =========================================================================\n### S3 classes as S4 classes\n### -------------------------------------------------------------------------\n###\n### We register some old-style (aka S3) classes as formally defined (aka S4)\n### classes. This allows S4 methods defined in Bioconductor packages to use\n### them in their signatures. Note that dispatch still works without this\n### registration but causes 'R CMD INSTALL' to (gently) complain.\n\n### connection class and subclasses\n.connectionClasses <- c(\"file\", \"url\", \"gzfile\", \"bzfile\", \"unz\", \"pipe\",\n                        \"fifo\", \"sockconn\", \"terminal\", \"textConnection\",\n                        \"gzcon\")\napply(cbind(.connectionClasses, \"connection\"), 1, setOldClass,\n      where = environment())\n\nsetClassUnion(\"character_OR_connection\", c(\"character\", \"connection\"))\n\n### others\nsetOldClass(\"AsIs\")\n\n#setOldClass(\"xtabs\", \"table\")  # this seems to cause problems when installing\n                                # IRanges:\n                                # Warning: replacing previous import\n                                # ‘.__C__table’ when loading ‘BiocGenerics’\n\nsetOldClass(\"dist\")\n\n",
        "annotation.R": "### =========================================================================\n### The annotation() and `annotation<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"annotation\", \n    function(object, ...) standardGeneric(\"annotation\")\n)\n\nsetGeneric(\"annotation<-\", \n    function(object, ..., value) standardGeneric(\"annotation<-\")\n)\n\n",
        "aperm.R": "### =========================================================================\n### The aperm() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::aperm is an S3 generic.\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('a', 'perm'). Here we set dispatch on\n### the 1st arg (the 'a' arg) only!\n\nsetGeneric(\"aperm\", signature=\"a\")\n\n",
        "append.R": "### =========================================================================\n### The append() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('x', 'values', 'after'). Here we set\n### dispatch on the first two args (the 'x' and 'values' args) only!\n\nsetGeneric(\"append\", signature=c(\"x\", \"values\"))\n\n",
        "as.data.frame.R": "### =========================================================================\n### The as.data.frame() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::as.data.frame is an S3 generic.\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"as.data.frame\", signature=\"x\")\n\n",
        "as.list.R": "### =========================================================================\n### The as.list() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::as.list is an S3 generic.\n\nsetGeneric(\"as.list\")\n\n",
        "as.vector.R": "### =========================================================================\n### The as.vector() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('x', 'mode'). Here we set dispatch on\n### the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"as.vector\", signature=\"x\")\n\n",
        "boxplot.R": "### =========================================================================\n### The boxplot() generic\n### -------------------------------------------------------------------------\n###\n### Note that graphics::boxplot is an S3 generic.\n\nsetGeneric(\"boxplot\")\n\n",
        "cbind.R": "### =========================================================================\n### The cbind() and rbind() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on 'deparse.level'.\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"cbind\", signature=\"...\")\n\nsetGeneric(\"rbind\", signature=\"...\")\n\n",
        "combine.R": "### =========================================================================\n### The combine() generic\n### -------------------------------------------------------------------------\n###\n### A \"combine\" default method + methods for some standard types are\n### also provided.\n###\n\nsetGeneric(\"combine\",\n    function(x, y, ...)\n    {\n        if (length(list(...)) > 0L) {\n            combine(x, do.call(combine, list(y, ...)))\n        } else {\n            standardGeneric(\"combine\")\n        }\n    }\n)\n\nsetMethod(\"combine\", c(\"ANY\", \"missing\"), function(x, y, ...) x)\n\nsetMethod(\"combine\", c(\"data.frame\", \"data.frame\"),\n    function(x, y, ...)\n    {\n        if (all(dim(x) == 0L) && all(dim(y) == 0L))\n                return(x)\n        else if (all(dim(x) == 0L)) return(y)\n        else if (all(dim(y) == 0L)) return(x)\n\n        uniqueRows <- unique(c(row.names(x), row.names(y)))\n        uniqueCols <- unique(c(names(x), names(y)))\n        sharedCols <- intersect(names(x), names(y))\n\n        ## check possible to combine\n        alleq <- function(x, y) {\n            res <- all.equal(x, y, check.attributes=FALSE)\n            if (!is.logical(res)) {\n                warning(res)\n                FALSE\n            } else TRUE\n        }\n        sharedRows <- intersect(row.names(x), row.names(y))\n        ok <- sapply(sharedCols,\n            function(nm) {\n                if (!all(class(x[[nm]]) == class(y[[nm]])))\n                    return(FALSE)\n                switch(class(x[[nm]])[[1L]],\n                       factor={\n                           if (!alleq(levels(x[[nm]]), levels(y[[nm]]))) {\n                               warning(\"data frame column '\", nm,\n                                       \"' levels not all.equal\",\n                                       call.=FALSE)\n                               TRUE\n                           } else if (!alleq(x[sharedRows, nm, drop=FALSE],\n                                             y[sharedRows, nm, drop=FALSE])) {\n                               warning(\"data frame column '\", nm,\n                                       \"' shared rows not all equal\",\n                                       call.=FALSE)\n                               FALSE\n                           } else TRUE\n                       },\n                       ## ordered and non-factor columns need to\n                       ## satisfy the following identity; it seems\n                       ## possible that ordered could be treated\n                       ## differently, but these have not been\n                       ## encountered.\n                       ordered=,\n                       if (!alleq(x[sharedRows, nm, drop=FALSE],\n                                  y[sharedRows, nm, drop=FALSE])) {\n                           warning(\"data frame column '\", nm,\n                                   \"' shared rows not all equal\")\n                           FALSE\n                       } else TRUE)\n              })\n        if (!all(ok))\n            stop(\"data.frames contain conflicting data:\",\n                 \"\\n\\tnon-conforming colname(s): \",\n                 paste(sharedCols[!ok], collapse=\", \"))\n\n        ## x or y with zero rows -- make palatable to merge, but drop\n        ## before return\n        if (length(uniqueRows) == 0L) {\n            x <- x[\"tmp\",,drop=FALSE]\n            y <- y[\"tmp\",,drop=FALSE]\n        } else if (nrow(x) == 0L) {\n            x <- x[row.names(y),,drop=FALSE]\n            row.names(x) <- row.names(y)\n        } else if (nrow(y) == 0L) {\n            y <- y[row.names(x),,drop=FALSE]\n            row.names(y) <- row.names(x)\n        }\n\n        ## make colnames of merged data robust\n        if (length(uniqueCols) > 0L)\n            extLength <- max(nchar(sub(\".*\\\\.\", \"\", uniqueCols))) + 1L\n        else extLength <- 1L\n        extX <- paste(c(\".\", rep(\"x\", extLength)), collapse=\"\")\n        extY <- paste(c(\".\", rep(\"y\", extLength)), collapse=\"\")\n        z <- merge(x, y, by=\"row.names\", all=TRUE, suffixes=c(extX, extY))\n\n        ## shared cols\n        for (nm in sharedCols) {\n            nmx <- paste(nm, extX, sep=\"\")\n            nmy <- paste(nm, extY, sep=\"\")\n            z[[nm]] <-\n              switch(class(z[[nmx]])[[1]],\n                     AsIs=I(ifelse(is.na(z[[nmx]]), z[[nmy]], z[[nmx]])),\n                     factor={\n                         col <- ifelse(is.na(z[[nmx]]),\n                                       as.character(z[[nmy]]),\n                                       as.character(z[[nmx]]))\n                         if (!identical(levels(z[[nmx]]), levels(z[[nmy]])))\n                             factor(col)\n                         else\n                             factor(col, levels=levels(z[[nmx]]))\n                     },\n                     {\n                         col <- ifelse(is.na(z[[nmx]]), z[[nmy]], z[[nmx]])\n                         class(col) <- class(z[[nmx]])\n                         col\n                     })\n        }\n\n        ## tidy\n        row.names(z) <- if (is.integer(attr(x, \"row.names\")) &&\n                            is.integer(attr(y, \"row.names\")))\n                            as.integer(z$Row.names)\n                        else\n                            z$Row.names\n        z$Row.names <- NULL\n        z[uniqueRows, uniqueCols, drop=FALSE]\n    }\n)\n\nsetMethod(\"combine\", c(\"matrix\", \"matrix\"),\n    function(x, y, ...)\n    {\n        if (length(y) == 0L)\n            return(x)\n        else if (length(x) == 0L)\n            return(y)\n        if (mode(x) != mode(y))\n            stop(\"matrix modes \", mode(x), \", \", mode(y), \" differ\")\n        if (typeof(x) != typeof(y))\n            warning(\"matrix typeof \", typeof(x), \", \", typeof(y), \" differ\")\n        xdim <- dimnames(x)\n        ydim <- dimnames(y)\n        if (is.null(xdim) || is.null(ydim) ||\n            any(sapply(xdim, is.null)) ||\n            any(sapply(ydim, is.null)))\n            stop(\"matricies must have dimnames for 'combine'\")\n        sharedRows <- intersect(xdim[[1L]], ydim[[1L]])\n        sharedCols <- intersect(xdim[[2L]], ydim[[2L]])\n        ok <- all.equal(x[sharedRows, sharedCols], y[sharedRows, sharedCols])\n        if (!isTRUE(ok))\n            stop(\"matrix shared row and column elements differ: \", ok)\n        unionRows <- union(xdim[[1L]], ydim[[1L]])\n        unionCols <- union(xdim[[2L]], ydim[[2L]])\n\n        m <- matrix(new(class(as.vector(x))),\n                    nrow=length(unionRows), ncol=length(unionCols),\n                    dimnames=list(unionRows, unionCols))\n        m[rownames(x), colnames(x)] <- x\n        m[rownames(y), colnames(y)] <- y\n        m\n    }\n)\n\n",
        "containsOutOfMemoryData.R": "### =========================================================================\n### The containsOutOfMemoryData() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"containsOutOfMemoryData\",\n    function(object) standardGeneric(\"containsOutOfMemoryData\")\n)\n\n.S4_object_contains_out_of_memory_data <- function(object)\n{\n    slot_names <- slotNames(class(object))\n    for (name in slot_names) {\n        if (containsOutOfMemoryData(slot(object, name)))\n            return(TRUE)\n    }\n    FALSE\n}\n\n.list_contains_out_of_memory_data <- function(object)\n{\n    for (x in object) {\n        if (containsOutOfMemoryData(x))\n            return(TRUE)\n    }\n    FALSE\n}\n\n.environment_contains_out_of_memory_data <- function(object)\n{\n    for (name in names(object)) {\n        if (containsOutOfMemoryData(object[[name]]))\n            return(TRUE)\n    }\n    FALSE\n}\n\nsetMethod(\"containsOutOfMemoryData\", \"ANY\",\n    function(object)\n    {\n        if (isS4(object))\n            return(.S4_object_contains_out_of_memory_data(object))\n        FALSE\n    }\n)\n\nsetMethod(\"containsOutOfMemoryData\", \"list\",\n    .list_contains_out_of_memory_data\n)\n\nsetMethod(\"containsOutOfMemoryData\", \"environment\",\n    .environment_contains_out_of_memory_data\n)\n\nsetClass(\"OutOfMemoryObject\", representation(\"VIRTUAL\"))\n\nsetMethod(\"containsOutOfMemoryData\", \"OutOfMemoryObject\",\n    function(object) TRUE\n)\n\n",
        "dbconn.R": "### =========================================================================\n### The dbconn() and dbfile() generics\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"dbconn\", function(x) standardGeneric(\"dbconn\"))\n\nsetGeneric(\"dbfile\", function(x) standardGeneric(\"dbfile\"))\n",
        "density.R": "### =========================================================================\n### The density() generic\n### -------------------------------------------------------------------------\n###\n### Note that stats::density is an S3 generic.\n\nsetGeneric(\"density\")\n\n",
        "dge.R": "# Currently, these are for DESeq and DEXSeq. Could be extended to a more general\n#  infrastructure for count datasets.\nsetGeneric(\"counts\",        function(object, ...)        standardGeneric(\"counts\"))\nsetGeneric(\"counts<-\",      function(object, ..., value) standardGeneric(\"counts<-\"))\nsetGeneric(\"dispTable\",     function(object, ...)        standardGeneric(\"dispTable\"))\nsetGeneric(\"dispTable<-\",   function(object, ..., value) standardGeneric(\"dispTable<-\"))\nsetGeneric(\"sizeFactors\",   function(object, ...)        standardGeneric(\"sizeFactors\"))\nsetGeneric(\"sizeFactors<-\", function(object, ..., value) standardGeneric(\"sizeFactors<-\"))\n\nsetGeneric(\"conditions\",    function(object, ...)        standardGeneric(\"conditions\"))\nsetGeneric(\"conditions<-\",  function(object, ..., value) standardGeneric(\"conditions<-\"))\nsetGeneric(\"design\",        function(object, ...)        standardGeneric(\"design\"))\nsetGeneric(\"design<-\",      function(object, ..., value) standardGeneric(\"design<-\"))\n\nsetGeneric(\"estimateSizeFactors\", function(object, ...) standardGeneric(\"estimateSizeFactors\"))\nsetGeneric(\"estimateDispersions\", function(object, ...) standardGeneric(\"estimateDispersions\"))\nsetGeneric(\"plotDispEsts\", function(object, ...) standardGeneric(\"plotDispEsts\"))\n\n",
        "dims.R": "### =========================================================================\n### The dims(), nrows() and ncols() generics\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"dims\", signature=\"x\",\n    function(x, use.names=TRUE) standardGeneric(\"dims\")\n)\n\nsetGeneric(\"nrows\", signature=\"x\",\n    function(x, use.names=TRUE) standardGeneric(\"nrows\")\n)\n\nsetGeneric(\"ncols\", signature=\"x\",\n    function(x, use.names=TRUE) standardGeneric(\"ncols\")\n)\n\n",
        "do.call.R": "### =========================================================================\n### The do.call() generic\n### -------------------------------------------------------------------------\n\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st and 2nd args only!\n\nsetGeneric(\"do.call\", signature=c(\"what\", \"args\"))\n\n",
        "duplicated.R": "### =========================================================================\n### The duplicated() and anyDuplicated() generics\n### -------------------------------------------------------------------------\n###\n### Note that base::duplicated and base::anyDuplicated are S3 generics.\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on ('x', 'incomparables'). Here we set\n### dispatch on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"duplicated\", signature=\"x\")\n\nsetGeneric(\"anyDuplicated\", signature=\"x\")\n\n",
        "eval.R": "### =========================================================================\n### The eval() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the first two args (the 'expr' and 'envir' args) only!\n\nsetGeneric(\"eval\", signature=c(\"expr\", \"envir\"),\n    function(expr, envir=parent.frame(),\n                   enclos=if (is.list(envir) || is.pairlist(envir))\n                          parent.frame() else baseenv())\n    {\n        force(envir)\n        force(enclos)\n        standardGeneric(\"eval\")\n    }\n)\n\nevalq <- function(expr, envir = parent.frame(),\n                  enclos = if (is.list(envir) || is.pairlist(envir))\n                  parent.frame() else baseenv())\n  eval(substitute(expr), envir, enclos)\n",
        "fileName.R": "### =========================================================================\n### The fileName() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"fileName\", function(object, ...) standardGeneric(\"fileName\"))\n\n",
        "format.R": "### =========================================================================\n### The format() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::format is an S3 generic.\n\nsetGeneric(\"format\")\n\n### The base package doesn't define a specific format() method for list\n### objects and format.default() does a poor job on a list:\n###\n###   > format(list(1:10))\n###   [1] \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10\"\n###   > library(IRanges)\n###   > format(list(IRanges(1, 8:9)))\n###   Error in h(simpleError(msg, call)) :\n###     error in evaluating the argument 'obj' in selecting a method for\n###     function 'unname': IRanges objects don't support [[, as.list(),\n###     lapply(), or unlist() at the moment\n###\n### OTOH format.AsIs() does a good job with lists:\n###\n###   > format.AsIs(list(1:10))\n###   [1] \"1, 2, 3,....\"\n###   > format.AsIs(list(IRanges(1, 8:9)))\n###   [1] \"1-8, 1-9\"\n###\n### So we define a format() **S3** method for list objects that does that.\nformat.list <- base::format.AsIs\n\n",
        "funprog.R": "### =========================================================================\n### The Reduce(), Filter(), Find(), Map() and Position() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the 2nd arg (the 'x' or '...' arg) only!\n\nsetGeneric(\"Reduce\", signature=\"x\")\n\nsetGeneric(\"Filter\", signature=\"x\")\n\nsetGeneric(\"Find\", signature=\"x\")\n\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\nsetGeneric(\"Map\", signature=\"...\")\n\nsetGeneric(\"Position\", signature=\"x\")\n\n",
        "get.R": "### =========================================================================\n### The get() and mget() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the first 3 args ('x', 'pos', 'envir') for get(), and on the\n### first 2 args ('x', 'envir') for mget().\n\nsetGeneric(\"get\", signature=c(\"x\", \"pos\", \"envir\"))\n\nsetGeneric(\"mget\", signature=c(\"x\", \"envir\"))\n\n",
        "grep.R": "### =========================================================================\n### The grep() and grepl() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the first 2 args ('pattern', 'x').\n\nsetGeneric(\"grep\", signature = c(\"pattern\", \"x\"))\n\nsetGeneric(\"grepl\", signature = c(\"pattern\", \"x\"))\n",
        "image.R": "### =========================================================================\n### The image() generic\n### -------------------------------------------------------------------------\n###\n### Note that graphics::image is an S3 generic.\n\nsetGeneric(\"image\")\n\n",
        "is.unsorted.R": "### =========================================================================\n### The is.unsorted() generic\n### -------------------------------------------------------------------------\n\n### base::is.unsorted() doesn't have the ellipsis. We add it to the generic\n### function defined below so methods can support additional arguments (e.g.\n### the 'ignore.strand' argument for the method for GenomicRanges objects).\n\n.is.unsorted.useAsDefault <- function(x, na.rm=FALSE, strictly=FALSE, ...)\n    base::is.unsorted(x, na.rm=na.rm, strictly=strictly, ...)\n\nsetGeneric(\"is.unsorted\", signature=\"x\",\n    function(x, na.rm=FALSE, strictly=FALSE, ...)\n        standardGeneric(\"is.unsorted\"),\n    useAsDefault=.is.unsorted.useAsDefault\n)\n\n",
        "lapply.R": "### =========================================================================\n### The lapply() and sapply() generics\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define those generics otherwise the implicit generics\n### in package \"base\" would dispatch on all their arguments. Here we set\n### dispatch on the 1st arg (the 'X' arg) only!\n\nsetGeneric(\"lapply\", signature=\"X\")\n\nsetGeneric(\"sapply\", signature=\"X\")\n\n",
        "longForm.R": "### =========================================================================\n### The longForm() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"longForm\",\n    function(object, ...) standardGeneric(\"longForm\")\n)\n\n",
        "mad.R": "### =========================================================================\n### The mad() generic\n### -------------------------------------------------------------------------\n###\n### Dispatches only on 'x'\n###\n\nsetGeneric(\"mad\", signature=\"x\")\n",
        "mapply.R": "### =========================================================================\n### The mapply() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 2nd arg (the '...' arg) only!\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"mapply\", signature=\"...\")\n\n",
        "match.R": "### =========================================================================\n### The match() generic\n### -------------------------------------------------------------------------\n###\n### base::match() doesn't have the ... argument. We add it to the generic\n### function defined here. We also set dispatch on the first two args (the\n### 'x' and 'table' args) only!\n\n.match.useAsDefault <-\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n        base::match(x, table, nomatch=nomatch, incomparables=incomparables, ...)\n\nsetGeneric(\"match\", signature=c(\"x\", \"table\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n        standardGeneric(\"match\"),\n    useAsDefault=.match.useAsDefault\n)\n\nsetGeneric(\"%in%\", function(x, table) standardGeneric(\"%in%\"))\n\n",
        "mean.R": "### -------------------------------------------------------------------------\n### The mean() generic\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"mean\")\n",
        "normalize.R": "### =========================================================================\n### The normalize() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"normalize\",\n    function(object, ...) standardGeneric(\"normalize\")\n)\n\n",
        "normarg-utils.R": "### =========================================================================\n### Utility functions for checking/fixing user-supplied arguments\n### -------------------------------------------------------------------------\n\n### NOTE: The stuff in this file (not exported) is a copy/paste of some of\n### the functions in S4Vectors but it doesn't really belong to BiocGenerics.\n### It seems that the only reason for having it duplicated here is that it's\n### used by the stuff in the update-utils.R file. However the stuff in\n### update-utils.R doesn't really belong to BiocGenerics either!\n###\n### TODO: This stuff would need to be moved to a more appropriate place (when\n### we have one), and then we should get rid of the duplication between the\n### functions below and the same functions in S4Vectors.\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### For checking only.\n###\n\nisTRUEorFALSE <- function(x)\n{\n  is.logical(x) && length(x) == 1L && !is.na(x)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Handling variadic calls\n###\n\nextraArgsAsList <- function(.valid.argnames, ...)\n{\n  args <- list(...)\n  argnames <- names(args)\n  if (length(args) != 0L\n      && (is.null(argnames) || any(argnames %in% c(\"\", NA))))\n    stop(\"all extra arguments must be named\")\n  if (!is.null(.valid.argnames) && !all(argnames %in% .valid.argnames))\n    stop(\"valid extra argument names are \",\n         paste(\"'\", .valid.argnames, \"'\", sep=\"\", collapse=\", \"))\n  if (anyDuplicated(argnames))\n    stop(\"argument names must be unique\")\n  args\n}\n",
        "nrow.R": "### =========================================================================\n### The nrow(), ncol(), NROW() and NCOL() generics\n### -------------------------------------------------------------------------\n\n### The corresponding functions are standard functions defined in the base\n### package.\n\nsetGeneric(\"nrow\")\nsetGeneric(\"ncol\")\nsetGeneric(\"NROW\")\nsetGeneric(\"NCOL\")\n\n",
        "order.R": "### =========================================================================\n### The order() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('na.last', 'decreasing', 'method').\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"order\", signature=\"...\")\n\n",
        "organism_species.R": "### =========================================================================\n### The organism(), `organism<-`(), species(), and `species<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"organism\", function(object) standardGeneric(\"organism\"))\n\nsetGeneric(\"organism<-\", signature=\"object\",\n    function(object, value) standardGeneric(\"organism<-\")\n)\n\nsetGeneric(\"species\", function(object) standardGeneric(\"species\"))\n\nsetGeneric(\"species<-\", signature=\"object\",\n    function(object, value) standardGeneric(\"species<-\")\n)\n\n",
        "paste.R": "### =========================================================================\n### The paste() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('sep', 'collapse').\n###\n### Note that dispatching on '...' is supported starting with R 2.8.0 only.\n\nsetGeneric(\"paste\", signature=\"...\")\n\n",
        "paste2.R": "### =========================================================================\n### The paste2() generic and add_prefix()/add_suffix() wrappers\n### -------------------------------------------------------------------------\n###\n\n\n### A binary paste0() that follows the same rules as arithmetic operations\n### (+, *, etc...) for recycling and propagation of names, dimensions, and\n### dimnames.\n### Recycling: The longer argument wins i.e. the shorter argument is\n### recycled to the length of the longer with a warning if the length of the\n### latter is not a multiple of the length of the former. Exception: if one\n### of the two arguments has length 0 then no recycling is performed and a\n### zero-length vector is returned.\n### Name propagation: The longer argument also wins. If the 2 arguments\n### have the same length then the names on the first argument are propagated,\n### if any. Otherwise the names on the second argument are propagated, if\n### any.\nsetGeneric(\"paste2\", function(x, y) standardGeneric(\"paste2\"))\n\n.paste2_vector_vector <- function(x, y)\n{\n    stopifnot(is.character(x), is.character(y))\n\n    x_len <- length(x)\n    y_len <- length(y)\n\n    ## Zero-length case.\n    if (x_len == 0L) {\n        if (y_len == 0L && is.null(names(x)))\n            names(x) <- names(y)  # NULL or character(0)\n        return(x)\n    }\n    if (y_len == 0L)\n        return(y)\n\n    ## Non zero-length case.\n    ans <- paste0(x, y)\n    warn_msg <- c(\"longer object length is not a \",\n                  \"multiple of shorter object length\")\n    if (x_len > y_len) {\n        if (x_len %% y_len != 0L)\n            warning(warn_msg)\n        ans_names <- names(x)\n    } else if (x_len < y_len) {\n        if (y_len %% x_len != 0L)\n            warning(warn_msg)\n        ans_names <- names(y)\n    } else {\n        ans_names <- names(x)\n        if (is.null(ans_names))\n            ans_names <- names(y)\n    }\n    setNames(ans, ans_names)\n}\n\n### Returns an array of same dimensions and dimnames as 'x' **except** when\n### length(y) == 0 and length(x) != 0.\n.paste2_array_vector <- function(x, y, switch=FALSE)\n{\n    stopifnot(is.array(x), is.character(y))\n\n    x_len <- length(x)\n    y_len <- length(y)\n\n    ## Zero-length case.\n    if (x_len == 0L) {\n        if (storage.mode(x) != \"character\")\n            storage.mode(x) <- \"character\"\n        return(x)\n    }\n    if (y_len == 0L)\n        return(y)  # only case where we don't return an array\n\n    ## Non zero-length case.\n    if (y_len > x_len)\n        stop(\"non-array object is longer than array object\")\n    ans <- if (switch) paste0(y, x) else paste0(x, y)\n    warn_msg <- c(\"longer object length is not a \",\n                  \"multiple of shorter object length\")\n    if (x_len %% y_len != 0L)\n        warning(warn_msg)\n    dim(ans) <- dim(x)\n    dimnames(ans) <- dimnames(x)\n    ans\n}\n\n.paste2_array_array <- function(x, y)\n{\n    stopifnot(is.array(x), is.array(y))\n\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!(length(x_dim) == length(y_dim) && all(x_dim == y_dim)))\n        stop(\"non-conformable arrays\")\n\n    x_len <- length(x)  # same as length(y)\n\n    ## Zero-length case.\n    if (x_len == 0L) {\n        if (storage.mode(x) != \"character\")\n            storage.mode(x) <- \"character\"\n        if (is.null(dimnames(x)))\n            dimnames(x) <- dimnames(y)\n        return(x)\n    }\n\n    ## Non zero-length case.\n    ans <- paste0(x, y)\n    dim(ans) <- x_dim\n    ans_dimnames <- dimnames(x)\n    if (is.null(ans_dimnames))\n        ans_dimnames <- dimnames(y)\n    dimnames(ans) <- ans_dimnames\n    ans\n}\n\nsetMethod(\"paste2\", c(\"ANY\", \"ANY\"),\n    function(x, y)\n    {\n        ## Turn both arguments into character vectors.\n        if (!is.character(x))\n            x <- setNames(as.character(x), names(x))\n        if (!is.character(y))\n            y <- setNames(as.character(y), names(y))\n        .paste2_vector_vector(x, y)\n    }\n)\n\nsetMethod(\"paste2\", c(\"array\", \"ANY\"),\n    function(x, y)\n    {\n        if (!is.character(y))\n            y <- setNames(as.character(y), names(y))\n        .paste2_array_vector(x, y)\n    }\n)\n\nsetMethod(\"paste2\", c(\"ANY\", \"array\"),\n    function(x, y)\n    {\n        if (!is.character(x))\n            x <- setNames(as.character(x), names(x))\n        .paste2_array_vector(y, x, switch=TRUE)\n    }\n)\n\nsetMethod(\"paste2\", c(\"array\", \"array\"),\n    function(x, y) .paste2_array_array(x, y)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### add_prefix(), add_suffix()\n###\n\nadd_prefix <- function(x, prefix=\"\") paste2(prefix, x)\n\nadd_suffix <- function(x, suffix=\"\") paste2(x, suffix)\n\n",
        "path.R": "### =========================================================================\n### The path(), basename(), and dirname() getters/setters\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### path() getter and setter\n###\n\nsetGeneric(\"path\", function(object, ...) standardGeneric(\"path\"))\nsetGeneric(\"path<-\", signature=\"object\",\n    function(object, ..., value) standardGeneric(\"path<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### basename() and dirname() getters and setters\n###\n### The basename() and dirname() functions defined in the base package\n### only take 1 argument. We add the ... argument to the generic functions\n### defined here so they can be called with additional arguments.\n###\n\n.basename.useAsDefault <- function(path, ...) base::basename(path, ...)\nsetGeneric(\"basename\",\n    function(path, ...) standardGeneric(\"basename\"),\n    useAsDefault=.basename.useAsDefault\n)\nsetGeneric(\"basename<-\", signature=\"path\",\n    function(path, ..., value) standardGeneric(\"basename<-\")\n)\n\n.dirname.useAsDefault <- function(path, ...) base::dirname(path, ...)\nsetGeneric(\"dirname\",\n    function(path, ...) standardGeneric(\"dirname\"),\n    useAsDefault=.dirname.useAsDefault\n)\nsetGeneric(\"dirname<-\", signature=\"path\",\n    function(path, ..., value) standardGeneric(\"dirname<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default basename() and dirname() getters\n###\n### The purpose of these methods is to make the basename() and dirname()\n### getters work out-of-the-box on any object for which the path()\n### getter works.\n###\n\nsetMethod(\"basename\", \"ANY\",\n    function(path, ...)\n    {\n        ## If 'path' inherits from character (e.g. 'path' is a glue object\n        ## as returned by something like 'glue::glue(\"some/path\")'), we must\n        ## return 'base::basename(path)'.\n        ## See https://github.com/Bioconductor/BiocGenerics/issues/10\n        if (is.character(path) || !is.object(path)) {\n            ## We intentionally pass ... to cause failure if additional\n            ## arguments were supplied.\n            base::basename(path, ...)\n        } else {\n            base::basename(path(path, ...))\n        }\n    }\n)\n\nsetMethod(\"dirname\", \"ANY\",\n    function(path, ...)\n    {\n        ## If 'path' inherits from character (e.g. 'path' is a glue object\n        ## as returned by something like 'glue::glue(\"some/path\")'), we must\n        ## return 'base::dirname(path)'.\n        if (is.character(path) || !is.object(path)) {\n            ## We intentionally pass ... to cause failure if additional\n            ## arguments were supplied.\n            base::dirname(path, ...)\n        } else {\n            base::dirname(path(path, ...))\n        }\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default basename() and dirname() setters\n###\n### The purpose of these replacement methods is to make the basename() and\n### dirname() setters work out-of-the-box on any object for which the path()\n### getter and setter work.\n###\n\nsetReplaceMethod(\"basename\", \"character\",\n    function(path, ..., value)\n    {\n        if (length(list(...)) != 0L) {\n            dots <- match.call(expand.dots=FALSE)[[3L]]\n            stop(unused_arguments_msg(dots))\n        }\n        path_len <- length(path)\n        path <- setNames(file.path(dirname(path), value), names(path))\n        if (length(path) != path_len)\n            stop(\"number of supplied basenames is incompatible \",\n                 \"with number of paths\")\n        path\n    }\n)\n\nsetReplaceMethod(\"basename\", \"ANY\",\n    function(path, ..., value)\n    {\n        ppath <- path(path)\n        basename(ppath, ...) <- value\n        path(path) <- ppath\n        path\n    }\n)\n\nsetReplaceMethod(\"dirname\", \"character\",\n    function(path, ..., value)\n    {\n        if (length(list(...)) != 0L) {\n            dots <- match.call(expand.dots=FALSE)[[3L]]\n            stop(unused_arguments_msg(dots))\n        }\n        path_len <- length(path)\n        path <- setNames(file.path(value, basename(path)), names(path))\n        if (length(path) != path_len)\n            stop(\"number of supplied dirnames is incompatible \",\n                 \"with number of paths\")\n        path\n    }\n)\n\nsetReplaceMethod(\"dirname\", \"ANY\",\n    function(path, ..., value)\n    {\n        ppath <- path(path)\n        dirname(ppath, ...) <- value\n        path(path) <- ppath\n        path\n    }\n)\n\n",
        "plotMA.R": "setGeneric(\"plotMA\", function(object, ...) {\n    standardGeneric(\"plotMA\")\n})\n\nsetMethod(\"plotMA\", signature=\"ANY\", \n  definition = function(object, ...) {\n     msg = sprintf(\"Error from the generic function 'plotMA' defined in package 'BiocGenerics': no S4 method definition for argument '%s' of class '%s' was found. Did you perhaps mean calling the function 'plotMA' from another package, e.g. 'limma'? In that case, please use the syntax 'limma::plotMA'.\",\n         deparse(substitute(object)), class(object))\n     stop(msg)\n })\n",
        "plotPCA.R": "setGeneric(\"plotPCA\", function(object, ...) {\n    standardGeneric(\"plotPCA\")\n})\n",
        "rank.R": "### =========================================================================\n### The rank() generic\n### -------------------------------------------------------------------------\n###\n\n### base::rank() doesn't have the ellipsis. We add it to the generic\n### function defined below so methods can support additional arguments (e.g.\n### the 'ignore.strand' argument for the method for GenomicRanges objects).\n\n.is.rank.useAsDefault <- function(x, na.last=TRUE,\n    ties.method=c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"), ...)\n{\n    base::rank(x, na.last=na.last, ties.method=ties.method, ...)\n}\n\nsetGeneric(\"rank\", signature=\"x\",\n    function(x, na.last=TRUE,\n        ties.method=c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"), ...)\n        standardGeneric(\"rank\"),\n    useAsDefault=.is.rank.useAsDefault\n)\n\n",
        "relist.R": "### =========================================================================\n### The relist() generic\n### -------------------------------------------------------------------------\n###\n### Note that utils::relist is an S3 generic.\n\nsetGeneric(\"relist\")\n\n",
        "rep.R": "### =========================================================================\n### The rep.int() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"rep.int\")\n\n",
        "replaceSlots.R": "### =========================================================================\n### Efficient multiple slots replacement of an S4 object\n### -------------------------------------------------------------------------\n###\n### From a caller point of views, replacement of the slots should feel atomic\n### i.e. the object gets validated only after all the slots have been replaced.\n###\n### NOTE: The stuff in this file (not exported) doesn't really belong to\n### BiocGenerics.\n###\n### TODO: This stuff would need to be moved to a more appropriate place (when\n### we have one).\n###\n\nunsafe_replaceSlots <- function(object, ..., .slotList=list())\n{\n    ## This function is no longer 'unsafe', in that it does not do\n    ## in-place modification via `slot<-()`; see\n    ## https://github.com/Bioconductor/BiocGenerics/pull/1\n    slots <- c(list(...), .slotList)\n    slots_names <- names(slots)\n    ## This is too slow. See further down for a much faster way to check\n    ## that the supplied slots exist.\n    #invalid_idx <- which(!(slots_names %in% slotNames(object)))\n    #if (length(invalid_idx) != 0L) {\n    #    in1string <- paste0(slots_names[invalid_idx], collapse=\", \")\n    #    stop(wmsg(\"invalid slot(s) for \", class(object), \" instance: \",\n    #              in1string))\n    #}\n    for (i in seq_along(slots)) {\n        slot_name <- slots_names[[i]]\n        if (slot_name == \"mcols\")\n            slot_name <- \"elementMetadata\"\n        ## Even if we won't make any use of 'old_slot_val', this is a very\n        ## efficient way to check that the supplied slot exists.\n        ## We need to check this because the slot() setter won't raise an error\n        ## in case of invalid slot name when used with 'check=FALSE'. It will\n        ## silently be a no-op!\n        old_slot_val <- slot(object, slot_name) # check slot existence\n        slot_val <- slots[[i]]\n        ## Too risky! identical() is not reliable enough e.g. with objects\n        ## that contain external pointers. For example, DNAStringSet(\"A\")\n        ## and DNAStringSet(\"T\") are considered to be identical! identical()\n        ## would first need to be fixed.\n        #if (identical(old_slot_val, slot_val))\n        #    next\n        slot(object, slot_name, check=FALSE) <- slot_val\n    }\n    object\n}\n\n### replaceSlots() is essentially a more efficient initialize(), especially\n### when called with 'check=FALSE'.\nreplaceSlots <- function(object, ..., check=TRUE)\n{\n    if (!isTRUEorFALSE(check)) \n        stop(\"'check' must be TRUE or FALSE\")\n    object <- unsafe_replaceSlots(object, ...)\n    if (check)\n        validObject(object)\n    object\n}\n\n",
        "residuals.R": "### =========================================================================\n### The residuals() generic\n### -------------------------------------------------------------------------\n###\n### Note that stats::residuals is an S3 generic.\n\nsetGeneric(\"residuals\")\n\n",
        "row_colnames.R": "### =========================================================================\n### The rownames() and colnames() generics\n### -------------------------------------------------------------------------\n###\n\n### Dispatch on the 1st arg (the 'x' arg) only!\nsetGeneric(\"rownames\", signature=\"x\")\n\nsetGeneric(\"rownames<-\")\n\n### Dispatch on the 1st arg (the 'x' arg) only!\nsetGeneric(\"colnames\", signature=\"x\")\n\nsetGeneric(\"colnames<-\")\n\n",
        "saveRDS.R": "### =========================================================================\n### The saveRDS() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic\n### in package \"base\" would dispatch on all its argument ('object', 'file',\n### 'ascii', etc...). Here we set dispatch on the 1st arg (the 'object' arg)\n### only!\n\nsetGeneric(\"saveRDS\", signature=\"object\")\n\n### Note that this overwrites base::saveRDS()!\nsetMethod(\"saveRDS\", \"ANY\",\n    function(object, file=\"\", ascii=FALSE, version=NULL,\n             compress=TRUE, refhook=NULL)\n    {\n        ## Only a warning for now. Should we make this an error?\n        if (containsOutOfMemoryData(object))\n            warning(\"Object contains out-of-memory data so cannot be \",\n                    \"serialized reliably.\\n  See '?containsOutOfMemoryData'.\")\n        base::saveRDS(object, file=file, ascii=ascii, version=version,\n                      compress=compress, refhook=refhook)\n    }\n)\n\n",
        "score.R": "### =========================================================================\n### The score() and `score<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"score\", function(x, ...) standardGeneric(\"score\"))\n\nsetGeneric(\"score<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"score<-\")\n)\n\n",
        "setops.R": "### =========================================================================\n### The union(), intersect(), setdiff(), and setequal() generics\n### -------------------------------------------------------------------------\n###\n### The default methods are defined in CRAN package generics.\n\nsetGeneric(\"union\",\n    function(x, y, ...) standardGeneric(\"union\"),\n    useAsDefault=generics::union\n)\n\nsetGeneric(\"intersect\",\n    function(x, y, ...) standardGeneric(\"intersect\"),\n    useAsDefault=generics::intersect\n\n)\n\nsetGeneric(\"setdiff\",\n    function(x, y, ...) standardGeneric(\"setdiff\"),\n    useAsDefault=generics::setdiff\n)\n\nsetGeneric(\"setequal\",\n    function(x, y, ...) standardGeneric(\"setequal\"),\n    useAsDefault=generics::setequal\n)\n\n",
        "sort.R": "### =========================================================================\n### The sort() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::sort is an S3 generic.\n###\n### Need to explicitly define this generic otherwise the implicit generic\n### in package \"base\" would dispatch on ('x', 'decreasing'). Here we set\n### dispatch on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"sort\", signature=\"x\")\n\n",
        "start.R": "### =========================================================================\n### The start(), end(), width(), and pos() generic getters and setters\n### -------------------------------------------------------------------------\n###\n### Note that stats::start and stats::end are S3 generics.\n###\n\nsetGeneric(\"start\")\n\nsetGeneric(\"start<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"start<-\")\n)\n\nsetGeneric(\"end\")\n\nsetGeneric(\"end<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"end<-\")\n)\n\nsetGeneric(\"width\", function(x) standardGeneric(\"width\"))\n\nsetGeneric(\"width<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"width<-\")\n)\n\n### No pos() setter for now.\nsetGeneric(\"pos\", function(x) standardGeneric(\"pos\"))\n\n",
        "strand.R": "### =========================================================================\n### The strand() and `strand<-`() generics\n### -------------------------------------------------------------------------\n\nsetGeneric(\"strand\", function(x, ...) standardGeneric(\"strand\"))\n\nsetGeneric(\"strand<-\", function(x, ..., value) standardGeneric(\"strand<-\"))\n\nunstrand <- function(x)\n{\n    strand(x) <- \"*\"\n    x\n}\n\nsetGeneric(\"invertStrand\", function(x) standardGeneric(\"invertStrand\"))\n\nsetMethod(\"invertStrand\", \"ANY\",\n    function(x)\n    {\n        strand(x) <- invertStrand(strand(x))\n        x\n    }\n)\n\n",
        "subset.R": "### =========================================================================\n### The subset() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::subset is an S3 generic.\n\nsetGeneric(\"subset\")\n\n",
        "t.R": "### =========================================================================\n### The t() generic\n### -------------------------------------------------------------------------\n###\n### Note that base::t is an S3 generic.\n\nsetGeneric(\"t\")\n",
        "table.R": "### =========================================================================\n### The table() generic\n### -------------------------------------------------------------------------\n\n### base::table() has a broken signature (list.names() is a function\n### defined *inside* the body of base::table() so the default value for the\n### 'dnn' arg is an expression that cannot be evaluated *outside* the\n### base::table environment, this is poor design), we cannot keep all the\n### extra arguments in the table() generic (those extra arguments are ugly\n### and nobody uses them anyway).\n#setGeneric(\"table\", signature=\"...\",\n#    function(..., exclude = if (useNA == \"no\") c(NA, NaN),\n#                  useNA = c(\"no\", \"ifany\", \"always\"),\n#                  dnn = list.names(...),\n#                  deparse.level = 1)\n#        standardGeneric(\"table\")\n#)\n\n### So we use this instead.\n\n.table.useAsDefault <- function(...) base::table(...)\n\nsetGeneric(\"table\", signature=\"...\",\n    function(...) standardGeneric(\"table\"),\n    useAsDefault=.table.useAsDefault\n)\n\n",
        "tapply.R": "### =========================================================================\n### The tapply() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st and 2nd args only!\n\nsetGeneric(\"tapply\", signature=c(\"X\", \"INDEX\"))\n\n",
        "testPackage.R": "### \n\npackageRoot <- function(path)\n{\n    hasDescription <- function(path) {\n        file.exists(file.path(path, \"DESCRIPTION\"))\n    }\n    isRoot <- function(path) {\n        identical(path, dirname(path))\n    }\n    while (!hasDescription(path) && !isRoot(path)) {\n        path <- dirname(path)\n    }\n    if (isRoot(path)) {\n        NULL\n    } else {\n        path\n    }\n}\n\npackageInfo <- function(path)\n{\n    as.data.frame(read.dcf(file.path(path, \"DESCRIPTION\")),\n                  stringsAsFactors=FALSE)\n}\n\ntestPackage <- function(pkgname = NULL,\n                        subdir=\"unitTests\",\n                        pattern=\"^test_.*\\\\.R$\",\n                        path = getwd())\n{\n    .failure_details <- function(result) {\n        res <- result[[1L]]\n        if (res$nFail > 0 || res$nErr > 0) {\n            Filter(function(x) length(x) > 0,\n                   lapply(res$sourceFileResults,\n                          function(fileRes) {\n                              names(Filter(function(x) x$kind != \"success\",\n                                           fileRes))\n                          }))\n        } else list()\n    }\n\n    if (is.null(pkgname)) {\n        root <- packageRoot(path)\n        if (is.null(root))\n            stop(\"could not infer package root directory\")\n\n        pkgname0 <- packageInfo(root)$Package\n        if (is.null(pkgname)) {\n            pkgname <- pkgname0\n        } else if (!identical(pkgname, pkgname0)) {\n            stop(\"'pkgname' and inferred DESCRIPTION 'Package' differ\")\n        }\n    } else {\n        root <- system.file(package=pkgname)\n    }\n\n    library(pkgname, character.only = TRUE, quietly=TRUE)\n\n    dir <- file.path(root, subdir)\n    if (!file.exists(dir)) {            # try inst/subdir\n        dir <- file.path(root, \"inst\", subdir)\n    }\n    if (!file.exists(dir)) {\n        stop(\"unable to find unit tests, no subdir \", sQuote(subdir))\n    }\n\n    ## If we only load RUnit's namespace without attaching the package to\n    ## the search path, then many tests in many packages will fail with\n    ## errors like: could not find function \"checkIdentical\"\n    #if (!requireNamespace(\"RUnit\", quietly=TRUE))\n    #    stop(\"Couldn't load the RUnit package. You need to \",\n    #         \"install it before\\n  you can use testPackage().\")\n    library(\"RUnit\", quietly=TRUE)\n    RUnit_opts <- getOption(\"RUnit\", list())\n    RUnit_opts$verbose <- 0L\n    RUnit_opts$silent <- TRUE\n    RUnit_opts$verbose_fail_msg <- TRUE\n    oopt <- options(RUnit = RUnit_opts)\n    on.exit(options(oopt))\n    suite <- RUnit::defineTestSuite(name=paste(pkgname, \"RUnit Tests\"),\n                                    dirs=dir,\n                                    testFileRegexp=pattern,\n                                    rngKind=\"default\",\n                                    rngNormalKind=\"default\")\n    result <- RUnit::runTestSuite(suite)\n    cat(\"\\n\\n\")\n    RUnit::printTextProtocol(result, showDetails=FALSE)\n    if (length(details <- .failure_details(result)) > 0) {\n        cat(\"\\nTest files with failing tests\\n\")\n        for (i in seq_along(details)) {\n            cat(\"\\n  \", basename(names(details)[[i]]), \"\\n\")\n            for (j in seq_along(details[[i]])) {\n                cat(\"    \", details[[i]][[j]], \"\\n\")\n            }\n        }\n        cat(\"\\n\\n\")\n        stop(\"unit tests failed for package \", pkgname)\n    }\n    result\n}\n",
        "toTable.R": "### =========================================================================\n### The toTable() generic\n### -------------------------------------------------------------------------\n\nsetGeneric(\"toTable\", function(x, ...) standardGeneric(\"toTable\"))\n\n",
        "type.R": "### =========================================================================\n### The type() getter and setter\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getter\n###\n\nsetGeneric(\"type\", function(x) standardGeneric(\"type\"))\n\nsetMethod(\"type\", \"vector\", function(x) typeof(x))\n\nsetMethod(\"type\", \"array\", function(x) typeof(x))\n\nsetMethod(\"type\", \"factor\", function(x) \"character\")\n\n### NOT exported but used in S4Arrays.\n### Return a list with one list element per column in data frame 'x', with\n### the exception that a length-1 list is returned when 'x' has zero column.\n### All the list elements in the returned list are guaranteed to be ordinary\n### vectors (atomic or list) of length 0.\n### Note that:\n### - extract_data_frame_slice0() works on a data.frame object only if\n###   as.vector() can be applied to all its columns.\n### - Additionally, extract_data_frame_slice0() would also work out-of-the-box\n###   on any data-frame-like object granted that the object supports\n###   x[0L, , drop=FALSE]. This includes DataFrame, data.table, and\n###   tibble (tbl_df) objects.\nextract_data_frame_slice0 <- function(x)\n{\n    if (ncol(x) == 0L)\n        return(list(logical(0)))\n    x0 <- x[0L, , drop=FALSE]\n    ## Apply as.vector() on each column to turn them into ordinary vectors.\n    ## In particular this will turn columns that are factors into character\n    ## vectors, and columns that are Rle objects into atomic vectors of the\n    ## corresponding types.\n    ## Note that as.vector() is not guaranteed to work on all columns. For\n    ## example 'x' could be a data.frame or DataFrame object where some\n    ## columns are S4 objects that don't support as.vector(), in which\n    ## case 'type(x)' will fail.\n    lapply(x0, as.vector)\n}\n\n.get_data_frame_type <- function(x)\n{\n    slice0 <- extract_data_frame_slice0(x)\n    type(unlist(slice0, recursive=FALSE, use.names=FALSE))\n}\n\nsetMethod(\"type\", \"data.frame\", .get_data_frame_type)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setter\n###\n\nsetGeneric(\"type<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"type<-\")\n)\n\nsetReplaceMethod(\"type\", \"vector\",\n    function(x, value) `storage.mode<-`(x, value=value)\n)\n\nsetReplaceMethod(\"type\", \"array\",\n    function(x, value) `storage.mode<-`(x, value=value)\n)\n\n",
        "unique.R": "### =========================================================================\n### The unique() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on ('x', 'incomparables'). Here we set\n### dispatch on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"unique\", signature=\"x\")\n\n",
        "unlist.R": "### =========================================================================\n### The unlist() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"base\" would dispatch on all its arguments. Here we set dispatch\n### on the 1st arg (the 'x' arg) only!\n\nsetGeneric(\"unlist\", signature=\"x\")\n\n",
        "unsplit.R": "### =========================================================================\n### The unsplit() generic\n### -------------------------------------------------------------------------\n###\n### unsplit should not dispatch on 'drop'\n\nsetGeneric(\"unsplit\",\n           function (value, f, drop = FALSE) standardGeneric(\"unsplit\"),\n           signature=c(\"value\", \"f\"))\n\n",
        "updateObject.R": "### =========================================================================\n### The updateObject() generic and related utilities\n### -------------------------------------------------------------------------\n###\n### An \"updateObject\" default method + methods for some standard types are\n### also provided.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Utilities.\n###\n\nupdateObjectFrom_errf <- function(..., verbose=FALSE) {\n    function(err) {\n        if (verbose)\n            message(..., \":\\n    \", conditionMessage(err),\n                    \"\\n    trying next method...\")\n        NULL\n    }\n}\n\ngetObjectSlots <- function(object)  # object, rather than class defn, slots\n{\n    if (!is.object(object) || isVirtualClass(class(object)[[1L]]))\n        return(NULL)\n    value <- attributes(object)\n    value$class <- NULL\n    if (is(object, \"vector\")) {\n        .Data <- as.vector(object)\n        attr(.Data, \"class\") <- NULL\n        attrNames <- c(\"comment\", \"dim\", \"dimnames\",\n                       \"names\", \"row.names\", \"tsp\")\n        for (nm in names(value)[names(value) %in% attrNames])\n            attr(.Data, nm) <- value[[nm]]\n        value <- value[!names(value) %in% attrNames]\n        value$.Data <- .Data\n    }\n    value\n}\n\nupdateObjectFromSlots <- function(object, objclass=class(object)[[1L]],\n                                  ..., verbose=FALSE)\n{\n    if (is(object, \"environment\")) {\n        if (verbose)\n            message(\"returning original object of class 'environment'\")\n        return(object)\n    }\n    classSlots <- slotNames(objclass)\n    if (is.null(classSlots)) {\n        if (verbose)\n            message(\"definition of '\", objclass, \"' has no slots; \",\n                    \"returning original object\")\n        return(object)\n    }\n    if (verbose)\n        message(\"updateObjectFromSlots(object = '\", class(object)[[1L]],\n                \"' class = '\", objclass, \"')\")\n    objectSlots <- getObjectSlots(object)\n    ## de-mangle and remove NULL\n    nulls <- sapply(names(objectSlots),\n                    function(slt) is.null(slot(object, slt)))\n    objectSlots[nulls] <- NULL\n    joint <- intersect(names(objectSlots), classSlots)\n    toUpdate <- joint[joint!=\".Data\"]\n    objectSlots[toUpdate] <- lapply(objectSlots[toUpdate],\n                                    updateObject, ..., verbose=verbose)\n    toDrop <- which(!names(objectSlots) %in% classSlots)\n    if (length(toDrop) > 0L) {\n        warning(\"dropping slot(s) '\",\n                paste(names(objectSlots)[toDrop], collapse=\"', '\"),\n                \"' from object = '\", class(object)[[1L]], \"'\")\n        objectSlots <- objectSlots[-toDrop]\n    }\n    ## ad-hoc methods for creating new instances\n    res <- NULL\n    if (is.null(res)) {\n        if (verbose)\n            message(\"heuristic updateObjectFromSlots, method 1\")\n        res <- tryCatch({\n                   do.call(new, c(objclass, objectSlots[joint]))\n               }, error=updateObjectFrom_errf(\n                      \"'new(\\\"\", objclass, \"\\\", ...)' from slots failed\",\n                      verbose=verbose))\n    }\n    if (is.null(res)) {\n        if (verbose)\n            message(\"heuristic updateObjectFromSlots, method 2\")\n        res <- tryCatch({\n                   obj <- do.call(new, list(objclass))\n                   for (slt in joint)\n                       slot(obj, slt) <- updateObject(objectSlots[[slt]],\n                                                      ..., verbose=verbose)\n                   obj\n               }, error=updateObjectFrom_errf(\n                      \"failed to add slots to 'new(\\\"\", objclass, \"\\\", ...)'\",\n                      verbose=verbose))\n    }\n    if (is.null(res))\n        stop(\"could not updateObject to class '\", objclass, \"'\",\n             \"\\nconsider defining an 'updateObject' method for class '\",\n             class(object)[[1L]], \"'\")\n    res\n}\n\ngetObjectFields <- function(object)\n{\n    value <- object$.refClassDef@fieldClasses\n    for (field in names(value))\n        value[[field]] <- object$field(field)\n    value\n}\n\nupdateObjectFromFields <-\n    function(object, objclass=class(object)[[1L]], ..., verbose=FALSE)\n{\n    if (verbose)\n        message(\"updateObjectFromFields(object = '\", class(object)[[1L]],\n                \"' objclass = '\", objclass, \"')\")\n\n    classFields <- names(getRefClass(objclass)$fields())\n    if (is.null(classFields)) {\n        if (verbose)\n            message(\"definition of '\", objclass, \"' has no fields; \",\n                    \"regurning original object\")\n        return(object)\n    }\n\n    objectFields <- getObjectFields(object)\n\n    toUpdate <- joint <- intersect(names(objectFields), classFields)\n    objectFields[toUpdate] <-\n        lapply(objectFields[toUpdate], updateObject, ..., verbose=verbose)\n    toDrop <- which(!names(objectFields) %in% classFields)\n    if (length(toDrop) > 0L) {\n        warning(\"dropping fields(s) '\",\n                paste(names(objectFields)[toDrop], collapse=\"', '\"),\n                \"' from object = '\", class(object)[[1L]], \"'\")\n        objectFields <- objectFields[-toDrop]\n    }\n\n        ## ad-hoc methods for creating new instances\n\n    if (verbose)\n        message(\"heuristic updateObjectFromFields, method 1\")\n    res <- tryCatch({\n        do.call(new, c(objclass, objectFields[joint]))\n    }, error = updateObjectFrom_errf(\n           \"'new(\\\"\", objclass, \"\\\", ...' from slots failed\",\n           verbose=verbose)\n    )\n\n    if (is.null(res))\n        stop(\"could not updateObject to class '\", objclass, \"'\",\n             \"\\nconsider defining an 'updateObject' method for class '\",\n             class(object)[[1L]], \"'\")\n    res\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### attach_classdef_and_updateobjdef_pkgs()\n###\n\n### Known invalid packages found in 'attr(class(x), \"package\")' as of\n### Nov 17, 2021.\n.KNOWN_INVALID_CLASSDEF_PKGS <- c(\n  ## For some serialized S4 instances in the hubs 'attr(class(x), \"package\")'\n  ## is set to \".GlobalEnv\"! This is the case for example for CellMapperList\n  ## instances EH170 to EH175 in ExperimentHub. Not sure how that's allowed\n  ## but let's just deal with it.\n    \".GlobalEnv\",\n  ## SimResults class (e.g.\n  ## \"iCOBRA/inst/extdata/cobradata_example_simres.Rdata\") is defined in the\n  ## benchmarkR package which is not part of CRAN or Bioconductor (GitHub-only\n  ## package).\n    \"benchmarkR\",\n  ## The galgo.Obj class (e.g. \"GSgalgoR/inst/extdata/results/final_1.rda\")\n  ## used to be defined in galgoR but this package no longer exists (has\n  ## been renamed GSgalgoR).\n    \"galgoR\",\n  ## The MutationFeatureData class (e.g.\n  ## decompTumor2Sig/inst/extdata/Nik-Zainal_PMID_22608084-pmsignature-G.Rdata)\n  ## is defined in the pmsignature package which is not part of CRAN or\n  ## Bioconductor (GitHub-only package).\n    \"pmsignature\",\n  ## The QCStats class (e.g. \"arrayMvout/inst/simpleaffy/afxsubQC.rda\")\n  ## was defined in simpleaffy which got removed in BioC 3.13.\n    \"simpleaffy\",\n  ## The YAQCStats class (e.g. \"qcmetrics/inst/extdata/yqc.rda\")\n  ## was defined in yaqcaffy which got removed in BioC 3.14.\n    \"yaqcaffy\"\n)\n\n### A wrapper around attachNamespace() that tries to attach the package only\n### if it's not already attached.\n.attach_namespace <- function(pkg)\n{\n    if (!(paste0(\"package:\", pkg) %in% search())) {\n        suppressMessages(suppressWarnings(suppressPackageStartupMessages(\n            attachNamespace(pkg)\n        )))\n    }\n}\n\n### For some unclear reasons, updateObject(x) will fail sometimes if the\n### package where class(x) is defined (\"classdef\" pkg) is loaded but not\n### attached, or if the package where the updateObject() method for objects\n### of class class(x) is defined (\"updateobjdef\" pkg) is loaded but not\n### attached.\n### This happens for example if 'x' is of class enrichResult (the enrichResult\n### class is defined in the DOSE package) and if the DOSE package was\n### indirectly loaded with library(TimiRGeN).\n### This helper function will make sure that the \"classdef\" and \"updateobjdef\"\n### packages gets attached.\n### NOT exported but used in the updateObject package (in addition to being\n### used in the updateObject() generic function below).\nattach_classdef_and_updateobjdef_pkgs <- function(x_class)\n{\n    classdef_pkg <- attr(x_class, \"package\")\n    if (is.null(classdef_pkg) || classdef_pkg %in% .KNOWN_INVALID_CLASSDEF_PKGS)\n        return()\n    .attach_namespace(classdef_pkg)\n    updateobjdef <- selectMethod(updateObject, x_class)\n    updateobjdef_pkg <- environmentName(environment(updateobjdef))\n    if (updateobjdef_pkg == \"R_GlobalEnv\")\n        return()\n    .attach_namespace(updateobjdef_pkg)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### TODO: Would be cleaner if 'check' was a formal argument.\nsetGeneric(\"updateObject\", signature=\"object\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (!isTRUEorFALSE(verbose))\n            stop(\"'verbose' must be TRUE or FALSE\")\n        if (isTRUE(getOption(\"updateObject.can.attach.packages\"))) {\n            ## We silently try to **attach** (loading is not enough) the\n            ## packages where class(object) and\n            ## selectMethod(updateObject, class(object)) are defined.\n            ## This increases the chances of success of updateObject(object).\n            ## See attach_classdef_and_updateobjdef_pkgs() above for the\n            ## details.\n            ## Note that we don't do this by default, only if global\n            ## option \"updateObject.can.attach.packages\" is set to TRUE.\n            ## Problem with doing this by default (i.e. for regular use of\n            ## updateObject()) is that many packages call updateObject()\n            ## internally e.g. analyzeSNPhood() in the SNPhood package calls\n            ## the estimateSizeFactors() method for DESeqDataSet objects,\n            ## which in turn calls updateObject(). As a result, calling\n            ## analyzeSNPhood() will attach DESeq2 to the search path if\n            ## it's not already attached. Which is not good. See\n            ## https://stat.ethz.ch/pipermail/bioc-devel/2023-October/020024.html\n            ## for the full story.\n            ## Generally speaking, package functionalities should not have\n            ## the side effect of altering the search path.\n            ## The one place where we actually set global option\n            ## \"updateObject.can.attach.packages\" to TRUE is in\n            ## updateObject:::.update_object().\n            try(attach_classdef_and_updateobjdef_pkgs(class(object)),\n                silent=TRUE)\n        }\n        result <- standardGeneric(\"updateObject\")\n        check <- list(...)$check\n        if (is.null(check)) {\n            check <- TRUE\n        } else if (!isTRUEorFALSE(check)) {\n            stop(\"'check' must be TRUE or FALSE\")\n        }\n        if (check) {\n            if (verbose)\n                message(\"[updateObject] Validating the updated object ... \",\n                        appendLF=FALSE)\n            validObject(result)\n            if (verbose)\n                message(\"OK\")\n        }\n        result\n    }\n)\n\nsetMethod(\"updateObject\", \"ANY\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object=\\\"ANY\\\") default for object \",\n                    \"of class '\", class(object)[[1L]], \"'\")\n        if (length(getObjectSlots(object)) > 0L &&\n            !any(class(object) %in% c(\"data.frame\", \"factor\")))\n        {\n            updateObjectFromSlots(object, ..., verbose=verbose)\n        } else {\n            object\n        }\n    }\n)\n\nsetMethod(\"updateObject\", \"list\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object = 'list')\")\n        if (\"class\" %in% names(attributes(object)))\n            callNextMethod() # old-style S4\n        else {\n            result <- lapply(object, updateObject, ..., verbose=verbose)\n            attributes(result) <- attributes(object)\n            result\n        }\n    }\n)\n\nsetMethod(\"updateObject\", \"environment\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object = 'environment')\")\n        envLocked <- environmentIsLocked(object)\n        if (verbose) {\n            if (envLocked)\n                warning(\"updateObject duplicating locked environment\")\n            else\n                warning(\"updateObject modifying environment\")\n        }\n        env <- if (envLocked) new.env() else object\n        lapply(ls(object, all.names=TRUE),\n               function(elt) {    # side-effect!\n                   bindingLocked <- bindingIsLocked(elt, object)\n                   if (!envLocked && bindingLocked)\n                       stop(\"updateObject object = 'environment' \",\n                            \"cannot modify locked binding '\", elt, \"'\")\n                   else {\n                       env[[elt]] <<- updateObject(object[[elt]],\n                                                   ..., verbose=verbose)\n                       if (bindingLocked) lockBinding(elt, env)\n                   }\n                   NULL\n               })\n        attributes(env) <- attributes(object)\n        if (envLocked)\n            lockEnvironment(env)\n        env\n    }\n)\n\nsetMethod(\"updateObject\", \"formula\",\n    function(object, ..., verbose=FALSE)\n{\n    if (verbose)\n        ## object@.Environment could be too general, e.g,. R_GlobalEnv\n        message(\"updateObject(object = 'formula'); ignoring .Environment\")\n    object\n})\n\nsetMethod(\"updateObject\", \"envRefClass\",\n    function(object, ..., verbose=FALSE)\n{\n    msg <- sprintf(\"updateObject(object= '%s')\", class(object)[[1L]])\n    if (verbose)\n        message(msg)\n    updateObjectFromFields(object, ..., verbose=verbose)\n})\n",
        "utils.R": "### =========================================================================\n### Miscellaneous low-level utils\n### -------------------------------------------------------------------------\n###\n\n### Like toString() but also injects names(x) in the returned string.\n### For example with:\n###   x <- alist(b = 99, 98:96, zz)\n### to_string(x) returns:\n###   \"b = 99, 98:96, zz\"\nto_string <- function(x)\n{\n    x_names <- names(x)\n    x <- as.character(x)\n    if (!is.null(x_names)) {\n        x_names <- paste0(x_names, ifelse(x_names == \"\", \"\", \" = \"))\n        x <- paste0(x_names, x)\n    }\n    paste(x, collapse=\", \")\n}\n\nunused_arguments_msg <- function(dots)\n{\n    msg <- \"unused argument\"\n    if (length(dots) >= 2L)\n        msg <- c(msg, \"s\")\n    c(msg, \" (\", to_string(dots), \")\")\n}\n\n",
        "var.R": "### =========================================================================\n### The var() and sd() generics\n### -------------------------------------------------------------------------\n###\n### Dispatches only on 'x' (and 'y' for var)\n###\n\nsetGeneric(\"var\", signature=c(\"x\", \"y\"))\n\nsetGeneric(\"sd\", signature=\"x\")\n",
        "weights.R": "### =========================================================================\n### The weights() generic\n### -------------------------------------------------------------------------\n###\n### Note that stats::weights is an S3 generic.\n\nsetGeneric(\"weights\")\n\n",
        "which.R": "### =========================================================================\n### The which() generic\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"which\")\n\n",
        "which.min.R": "### =========================================================================\n### The which.min() and which.max() generics\n### -------------------------------------------------------------------------\n###\n### Michael, June 2016 (commit 860cce0ec85b94ebca190802be95e61c4f469d6b):\n###\n### The default methods (defined in the base package) only take 1 argument.\n### We add the ... argument to the generic functions defined here so they\n### can be called with an arbitrary number of effective arguments. This was\n### motivated by the desire to optionally return global subscripts from\n### methods on List.\n### These generics are slated to be internalized in base R. When that\n### happens, these calls will effectively be no-ops.\n\n.which.min.useAsDefault <- function(x, ...) base::which.min(x, ...)\n.which.max.useAsDefault <- function(x, ...) base::which.max(x, ...)\n\nsetGeneric(\"which.min\",\n    function(x, ...) standardGeneric(\"which.min\"),\n    useAsDefault=.which.min.useAsDefault\n)\n\nsetGeneric(\"which.max\",\n    function(x, ...) standardGeneric(\"which.max\"),\n    useAsDefault=.which.max.useAsDefault\n)\n\n",
        "xtabs.R": "### =========================================================================\n### The xtabs() generic\n### -------------------------------------------------------------------------\n###\n### Need to explicitly define this generic otherwise the implicit generic in\n### package \"stats\" would dispatch on all its arguments. Here we set dispatch\n### on the 2nd arg (the 'data' arg) only!\n\nsetGeneric(\"xtabs\", signature=\"data\")\n\n",
        "zzz.R": ".test <- function() testPackage(\"BiocGenerics\")\n\n"
    },
    "GenomeInfoDb": {
        "Ensembl-utils.R": "### =========================================================================\n### Some low-level utilities to fetch data from Ensembl\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### get_Ensembl_FTP_mysql_url() and get_Ensembl_FTP_gtf_url()\n###\n\n.ENSEMBL_FTP_PUB_URL <- \"ftp://ftp.ensembl.org/pub/\"\n.ENSEMBL_FTP_PUB_GRCH37_URL <- \"ftp://ftp.ensembl.org/pub/grch37/\"\n.ENSEMBLGENOMES_FTP_PUB_URL <- \"ftp://ftp.ensemblgenomes.org/pub/\"\n.ENSEMBL_FTP_RELEASE_PREFIX <- \"release-\"\n.ENSEMBL_DIVISIONS <- c(\"bacteria\", \"fungi\", \"metazoa\", \"plants\", \"protists\")\n\n.normarg_division <- function(division, use.grch37=FALSE)\n{\n    if (!isSingleStringOrNA(division))\n        stop(wmsg(\"'division' must be a single string (or NA)\"))\n    if (is.na(division))\n        return(NA)\n    if (division == \"\")\n        stop(wmsg(\"'division' cannot be the empty string\"))\n    if (use.grch37)\n        stop(wmsg(\"'division' and 'use.grch37' cannot both be specified\"))\n    if (!(division %in% .ENSEMBL_DIVISIONS))\n        stop(wmsg(\"'division' should be one of \",\n                  paste0('\"', .ENSEMBL_DIVISIONS, '\"', collapse=\", \")))\n    division\n}\n\n### 'division' must be NA or one of the Ensembl Genomes divisions.\n.get_Ensembl_FTP_top_url <- function(division=NA, use.grch37=FALSE)\n{\n    if (!isTRUEorFALSE(use.grch37))\n        stop(wmsg(\"'use.grch37' must be TRUE or FALSE\"))\n    division <- .normarg_division(division, use.grch37)\n    if (!is.na(division)) {\n        top_url <- paste0(.ENSEMBLGENOMES_FTP_PUB_URL, division, \"/\")\n    } else if (use.grch37) {\n        top_url <- .ENSEMBL_FTP_PUB_GRCH37_URL\n    } else {\n        top_url <- .ENSEMBL_FTP_PUB_URL\n    }\n    top_url\n}\n\n### 'division' must be NA or one of the Ensembl Genomes divisions.\nget_Ensembl_FTP_mysql_url <- function(release=NA, division=NA,\n                                      use.grch37=FALSE)\n{\n    if (!is_single_value(release))\n        stop(wmsg(\"'release' must be a single value\"))\n    top_url <- .get_Ensembl_FTP_top_url(division, use.grch37)\n    if (!is.na(release)) {\n        mysql_subdir <- paste0(.ENSEMBL_FTP_RELEASE_PREFIX, release, \"/mysql\")\n    } else if (is.na(division) && !use.grch37) {\n        mysql_subdir <- \"current_mysql\"\n    } else {\n        mysql_subdir <- \"current/mysql\"\n    }\n    paste0(top_url, mysql_subdir, \"/\")\n}\n\n### 'division' must be NA or one of the Ensembl Genomes divisions.\nget_Ensembl_FTP_gtf_url <- function(release=NA, division=NA,\n                                    use.grch37=FALSE)\n{\n    if (!is_single_value(release))\n        stop(wmsg(\"'release' must be a single value\"))\n    top_url <- .get_Ensembl_FTP_top_url(division, use.grch37)\n    if (!is.na(release)) {\n        gtf_subdir <- paste0(.ENSEMBL_FTP_RELEASE_PREFIX, release, \"/gtf\")\n    } else if (is.na(division) && !use.grch37) {\n        gtf_subdir <- \"current_gtf\"\n    } else {\n        gtf_subdir <- \"current/gtf\"\n    }\n    paste0(top_url, gtf_subdir, \"/\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .list_Ensembl_FTP_core_dbs()\n###\n\n### The keys are FTP URLs to \"mysql\" directories e.g.\n###   \"ftp://ftp.ensembl.org/pub/current_mysql/\"\n###   \"ftp://ftp.ensembl.org/pub/release-98/mysql/\"\n###   \"ftp://ftp.ensemblgenomes.org/pub/bacteria/current/mysql/\"\n###   \"ftp://ftp.ensemblgenomes.org/pub/plants/release-45/mysql/\"\n### etc...\n.Ensembl_FTP_cached_core_dbs <- new.env(parent=emptyenv())\n\n.list_Ensembl_FTP_core_dbs <- function(mysql_url, release=NA)\n{\n    stopifnot(isSingleString(mysql_url))\n    pattern <- \"_core_\"\n    core_dbs <- .Ensembl_FTP_cached_core_dbs[[mysql_url]]\n    if (is.null(core_dbs)) {\n        subdirs <- list_ftp_dir(mysql_url, subdirs.only=TRUE)\n        core_dbs <- subdirs[grep(pattern, subdirs, fixed=TRUE)]\n        .Ensembl_FTP_cached_core_dbs[[mysql_url]] <- core_dbs\n    }\n    if (is.na(release))\n        return(core_dbs)\n    pattern <- paste0(pattern, release, \"_\")\n    core_dbs[grep(pattern, core_dbs, fixed=TRUE)]\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### get_current_Ensembl_release()\n###\n\n### The keys are FTP URLs to Ensembl division top-level directories e.g.\n###   \"ftp://ftp.ensembl.org/pub/\"\n###   \"ftp://ftp.ensembl.org/pub/grch37/\"\n###   \"ftp://ftp.ensemblgenomes.org/pub/plants/\"\n### etc...\n.Ensembl_FTP_cached_releases <- new.env(parent=emptyenv())\n\n### 'division' must be NA or one of the Ensembl Genomes divisions.\n.list_Ensembl_FTP_releases <- function(division=NA, use.grch37=FALSE,\n                                       as.subdirs=FALSE)\n{\n    if (!isTRUEorFALSE(as.subdirs))\n        stop(wmsg(\"'as.subdirs' must be TRUE or FALSE\"))\n    top_url <- .get_Ensembl_FTP_top_url(division, use.grch37)\n    releases <- .Ensembl_FTP_cached_releases[[top_url]]\n    if (is.null(releases)) {\n        top_files <- list_ftp_dir(top_url)\n        nc <- nchar(.ENSEMBL_FTP_RELEASE_PREFIX)\n        prefixes <- substr(top_files, 1L, nc)\n        releases <- top_files[prefixes == .ENSEMBL_FTP_RELEASE_PREFIX]\n        releases <- substr(releases, nc + 1L, nchar(releases))\n        releases <- sort(as.integer(releases))\n        .Ensembl_FTP_cached_releases[[top_url]] <- releases\n    }\n    if (as.subdirs)\n        releases <- paste0(.ENSEMBL_FTP_RELEASE_PREFIX, releases)\n    releases\n}\n\n### 'division' must be NA or one of the Ensembl Genomes divisions.\nget_current_Ensembl_release <- function(division=NA, use.grch37=FALSE)\n{\n    releases <- .list_Ensembl_FTP_releases(division, use.grch37)\n    current_release <- max(as.integer(releases))\n    ## We should be done here. However, sometimes the Ensembl folks create\n    ## FTP folder ftp.ensembl.org/pub/release-<current_release>/ a few days\n    ## before it's officially released. In this case the folder typically\n    ## misses a bunch of subfolders like mysql/. So we check that subfolder\n    ## mysql/ can be listed and contains the right thing.\n    while (TRUE) {\n        mysql_url <- get_Ensembl_FTP_mysql_url(current_release, division,\n                                               use.grch37)\n        core_dbs <- try(suppressWarnings(\n                            .list_Ensembl_FTP_core_dbs(mysql_url)\n                        ), silent=TRUE)\n        if (inherits(core_dbs, \"try-error\") || length(core_dbs) == 0L) {\n            current_release <- current_release - 1L\n            next\n        }\n        ok <- grepl(paste0(\"_core_\", current_release, \"_\"), core_dbs)\n        if (!all(ok)) {\n            current_release <- current_release - 1L\n            next\n        }\n        break\n    }\n    current_release\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### fetch_species_index_from_Ensembl_FTP()\n###\n\n### The species index file can be used with Ensembl releases >= 96 and\n### Ensembl Genomes releases >= 22.\nuse_species_index_from_Ensembl_FTP <- function(release=NA, division=NA,\n                                               use.grch37=FALSE)\n{\n    if (!is_single_value(release))\n        stop(wmsg(\"'release' must be a single value\"))\n    if (!isTRUEorFALSE(use.grch37))\n        stop(wmsg(\"'use.grch37' must be TRUE or FALSE\"))\n    division <- .normarg_division(division, use.grch37)\n    if (use.grch37)\n        return(FALSE)\n    if (is.na(release))\n        return(TRUE)\n    release <- as.integer(release)\n    if (is.na(division))\n        return(release >= 96L)\n    release >= 22L\n}\n\n.get_Ensembl_FTP_species_index_url <- function(release=NA, division=NA)\n{\n    if (!is_single_value(release))\n        stop(wmsg(\"'release' must be a single value\"))\n    top_url <- .get_Ensembl_FTP_top_url(division)\n    if (is.na(division)) {\n        ## Available in Ensembl release 96 (March 2019) and above.\n        species_file <- \"species_EnsemblVertebrates.txt\"\n    } else {\n        ## Available in Ensembl Genomes release 17 (Feb 2013) and above.\n        ## However the current format is used only since release 22 (March\n        ## 2014). See .load_or_fetch_species_index_from_url() below.\n        species_file <- switch(division,\n            bacteria=\"species_EnsemblBacteria.txt\",\n            fungi=\"species_EnsemblFungi.txt\",\n            metazoa=\"species_EnsemblMetazoa.txt\",\n            plants=\"species_EnsemblPlants.txt\",\n            protists=\"species_EnsemblProtists.txt\",\n            stop(\"Invalid division: \", division, \"\\n  \",\n                 wmsg(\"Must be one of NA (stands for the main Ensembl \",\n                      \"division), \\\"bacteria\\\", \\\"fungi\\\", \\\"metazoa\\\", \",\n                      \"\\\"plants\\\", or \\\"protists\\\".\"))\n        )\n    }\n    if (is.na(release) && !is.na(division)) {\n        subdir <- \"current\"\n    } else {\n        if (is.na(release))\n            release <- get_current_Ensembl_release()\n        subdir <- paste0(.ENSEMBL_FTP_RELEASE_PREFIX, release)\n    }\n    paste0(top_url, subdir, \"/\", species_file)\n}\n\n.fetch_species_index_from_url <- function(url)\n{\n    species_index <- fetch_table_from_url(url, header=TRUE)\n    species_index_ncol <- ncol(species_index)\n    if (species_index_ncol != 15L && species_index_ncol != 16L)\n        stop(wmsg(url, \" does not contain the expected fields\"))\n\n    ## This is the format used in Ensembl releases >= 96 and Ensembl\n    ## Genomes releases >= 22.\n    expected_colnames <- c(\n        \"name\", \"species\", \"division\", \"taxonomy_id\",\n        \"assembly\", \"assembly_accession\", \"genebuild\", \"variation\",\n        \"pan_compara\", \"peptide_compara\", \"genome_alignments\",\n        \"other_alignments\", \"core_db\", \"species_id\"\n    )\n    ## The \"microarray\" field was added in Ensembl 103 and Ensembl Genomes 50.\n    if (species_index_ncol == 16L)\n        expected_colnames <- append(expected_colnames, \"microarray\", after=8L)\n\n    ## Note that Ensembl species index files are broken: the header line\n    ## specifies 14 fields separated by 13 tabs BUT each line of data\n    ## contains 14 tabs! The last tab is an additional tab placed\n    ## at the end of the line i.e. after the 14th value in the line.\n    ## For read.table() this means that there are actually 15 values\n    ## and that the last value is missing! As a consequence the colnames\n    ## on the returned data frame are completely messed up!\n    expected_messed_up_colnames <- c(\"row.names\", expected_colnames)\n    expected_messed_up_colnames[2L] <- \"X.name\"\n    if (!identical(colnames(species_index), expected_messed_up_colnames))\n        stop(wmsg(url, \" does not contain the expected fields\"))\n    colnames(species_index) <- c(expected_colnames,\n                                 paste0(\"V\", species_index_ncol))\n\n    ## The last column should be filled with NAs. Drop it.\n    stopifnot(all(is.na(species_index[[species_index_ncol]])))\n    species_index[-species_index_ncol]\n}\n\n.cached_species_index <- new.env(parent=emptyenv())\n\n.load_or_fetch_species_index_from_url <- function(url)\n{\n    species_index <- .cached_species_index[[url]]\n    if (is.null(species_index)) {\n        species_index <- .fetch_species_index_from_url(url)\n        .cached_species_index[[url]] <- species_index\n    }\n    species_index\n}\n\nfetch_species_index_from_Ensembl_FTP <- function(release=NA, division=NA)\n{\n    url <- .get_Ensembl_FTP_species_index_url(release=release,\n                                              division=division)\n    .load_or_fetch_species_index_from_url(url)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .lookup_species_in_species_index()\n###\n\n.normalize_species <- function(species) chartr(\" \", \"_\", tolower(species))\n\n.stop_on_ambiguous_lookup <- function(species_index, idx, max_print,\n                                      species, column, url)\n{\n    show_matching_entries <- function(species_index, idx) {\n        cat(\"\\n  Matching entries\")\n        truncate <- length(idx) > max_print\n        if (truncate) {\n            cat(\" (showing the first\", max_print, \"only)\")\n            idx <- head(idx, n=max_print)\n        }\n        cat(\":\\n\")\n        ## We drop columns that are totally uninteresting/meaningless in\n        ## the context of species lookup.\n        drop_columns <- c(\n            \"variation\", \"pan_compara\", \"peptide_compara\",\n            \"genome_alignments\", \"other_alignments\", \"species_id\"\n        )\n        m <- as.matrix(drop_cols(species_index[idx, ], drop_columns))\n        if (truncate) {\n            ellipsis <- \"...\"\n            m <- rbind(m, rep.int(ellipsis, ncol(m)))\n            rownames(m)[max_print + 1L] <- ellipsis\n        }\n        rownames(m) <- paste0(\"    \", rownames(m))\n        print(m, quote=FALSE, right=TRUE)\n    }\n    on.exit(show_matching_entries(species_index, idx))\n    stop(\"\\n  \", wmsg(\"Found \", length(idx), \" matches (case insensitive) \",\n              \"for \\\"\", species, \"\\\" in \\\"\", column, \"\\\" column of \",\n              \"Ensembl species index file:\"),\n              \"\\n    \", url)\n}\n\n### Find the core DB in 'core_dbs' that matches 'species'.\n.lookup_species_in_core_dbs <- function(species, core_dbs)\n{\n    trimmed_core_dbs <- sub(\"_core_.*$\", \"\", core_dbs)\n    ## First assume that 'species' was supplied as the name of a core DB\n    ## (after removal of the _core_.* suffix) e.g. \"homo_sapiens\".\n    idx <- grep(species, trimmed_core_dbs)\n    if (length(idx) == 1L)\n        return(idx)\n    ## Then assume that 'species' was supplied as the name of a BioMart\n    ## dataset e.g. \"hsapiens\" or \"hsapiens_gene_ensembl\".\n    abbrev_core_dbs <- sub(\"^(.)[^_]*_\", \"\\\\1\", trimmed_core_dbs)\n    if (species == \"mfuro_gene_ensembl\") {\n        abbrev_species <- \"mputorius_furo\"\n    } else {\n        abbrev_species <- strsplit(species, \"_\", fixed=TRUE)[[1L]][[1L]]\n    }\n    which(abbrev_species == abbrev_core_dbs)\n}\n\n### Find the row in 'species_index' that matches 'species'.\n.lookup_species_in_species_index <- function(species, species_index, url)\n{\n    ## Exact match (case insensitive).\n    search_columns <- c(\"name\", \"species\", \"taxonomy_id\",\n                        \"assembly\", \"assembly_accession\", \"core_db\")\n    for (column in search_columns) {\n        if (column %in% c(\"name\", \"taxonomy_id\")) {\n            target <- species\n        } else {\n            target <- .normalize_species(species)\n        }\n        idx <- which(tolower(species_index[ , column]) %in% target)\n        if (length(idx) == 1L)\n            return(idx)\n        if (length(idx) > 1L)\n            .stop_on_ambiguous_lookup(species_index, idx, 4L,\n                                      species, column, url)\n    }\n\n    ## Lookup 'species' in the \"core_db\" column.\n    idx <- .lookup_species_in_core_dbs(.normalize_species(species),\n                                       species_index[ , \"core_db\"])\n    if (length(idx) == 1L)\n        return(idx)\n    if (length(idx) > 1L)\n        .stop_on_ambiguous_lookup(species_index, idx, 4L,\n                                  species, \"core_db\", url)\n\n    ## Fuzzy match (grep()-based).\n    search_columns <- c(\"name\", \"species\", \"assembly\", \"core_db\")\n    for (column in search_columns) {\n        if (column %in% \"name\") {\n            target <- species\n        } else {\n            target <- .normalize_species(species)\n        }\n        idx <- grep(target, species_index[ , column], ignore.case=TRUE)\n        if (length(idx) == 1L)\n            return(idx)\n        if (length(idx) > 1L)\n            .stop_on_ambiguous_lookup(species_index, idx, 4L,\n                                      species, column, url)\n    }\n\n    ## We tried hard and failed!\n    stop(wmsg(\"Couldn't find \\\"\", species, \"\\\" in \",\n              \"Ensembl species index file:\"),\n         \"\\n    \", url)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level utilities for obtaining/making/checking \"species_info\" objects\n###\n### A \"species_info\" object is just a named list at the moment.\n###\n\n.extract_species_info_from_species_index <- function(species_index, idx,\n                                                     release=NA, division=NA)\n{\n    stopifnot(is_single_value(release))\n    if (is.na(release)) {\n        release <- get_current_Ensembl_release(division)\n    } else {\n        release <- as.integer(release)\n    }\n    list(\n        name=species_index[idx, \"name\"],\n        species=species_index[idx, \"species\"],\n        division=species_index[idx, \"division\"],\n        Ensembl_release=release,\n        taxonomy_id=species_index[idx, \"taxonomy_id\"],\n        assembly=species_index[idx, \"assembly\"],\n        assembly_accession=species_index[idx, \"assembly_accession\"],\n        core_db=species_index[idx, \"core_db\"]\n    )\n}\n\n.make_species_info_for_grch37 <- function(release=NA)\n{\n    stopifnot(is_single_value(release))\n    if (is.na(release)) {\n        release <- get_current_Ensembl_release(use.grch37=TRUE)\n    } else {\n        release <- as.integer(release)\n    }\n    core_db <- paste0(\"homo_sapiens_core_\", release, \"_37\")\n    list(\n        name=\"Human\",\n        species=\"homo_sapiens\",\n        division=\"EnsemblVertebrates\",\n        Ensembl_release=release,\n        taxonomy_id=9606L,\n        assembly=\"GRCh37\",\n        assembly_accession=\"GCF_000001405.13\",\n        core_db=core_db\n    )\n}\n\ncheck_species_info <- function(species_info)\n{\n    stopifnot(is.list(species_info))\n    fields <- names(species_info)\n    stopifnot(!is.null(fields), is_primary_key(fields),\n              all(c(\"species\", \"Ensembl_release\") %in% fields))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### get_Ensembl_FTP_core_db_url()\n###\n\n### Returns a single string with the \"species_info\" attribute (named list)\n### on it.\n.find_core_db_in_Ensembl_FTP_species_index <- function(species,\n                                                       release=NA, division=NA)\n{\n    stopifnot(isSingleString(species))\n    url <- .get_Ensembl_FTP_species_index_url(release=release,\n                                              division=division)\n    species_index <- .load_or_fetch_species_index_from_url(url)\n    idx <- .lookup_species_in_species_index(species, species_index, url)\n    species_info <- .extract_species_info_from_species_index(species_index,\n                                                             idx,\n                                                             release, division)\n    core_db <- species_info$core_db\n    attr(core_db, \"species_info\") <- species_info\n    core_db\n}\n\n.warn_species_was_ignored <- function(species)\n{\n    if (missing(species))\n        return(invisible(NULL))\n    ok <- FALSE\n    if (is_single_value(species)) {\n        if (is.na(species)) {\n            ok <- TRUE\n        } else if (is.character(species)) {\n            ok <- species == \"\" ||\n                  grepl(\"human\", species, ignore.case=TRUE) ||\n                  grepl(\"homo\", species, ignore.case=TRUE) ||\n                  grepl(\"sapiens\", species, ignore.case=TRUE) ||\n                  grepl(\"GRCh37\", species, ignore.case=TRUE)\n        }\n    }\n    if (!ok)\n        warning(wmsg(\"you've set 'use.grch37' to TRUE \",\n                     \"so 'species' was ignored\"))\n}\n\n### Returns a single string with the \"species_info\" attribute (named list)\n### on it.\n.predict_core_db_in_Ensembl_FTP_grch37 <- function(release=NA)\n{\n    species_info <- .make_species_info_for_grch37(release)\n    core_db <- species_info$core_db\n    attr(core_db, \"species_info\") <- species_info\n    core_db\n}\n\n### Returns a single string with the \"species_info\" attribute (named list)\n### on it.\n.find_core_db_in_Ensembl_FTP_core_dbs <- function(mysql_url, species,\n                                                  release=NA, division=NA)\n{\n    stopifnot(isSingleString(species))\n    core_dbs <- .list_Ensembl_FTP_core_dbs(mysql_url, release=release)\n    species2 <- .normalize_species(species)\n    idx <- .lookup_species_in_core_dbs(species2, core_dbs)\n    if (length(idx) != 1L)\n        stop(wmsg(\"found 0 or more than 1 subdir for \\\"\", species,\n                  \"\\\" species at \", mysql_url))\n    core_db <- core_dbs[[idx]]\n    if (is.na(release)) {\n        release <- get_current_Ensembl_release(division)\n    } else {\n        release <- as.integer(release)\n    }\n    attr(core_db, \"species_info\") <- list(\n        species=sub(\"_core_.*$\", \"\", core_db),\n        Ensembl_release=release,\n        core_db=core_db\n    )\n    core_db\n}\n\n### 'division' must be NA or one of the Ensembl Genomes divisions i.e.\n### \"bacteria\", \"fungi\", \"metazoa\", \"plants\", or \"protists\".\n### Return URL to Ensemble Core DB (FTP access) in a single string with\n### the \"species_info\" attribute (named list) on it.\nget_Ensembl_FTP_core_db_url <- function(species, release=NA, division=NA,\n                                        use.grch37=FALSE)\n{\n    mysql_url <- get_Ensembl_FTP_mysql_url(release=release,\n                                           division=division,\n                                           use.grch37=use.grch37)\n    if (use.grch37) {\n        ## We ignore user-supplied 'species'.\n        .warn_species_was_ignored(species)\n        core_db <- .predict_core_db_in_Ensembl_FTP_grch37(release)\n    } else {\n        if (!isSingleString(species) || species == \"\")\n            stop(wmsg(\"'species' must be a single non-empty string\"))\n        use_species_index <- use_species_index_from_Ensembl_FTP(\n                                           release=release,\n                                           division=division,\n                                           use.grch37=use.grch37)\n        if (use_species_index) {\n            ## The new way!\n            core_db <- .find_core_db_in_Ensembl_FTP_species_index(\n                                           species,\n                                           release=release,\n                                           division=division)\n        } else {\n            ## The old way. Dumb, unreliable, and slow!\n            core_db <- .find_core_db_in_Ensembl_FTP_core_dbs(\n                                           mysql_url,\n                                           species,\n                                           release=release, division=division)\n        }\n    }\n    species_info <- attr(core_db, \"species_info\")\n    check_species_info(species_info)\n    core_db_url <- paste0(mysql_url, core_db, \"/\")\n    attr(core_db_url, \"species_info\") <- species_info\n    core_db_url\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Fetch core DB data from the Ensembl FTP server\n###\n\nfetch_default_coord_systems_from_Ensembl_FTP <- function(core_db_url)\n{\n    coord_system <- fetch_table_dump_from_Ensembl_FTP(core_db_url,\n                                                      \"coord_system\")\n\n    ## Drop rows that do not have the default_version attrib.\n    keep_idx <- grep(\"default_version\", coord_system[ , \"attrib\"], fixed=TRUE)\n    ans <- S4Vectors:::extract_data_frame_rows(coord_system, keep_idx)\n\n    ## Even though we expect that column \"name\" will always have unique\n    ## values within the remaining rows, we want to be informed if this\n    ## is not the case.\n    coord_system.name <- ans[ , \"name\"]\n    if (anyDuplicated(coord_system.name))\n        warning(wmsg(\"column \\\"coord_system.name\\\" contains duplicates \",\n                     \"within the rows that have the default_version attrib\"))\n    ans\n}\n\n### Retrieves all synonyms for the supplied sequence ids.\n### This is done via tables \"seq_region_synonym\" and \"external_db\".\n### Return a list parallel to 'seq_region_ids' where each list element is a\n### named character vector containing all the synonyms for the corresponding\n### sequence id. The names on the character vector indicate the origin of\n### the synonym i.e. the external DB where it's used (e.g. \"INSDC\",\n### \"RefSeq_genomic\", \"UCSC\", \"ensembl_internal_synonym\", etc..)\n.fetch_synonyms_from_Ensembl_FTP <- function(core_db_url, seq_region_ids)\n{\n    stopifnot(is_primary_key(seq_region_ids))\n\n    all_synonyms <- fetch_table_dump_from_Ensembl_FTP(core_db_url,\n                                                      \"seq_region_synonym\")\n    keep_idx <- which(all_synonyms[ , \"seq_region_id\"] %in% seq_region_ids)\n    synonyms <- S4Vectors:::extract_data_frame_rows(all_synonyms, keep_idx)\n\n    external_dbs <- fetch_table_dump_from_Ensembl_FTP(core_db_url,\n                                                      \"external_db\")\n    synonyms <- join_dfs(synonyms, external_dbs,\n                         \"external_db_id\", \"external_db_id\",\n                         keep.Rcol=TRUE)  # we'll drop it below\n\n    f <- factor(synonyms[ , \"seq_region_id\"], levels=seq_region_ids)\n    unlisted_ans <- setNames(synonyms[ , \"synonym\"], synonyms[ , \"db_name\"])\n    split(unlisted_ans, f)\n}\n\n.attrib_type_codes_to_ids_from_Ensembl_FTP <- function(core_db_url, codes)\n{\n    if (!is.character(codes))\n        stop(wmsg(\"'codes' must be a character vector\"))\n    if (anyDuplicated(codes))\n        stop(wmsg(\"'codes' cannot contain duplicates\"))\n\n    ## UGLY HACK (AND TIME BOMB!): Get only the first 99 rows of\n    ## the 'attrib_type' table!\n    ## The reason we don't read in the entire table is because some rows at\n    ## the bottom of the table (rows with attrib_type_id >= 416, these rows\n    ## were added in Ensembl 75) contain embedded EOL characters that break\n    ## read.table(). Since in practice we only need to lookup the\n    ## attrib_type_id associated with the \"toplevel\" and \"non_ref\" codes,\n    ## and since these codes are generally found at the beginning of the\n    ## file (AFAIK \"toplevel\" has always been assigned the attrib_type_id\n    ## of 6 and the lines in the file seem to always be ordered by\n    ## attrib_type_id), reading in the first 99 rows should be way enough\n    ## to get what we need.\n    ##\n    ## APRIL 2022 UPDATE: It didn't take that long for the above time bomb\n    ## to explode! In Ensembl release 106, the rows in 'attrib_type.txt.gz'\n    ## for \"celegans\" are shuffled. See:\n    ##   http://ftp.ensembl.org/pub/release-106/mysql/caenorhabditis_elegans_core_106_279/\n    ## This is unseen before! Unfortunately this breaks our ugly hack. The\n    ## good news is that the issue that motivated our ugly hack in the first\n    ## place seems to have vanished! Tested with:\n    ##   for (release in c(75:88, 90:106)) {\n    ##     cat(release, \"\\n\")\n    ##     core_db_url <- GenomeInfoDb:::get_Ensembl_FTP_core_db_url(\n    ##                                               \"hsapiens\",\n    ##                                               release=release)\n    ##     attrib_type <- GenomeInfoDb:::fetch_table_dump_from_Ensembl_FTP(\n    ##                                               core_db_url,\n    ##                                               \"attrib_type\")\n    ##   }\n    ## Note that we skip release 89 because the dump files there are broken:\n    ##   http://ftp.ensembl.org/pub/release-89/mysql/homo_sapiens_core_89_38/\n    ## e.g. many of them (including dump file for \"attrib_type\" table) have\n    ## extension .gz.bz2 which is a mess!\n    #attrib_type <- fetch_table_dump_from_Ensembl_FTP(core_db_url,\n    #                                                 \"attrib_type\", nrows=99L)\n    attrib_type <- fetch_table_dump_from_Ensembl_FTP(core_db_url, \"attrib_type\")\n\n    m <- solid_match(codes, attrib_type[ , \"code\"],\n                     x_what=\"supplied code\",\n                     table_what=\"\\\"attrib_type.code\\\" value\")\n    bad_idx <- which(is.na(m))\n    if (length(bad_idx) != 0L) {\n        in1string <- paste0(codes[bad_idx], collapse=\", \")\n        stop(wmsg(\"table \\\"attrib_type\\\" has no entry for: \", in1string))\n    }\n    setNames(attrib_type[m, \"attrib_type_id\"], codes)\n}\n\n.external_db_names_to_ids_from_Ensembl_FTP <- function(core_db_url, db_names)\n{\n    if (!is.character(db_names))\n        stop(wmsg(\"'db_names' must be a character vector\"))\n    if (anyDuplicated(db_names))\n        stop(wmsg(\"'db_names' cannot contain duplicates\"))\n    external_db <- fetch_table_dump_from_Ensembl_FTP(core_db_url, \"external_db\")\n    m <- solid_match(db_names, external_db[ , \"db_name\"],\n                     x_what=\"supplied db_name\",\n                     table_what=\"\\\"external_db.db_name\\\" value\")\n    bad_idx <- which(is.na(m))\n    if (length(bad_idx) != 0L) {\n        in1string <- paste0(db_names[bad_idx], collapse=\", \")\n        stop(wmsg(\"table \\\"external_db\\\" has no entry for: \", in1string))\n    }\n    setNames(external_db[m, \"external_db_id\"], db_names)\n}\n\n### Retrieves attribs \"toplevel\" and \"non_ref\" for the supplied sequence ids.\n### This is done via tables \"seq_region_attrib\" and \"attrib_type\".\n.fetch_attribs_from_Ensembl_FTP <- function(core_db_url, seq_region_ids,\n                                            toplevel=FALSE, non_ref=FALSE)\n{\n    all_attribs <- fetch_table_dump_from_Ensembl_FTP(core_db_url,\n                                                     \"seq_region_attrib\")\n    attrib_type_id <- all_attribs[ , \"attrib_type_id\"]\n    codes <- c(\"toplevel\", \"non_ref\")\n    code2id <- .attrib_type_codes_to_ids_from_Ensembl_FTP(core_db_url, codes)\n    if (toplevel) {\n        keep_idx <- which(attrib_type_id == code2id[[\"toplevel\"]])\n        ids <- all_attribs[keep_idx, \"seq_region_id\"]\n        toplevel <- seq_region_ids %in% ids\n    } else {\n        toplevel <- NULL\n    }\n    if (non_ref) {\n        keep_idx <- which(attrib_type_id == code2id[[\"non_ref\"]])\n        ids <- all_attribs[keep_idx, \"seq_region_id\"]\n        non_ref <- seq_region_ids %in% ids\n    } else {\n        non_ref <- NULL\n    }\n    list(toplevel=toplevel, non_ref=non_ref)\n}\n\n### This is the workhorse behind getChromInfoFromEnsembl().\n### Typical use:\n###   core_db_url <- get_Ensembl_FTP_core_db_url(\"hsapiens\")\n###   fetch_seq_regions_from_Ensembl_FTP(core_db_url)\nfetch_seq_regions_from_Ensembl_FTP <- function(core_db_url,\n                                               add.toplevel.col=FALSE,\n                                               add.non_ref.col=FALSE)\n{\n    stopifnot(isTRUEorFALSE(add.toplevel.col),\n              isTRUEorFALSE(add.non_ref.col))\n\n    coord_systems <- fetch_default_coord_systems_from_Ensembl_FTP(core_db_url)\n\n    ## Fetch table \"seq_region\".\n    seq_regions <- fetch_table_dump_from_Ensembl_FTP(core_db_url, \"seq_region\")\n\n    ## INNER JOIN table \"seq_region\" with table \"coord_system\".\n    Rtable <- \"coord_system\"\n    colnames(coord_systems) <- paste(Rtable, colnames(coord_systems), sep=\".\")\n    Lcolumn <- \"coord_system_id\"\n    Rcolumn <- paste(Rtable, Lcolumn, sep=\".\")\n    ans <- join_dfs(seq_regions, coord_systems, Lcolumn, Rcolumn)\n    seq_region_ids <- ans[ , \"seq_region_id\"]\n\n    ans$synonyms <- .fetch_synonyms_from_Ensembl_FTP(core_db_url,\n                                                     seq_region_ids)\n\n    if (add.toplevel.col || add.non_ref.col) {\n        cols <- .fetch_attribs_from_Ensembl_FTP(core_db_url,\n                                                seq_region_ids,\n                                                toplevel=add.toplevel.col,\n                                                non_ref=add.non_ref.col)\n        ans <- cbind(ans, S4Vectors:::delete_NULLs(cols),\n                     stringsAsFactors=FALSE)\n    }\n\n    ans\n}\n\n",
        "GenomeDescription-class.R": "### =========================================================================\n### The \"GenomeDescription\" class\n### -------------------------------------------------------------------------\n\nsetClass(\"GenomeDescription\",\n    representation(\n        ## organism: \"Homo sapiens\", \"Mus musculus\", etc...\n        organism=\"character\",\n\n        ## common_name: \"Human\", \"Mouse\", etc...\n        common_name=\"character\",\n\n        ## provider: \"UCSC\", \"BDGP\", etc...\n        provider=\"character\",\n\n        ## provider_version: \"hg18\", \"mm8\", \"sacCer1\", etc...\n        provider_version=\"character\",\n\n        ## release_date: \"Mar. 2006\", \"Feb. 2006\", \"Oct. 2003\", etc...\n        release_date=\"character\",\n\n        ## release_name: \"NCBI Build 36.1\", \"NCBI Build 36\",\n        ## \"SGD 1 Oct 2003 sequence\", etc...\n        release_name=\"character\",\n\n        ## names, lengths, and circularity flags of the genome sequences\n        seqinfo=\"Seqinfo\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\nsetMethod(\"organism\", \"GenomeDescription\", function(object) object@organism)\n\nsetGeneric(\"commonName\", function(object) standardGeneric(\"commonName\"))\nsetMethod(\"commonName\", \"GenomeDescription\",\n    function(object) object@common_name\n)\n\nsetGeneric(\"provider\", function(x) standardGeneric(\"provider\"))\nsetMethod(\"provider\", \"GenomeDescription\", function(x) x@provider)\n\nsetGeneric(\"providerVersion\", function(x) standardGeneric(\"providerVersion\"))\nsetMethod(\"providerVersion\", \"GenomeDescription\", function(x) x@provider_version)\n\nsetGeneric(\"releaseDate\", function(x) standardGeneric(\"releaseDate\"))\nsetMethod(\"releaseDate\", \"GenomeDescription\", function(x) x@release_date)\n\nsetGeneric(\"bsgenomeName\", function(x) standardGeneric(\"bsgenomeName\"))\nsetMethod(\"bsgenomeName\", \"GenomeDescription\",\n    function(x)\n    {\n        part1 <- \"BSgenome\"\n        tmp <- strsplit(organism(x), \" \", fixed=TRUE)[[1L]]\n        part2 <- paste(substr(tmp[1L], start=1L, stop=1L), tmp[2L], sep=\"\")\n        part3 <- provider(x)\n        part4 <- providerVersion(x)\n        paste(part1, part2, part3, part4, sep=\".\")\n    }\n)\n\nsetMethod(\"seqinfo\", \"GenomeDescription\", function(x) x@seqinfo)\n\nsetMethod(\"seqnames\", \"GenomeDescription\",\n    function(x)\n    {\n        ## Do NOT use 'seqnames(x)' here or you'll get infinite recursion!\n        ans <- seqnames(seqinfo(x))\n        if (length(ans) == 0L)\n            ans <- NULL\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\nsetValidity(\"GenomeDescription\",\n    function(object)\n    {\n        SINGLE_STRING_SLOTS <- setdiff(slotNames(\"GenomeDescription\"),\n                                       \"seqinfo\")\n        .validSlot <- function(slotname)\n        {\n            slotval <- slot(object, slotname)\n            if (isSingleStringOrNA(slotval))\n                return(NULL)\n            problem <- paste(\"slot '\", slotname, \"' must be a \",\n                             \"single string (or NA)\", sep=\"\")\n            return(problem)\n        }\n        unlist(lapply(SINGLE_STRING_SLOTS, .validSlot))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor-like functions\n###\n\n.norm_GenomeDescription_arg <- function(arg, argname)\n{\n    if (!isSingleStringOrNA(arg))\n        stop(wmsg(\"'\", argname, \"' must be a single string or NA\"))\n    if (toupper(arg) %in% c(NA, \"NA\", \"\"))\n        arg <- NA_character_\n    arg\n}\n\n### NOTE: In BioC 3.1, the 'species' argument was replaced with the\n### 'common_name' argument but the former was kept for backward compatibility\n### (essentially with existing SNPlocs and XtraSNPlocs packages).\n### TODO: At some point the 'species' argument needs to be deprecated.\nGenomeDescription <- function(organism=NA, common_name=NA,\n                              provider=NA, provider_version=NA,\n                              release_date=NA, release_name=NA,\n                              seqinfo,\n                              species=NA)\n{\n    organism <- .norm_GenomeDescription_arg(organism, \"organism\")\n    species <- .norm_GenomeDescription_arg(species, \"species\")\n    if (missing(common_name)) {\n        common_name <- species\n    } else {\n        common_name <- .norm_GenomeDescription_arg(common_name, \"common_name\")\n    }\n    provider <- .norm_GenomeDescription_arg(provider, \"provider\")\n    provider_version <- .norm_GenomeDescription_arg(provider_version,\n                                                    \"provider_version\")\n    release_date <- .norm_GenomeDescription_arg(release_date, \"release_date\")\n    release_name <- .norm_GenomeDescription_arg(release_name, \"release_name\")\n    new(\"GenomeDescription\",\n        organism=organism,\n        common_name=common_name,\n        provider=provider,\n        provider_version=provider_version,\n        release_date=release_date,\n        release_name=release_name,\n        seqinfo=seqinfo)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The 'show' method\n###\n\n### NOT exported but used in BSgenome package.\n### Kind of very low-level. Could go into S4Vectors if someone else needed\n### this...\ncompactPrintNamedAtomicVector <- function(x, margin=\"\")\n{\n    x_len <- length(x)\n    halfWidth <- (getOption(\"width\") - nchar(margin)) %/% 2L\n    first <- max(1L, halfWidth)\n    showMatrix <-\n      rbind(as.character(head(names(x), first)),\n            as.character(head(x, first)))\n    if (x_len > first) {\n        last <- min(x_len - first, halfWidth)\n        showMatrix <-\n          cbind(showMatrix,\n                rbind(as.character(tail(names(x), last)),\n                      as.character(tail(x, last))))\n    }\n    showMatrix <- format(showMatrix, justify=\"right\")\n    cat(S4Vectors:::labeledLine(margin, showMatrix[1L, ], count=FALSE,\n                                        labelSep=\"\"), sep=\"\")\n    cat(S4Vectors:::labeledLine(margin, showMatrix[2L, ], count=FALSE,\n                                        labelSep=\"\"), sep=\"\")\n}\n\n### NOT exported (but used in the BSgenome package).\nshowGenomeDescription <- function(x, margin=\"\", print.seqlengths=FALSE)\n{\n    cat(margin, \"organism: \", organism(x), sep=\"\")\n    common_name <- commonName(x)\n    if (!is.na(common_name))\n        cat(\" (\",  common_name, \")\", sep=\"\")\n    cat(\"\\n\")\n    cat(margin, \"provider: \", provider(x), \"\\n\", sep=\"\")\n    cat(margin, \"genome: \", providerVersion(x), \"\\n\", sep=\"\")\n    release_date <- releaseDate(x)\n    if (!is.na(release_date))\n        cat(margin, \"release date: \", release_date, \"\\n\", sep=\"\")\n    if (print.seqlengths) {\n        cat(margin, \"---\\n\", sep=\"\")\n        cat(margin, \"seqlengths:\\n\", sep=\"\")\n        compactPrintNamedAtomicVector(seqlengths(x), margin=margin)\n    }\n}\n\nsetMethod(\"show\", \"GenomeDescription\",\n    function(object)\n    {\n        showGenomeDescription(object, margin=\"| \", print.seqlengths=TRUE)\n    }\n)\n\n",
        "NCBI-utils.R": "### =========================================================================\n### Some low-level utilities to fetch data from NCBI\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, nothing in this file is exported.\n###\n\n\n.NCBI_ASSEMBLY_REPORTS_URL <-\n    \"https://ftp.ncbi.nlm.nih.gov/genomes/ASSEMBLY_REPORTS/\"\n\n.NCBI_ALL_ASSEMBLY_FTP_DIR <- \"https://ftp.ncbi.nlm.nih.gov/genomes/all/\"\n.GENBANK_ASSEMBLY_ACCESSION_PREFIX <- \"GCA_\"\n.REFSEQ_ASSEMBLY_ACCESSION_PREFIX <- \"GCF_\"\n\n.is_genbank_assembly_accession <- function(x)\n{\n    ## We use %in% instead of == to be NA-proof.\n    substr(x, 1L, nchar(.GENBANK_ASSEMBLY_ACCESSION_PREFIX)) %in%\n        .GENBANK_ASSEMBLY_ACCESSION_PREFIX\n}\n\n.is_refseq_assembly_accession <- function(x)\n{\n    ## We use %in% instead of == to be NA-proof.\n    substr(x, 1L, nchar(.REFSEQ_ASSEMBLY_ACCESSION_PREFIX)) %in%\n        .REFSEQ_ASSEMBLY_ACCESSION_PREFIX\n}\n\n.assembly_summary_cache <- new.env(parent=emptyenv())\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### fetch_assembly_summary()\n###\n\n.PAIRED_ASM_COMP_LEVELS <- c(\"identical\", \"different\", NA)\n\n### Performs some quick sanity checks on the assembly summary.\n.check_assembly_summary <- function(assembly_summary, genbank_or_refseq)\n{\n    ## Check \"assembly_accession\" prefixes.\n    assembly_accession <- assembly_summary[ , \"assembly_accession\"]\n    if (genbank_or_refseq == \"genbank\") {\n        is_valid_accession <- .is_genbank_assembly_accession\n    } else {\n        is_valid_accession <- .is_refseq_assembly_accession\n    }\n    stopifnot(all(is_valid_accession(assembly_accession)))\n\n    ## Check \"assembly_accession\" uniqueness.\n    stopifnot(anyDuplicated(assembly_accession) == 0L)\n\n    ## Check \"paired_asm_comp\" levels.\n    paired_asm_comp <- assembly_summary[ , \"paired_asm_comp\"]\n    stopifnot(all(paired_asm_comp %in% .PAIRED_ASM_COMP_LEVELS))\n\n    ## Check gbrs_paired_asm/paired_asm_comp consistency.\n    gbrs_paired_asm <- assembly_summary[ , \"gbrs_paired_asm\"]\n    idx1 <- which(is.na(gbrs_paired_asm))\n    idx2 <- which(is.na(paired_asm_comp))\n    stopifnot(identical(idx1, idx2))\n    if (length(idx1) != 0L)\n        gbrs_paired_asm <- gbrs_paired_asm[-idx1]\n\n    ## Check \"gbrs_paired_asm\" prefixes.\n    if (genbank_or_refseq == \"genbank\") {\n        is_valid_accession <- .is_refseq_assembly_accession\n    } else {\n        is_valid_accession <- .is_genbank_assembly_accession\n    }\n    stopifnot(all(is_valid_accession(gbrs_paired_asm)))\n\n    ## Check \"gbrs_paired_asm\" uniqueness.\n    stopifnot(anyDuplicated(gbrs_paired_asm) == 0L)\n}\n\nfetch_assembly_summary <- function(genbank_or_refseq, quiet=FALSE)\n{\n    objname <- paste0(\"assembly_summary_\", genbank_or_refseq)\n    ans <- try(get(objname, envir=.assembly_summary_cache, inherits=FALSE),\n               silent=TRUE)\n    if (!is(ans, \"try-error\"))\n        return(ans)\n    assembly_summary_filename <- paste0(objname, \".txt\")\n    url <- paste0(.NCBI_ASSEMBLY_REPORTS_URL, assembly_summary_filename)\n    destfile <- tempfile()\n    download.file(url, destfile, quiet=quiet)\n    ans <- read.table(destfile, header=TRUE, sep=\"\\t\", quote=\"\",\n                                na.strings=\"na\", skip=1L, comment.char=\"\",\n                                stringsAsFactors=FALSE)\n    expected_colnames <- c(\n        \"X..assembly_accession\", \"bioproject\", \"biosample\", \"wgs_master\",\n        \"refseq_category\", \"taxid\", \"species_taxid\", \"organism_name\",\n        \"infraspecific_name\", \"isolate\", \"version_status\", \"assembly_level\",\n        \"release_type\", \"genome_rep\", \"seq_rel_date\", \"asm_name\", \"submitter\",\n        \"gbrs_paired_asm\", \"paired_asm_comp\", \"ftp_path\",\n        \"excluded_from_refseq\")\n    if (!identical(expected_colnames, colnames(ans)))\n        stop(wmsg(url, \" does not contain the expected fields\"))\n    colnames(ans)[1L] <- \"assembly_accession\"\n    .check_assembly_summary(ans, genbank_or_refseq)\n    assign(objname, ans, envir=.assembly_summary_cache)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### build_and_save_assembly_accessions_table()\n###\n### Use this utility to update assembly_accessions dataset located in\n### GenomeInfoDb package (in /inst/extdata/).\n### It will issue a warning that a small number of assemblies were dropped\n### (3 on Feb 2017). It's OK to ignore if the number is small.\n###\n\n.make_assembly_accessions_table_from_assembly_summaries <-\n    function(genbank_assembly_summary, refseq_assembly_summary)\n{\n    genbank_accession0 <- genbank_assembly_summary[ , \"assembly_accession\"]\n    genbank_rs_paired_asm0 <- genbank_assembly_summary[ , \"gbrs_paired_asm\"]\n    refseq_accession0 <- refseq_assembly_summary[ , \"assembly_accession\"]\n    refseq_gb_paired_asm0 <- refseq_assembly_summary[ , \"gbrs_paired_asm\"]\n\n    df1 <- data.frame(genbank_accession=genbank_accession0,\n                      refseq_accession=genbank_rs_paired_asm0,\n                      stringsAsFactors=FALSE)\n    df2 <- data.frame(genbank_accession=refseq_gb_paired_asm0,\n                      refseq_accession=refseq_accession0,\n                      stringsAsFactors=FALSE)\n    ans <- merge.data.frame(df1, df2, all=TRUE)\n    genbank_accession <- ans[ , \"genbank_accession\"]\n    refseq_accession <- ans[ , \"refseq_accession\"]\n    if (anyDuplicated(genbank_accession, incomparables=NA)\n     || anyDuplicated(refseq_accession, incomparables=NA))\n        stop(wmsg(\"GenomeInfoDb internal error\"))\n\n    m1 <- match(genbank_accession, genbank_accession0)\n    m2 <- match(refseq_accession, refseq_accession0)\n    is_na1 <- is.na(m1)\n    is_na2 <- is.na(m2)\n\n    ## Add \"asm_name\", \"organism_name\", and \"taxid\" columns.\n    asm_name1 <- genbank_assembly_summary[m1, \"asm_name\"]\n    organism_name1 <- genbank_assembly_summary[m1, \"organism_name\"]\n    taxid1 <- genbank_assembly_summary[m1, \"taxid\"]\n    ans1 <- data.frame(asm_name=asm_name1,\n                       organism_name=organism_name1,\n                       taxid=taxid1,\n                       stringsAsFactors=FALSE)\n    asm_name2 <- refseq_assembly_summary[m2, \"asm_name\"]\n    organism_name2 <- refseq_assembly_summary[m2, \"organism_name\"]\n    taxid2 <- refseq_assembly_summary[m2, \"taxid\"]\n    ans2 <- data.frame(asm_name=asm_name2,\n                       organism_name=organism_name2,\n                       taxid=taxid2,\n                       stringsAsFactors=FALSE)\n    disagrement_idx <- which(!(is_na1 | is_na2 |\n                               (asm_name1 == asm_name2 &\n                                organism_name1 == organism_name2 &\n                                taxid1 == taxid2)))\n    if (length(disagrement_idx) != 0L) {\n        warning(wmsg(length(disagrement_idx), \" assemblies were dropped \",\n                     \"because the asm_name, organism_name, and/or taxid \",\n                     \"reported by GenBank and RefSeq do not agree\"))\n        ans <- ans[-disagrement_idx, , drop=FALSE]\n        genbank_accession <- ans[ , \"genbank_accession\"]\n        refseq_accession <- ans[ , \"refseq_accession\"]\n        m1 <- m1[-disagrement_idx]\n        m2 <- m2[-disagrement_idx]\n        is_na1 <- is.na(m1)\n        is_na2 <- is.na(m2)\n        ans1 <- ans1[-disagrement_idx, , drop=FALSE]\n        ans2 <- ans2[-disagrement_idx, , drop=FALSE]\n    }\n    ans1[is_na1, c(\"asm_name\", \"organism_name\", \"taxid\")] <-\n        ans2[is_na1, c(\"asm_name\", \"organism_name\", \"taxid\")]\n    ## Turning the \"organism_name\" column into a factor makes it bigger in\n    ## memory and on disk. Not worth it.\n    #ans1[ , \"organism_name\"] <- factor(ans1[ , \"organism_name\"],\n    #                                   levels=unique(ans1[ , \"organism_name\"]))\n    ans <- cbind(ans, ans1)\n\n    ## Add \"paired_asm_comp\", \"GCA_ftp_path\", and \"GCF_ftp_path\" columns.\n    paired_asm_comp1 <- genbank_assembly_summary[m1, \"paired_asm_comp\"]\n    paired_asm_comp2 <- refseq_assembly_summary[m2, \"paired_asm_comp\"]\n    stopifnot(all(is_na1 | is_na2 | paired_asm_comp1 == paired_asm_comp2))\n    paired_asm_comp1[is_na1] <- paired_asm_comp2[is_na1]\n    paired_asm_comp <- factor(paired_asm_comp1,\n                              levels=.PAIRED_ASM_COMP_LEVELS)\n\n    GCA_ftp_path <- genbank_assembly_summary[m1, \"ftp_path\"]\n    GCF_ftp_path <- refseq_assembly_summary[m2, \"ftp_path\"]\n\n    cbind(ans, paired_asm_comp=paired_asm_comp,\n               GCA_ftp_path=GCA_ftp_path,\n               GCF_ftp_path=GCF_ftp_path,\n               stringsAsFactors=FALSE)\n}\n\n### Saves \"assembly_accessions.rda\" in directory specified thru 'dir'.\nbuild_and_save_assembly_accessions_table <- function(dir=\".\", quiet=FALSE)\n{\n    gb_assembly_summary <- fetch_assembly_summary(\"genbank\", quiet=quiet)\n    rs_assembly_summary <- fetch_assembly_summary(\"refseq\", quiet=quiet)\n    assembly_accessions <-\n        .make_assembly_accessions_table_from_assembly_summaries(\n            gb_assembly_summary, rs_assembly_summary)\n    save(assembly_accessions, file=file.path(dir, \"assembly_accessions.rda\"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .lookup_refseq_assembly_accession()\n###\n\n### 'assembly_accession' can be:\n###   (a) a GenBank assembly accession (e.g. \"GCA_000001405.15\");\n###   (b) an NCBI assembly name (e.g. \"GRCh38\").\n.lookup_refseq_assembly_accession <- function(assembly_accession)\n{\n    objname <- \"assembly_accessions\"\n    assembly_accessions <- try(get(objname, envir=.assembly_summary_cache,\n                                   inherits=FALSE), silent=TRUE)\n    if (is(assembly_accessions, \"try-error\")) {\n        filename <- paste0(objname, \".rda\")\n        filepath <- system.file(\"extdata\", filename, package=\"GenomeInfoDb\")\n        load(filepath, envir=.assembly_summary_cache)\n        assembly_accessions <- get(objname, envir=.assembly_summary_cache,\n                                   inherits=FALSE)\n    }\n\n    if (.is_genbank_assembly_accession(assembly_accession)) {\n        idx <- match(assembly_accession,\n                     assembly_accessions[ , \"genbank_accession\"])\n        return(assembly_accessions[idx, \"refseq_accession\"])\n    }\n\n    ## If 'assembly_accession' is not a RefSeq or GenBank assembly accession,\n    ## then we assume it's an assembly name (e.g. \"GRCh38\", or \"hg16\", or\n    ## \"Pan_troglodytes-2.1.4\").\n\n    ## Exact match.\n    idx <- which(assembly_accessions[ , \"asm_name\"] == assembly_accession)\n    if (length(idx) == 1L)\n        return(assembly_accessions[idx , \"refseq_accession\"])\n    if (length(idx) >= 2L)\n        stop(wmsg(\"more than one RefSeq assembly accession found for \",\n                  \"\\\"\", assembly_accession, \"\\\"\"))\n\n    ## Fuzzy match.\n    warning(\"No RefSeq assembly accession found for \",\n            \"\\\"\", assembly_accession, \"\\\".\\n\",\n            \"  Searching again using \",\n            \"\\\"\", assembly_accession, \"\\\" as a regular expression.\")\n    idx <- grep(assembly_accession, assembly_accessions[ , \"asm_name\"],\n                ignore.case=TRUE)\n    if (length(idx) == 1L)\n        return(assembly_accessions[idx, \"refseq_accession\"])\n    if (length(idx) >= 2L)\n        stop(wmsg(\"more than one RefSeq assembly accession found for \",\n                  \"regular expression \\\"\", assembly_accession, \"\\\"\"))\n\n    NA_character_\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### find_NCBI_assembly_ftp_dir()\n###\n### This is exported!\n\n.assembly_not_found_msg <- function(shortmsg, assembly_accession,\n                                    assembly_name=NA, ftp_dir=NA)\n{\n    msg <- paste0(shortmsg, \" for assembly \", assembly_accession)\n    if (!is.na(assembly_name))\n        msg <- paste0(msg, \" (\", assembly_name, \")\")\n    if (!is.na(ftp_dir))\n        msg <- paste0(msg, \" in \", ftp_dir)\n    msg\n}\n\n### Return a length-2 character vector. The 1st element in the vector is the\n### URL to the FTP dir and the 2nd element the prefix of all the files in the\n### FTP dir.\nfind_NCBI_assembly_ftp_dir <- function(assembly_accession, assembly_name=NA)\n{\n    if (!isSingleString(assembly_accession) || assembly_accession == \"\")\n        stop(wmsg(\"'assembly_accession' must be a single (non-empty) string\"))\n    if (.is_genbank_assembly_accession(assembly_accession)) {\n        GCA_or_GCF <- \"GCA\"\n    } else if (.is_refseq_assembly_accession(assembly_accession)) {\n        GCA_or_GCF <- \"GCF\"\n    } else {\n        stop(wmsg(\"malformed assembly accession: \", assembly_accession))\n    }\n    if (!isSingleStringOrNA(assembly_name))\n        stop(wmsg(\"'assembly_name' must be a single string or NA\"))\n    GCA_or_GCF_ftp_dir <- paste0(.NCBI_ALL_ASSEMBLY_FTP_DIR, GCA_or_GCF, \"/\")\n    parts_end <- 4L + (1:3) * 3L\n    parts <- substring(assembly_accession, parts_end - 2L, parts_end)\n    ftp_dir <- paste0(GCA_or_GCF_ftp_dir, paste0(parts, collapse=\"/\"), \"/\")\n    listing <- try(list_ftp_dir(ftp_dir), silent=TRUE)\n    if (inherits(listing, \"try-error\")) {\n        condition <- attr(listing, \"condition\")\n        if (inherits(condition, \"REMOTE_ACCESS_DENIED\")) {\n            new_msg <- .assembly_not_found_msg(\"unable to find FTP dir\",\n                                               assembly_accession,\n                                               ftp_dir=GCA_or_GCF_ftp_dir)\n            condition$message <- wmsg(new_msg)\n        }\n        stop(condition)\n    }\n    idx <- which(paste0(assembly_accession, \"_\") ==\n                 substr(listing, 1L, nchar(assembly_accession)+1L))\n    if (length(idx) == 0L) {\n        msg <- .assembly_not_found_msg(\"unable to find FTP dir\",\n                                       assembly_accession,\n                                       ftp_dir=ftp_dir)\n        stop(wmsg(msg))\n    }\n    if (length(idx) > 1L) {\n        if (is.na(assembly_name)) {\n            msg <- .assembly_not_found_msg(\"More than one FTP dir found\",\n                                           assembly_accession,\n                                           ftp_dir=ftp_dir)\n            stop(wmsg(msg, \":\"),\n                 \"\\n\",\n                 paste0(\"    - \", listing[idx], \"\\n\"),\n                 \"  \",\n                 wmsg(\"Please specify the name of the assembly (via \",\n                      \"the 'assembly_name' argument) in addition to \",\n                      \"its accession.\"))\n        }\n        subdir <- paste0(assembly_accession, \"_\", assembly_name)\n        idx <- which(subdir == listing)\n        if (length(idx) == 0L) {\n            msg <- .assembly_not_found_msg(\"unable to find FTP dir\",\n                                           assembly_accession,\n                                           assembly_name=assembly_name,\n                                           ftp_dir=ftp_dir)\n            stop(wmsg(msg))\n        }\n        if (length(idx) > 1L) {  # should never happen\n            msg <- .assembly_not_found_msg(\"more than one FTP dir found\",\n                                           assembly_accession,\n                                           assembly_name=assembly_name,\n                                           ftp_dir=ftp_dir)\n            stop(wmsg(msg))\n        }\n    }\n    prefix <- listing[[idx]]\n    c(paste0(ftp_dir, prefix), prefix)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### fetch_assembly_report()\n###\n### This is exported!\n### Workhorse behind getChromInfoFromNCBI().\n\n### 'assembly_accession' can be:\n###   (a) a GenBank assembly accession (e.g. \"GCA_000001405.15\");\n###   (b) a RefSeq assembly accession (e.g. \"GCF_000001405.26\");\n###   (c) an NCBI assembly name (e.g. \"GRCh38\").\n.normarg_assembly_accession <- function(assembly_accession)\n{\n    if (.is_genbank_assembly_accession(assembly_accession) ||\n        .is_refseq_assembly_accession(assembly_accession))\n        return(assembly_accession)\n    accession0 <- assembly_accession\n    assembly_accession <- .lookup_refseq_assembly_accession(accession0)\n    if (is.na(assembly_accession))\n        stop(wmsg(\"cannot find a RefSeq assembly accession for \\\"\",\n                  accession0, \"\\\"\"))\n    assembly_accession\n}\n\n### Returns https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/405/GCA_000001405.15_GRCh38/GCA_000001405.15_GRCh38_assembly_report.txt for GCA_000001405.15\n.form_assembly_report_url <- function(assembly_accession, assembly_name=NA)\n{\n    ftp_dir <- find_NCBI_assembly_ftp_dir(assembly_accession,\n                                          assembly_name=assembly_name)\n    paste0(ftp_dir[[1L]], \"/\", ftp_dir[[2L]], \"_assembly_report.txt\")\n}\n\n.fetch_assembly_report_from_url <- function(url)\n{\n    ## R doesn't like seeing dashes (\"-\") or slashes (\"/\") in the colnames\n    ## of a data frame. So we remove them from the official field names used\n    ## by NCBI in the assembly report.\n    colnames <- c(\"SequenceName\", \"SequenceRole\", \"AssignedMolecule\",\n                  \"AssignedMoleculeLocationOrType\", \"GenBankAccn\",\n                  \"Relationship\", \"RefSeqAccn\", \"AssemblyUnit\" ,\n                  \"SequenceLength\", \"UCSCStyleName\")\n    fetch_table_from_url(url, colnames=colnames, comment.char=\"#\")\n}\n\n### See .normarg_assembly_accession() above for how 'assembly_accession'\n### can be specified. In addition, here 'assembly_accession' can be the URL\n### to an assembly report (a.k.a. \"full sequence report\"). Examples of such\n### URLs:\n###   ftp://ftp.ncbi.nlm.nih.gov/genomes/ASSEMBLY_REPORTS/All/GCF_000001405.26.assembly.txt\n###   ftp://ftp.ncbi.nlm.nih.gov/genbank/genomes/Eukaryotes/vertebrates_mammals/Homo_sapiens/GRCh38/GCA_000001405.15_GRCh38_assembly_report.txt\n### Note that the 2 URls above both point to the assembly report for GRCh38,\n### but the report at the 1st URL contains a little bit more information than\n### the report at the 2nd URL.\nfetch_assembly_report <- function(assembly_accession, assembly_name=NA,\n                                  AssemblyUnits=NULL)\n{\n    if (!isSingleString(assembly_accession) || assembly_accession == \"\")\n        stop(wmsg(\"'assembly_accession' must be a single (non-empty) string\"))\n    if (!isSingleStringOrNA(assembly_name))\n        stop(wmsg(\"'assembly_name' must be a single string or NA\"))\n    if (grepl(\"://\", assembly_accession, fixed=TRUE)) {\n        report_url <- assembly_accession\n    } else {\n        assembly_accession <- .normarg_assembly_accession(assembly_accession)\n        report_url <- .form_assembly_report_url(assembly_accession,\n                                                assembly_name=assembly_name)\n    }\n    ans <- .fetch_assembly_report_from_url(report_url)\n    if (!is.null(AssemblyUnits)) {\n        stopifnot(all(AssemblyUnits %in% ans$AssemblyUnit))\n        idx <- which(ans$AssemblyUnit %in% AssemblyUnits)\n        ans <- ans[idx, , drop=FALSE]\n    }\n    ans\n}\n\n",
        "Seqinfo-class.R": "### =========================================================================\n### Seqinfo objects\n### -------------------------------------------------------------------------\n###\n### A Seqinfo object is a table-like object that contains basic information\n### about a set of genomic sequences. The table has one entry per sequence,\n### with each entry containing the following sequence attributes:\n###   - sequence name (primary key)\n###   - sequence length\n###   - circularity flag\n###   - genome (e.g. hg19)\n###\n\nsetClass(\"Seqinfo\",\n    representation(\n        seqnames=\"character\",\n        seqlengths=\"integer\",\n        is_circular=\"logical\",\n        genome=\"character\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"seqnames\", \"Seqinfo\", function(x) x@seqnames)\n\nsetMethod(\"names\", \"Seqinfo\", function(x) seqnames(x))\n\nsetMethod(\"length\", \"Seqinfo\", function(x) length(seqnames(x)))\n\nsetMethod(\"seqlevels\", \"Seqinfo\", function(x) seqnames(x))\n\nsetMethod(\"seqlengths\", \"Seqinfo\",\n    function(x)\n    {\n        ans <- x@seqlengths\n        names(ans) <- seqnames(x)\n        ans\n    }\n)\n\nsetMethod(\"isCircular\", \"Seqinfo\",\n    function(x)\n    {\n        ans <- x@is_circular\n        names(ans) <- seqnames(x)\n        ans\n    }\n)\n\nsetMethod(\"genome\", \"Seqinfo\",\n    function(x)\n    {\n        ans <- x@genome\n        names(ans) <- seqnames(x)\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid.Seqinfo.seqnames <- function(x_seqnames, what=\"'seqnames(x)'\")\n{\n    if (!is.character(x_seqnames))\n        return(paste0(what, \" must be a character vector\"))\n    if (!is.null(names(x_seqnames)))\n        return(paste0(what, \" must be unnamed\"))\n    if (any(x_seqnames %in% c(NA, \"\")))\n        return(paste0(what, \" cannot contain NAs or empty strings (\\\"\\\")\"))\n    if (anyDuplicated(x_seqnames))\n        return(paste0(what, \" cannot contain duplicated sequence names\"))\n    NULL\n}\n\n### Not really checking the slot itself but the value returned by the\n### slot accessor.\n.valid.Seqinfo.seqlengths <- function(x)\n{\n    x_seqlengths <- seqlengths(x)\n    if (!is.integer(x_seqlengths)\n     || length(x_seqlengths) != length(x)\n     || !identical(names(x_seqlengths), seqnames(x)))\n        return(\"'seqlengths(x)' must be an integer vector of the length of 'x' and with names 'seqnames(x)'\")\n    if (any(x_seqlengths < 0L, na.rm=TRUE))\n        return(\"'seqlengths(x)' contains negative values\")\n    NULL\n}\n\n### Not really checking the slot itself but the value returned by the\n### slot accessor.\n.valid.Seqinfo.isCircular <- function(x)\n{\n    x_is_circular <- isCircular(x)\n    if (!is.logical(x_is_circular)\n     || length(x_is_circular) != length(x)\n     || !identical(names(x_is_circular), seqnames(x)))\n        return(\"'isCircular(x)' must be a logical vector of the length of 'x' and with names 'seqnames(x)'\")\n    NULL\n}\n\n### Not really checking the slot itself but the value returned by the\n### slot accessor.\n.valid.Seqinfo.genome <- function(x)\n{\n    x_genome <- genome(x)\n    if (!is.character(x_genome)\n     || length(x_genome) != length(x)\n     || !identical(names(x_genome), seqnames(x)))\n        return(\"'genome(x)' must be a character vector of the length of 'x' and with names 'seqnames(x)'\")\n    NULL\n}\n\n.valid.Seqinfo <- function(x)\n{\n    c(.valid.Seqinfo.seqnames(seqnames(x)),\n      .valid.Seqinfo.seqlengths(x),\n      .valid.Seqinfo.isCircular(x),\n      .valid.Seqinfo.genome(x))\n}\n\nsetValidity2(\"Seqinfo\", .valid.Seqinfo)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n### The .normarg_*() helper functions below do only partial checking of the\n### arguments. The full validation is performed by the validity method when\n### new() is called.\n###\n\n.make_Seqinfo_from_genome <- function(genome)\n{\n    if (!isSingleString(genome) || genome == \"\")\n        stop(\"'genome' must be a single non-empty string\")\n    NCBI_assemblies <- registered_NCBI_assemblies()\n    if (genome %in% NCBI_assemblies[ , \"assembly\"] ||\n        genome %in% NCBI_assemblies[ , \"assembly_accession\"])\n        return(getChromInfoFromNCBI(genome, as.Seqinfo=TRUE))\n    UCSC_genomes <- registered_UCSC_genomes()\n    if (genome %in% UCSC_genomes[ , \"genome\"])\n        return(getChromInfoFromUCSC(genome, as.Seqinfo=TRUE))\n    stop(wmsg(\"\\\"\", genome, \"\\\" is not a registered NCBI assembly \",\n              \"or UCSC genome (use registered_NCBI_assemblies() or \",\n              \"registered_UCSC_genomes() to list the NCBI or UCSC \",\n              \"assemblies/genomes currently registered in the \",\n              \"GenomeInfoDb package)\"))\n}\n\n### Make sure this always returns an *unnamed* character vector.\n.normarg_seqlevels <- function(seqlevels)\n{\n    if (is.null(seqlevels))\n        return(character(0))\n    seqlevels <- unname(seqlevels)\n    errmsg <- .valid.Seqinfo.seqnames(seqlevels, what=\"supplied 'seqlevels'\")\n    if (!is.null(errmsg))\n        stop(errmsg)\n    seqlevels\n}\n\n### Make sure this always returns an *unnamed* integer vector.\n.normarg_seqlengths <- function(seqlengths, seqnames)\n{\n    if (identical(seqlengths, NA))\n        return(rep.int(NA_integer_, length(seqnames)))\n    if (!is.vector(seqlengths))\n        stop(wmsg(\"supplied 'seqlengths' must be a vector\"))\n    if (length(seqlengths) != length(seqnames))\n        stop(wmsg(\"the length of the supplied 'seqlengths' vector \",\n                  \"must be equal to the number of sequences\"))\n    if (!is.null(names(seqlengths))\n     && !identical(names(seqlengths), seqnames))\n        stop(wmsg(\"the names on the supplied 'seqlengths' vector \",\n                  \"must be identical to the seqnames\"))\n    if (is.logical(seqlengths)) {\n        if (all(is.na(seqlengths)))\n            return(as.integer(seqlengths))\n        stop(wmsg(\"bad supplied 'seqlengths' vector\"))\n    }\n    if (!is.numeric(seqlengths))\n        stop(wmsg(\"bad supplied 'seqlengths' vector\"))\n    if (is.integer(seqlengths)) {\n        seqlengths <- unname(seqlengths)\n    } else {\n        seqlengths <- as.integer(seqlengths)\n    }\n    if (any(seqlengths < 0L, na.rm=TRUE))\n        stop(wmsg(\"the supplied 'seqlengths' vector contains negative values\"))\n    seqlengths\n}\n\n### Make sure this always returns an *unnamed* logical vector.\n.normarg_isCircular <- function(isCircular, seqnames)\n{\n    if (identical(isCircular, NA))\n        return(rep.int(NA, length(seqnames)))\n    if (!is.vector(isCircular))\n        stop(wmsg(\"supplied 'isCircular' must be a vector\"))\n    if (length(isCircular) != length(seqnames))\n        stop(wmsg(\"the length of the supplied 'isCircular' vector \",\n                  \"must be equal to the number of sequences\"))\n    if (!is.null(names(isCircular))\n     && !identical(names(isCircular), seqnames))\n        stop(wmsg(\"the names on the supplied 'isCircular' vector \",\n                  \"must be identical to the seqnames\"))\n    if (!is.logical(isCircular))\n        stop(wmsg(\"bad supplied 'isCircular' vector\"))\n    unname(isCircular)\n}\n\n### Make sure this always returns an *unnamed* character vector parallel to\n### 'seqnames'.\n.normarg_genome <- function(genome, seqnames)\n{\n    if (!(is.vector(genome) || is.factor(genome)))\n        stop(wmsg(\"supplied 'genome' must be a vector or factor\"))\n    if (!is.character(genome))\n        genome <- as.character(genome)\n\n    if (length(genome) == 0L) {\n        if (length(seqnames) == 0L)\n            return(unname(genome))\n        stop(wmsg(\"supplied 'genome' vector is empty\"))\n    }\n\n    ## The most common situation is that the supplied 'genome' vector contains\n    ## a single (possibly NA) unique value. Note that, in that case, the names\n    ## on 'genome' are ignored.\n    ugenome <- unique(genome)\n    if (length(ugenome) == 1L)\n        return(rep.int(ugenome, length(seqnames)))\n\n    if (!is.null(names(genome))) {\n        if (identical(names(genome), seqnames))\n            return(unname(genome))\n        stop(wmsg(\"when the supplied 'genome' vector contains more \",\n                  \"than one distinct value, the names on it must be \",\n                  \"identical to the seqlevels of the object\"))\n    }\n    if (length(genome) == length(seqnames))\n        return(genome)\n    if (length(genome) != 1L)\n        stop(wmsg(\"when the length of the supplied 'genome' vector is not 1, \",\n                  \"then it must be equal to the number of sequences\"))\n    rep.int(genome, length(seqnames))\n}\n\nSeqinfo <- function(seqnames=NULL, seqlengths=NA, isCircular=NA, genome=NA)\n{\n    ## Handle special case where only 'genome' is specified e.g.:\n    ##   Seqinfo(genome=\"hg38\")\n    if (is.null(seqnames)\n     && identical(seqlengths, NA)\n     && identical(isCircular, NA)\n     && isSingleString(genome))\n        return(.make_Seqinfo_from_genome(genome))\n\n    if (is.null(seqnames)) {\n        ## If 'seqnames' is omitted, then we try to infer it\n        ## from the other arguments.\n        seqnames1 <- seqnames2 <- seqnames3 <- NULL\n        if (!identical(seqlengths, NA)) {\n            if (!is.numeric(seqlengths))\n                stop(wmsg(\"when specified, 'seqlengths' \",\n                          \"must be a numeric vector\"))\n            seqnames1 <- names(seqlengths)\n        }\n        if (!identical(isCircular, NA)) {\n            if (!is.logical(isCircular))\n                stop(wmsg(\"when specified, 'isCircular' \",\n                          \"must be a logical vector\"))\n            seqnames2 <- names(isCircular)\n        }\n        if (!identical(genome, NA)) {\n            if (!(is.vector(genome) || is.factor(genome)))\n                stop(wmsg(\"when specified, 'genome' \",\n                          \"must be a vector or factor\"))\n            seqnames3 <- names(genome)\n        }\n        seqnames <- unique(c(seqnames1, seqnames2, seqnames3))\n        if (!(is.null(seqnames1) || identical(seqnames, seqnames1))\n         || !(is.null(seqnames2) || identical(seqnames, seqnames2))\n         || !(is.null(seqnames3) || identical(seqnames, seqnames3)))\n            stop(wmsg(\"the names on the supplied 'seqlengths', \",\n                      \"'isCircular', and 'genome' vectors, if any, \",\n                      \"must be identical\"))\n    }\n    seqnames <- .normarg_seqlevels(seqnames)\n    seqlengths <- .normarg_seqlengths(seqlengths, seqnames)\n    is_circular <- .normarg_isCircular(isCircular, seqnames)\n    genome <- .normarg_genome(genome, seqnames)\n    new(\"Seqinfo\", seqnames=seqnames,\n                   seqlengths=seqlengths,\n                   is_circular=is_circular,\n                   genome=genome)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Updating old Seqinfo objects\n###\n\nsetMethod(\"updateObject\", \"Seqinfo\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (verbose)\n            message(\"updateObject(object = 'Seqinfo')\")\n        if (!is(try(object@genome, silent=TRUE), \"try-error\"))\n            return(genome)\n        as(Seqinfo(seqnames=object@seqnames,\n                   seqlengths=object@seqlengths,\n                   isCircular=object@is_circular),\n           class(object))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n### Support subsetting only by name.\nsetMethod(\"[\", \"Seqinfo\",\n    function(x, i, j, ..., drop=TRUE)\n    {\n        if (!missing(j) || length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        if (missing(i))\n            return(x)\n        if (!is.character(i))\n            stop(\"a Seqinfo object can be subsetted only by name\")\n        if (!identical(drop, TRUE))\n            warning(\"'drop' argument is ignored when subsetting \",\n                    \"a Seqinfo object\")\n        x_names <- names(x)\n        i2names <- match(i, x_names)\n        new_seqlengths <- unname(seqlengths(x))[i2names]\n        new_isCircular <- unname(isCircular(x))[i2names]\n        new_genome <- unname(genome(x))[i2names]\n        Seqinfo(seqnames=i, seqlengths=new_seqlengths,\n                isCircular=new_isCircular, genome=new_genome)\n\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setters\n###\n\nsetReplaceMethod(\"seqnames\", \"Seqinfo\",\n    function(x, value)\n    {\n        value <- .normarg_seqlevels(value)\n        if (length(value) != length(x))\n            stop(\"length of supplied 'seqnames' vector must equal \",\n                 \"the number of sequences\")\n        x@seqnames <- value\n        x\n    }\n)\n\nsetReplaceMethod(\"names\", \"Seqinfo\",\n    function(x, value) `seqnames<-`(x, value)\n)\n\nsetReplaceMethod(\"seqlevels\", \"Seqinfo\",\n    function(x,\n             pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n             value)\n    {\n        pruning.mode <- match.arg(pruning.mode)\n        if (pruning.mode != \"error\")\n            warning(\"'pruning.mode' is ignored in \\\"seqlevels<-\\\" method \",\n                    \"for Seqinfo objects\")\n        new2old <- getSeqlevelsReplacementMode(value, seqlevels(x))\n        if (identical(new2old, -3L)) {\n            ## \"renaming\" mode\n            seqnames(x) <- value\n            return(x)\n        }\n        if (identical(new2old, -2L) || identical(new2old, -1L)) {\n            ## \"subsetting\" mode\n            return(x[value])\n        }\n        new_seqlengths <- unname(seqlengths(x))[new2old]\n        new_isCircular <- unname(isCircular(x))[new2old]\n        new_genome <- unname(genome(x))[new2old]\n        Seqinfo(seqnames=value, seqlengths=new_seqlengths,\n                isCircular=new_isCircular, genome=new_genome)\n    }\n)\n\nsetReplaceMethod(\"seqlengths\", \"Seqinfo\",\n    function(x, value)\n    {\n        x@seqlengths <- .normarg_seqlengths(value, seqnames(x))\n        x\n    }\n)\n\nsetReplaceMethod(\"isCircular\", \"Seqinfo\",\n    function(x, value)\n    {\n        x@is_circular <- .normarg_isCircular(value, seqnames(x))\n        x\n    }\n)\n\nsetReplaceMethod(\"genome\", \"Seqinfo\",\n    function(x, value)\n    {\n        x@genome <- .normarg_genome(value, seqnames(x))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### S3/S4 combo for as.data.frame.Seqinfo\nas.data.frame.Seqinfo <- function(x, row.names=NULL, optional=FALSE, ...)\n{\n    if (!is.null(row.names))\n        warning(\"supplied 'row.names' value was ignored\")\n    if (!identical(optional, FALSE))\n        warning(\"supplied 'optional' value was ignored\")\n    if (length(list(...)) != 0L)\n        warning(\"extra arguments were ignored\")\n    data.frame(seqlengths=unname(seqlengths(x)),\n               isCircular=unname(isCircular(x)),\n               genome=unname(genome(x)),\n               row.names=seqnames(x),\n               check.names=FALSE,\n               stringsAsFactors=FALSE)\n}\nsetMethod(\"as.data.frame\", \"Seqinfo\", as.data.frame.Seqinfo)\n\n.from_DataFrame_to_Seqinfo <- function(from)\n{\n    if (!is.data.frame(from) && !is(from, \"DataFrame\"))\n        stop(\"'from' must be a data.frame or DataFrame object\")\n    from_colnames <- colnames(from)\n\n    ## Extract seqnames.\n    if (\"seqnames\" %in% from_colnames) {\n        ans_seqnames <- from[ , \"seqnames\"]\n    } else if (\"seqlevels\" %in% from_colnames) {\n        ans_seqnames <- from[ , \"seqlevels\"]\n    } else {\n        ans_seqnames <- rownames(from)\n        seqnames_as_ints <- suppressWarnings(as.integer(ans_seqnames))\n        if (!any(is.na(seqnames_as_ints))\n          && all(seqnames_as_ints == ans_seqnames))\n            stop(\"no sequence names found in input\")\n    }\n    if (!is.character(ans_seqnames))\n        ans_seqnames <- as.character(ans_seqnames)\n\n    ## Extract seqlengths.\n    if (\"seqlengths\" %in% from_colnames) {\n        ans_seqlengths <- from[ , \"seqlengths\"]\n    } else {\n        ans_seqlengths <- rep.int(NA_integer_, nrow(from))\n    }\n    if (!is.integer(ans_seqlengths))\n        ans_seqlengths <-  as.integer(ans_seqlengths)\n\n    ## Extract isCircular.\n    if (\"isCircular\" %in% from_colnames) {\n        ans_isCircular <- from[ , \"isCircular\"]\n    } else if (\"is_circular\" %in% from_colnames) {\n        ans_isCircular <- from[ , \"is_circular\"]\n    } else {\n        ans_isCircular <- rep.int(NA, nrow(from))\n    }\n    if (!is.logical(ans_isCircular))\n        ans_isCircular <-  as.logical(ans_isCircular)\n\n    ## Extract genome.\n    if (\"genome\" %in% from_colnames) {\n        ans_genome <- from[ , \"genome\"]\n    } else {\n        ans_genome <- rep.int(NA_character_, nrow(from))\n    }\n    if (!is.character(ans_genome))\n        ans_genome <-  as.character(ans_genome)\n\n    Seqinfo(seqnames=ans_seqnames, seqlengths=ans_seqlengths,\n            isCircular=ans_isCircular, genome=ans_genome)\n}\nsetAs(\"data.frame\", \"Seqinfo\", .from_DataFrame_to_Seqinfo)\nsetAs(\"DataFrame\", \"Seqinfo\", .from_DataFrame_to_Seqinfo)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.Seqinfo\nsummary.Seqinfo <- function(object, ...)\n{\n    ## nb of sequences\n    object_len <- length(object)\n    if (object_len == 0L)\n        return(\"no sequences\")\n    ans <- c(object_len, \" sequence\")\n    if (object_len > 1L)\n        ans <- c(ans, \"s\")\n    ## circularity\n    circ_count <- sum(isCircular(object), na.rm=TRUE)\n    if (circ_count != 0L)\n        ans <- c(ans, \" (\", circ_count, \" circular)\")\n    ## genomes\n    ugenomes <- unique(genome(object))\n    genome_count <- length(ugenomes)\n    if (genome_count == 1L) {\n        if (is.na(ugenomes))\n            ans <- c(ans, \" from an unspecified genome\")\n        else\n            ans <- c(ans, \" from \", ugenomes, \" genome\")\n    } else {\n        if (genome_count > 3L)\n            ugenomes <- c(ugenomes[1:2], \"...\")\n        genomes_in1string <- paste0(ugenomes, collapse=\", \")\n        ans <- c(ans, \" from \", genome_count, \" genomes \",\n                      \"(\", genomes_in1string, \")\")\n    }\n    ## seqlengths\n    seqlengths <- seqlengths(object)\n    if (all(is.na(seqlengths)))\n        ans <- c(ans, \"; no seqlengths\")\n    paste0(ans, collapse=\"\")\n}\nsetMethod(\"summary\", \"Seqinfo\", summary.Seqinfo)\n\n### cat(.showOutputAsCharacter(x), sep=\"\\n\") is equivalent to show(x).\n.showOutputAsCharacter <- function(x)\n{\n    tmp <- tempfile()\n    sink(file=tmp, type=\"output\")\n    show(x)\n    sink(file=NULL)\n    readLines(tmp)\n}\n\n.compactDataFrame <- function(x)\n{\n    head_nrow <- get_showHeadLines()\n    tail_nrow <- get_showTailLines()\n    max_nrow <- head_nrow + tail_nrow + 1L\n    if (nrow(x) <= max_nrow)\n        return(x)\n    head <- head(x, n=head_nrow)\n    tail <- tail(x, n=tail_nrow)\n    dotrow <- rep.int(\"...\", ncol(x))\n    names(dotrow) <- colnames(x)\n    dotrow <- data.frame(as.list(dotrow),\n                         row.names=\"...\",\n                         check.names=FALSE,\n                         stringsAsFactors=FALSE)\n    ## Won't handle properly the situation where one row in 'head' or 'tail'\n    ## happens to be named \"...\".\n    rbind(head, dotrow, tail)\n}\n\n### Should work properly on \"narrow\" data frames. Untested on data frames\n### that are wider than the terminal.\nshowCompactDataFrame <- function(x, rownames.label=\"\", left.margin=\"\")\n{\n    compactdf <- .compactDataFrame(x)\n    label_nchar <- nchar(rownames.label)\n    if (label_nchar != 0L)\n        row.names(compactdf) <- format(row.names(compactdf), width=label_nchar)\n    showme <- .showOutputAsCharacter(compactdf)\n    if (label_nchar != 0L)\n        substr(showme[1L], 1L, label_nchar) <- rownames.label\n    cat(paste0(left.margin, showme), sep=\"\\n\")\n}\n\nsetMethod(\"show\", \"Seqinfo\",\n    function(object)\n    {\n        cat(class(object), \" object with \", summary(object), sep=\"\")\n        if (length(object) == 0L) {\n            cat(\"\\n\")\n            return(NULL)\n        }\n        cat(\":\\n\")\n        showCompactDataFrame(as.data.frame(object),\n                             rownames.label=\"seqnames\", left.margin=\"  \")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Combining\n###\n### Why no c() or rbind() method for Seqinfo objects?\n###\n### c() is expected to follow an \"appending semantic\", that is, 'c(x, y)' is\n### expected to form a new object by **appending** the entries in 'y' to the\n### entries in 'x', thus resulting in an object with 'length(x) + length(y)'\n### entries. Problem with such operation is that it won't be very useful in\n### general, because it will tend to break the constraint that the seqnames\n### of a Seqinfo object must be unique (primary key).\n### A more useful operation is a \"merge\" operation that does the following:\n### - If an entry in Seqinfo object 'x' has the same seqname as an entry in\n###   Seqinfo object 'y', then the 2 entries are fusioned/melded together\n###   to produce a single entry in the result. This fusion only happens if\n###   the 2 entries contain compatible information.\n### - If 2 entries cannot be fusioned/melded because they contain incompatible\n###   information (e.g. different seqlengths or different circularity flags),\n###   then the \"merge\" operation fails with an informative error of why 'x'\n###   and 'y' could not be merged.\n###\n### We also implement an \"update\" operation for Seqinfo objects. See below.\n###\n\n### Binary merge.\n.merge_two_Seqinfo_objects <- function(x, y)\n{\n    ans_seqnames    <- union(seqnames(x), seqnames(y))\n    ans_genome      <- mergeNamedAtomicVectors(genome(x), genome(y),\n                           what=c(\"sequence\", \"genomes\"))\n    ans_seqlengths  <- mergeNamedAtomicVectors(seqlengths(x), seqlengths(y),\n                           what=c(\"sequence\", \"seqlengths\"))\n    ans_is_circular <- mergeNamedAtomicVectors(isCircular(x), isCircular(y),\n                           what=c(\"sequence\", \"circularity flags\"))\n\n    common_seqnames <- intersect(seqnames(x), seqnames(y))\n    x_proper_seqnames <- setdiff(seqnames(x), common_seqnames)\n    y_proper_seqnames <- setdiff(seqnames(y), common_seqnames)\n    if (length(x_proper_seqnames) != 0L && length(y_proper_seqnames) != 0L) {\n        if (length(common_seqnames) == 0L) {\n            msg <- c(\"The 2 combined objects have no sequence levels in \",\n                     \"common. (Use\\n  suppressWarnings() to suppress this \",\n                     \"warning.)\")\n            warning(msg)\n        } else if (any(is.na(genome(x)[common_seqnames]))\n                || any(is.na(genome(y)[common_seqnames]))) {\n            msg <- c(\"Each of the 2 combined objects has sequence levels \",\n                     \"not in the other:\\n\",\n                     \"  - in 'x': \",\n                     paste(x_proper_seqnames, collapse=\", \"), \"\\n\",\n                     \"  - in 'y': \",\n                     paste(y_proper_seqnames, collapse=\", \"), \"\\n\",\n                     \"  Make sure to always combine/compare objects based on \",\n                     \"the same reference\\n  genome (use suppressWarnings() \",\n                     \"to suppress this warning).\")\n            warning(msg)\n        }\n    }\n    Seqinfo(seqnames=ans_seqnames, seqlengths=ans_seqlengths,\n            isCircular=ans_is_circular, genome=ans_genome)\n}\n\n## N-ary merge.\n.merge_Seqinfo_objects <- function(...)\n{\n    args <- unname(list(...))\n    ## Remove NULL elements...\n    arg_is_null <- sapply(args, is.null)\n    if (any(arg_is_null))\n        args[arg_is_null] <- NULL  # ... by setting them to NULL!\n    if (length(args) == 0L)\n        return(Seqinfo())\n    x <- args[[1L]]\n    if (length(args) == 1L)\n        return(x)\n    args <- args[-1L]\n    if (!all(sapply(args, is, class(x))))\n        stop(\"all arguments in must be \", class(x), \" objects (or NULLs)\")\n    for (y in args)\n        x <- .merge_two_Seqinfo_objects(x, y)\n    x\n}\n\n### S3 merge() method for Seqinfo objects.\nmerge.Seqinfo <- function(x, y, ...) .merge_Seqinfo_objects(x, y, ...)\n\n### These methods should not be called with named arguments: this tends to\n### break dispatch!\nsetMethod(\"merge\", c(\"Seqinfo\", \"missing\"),\n    function(x, y, ...) .merge_Seqinfo_objects(x, ...)\n)\n\nsetMethod(\"merge\", c(\"missing\", \"Seqinfo\"),\n    function(x, y, ...) .merge_Seqinfo_objects(y, ...)\n)\n\nsetMethod(\"merge\", c(\"Seqinfo\", \"NULL\"),\n    function(x, y, ...) .merge_Seqinfo_objects(x, ...)\n)\n\nsetMethod(\"merge\", c(\"NULL\", \"Seqinfo\"),\n    function(x, y, ...) .merge_Seqinfo_objects(y, ...)\n)\n\nsetMethod(\"merge\", c(\"Seqinfo\", \"Seqinfo\"),\n    function(x, y, ...) .merge_Seqinfo_objects(x, y, ...)\n)\n\nsetMethod(\"intersect\", c(\"Seqinfo\", \"Seqinfo\"), function(x, y) {\n  merge(x, y)[intersect(seqnames(x), seqnames(y))]\n})\n\n### Update the entries in Seqinfo object 'object' with the corresponding\n### entries in Seqinfo object 'value'. Note that the seqnames in 'value'\n### must be a subset of the seqnames in 'object'.\n.update_Seqinfo <- function(object, value)\n{\n   if (!is(object, \"Seqinfo\"))\n        stop(\"object to update 'object' must be a Seqinfo object\")\n   if (!is(value, \"Seqinfo\"))\n        stop(\"replacement value must be a Seqinfo object\")\n\n    ## Infer 'i'.\n    i <- match(seqnames(value), seqnames(object))\n    if (anyNA(i))\n        stop(wmsg(\"the seqnames in replacement Seqinfo object must be \",\n                  \"a subset of the seqnames in Seqinfo object to update\"))\n\n    ## Modify and return 'object'.\n    object@seqlengths[i] <- value@seqlengths\n    object@is_circular[i] <- value@is_circular\n    object@genome[i] <- value@genome\n    object\n}\n\n### S3/S4 combo for update.Seqinfo\nupdate.Seqinfo <- function(object, ...) .update_Seqinfo(object, ...)\nsetMethod(\"update\", \"Seqinfo\", update.Seqinfo)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### checkCompatibleSeqinfo()\n###\n\ncheckCompatibleSeqinfo <- function(x, y) merge(seqinfo(x), seqinfo(y))\n\n",
        "UCSC-utils.R": "### =========================================================================\n### Some low-level utilities to fetch data from the UCSC Genome Browser\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n\n### TODO: Everything in this file should move to the UCSC.utils package.\n\n### UCSC provides a dump of each genome database at:\n###   <goldenPath.url>/<genome>/database/\n### The database tables are dumped as compressed tab-delimited text files.\n### fetch_table_dump_from_UCSC() downloads the specified table and\n### imports it as a data.frame.\nfetch_table_dump_from_UCSC <- function(genome, table, col2class,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    url <- paste(goldenPath.url, genome, \"database\",\n                 paste0(table, \".txt.gz\"), sep=\"/\")\n    fetch_table_from_url(url, colnames=names(col2class), col2class=col2class)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### fetch_chrom_sizes_from_UCSC()\n###\n\n.check_chrom_sizes <- function(chrom_sizes, in_what)\n{\n    chroms <- chrom_sizes[ , \"chrom\"]\n    if (!is_primary_key(chroms))\n        stop(wmsg(\"invalid data in \", in_what, \": \",\n                  \"\\\"chrom\\\" column contains NAs, empty strings, \",\n                  \"or duplicates\"))\n    sizes <- chrom_sizes[ , \"size\"]\n    if (anyNA(sizes) || any(sizes < 0L))\n        stop(wmsg(\"invalid data in \", in_what, \": \",\n                  \"\\\"size\\\" column contains NAs or negative values\"))\n}\n\n.fetch_chrom_sizes_from_UCSC_database <- function(genome,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    col2class <- c(chrom=\"character\", size=\"integer\", fileName=\"NULL\")\n    ans <- fetch_table_dump_from_UCSC(genome, \"chromInfo\",\n                                      col2class=col2class,\n                                      goldenPath.url=goldenPath.url)\n    ## Some sanity checks that should never fail.\n    in_what <- paste0(\"\\\"chromInfo\\\" table for UCSC genome \", genome)\n    .check_chrom_sizes(ans, in_what)\n    ans\n}\n\n.fetch_chrom_sizes_from_UCSC_bigZips <- function(genome, use.latest=FALSE,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    filename <- paste0(genome, \".chrom.sizes\")\n    url <- paste(goldenPath.url, genome, \"bigZips\", sep=\"/\")\n    if (use.latest)\n        url <- paste(url, \"latest\", sep=\"/\")\n    url <- paste(url, filename, sep=\"/\")\n    col2class <- c(chrom=\"character\", size=\"integer\")\n    ans <- fetch_table_from_url(url, colnames=names(col2class),\n                                     col2class=col2class)\n    ## Some sanity checks that should never fail.\n    in_what <- paste0(\"UCSC file \", filename)\n    .check_chrom_sizes(ans, in_what)\n    ans\n}\n\n### UCSC chrom sizes can be fetched from two locations:\n### 1. The 'chromInfo.txt.gz' file at <goldenPath.url>/<genome>/database/:\n###    This is a 3-column tab-delimited text file that is compressed.\n### 2. The '<genome>.chrom.sizes' file at <goldenPath.url>/<genome>/bigZips/:\n###    This is a 2-column tab-delimited text file (uncompressed).\n### Except for some rare exceptions, the two files should be available for\n### all genomes. Known exceptions (as of Nov 10, 2022):\n###   - UCSC does NOT provide 1. for genomes hs1 and mpxvRivers.\n###   - UCSC does NOT provide 2. for genomes hg15, rn1, rn2, and rn3.\nfetch_chrom_sizes_from_UCSC <- function(genome,\n    from=c(\"database\", \"bigZips\", \"bigZips_latest\"),\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    if (!isSingleString(genome))\n        stop(wmsg(\"'genome' must be a single string\"))\n    if (missing(from)) {\n        from <- from[[1L]]\n    } else {\n        if (!isSingleString(from))\n            stop(wmsg(\"'from' must be set to \\\"database\\\", \",\n                      \"\\\"bigZips\\\", or \\\"bigZips_latest\\\"\"))\n        from <- match.arg(from)\n    }\n    if (!isSingleString(goldenPath.url))\n        stop(wmsg(\"'goldenPath.url' must be a single string\"))\n\n    if (from == \"database\") {\n        ans <- .fetch_chrom_sizes_from_UCSC_database(genome,\n                                  goldenPath.url=goldenPath.url)\n    } else {\n        use_latest <- from == \"bigZips_latest\"\n        ans <- .fetch_chrom_sizes_from_UCSC_bigZips(genome,\n                                  use.latest=use_latest,\n                                  goldenPath.url=goldenPath.url)\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### read_UCSC_assembled_molecules_db_table()\n###\n\nread_UCSC_assembled_molecules_db_table <- function(file)\n{\n    col2class <- c(chrom=\"character\", size=\"integer\", circular=\"logical\")\n    simple_read_table(file, header=TRUE, col2class=col2class)\n}\n\n",
        "fetch_table_dump_from_Ensembl_FTP.R": "### =========================================================================\n### fetch_table_dump_from_Ensembl_FTP()\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Ensembl Core schema (only for the tables we care about)\n###\n### List of Ensembl public MySQL servers / ports\n###   https://www.ensembl.org/info/data/mysql.html\n### Ensembl Core Schema:\n###   https://www.ensembl.org/info/docs/api/core/core_schema.html\n\n### Fundamental Tables\n\n### 'attrib_type' table.\n### (331 rows in homo_sapiens_core_99_38)\n.ENSEMBLDB_ATTRIB_TYPE_COLUMNS <- c(\n    \"attrib_type_id\",         # primary key\n    \"code\",\n    \"name\",\n    \"description\"\n)\n\n### Assembly Tables\n\n### 'seq_region' table.\n### (268443 rows in homo_sapiens_core_99_38)\n.ENSEMBLDB_SEQ_REGION_COLUMNS <- c(\n    \"seq_region_id\",          # primary key\n    \"name\",\n    \"coord_system_id\",        # ==> coord_system.coord_system_id\n    \"length\"\n)\n\n### 'coord_system' table.\n### (9 rows in homo_sapiens_core_99_38)\n.ENSEMBLDB_COORD_SYSTEM_COLUMNS <- c(\n    \"coord_system_id\",        # primary key\n    \"species_id\",\n    \"name\",\n    \"version\",\n    \"rank\",\n    \"attrib\"\n)\n\n### 'seq_region_attrib' table.\n### (5927 rows in homo_sapiens_core_99_38)\n.ENSEMBLDB_SEQ_REGION_ATTRIB_COLUMNS <- c(\n    \"seq_region_id\",          # ==> seq_region.seq_region_id\n    \"attrib_type_id\",         # ==> attrib_type.attrib_type_id\n    \"value\"\n)\n\n### 'seq_region_synonym' table.\n### (2360 rows in homo_sapiens_core_99_38)\n.ENSEMBLDB_SEQ_REGION_SYNONYM_COLUMNS <- c(\n    \"seq_region_synonym_id\",  # primary key\n    \"seq_region_id\",          # ==> seq_region.seq_region_id\n    \"synonym\",\n    \"external_db_id\"          # ==> external_db.external_db_id\n)\n\n### External References\n\n### 'external_db' table.\n### (446 rows in homo_sapiens_core_99_38)\n.ENSEMBLDB_EXTERNAL_DB_COLUMNS <- c(\n    \"external_db_id\",         # primary key\n    \"db_name\",\n    \"db_release\",\n    \"status\",\n    \"priority\",\n    \"db_display_name\",\n    \"type\",\n    \"secondary_db_name\",\n    \"secondary_db_table\",\n    \"description\"\n)\n\n.ENSEMBLDB_COLUMNS <- list(\n    attrib_type=.ENSEMBLDB_ATTRIB_TYPE_COLUMNS,\n    seq_region=.ENSEMBLDB_SEQ_REGION_COLUMNS,\n    coord_system=.ENSEMBLDB_COORD_SYSTEM_COLUMNS,\n    seq_region_attrib=.ENSEMBLDB_SEQ_REGION_ATTRIB_COLUMNS,\n    seq_region_synonym=.ENSEMBLDB_SEQ_REGION_SYNONYM_COLUMNS,\n    external_db=.ENSEMBLDB_EXTERNAL_DB_COLUMNS\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### fetch_table_dump_from_Ensembl_FTP()\n###\n### Fetch a table (.txt.gz file) from one of the core DB dumps located on\n### the Ensembl FTP server (ftp.ensembl.org).\n### This provides access to stuff that is not available thru biomaRt like\n### for example the lengths of the sequences in the reference genome\n### associated with a particular dataset and Ensembl release (e.g. for\n### dataset \"hsapiens_gene_ensembl\" in release \"64\").\n###\n### TODO: Querying the Ensembl MySQL server (via RMariaDB) would probably\n### be a better way to do this.\n### Update (Feb 10, 2020): Some preliminary testing indicates that using\n### RMariaDB to fetch full tables is actually significantly slower.\n### For example, to fetch table \"seq_region\" from the homo_sapiens_core_99_38\n### core DB (the table has 268443 rows and 4 columns):\n###   o The utils::download.file() + utils::read.table() approach takes about\n###     7 sec to download and parse the MySQL dump located at:\n###         ftp://ftp.ensembl.org/pub/current_mysql/homo_sapiens_core_99_38/\n###   o The RMariaDB method takes about 22 sec to retrieve the table from the\n###     MySQL server at ensembldb.ensembl.org.\n###\n\n### Table dumps from Ensembl release < 99 can contain inline \\r characters\n### (carriage returns) which break utils::read.table().\n.table_can_contain_CRs <- function(core_db_url)\n{\n    release <- sub(\"_.*$\", \"\", sub(\"^.*_core_\", \"\", core_db_url))\n    release <- suppressWarnings(as.integer(release))\n    !is.na(release) && release < 99L\n}\n\n### 'core_db_url' must be the full URL to a core DB directory located\n### on the Ensembl FTP server e.g.\n### ftp://ftp.ensembl.org/pub/release-99/mysql/mus_musculus_core_99_38/ or\n### ftp://ftp.ensembl.org/pub/grch37/release-87/mysql/homo_sapiens_core_87_37/\n### The \"ftp://\" part and trailing slash are both mandatory!\n### Use get_Ensembl_FTP_core_db_url() defined in Ensembl-utils.R to obtain\n### such URL for a given species/release/division programmatically.\nfetch_table_dump_from_Ensembl_FTP <-\n    function(core_db_url, table, full.colnames=FALSE, nrows=-1L)\n{\n    columns <- .ENSEMBLDB_COLUMNS[[table]]\n    if (!is.null(columns) && full.colnames)\n        columns <- paste(table, columns, sep=\".\")\n    url <- paste0(core_db_url, table, \".txt.gz\")\n    remove_CRs <- .table_can_contain_CRs(core_db_url)\n    if (is.null(columns))\n        warning(wmsg(\"unknown table: \", table, \" (download might fail \",\n                     \"or the returned data frame will have automatic \",\n                     \"colnames)\"),\n                immediate.=TRUE)\n    ## fetch_table_from_url() downloads the full file before reading it.\n    ans <- fetch_table_from_url(url, colnames=columns, nrows=nrows,\n                                remove_CRs=remove_CRs)\n    if (is.null(columns) && full.colnames)\n        colnames(ans) <- paste(table, colnames(ans), sep=\".\")\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### OLD_fetch_table_dump_from_Ensembl_FTP()\n###\n### Replaced by fetch_table_dump_from_Ensembl_FTP() above that uses\n### fetch_table_from_url()'s newly added argument 'remove_CRs' to handle the\n### carriage return problem found in table dumps from Ensembl release < 99.\n### TODO: Either get rid of this (and of the soft dep on data.table and\n### R.utils), OR add the 'reader' argument to\n### fetch_table_dump_from_Ensembl_FTP() (choices would be reduced\n### to \"read.table\" or \"fread\" only, no more \"auto\", with default\n### being \"read.table\").\n\n.please_install_missing_CRAN_pkgs <- function(pkgs, reader0)\n{\n    fmt <- paste0(\"Couldn't load %s. The %s needed %s. Please install %s \",\n                  \"with 'install.packages(%s)' and try again.\")\n    if (length(pkgs) == 1L) {\n        what1 <- paste0(\"package \", pkgs)\n        what2 <- \"package is\"\n        what3 <- \"it\"\n        what4 <- paste0(\"\\\"\", pkgs, \"\\\"\")\n    } else {\n        what1 <- paste0(\"the following packages: \", paste0(pkgs, collapse=\", \"))\n        what2 <- \"packages are\"\n        what3 <- \"them\"\n        what4 <- paste0(\"c(\", paste0(\"\\\"\", pkgs, \"\\\"\",  collapse=\", \"), \")\")\n    }\n    if (reader0 == \"auto\") {\n        why <- paste0(\"to fetch data from Ensembl FTP server \",\n                      \"for Ensembl releases older than 99\")\n    } else {\n        why <- paste0(\"when 'reader=\\\"\", reader0, \"\\\"'\")\n    }\n    sprintf(fmt, what1, what2, why, what3, what4)\n}\n\n### 'core_db_url' must be the full URL to a core DB directory located\n### on the Ensembl FTP server e.g.\n### ftp://ftp.ensembl.org/pub/release-99/mysql/mus_musculus_core_99_38/ or\n### ftp://ftp.ensembl.org/pub/grch37/release-87/mysql/homo_sapiens_core_87_37/\n### The \"ftp://\" part and trailing slash are mandatory!\n### Use get_Ensembl_FTP_core_db_url() defined in Ensembl-utils.R to obtain\n### such URL for a given species/release/division programmatically.\nOLD_fetch_table_dump_from_Ensembl_FTP <-\n    function(core_db_url, table, full.colnames=FALSE, nrows=-1L,\n             reader=c(\"auto\", \"read.table\", \"fread\"))\n{\n    reader0 <- reader <- match.arg(reader)\n    columns <- .ENSEMBLDB_COLUMNS[[table]]\n    if (!is.null(columns) && full.colnames)\n        columns <- paste(table, columns, sep=\".\")\n    url <- paste0(core_db_url, table, \".txt.gz\")\n    if (reader == \"auto\") {\n        ## Table dumps from Ensembl release < 99 can contain inline \\r\n        ## characters (carriage returns) which break utils::read.table().\n        ## However data.table::fread() seems to be slightly better at handling\n        ## them. See https://github.com/Bioconductor/GenomeInfoDb/issues/98\n        ## and https://github.com/Bioconductor/GenomeInfoDb/issues/97.\n        if (.table_can_contain_CRs(core_db_url)) {\n            reader <- \"fread\"\n        } else {\n            reader <- \"read.table\"\n        }\n    }\n    if (reader == \"read.table\") {\n        if (is.null(columns))\n            warning(wmsg(\"unknown table: \", table, \" (download might fail \",\n                         \"or the returned data frame will have automatic \",\n                         \"colnames)\"),\n                    immediate.=TRUE)\n        ## fetch_table_from_url() downloads the full file before reading it.\n        ans <- fetch_table_from_url(url, colnames=columns, nrows=nrows)\n        if (is.null(columns) && full.colnames)\n            colnames(ans) <- paste(table, colnames(ans), sep=\".\")\n    } else {\n        if (is.null(columns))\n            stop(wmsg(\"unknown table: \", table))\n        ## data.table::fread() needs R.utils to read compressed files.\n        missing_pkgs <- character(0)\n        if (!requireNamespace(\"R.utils\", quietly=TRUE))\n            missing_pkgs <- c(missing_pkgs, \"R.utils\")\n        if (!requireNamespace(\"data.table\", quietly=TRUE))\n            missing_pkgs <- c(missing_pkgs, \"data.table\")\n        if (length(missing_pkgs) != 0L) {\n            errmsg <- .please_install_missing_CRAN_pkgs(missing_pkgs, reader0)\n            stop(wmsg(errmsg))\n        }\n        ## data.table::fread() downloads the full file before reading it.\n        ans <- data.table::fread(url, nrows=nrows, strip.white=FALSE,\n                                      showProgress=FALSE)\n        ans <- as.data.frame(ans)\n        colnames(ans) <- columns\n    }\n    ans\n}\n\n",
        "getChromInfoFromEnsembl.R": "### =========================================================================\n### getChromInfoFromEnsembl()\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .add_NCBI_cols_to_Ensembl_chrom_info()\n###\n\n.match_Ensembl_synonmys_to_NCBI_col <- function(Ensembl_seqlevels,\n                                                Ensembl_synonyms,\n                                                NCBI_accns,\n                                                what)\n{\n    stopifnot(is(Ensembl_synonyms, \"CompressedCharacterList\"))\n    Ensembl_unlisted_synonyms <- unlist(Ensembl_synonyms, use.names=FALSE)\n\n    ## solid_match() will fail with a not-so-useful error message\n    ## if 'Ensembl_unlisted_synonyms' contains duplicates. We check\n    ## this early so we can display a slightly better error message.\n    if (anyDuplicated(Ensembl_unlisted_synonyms))\n        stop(wmsg(\"'unlist(Ensembl_synonyms)' contains duplicates\"))\n\n    m <- solid_match(unname(Ensembl_unlisted_synonyms), NCBI_accns,\n                     x_what=\"Ensembl synonym\",\n                     table_what=what)\n\n    m <- relist(m, Ensembl_synonyms)\n    m <- m[!is.na(m)]\n    m_lens <- lengths(m)\n    ambig_idx <- which(m_lens > 1L)\n    if (length(ambig_idx) != 0L) {\n        in1string <- paste0(Ensembl_seqlevels[ambig_idx], collapse = \", \")\n        stop(wmsg(\"Ensembl seqlevel(s) matched to more \",\n                  \"than 1 \", what, \": \", in1string))\n    }\n    as.integer(m)\n}\n\n.mk_progress_str <- function(L2R, NCBI_seqlevels)\n{\n    N <- length(NCBI_seqlevels)\n    ## Using 'sum(!is.na(L2R))' would work but it is based on the assumption\n    ## that 'L2R' will never contain duplicates. We don't want to make this\n    ## assumption here so let's stay on the safe side.\n    revmap_count <- sum(tabulate(L2R, nbins=length(NCBI_seqlevels)) != 0L)\n    percent <- 100 * revmap_count / N\n    sprintf(\"Total NCBI seqlevels mapped: %d/%d -- %.2f%%\",\n            revmap_count, N, percent)\n}\n\n### The workhorse behind .add_NCBI_cols_to_Ensembl_chrom_info().\n### - All input vectors (except 'Ensembl_synonyms') must be character vectors.\n### - 'Ensembl_synonyms' must be a list-like object parallel to\n###   'Ensembl_seqlevels' where each list element is a character vector\n###   containing all the synonyms for the corresponding Ensembl seqlevel.\n### - All NCBI input vectors must have the same length.\n### - Vectors 'Ensembl_seqlevels' and 'NCBI_seqlevels' must be \"primary\n###   keys\" i.e. must not contain NAs, empty strings, or duplicates.\n###   (No such assumption is made about the other input vectors.)\n### Returns an integer vector parallel to 'Ensembl_seqlevels'.\n.map_Ensembl_seqlevels_to_NCBI_seqlevels <- function(Ensembl_seqlevels,\n                                                     Ensembl_synonyms,\n                                                     NCBI_seqlevels,\n                                                     NCBI_GenBankAccn,\n                                                     NCBI_RefSeqAccn,\n                                                     special_mappings=NULL,\n                                                     verbose=FALSE)\n{\n    stopifnot(is.character(Ensembl_seqlevels),\n              is_primary_key(Ensembl_seqlevels),\n              is(Ensembl_synonyms, \"list_OR_List\"),\n              is.character(NCBI_seqlevels),\n              is_primary_key(NCBI_seqlevels),\n              is.character(NCBI_GenBankAccn),\n              is.character(NCBI_RefSeqAccn))\n    if (!is(Ensembl_synonyms, \"CompressedCharacterList\"))\n        Ensembl_synonyms <- as(Ensembl_synonyms, \"CompressedCharacterList\")\n    stopifnot(length(Ensembl_synonyms) == length(Ensembl_seqlevels))\n\n    prefix <- \"Mapping Ensembl to NCBI: \"\n    L2R <- rep.int(NA_integer_, length(Ensembl_seqlevels))\n    unmapped_idx <- seq_along(L2R)\n\n    ## 1. Handle special mappings.\n    if (!is.null(special_mappings)) {\n        if (verbose)\n            message(prefix, \"Handle special mappings ... \", appendLF=FALSE)\n        m1 <- match(names(special_mappings), Ensembl_seqlevels)\n        if (anyNA(m1))\n            stop(wmsg(\"'names(special_mappings)' contains sequence \",\n                      \"names not found in Ensembl core db\"))\n        m2 <- match(special_mappings, NCBI_seqlevels)\n        if (anyNA(m2))\n            stop(wmsg(\"'special_mappings' contains sequence \",\n                      \"names not found in the NCBI assembly\"))\n        L2R[m1] <- m2\n        if (verbose)\n            message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n        unmapped_idx <- which(is.na(L2R))\n        if (length(unmapped_idx) == 0L)\n            return(L2R)\n    }\n\n    ## 2. Assign based on exact matching (case insensitive) of\n    ##    the seqlevels.\n    if (verbose)\n        message(prefix, \"Ensembl_seqlevels -> NCBI_seqlevels ... \",\n                appendLF=FALSE)\n    m <- solid_match2(Ensembl_seqlevels, NCBI_seqlevels,\n                      x_what=\"Ensembl seqlevel\",\n                      table_what=\"NCBI seqlevel\")\n    L2R[unmapped_idx] <- m[unmapped_idx]\n    if (verbose)\n        message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 3. Match 'Ensembl_seqlevels' to 'NCBI_GenBankAccn'.\n    if (verbose)\n        message(prefix, \"Ensembl_seqlevels -> NCBI_GenBankAccn ... \",\n                appendLF=FALSE)\n    m <- solid_match2(Ensembl_seqlevels, NCBI_GenBankAccn,\n                      x_what=\"Ensembl seqlevel\",\n                      table_what=\"NCBI GenBankAccn value\")\n    L2R[unmapped_idx] <- m[unmapped_idx]\n    if (verbose)\n        message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 4. Match 'Ensembl_seqlevels' to 'NCBI_RefSeqAccn'.\n    if (verbose)\n        message(prefix, \"Ensembl_seqlevels -> NCBI_RefSeqAccn ... \",\n                appendLF=FALSE)\n    m <- solid_match2(Ensembl_seqlevels, NCBI_RefSeqAccn,\n                      x_what=\"Ensembl seqlevel\",\n                      table_what=\"NCBI RefSeqAccn value\")\n    L2R[unmapped_idx] <- m[unmapped_idx]\n    if (verbose)\n        message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 5. Match 'Ensembl_synonyms' to 'NCBI_seqlevels'.\n    if (verbose)\n        message(prefix, \"Ensembl_synonyms -> NCBI_seqlevels ... \",\n                appendLF=FALSE)\n    m <- .match_Ensembl_synonmys_to_NCBI_col(Ensembl_seqlevels,\n                                             Ensembl_synonyms,\n                                             NCBI_seqlevels,\n                                             what=\"NCBI seqlevel\")\n    L2R[unmapped_idx] <- m[unmapped_idx]\n    if (verbose)\n        message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 6. Match 'Ensembl_synonyms' to 'NCBI_GenBankAccn'.\n    if (verbose)\n        message(prefix, \"Ensembl_synonyms -> NCBI_GenBankAccn ... \",\n                appendLF=FALSE)\n    m <- .match_Ensembl_synonmys_to_NCBI_col(Ensembl_seqlevels,\n                                             Ensembl_synonyms,\n                                             NCBI_GenBankAccn,\n                                             what=\"NCBI GenBankAccn value\")\n    L2R[unmapped_idx] <- m[unmapped_idx]\n    if (verbose)\n        message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 7. Match 'Ensembl_synonyms' to 'NCBI_RefSeqAccn'.\n    if (verbose)\n        message(prefix, \"Ensembl_synonyms -> NCBI_RefSeqAccn ... \",\n                appendLF=FALSE)\n    m <- .match_Ensembl_synonmys_to_NCBI_col(Ensembl_seqlevels,\n                                             Ensembl_synonyms,\n                                             NCBI_RefSeqAccn,\n                                             what=\"NCBI RefSeqAccn value\")\n    L2R[unmapped_idx] <- m[unmapped_idx]\n    if (verbose)\n        message(\"OK (\", .mk_progress_str(L2R, NCBI_seqlevels), \")\")\n\n    L2R\n}\n\n.add_NCBI_cols_to_Ensembl_chrom_info <- function(\n    Ensembl_chrom_info, assembly_accession,\n    NCBI2Ensembl_special_mappings=NULL)\n{\n    NCBI_chrom_info <- getChromInfoFromNCBI(assembly_accession)\n\n    Ensembl_seqlevels <- Ensembl_chrom_info[ , \"name\"]\n    Ensembl_synonyms  <- Ensembl_chrom_info[ , \"synonyms\"]\n    NCBI_seqlevels    <- NCBI_chrom_info[ , \"SequenceName\"]\n    NCBI_GenBankAccn  <- NCBI_chrom_info[ , \"GenBankAccn\"]\n    NCBI_RefSeqAccn   <- NCBI_chrom_info[ , \"RefSeqAccn\"]\n\n    ## Reverse the mappings.\n    if (is.null(NCBI2Ensembl_special_mappings)) {\n        special_mappings <- NULL\n    } else {\n        special_mappings <- names(NCBI2Ensembl_special_mappings)\n        names(special_mappings) <- NCBI2Ensembl_special_mappings\n    }\n\n    L2R <- .map_Ensembl_seqlevels_to_NCBI_seqlevels(\n                                          Ensembl_seqlevels,\n                                          Ensembl_synonyms,\n                                          NCBI_seqlevels,\n                                          NCBI_GenBankAccn,\n                                          NCBI_RefSeqAccn,\n                                          special_mappings=special_mappings)\n\n    NCBI_chrom_info <- S4Vectors:::extract_data_frame_rows(NCBI_chrom_info, L2R)\n\n    compare_idx <- which(!is.na(NCBI_chrom_info[ , \"SequenceLength\"]))\n    stopifnot(identical(Ensembl_chrom_info[compare_idx, \"length\"],\n                        NCBI_chrom_info[compare_idx, \"SequenceLength\"]))\n\n    drop_columns <- c(\"SequenceLength\", \"UCSCStyleName\", \"circular\")\n    NCBI_chrom_info <- drop_cols(NCBI_chrom_info, drop_columns)\n    colnames(NCBI_chrom_info) <- paste0(\"NCBI.\", colnames(NCBI_chrom_info))\n    cbind(Ensembl_chrom_info, NCBI_chrom_info)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### getChromInfoFromEnsembl()\n###\n\n.format_Ensembl_chrom_info <- function(seq_regions, circ_seqs=NULL)\n{\n    drop_columns <- c(\"seq_region_id\", \"coord_system_id\",\n                      \"coord_system.species_id\", \"coord_system.version\",\n                      \"coord_system.rank\", \"coord_system.attrib\")\n    ans <- drop_cols(seq_regions, drop_columns)\n\n    ## Column \"coord_system\".\n    ans <- rename_cols(ans, \"coord_system.name\", \"coord_system\")\n    ans[ , \"coord_system\"] <- factor(ans[ , \"coord_system\"])\n\n    ## Add column \"circular\".\n    circular <- make_circ_flags_from_circ_seqs(ans[ , \"name\"],\n                                               circ_seqs=circ_seqs)\n    ans$circular <- circular\n\n    ans\n}\n\n### Return NULL or a named list with at least component \"assembly_accession\"\n### and optionally component \"NCBI2Ensembl_special_mappings\" (plus possibly\n### other components that will be ignored by the caller).\n.find_NCBI_assembly_info_for_Ensembl_species_info <- function(species_info)\n{\n    check_species_info(species_info)\n    species <- species_info$species\n    Ensembl_release <- species_info$Ensembl_release\n\n    assembly_accession <- species_info$assembly_accession\n    if (is.null(assembly_accession)) {\n        warning(wmsg(\"'map.NCBI' got ignored for species \\\"\",\n                     species, \"\\\" (no assembly accession can be found \",\n                     \"for it in Ensembl release \", Ensembl_release, \")\"))\n        return(NULL)\n    }\n\n    ## Is this Ensembl species associated with a registered NCBI assembly?\n\n    NCBI_assembly_info <-\n        find_NCBI_assembly_info_for_accession(assembly_accession)\n    if (!is.null(NCBI_assembly_info))\n        return(NCBI_assembly_info)  # yes!\n\n    fallback_assembly_info <- list(assembly_accession=assembly_accession)\n\n    Ensembl_assembly <- species_info$assembly\n    if (is.null(Ensembl_assembly))\n        return(fallback_assembly_info)  # no\n\n    NCBI_assemblies <- registered_NCBI_assemblies()\n    idx <- which(NCBI_assemblies[ , \"assembly\"] %in% Ensembl_assembly)\n    if (length(idx) == 0L)\n        return(fallback_assembly_info)  # no\n\n    if (length(idx) == 1L) {        # yes!\n        accession <- NCBI_assemblies[idx , \"assembly_accession\"]\n        NCBI_assembly_info <- find_NCBI_assembly_info_for_accession(accession)\n        return(NCBI_assembly_info)\n    }\n    ## Yes, but ambiguously! We stick to the accession provided by Ensembl\n    ## with a warning.\n    in1string <- paste(NCBI_assemblies[idx , \"assembly_accession\"],\n                       collapse=\", \")\n    warning(wmsg(\n        \"Assembly accession found for species \\\"\", species, \"\\\" in \",\n        \"Ensembl release \", Ensembl_release, \" is \", assembly_accession, \". \",\n        \"This is not associated with **any** of the NCBI assemblies \",\n        \"registered in GenomeInfoDb (see registered_NCBI_assemblies()). \",\n        \"However, using the assembly name (\", Ensembl_assembly, \") \",\n        \"provided by Ensembl in release \", Ensembl_release, \", \",\n        \"it can be associated with **more than one** registered \",\n        \"NCBI assembly (\", in1string, \"). Because this association is \",\n        \"ambiguous, we ignored it and associated \\\"\", species, \"\\\" \",\n        \"with the assembly accession provided by Ensembl.\"))\n    fallback_assembly_info\n}\n\n.ENSEMBL_cached_chrom_info <- new.env(parent=emptyenv())\n\n.get_chrom_info_from_Ensembl_FTP <- function(core_db_url,\n    assembled.molecules.only=FALSE,\n    include.non_ref.sequences=FALSE,\n    include.contigs=FALSE,\n    include.clones=FALSE,\n    species_info=NULL,\n    recache=FALSE)\n{\n    ans <- .ENSEMBL_cached_chrom_info[[core_db_url]]\n    if (is.null(ans) || recache) {\n        seq_regions <- fetch_seq_regions_from_Ensembl_FTP(core_db_url,\n                                         add.toplevel.col=TRUE,\n                                         add.non_ref.col=TRUE)\n        ans <- .format_Ensembl_chrom_info(seq_regions)\n        .ENSEMBL_cached_chrom_info[[core_db_url]] <- ans\n    }\n\n    if (include.contigs) {\n        if (!is.null(species_info))\n            stop(wmsg(\"'map.NCBI' is not supported when 'include.contigs' \",\n                      \"is set to TRUE\"))\n    } else {\n        keep_idx <- which(!(ans[ , \"coord_system\"] %in% \"contig\"))\n        ans <- S4Vectors:::extract_data_frame_rows(ans, keep_idx)\n        ## Add NCBI cols.\n        if (!is.null(species_info)) {\n            NCBI_assembly_info <-\n                .find_NCBI_assembly_info_for_Ensembl_species_info(species_info)\n            if (!is.null(NCBI_assembly_info)) {\n                ans <- .add_NCBI_cols_to_Ensembl_chrom_info(\n                            ans, NCBI_assembly_info$assembly_accession,\n                            NCBI_assembly_info$NCBI2Ensembl_special_mappings)\n            }\n        }\n    }\n    if (assembled.molecules.only) {\n        ## FIXME: This is broken for some core dbs e.g. bos_taurus_core_99_12\n        ## where coord_system is not set to \"chromosome\" for chromosomes.\n        keep_idx <- which(ans[ , \"coord_system\"] %in% \"chromosome\")\n        ans <- S4Vectors:::extract_data_frame_rows(ans, keep_idx)\n    }\n    if (!include.non_ref.sequences) {\n        keep_idx <- which(!ans[ , \"non_ref\"])\n        ans <- S4Vectors:::extract_data_frame_rows(ans, keep_idx)\n    }\n    if (!include.clones) {\n        keep_idx <- which(!(ans[ , \"coord_system\"] %in% \"clone\"))\n        ans <- S4Vectors:::extract_data_frame_rows(ans, keep_idx)\n    }\n\n    if (!(is.null(species_info) || is.null(NCBI_assembly_info)))\n        attr(ans, \"NCBI_assembly_info\") <- NCBI_assembly_info\n    ans\n}\n\ngetChromInfoFromEnsembl <- function(species,\n    release=NA, division=NA, use.grch37=FALSE,\n    assembled.molecules.only=FALSE,\n    include.non_ref.sequences=FALSE,\n    include.contigs=FALSE,\n    include.clones=FALSE,\n    map.NCBI=FALSE,\n    recache=FALSE,\n    as.Seqinfo=FALSE)\n{\n    core_db_url <- get_Ensembl_FTP_core_db_url(species, release=release,\n                                               division=division,\n                                               use.grch37=use.grch37)\n    species_info <- attr(core_db_url, \"species_info\")\n    check_species_info(species_info)\n\n    if (!isTRUEorFALSE(assembled.molecules.only))\n        stop(wmsg(\"'assembled.molecules.only' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(include.non_ref.sequences))\n        stop(wmsg(\"'include.non_ref.sequences' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(include.contigs))\n        stop(wmsg(\"'include.contigs' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(include.clones))\n        stop(wmsg(\"'include.clones' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(map.NCBI))\n        stop(wmsg(\"'map.NCBI' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(recache))\n        stop(wmsg(\"'recache' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(as.Seqinfo))\n        stop(wmsg(\"'as.Seqinfo' must be TRUE or FALSE\"))\n\n    ans <- .get_chrom_info_from_Ensembl_FTP(core_db_url,\n                assembled.molecules.only=assembled.molecules.only,\n                include.non_ref.sequences=include.non_ref.sequences,\n                include.contigs=include.contigs,\n                include.clones=include.clones,\n                species_info=if (map.NCBI) species_info else NULL,\n                recache=recache)\n\n    if (!as.Seqinfo) {\n        attr(ans, \"species_info\") <- species_info\n        return(ans)\n    }\n    ans_genome <- NA_character_\n    assembly <- species_info$assembly\n    if (!is.null(assembly))\n        ans_genome <- assembly\n    Seqinfo(seqnames=ans[ , \"name\"],\n            seqlengths=ans[ , \"length\"],\n            isCircular=ans[ , \"circular\"],\n            genome=ans_genome)\n}\n\n",
        "getChromInfoFromNCBI.R": "### =========================================================================\n### getChromInfoFromNCBI()\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Load and access db of registered NCBI assemblies\n###\n\n.NCBI_assembly2accession <- new.env(parent=emptyenv())\n.NCBI_accession2assembly_info <- new.env(parent=emptyenv())\n\n.load_registered_NCBI_assembly <- function(file_path)\n{\n    filename <- basename(file_path)\n    if (substr(filename, nchar(filename)-1L, nchar(filename)) != \".R\")\n        stop(wmsg(\"name of assembly registration file '\", filename, \"' must \",\n                  \"have extension .R\"))\n    if (grepl(\" \", filename, fixed=TRUE))\n        stop(wmsg(\"name of assembly registration file '\", filename, \"' must \",\n                  \"not contain spaces\"))\n\n    ## Placeholders. Will actually get defined when we source the\n    ## assembly files.\n    ORGANISM <- NULL    # Expected to be a single string.\n    ASSEMBLIES <- NULL  # Expected to be a list with one list element per\n                        # assembly.\n    source(file_path, local=TRUE)\n\n    stop_if <- function(notok, ...) {\n        if (notok)\n            stop(\"Error in NCBI assembly registration file '\", filename,\n                 \"':\\n  \", wmsg(...))\n    }\n\n    ## Check ORGANISM.\n    stop_if(is.null(ORGANISM), \"'ORGANISM' must be defined\")\n    stop_if(!isSingleString(ORGANISM), \"'ORGANISM' must be a single string\")\n    stop_if(grepl(\"_\", ORGANISM, fixed=TRUE),\n            \"underscores are not allowed in 'ORGANISM' (use spaces instead)\")\n    target <- chartr(\"_\", \" \", substr(filename, 1L, nchar(filename)-2L))\n    stop_if(!identical(target, ORGANISM),\n            \"'ORGANISM' must match filename \",\n            \"(with spaces in place of underscores)\")\n\n    ## Check ASSEMBLIES.\n    stop_if(is.null(ASSEMBLIES), \"'ASSEMBLIES' must be defined\")\n    stop_if(!is.list(ASSEMBLIES), \"'ASSEMBLIES' must be a list of lists\")\n\n    required_fields <- c(\"assembly\", \"date\", \"assembly_accession\", \"circ_seqs\")\n    for (i in seq_along(ASSEMBLIES)) {\n        assembly_info <- ASSEMBLIES[[i]]\n        label <- sprintf(\"'ASSEMBLIES[[%d]]'\", i)\n\n        stop_if(!is.list(assembly_info), label, \" must be a named list\")\n        assembly_fields <- names(assembly_info)\n        stop_if(!is.character(assembly_fields), label, \" must be a named list\")\n        stop_if(!is_primary_key(assembly_fields),\n                \"the names on \", label, \" must \",\n                \"not contain NAs, empty strings, or duplicates\")\n        stop_if(!all(required_fields %in% names(assembly_info)),\n                label, \" must have fields: \",\n                paste(paste0(\"\\\"\", required_fields, \"\\\"\"), collapse=\", \"))\n\n        ## Check \"assembly\" field (required).\n        assembly <- assembly_info$assembly\n        stop_if(!isSingleString(assembly) || assembly == \"\",\n                \"\\\"assembly\\\" field in \", label, \" must \",\n                \"be a single non-empty string\")\n\n        ## Check \"date\" field (required).\n        date <- assembly_info$date\n        stop_if(!isSingleString(date) || date == \"\",\n                \"\\\"date\\\" field in \", label, \" must \",\n                \"be a single non-empty string\")\n\n        ## Check \"accession\" field (required).\n        accession <- assembly_info$assembly_accession\n        stop_if(!isSingleString(accession) || accession == \"\",\n                \"\\\"accession\\\" field in \", label, \" must \",\n                \"be a single non-empty string\")\n        stop_if(!is.null(.NCBI_accession2assembly_info[[accession]]),\n                \"assembly accession \", accession, \" used more than once\")\n\n        ## Check \"circ_seqs\" field (required).\n        circ_seqs <- assembly_info$circ_seqs\n        stop_if(!is.character(circ_seqs),\n                \"\\\"circ_seqs\\\" field in \", label, \" must \",\n                \"be a character vector\")\n        stop_if(!is_primary_key(circ_seqs),\n                \"\\\"circ_seqs\\\" field in \", label, \" must \",\n                \"not contain NAs, empty strings, or duplicates\")\n\n        ## Check optional fields.\n\n        extra_info <- assembly_info$extra_info\n        if (!is.null(extra_info)) {\n            stop_if(!is.character(extra_info),\n                \"\\\"extra_info\\\" field in \", label, \" must \",\n                \"be a named character vector\")\n            stop_if(anyNA(extra_info) || !all(nzchar(extra_info)),\n                \"\\\"extra_info\\\" field in \", label, \" must \",\n                \"not contain NAs or empty strings\")\n            tags <- names(extra_info)\n            stop_if(!is.character(tags),\n                \"\\\"extra_info\\\" field in \", label, \" must \",\n                \"be a named character vector\")\n            stop_if(anyNA(tags) || anyDuplicated(tags),\n                \"the names on \\\"extra_info\\\" field \", label, \" must \",\n                \"not contain NAs or duplicates\")\n        }\n\n        special_mappings <- assembly_info$NCBI2Ensembl_special_mappings\n        if (!is.null(special_mappings)) {\n            stop_if(!is.character(special_mappings),\n                \"\\\"NCBI2Ensembl_special_mappings\\\" field in \", label, \" must \",\n                \"be a named character vector\")\n            stop_if(is.null(names(special_mappings)),\n                \"\\\"NCBI2Ensembl_special_mappings\\\" field in \", label, \" must \",\n                \"be a named character vector\")\n        }\n\n        assembly <- tolower(assembly)\n        .NCBI_assembly2accession[[assembly]] <-\n            c(.NCBI_assembly2accession[[assembly]], accession)\n        assembly_info$organism <- ORGANISM\n        assembly_info$rank_within_organism <- i\n        .NCBI_accession2assembly_info[[accession]] <- assembly_info\n    }\n}\n\n.load_registered_NCBI_assemblies <- function()\n{\n    dir_path <- system.file(\"registered\", \"NCBI_assemblies\",\n                             package=\"GenomeInfoDb\")\n    file_paths <- list.files(dir_path, pattern=\"\\\\.R$\", full.names=TRUE)\n    for (file_path in file_paths)\n        .load_registered_NCBI_assembly(file_path)\n}\n\n.make_extra_info_col <- function(col0, ifmissing=\"\", sep=\":\", collapse=\"|\")\n{\n    stopifnot(is.list(col0), is.character(ifmissing), length(ifmissing) == 1L)\n    col <- rep.int(ifmissing, length(col0))\n    idx1 <- which(lengths(col0) != 0L)\n    if (length(idx1) != 0L) {\n        col1 <- col0[idx1]\n        unlisted_col1 <- unlist(col1)\n        stopifnot(is.character(unlisted_col1))\n        tags <- names(unlisted_col1)\n        stopifnot(is.character(tags),\n                  !anyNA(tags),\n                  all(nzchar(tags)))\n        col1 <- relist(paste(tags, unlisted_col1, sep=sep), col1)\n        col[idx1] <- unstrsplit(col1, sep=collapse)\n    }\n    col\n}\n\nregistered_NCBI_assemblies <- function(organism=NA)\n{\n    if (!isSingleStringOrNA(organism))\n        stop(wmsg(\"'organism' must be a single string or NA\"))\n    if (length(.NCBI_accession2assembly_info) == 0L)\n        .load_registered_NCBI_assemblies()\n    assemblies <- unname(as.list(.NCBI_accession2assembly_info, all.names=TRUE))\n\n    colnames <- c(\"organism\", \"rank_within_organism\", \"assembly\", \"date\",\n                  \"extra_info\", \"assembly_accession\", \"circ_seqs\")\n    make_col <- function(colname) {\n        col0 <- lapply(assemblies, `[[`, colname)\n        if (colname == \"extra_info\")\n            return(factor(.make_extra_info_col(col0)))\n        if (colname == \"circ_seqs\")\n            return(CharacterList(col0))\n        stopifnot(all(lengths(col0) == 1L))\n        col <- unlist(col0, use.names=FALSE)\n        if (colname == \"rank_within_organism\")\n            return(as.integer(col))\n        col <- as.character(col)\n        if (colname == \"organism\")\n            col <- factor(col)  # order of levels will dictate order\n                                # of rows in final DataFrame\n        col\n    }\n\n    listData <- lapply(setNames(colnames, colnames), make_col)\n    DF <- S4Vectors:::new_DataFrame(listData, nrows=length(assemblies))\n    oo <- order(DF$organism, DF$rank_within_organism)\n    DF <- drop_cols(DF, \"rank_within_organism\")[oo, , drop=FALSE]\n    if (!is.na(organism)) {\n        keep_idx <- grep(organism, DF$organism, ignore.case=TRUE)\n        DF <- DF[keep_idx, , drop=FALSE]\n    }\n    as.data.frame(DF)\n}\n\n.lookup_NCBI_assembly2accession <- function(assembly)\n{\n    stopifnot(isSingleString(assembly))\n    if (length(.NCBI_assembly2accession) == 0L)\n        .load_registered_NCBI_assemblies()\n    .NCBI_assembly2accession[[tolower(assembly)]]\n}\n\nfind_NCBI_assembly_info_for_accession <- function(accession)\n{\n    stopifnot(isSingleString(accession))\n    if (length(.NCBI_accession2assembly_info) == 0L)\n        .load_registered_NCBI_assemblies()\n    .NCBI_accession2assembly_info[[accession]]\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### getChromInfoFromNCBI()\n###\n\n.format_NCBI_chrom_info <- function(assembly_report, circ_seqs=NULL)\n{\n    ans <- drop_cols(assembly_report, \"AssignedMoleculeLocationOrType\")\n\n    ## Column \"GenBankAccn\".\n    GenBankAccn <- ans[ , \"GenBankAccn\"]\n    if (!is.character(GenBankAccn))\n        ans[ , \"GenBankAccn\"] <- as.character(GenBankAccn)\n\n    ## Column \"SequenceName\".\n    sequence_name <- as.character(ans[ , \"SequenceName\"])\n    if (all(is.na(sequence_name)))  # this happens for the CIEA01 assembly!\n        sequence_name <- ans[ , \"GenBankAccn\"]\n    stopifnot(is_primary_key(sequence_name))\n    ans[ , \"SequenceName\"] <- sequence_name\n\n    ## Column \"SequenceRole\".\n    SequenceRole_levels <- c(\"assembled-molecule\",\n                             \"alt-scaffold\",\n                             \"unlocalized-scaffold\",\n                             \"unplaced-scaffold\",\n                             \"pseudo-scaffold\",\n                             \"fix-patch\",\n                             \"novel-patch\")\n    sequence_role <- factor(ans[ , \"SequenceRole\"], levels=SequenceRole_levels)\n    stopifnot(identical(is.na(sequence_role), is.na(ans[ , \"SequenceRole\"])))\n    ans[ , \"SequenceRole\"] <- sequence_role\n\n    ## Re-order the rows based on SequenceRole.\n    oo <- order(as.integer(sequence_role))\n    ans <- S4Vectors:::extract_data_frame_rows(ans, oo)\n\n    ## Column \"AssignedMolecule\".\n    is_assembled <- ans[ , \"SequenceRole\"] %in% \"assembled-molecule\"\n    assembled_molecules <- ans[is_assembled, \"SequenceName\"]\n    ans[ , \"AssignedMolecule\"] <- factor(ans[ , \"AssignedMolecule\"],\n                                         levels=assembled_molecules)\n\n    ## Column \"Relationship\".\n    Relationship_levels <- c(\"=\", \"<>\")\n    ans[ , \"Relationship\"] <- factor(ans[ , \"Relationship\"],\n                                     levels=Relationship_levels)\n\n    ## Column \"RefSeqAccn\".\n    RefSeqAccn <- ans[ , \"RefSeqAccn\"]\n    if (!is.character(RefSeqAccn))\n        ans[ , \"RefSeqAccn\"] <- as.character(RefSeqAccn)\n\n    ## Column \"AssemblyUnit\".\n    ans[ , \"AssemblyUnit\"] <- factor(ans[ , \"AssemblyUnit\"])\n\n    ## Column \"UCSCStyleName\".\n    UCSCStyleName <- ans[ , \"UCSCStyleName\"]\n    if (!is.character(UCSCStyleName))\n        UCSCStyleName <- as.character(UCSCStyleName)\n    na_idx <- which(UCSCStyleName %in% \"na\")\n    UCSCStyleName[na_idx] <- NA_character_\n    ans[ , \"UCSCStyleName\"] <- UCSCStyleName\n\n    ## Add column \"circular\".\n    circular <- make_circ_flags_from_circ_seqs(ans[ , \"SequenceName\"],\n                                               circ_seqs=circ_seqs)\n    ans$circular <- circular & is_assembled\n\n    ans\n}\n\n.NCBI_cached_chrom_info <- new.env(parent=emptyenv())\n\n.get_NCBI_chrom_info_from_accession <- function(accession, assembly_name=NA,\n    circ_seqs=NULL,\n    assembled.molecules.only=FALSE,\n    assembly.units=NULL,\n    recache=FALSE)\n{\n    ans <- .NCBI_cached_chrom_info[[accession]]\n    if (is.null(ans) || recache) {\n        assembly_report <- fetch_assembly_report(accession,\n                                                 assembly_name=assembly_name)\n        ## Hardcoded special treatment of GCF_000002285.5 (Dog10K_Boxer_Tasha).\n        ## See inst/registered/NCBI_assemblies/Canis_lupus_familiaris.R\n        if (accession == \"GCF_000002285.5\") {\n            ## Full sequence report for GCF_000002285.5 has 2 entries for MT.\n            ## Drop the bogus one!\n            GenBankAccn <- assembly_report[ , \"GenBankAccn\"]\n            keep_idx <- which(!(GenBankAccn %in% \"CM023446.1\"))\n            assembly_report <-\n                S4Vectors:::extract_data_frame_rows(assembly_report, keep_idx)\n        }\n        ## Hardcoded special treatment of GCF_000258655.2 (panpan1.1).\n        ## See inst/registered/NCBI_assemblies/Pan_paniscus.R\n        if (accession == \"GCF_000258655.2\") {\n            ## Full sequence report for GCF_000258655.2 has 2 entries for MT.\n            ## Drop the bogus one!\n            GenBankAccn <- assembly_report[ , \"GenBankAccn\"]\n            keep_idx <- which(!(GenBankAccn %in% \"KT153251.1\"))\n            assembly_report <-\n                S4Vectors:::extract_data_frame_rows(assembly_report, keep_idx)\n        }\n        ans <- .format_NCBI_chrom_info(assembly_report, circ_seqs=circ_seqs)\n        .NCBI_cached_chrom_info[[accession]] <- ans\n    }\n    if (assembled.molecules.only) {\n        keep_idx <- which(ans[ , \"SequenceRole\"] %in% \"assembled-molecule\")\n        ans <- S4Vectors:::extract_data_frame_rows(ans, keep_idx)\n    }\n    if (!is.null(assembly.units)) {\n        lower_case_units <- tolower(assembly.units)\n        ans_assembly_units <- ans[ , \"AssemblyUnit\"]\n        ## \"Primary Assembly\" and \"non-nuclear\" are **always** considered valid\n        ## Assembly Units regardless of whether they appear in the AssemblyUnit\n        ## column or not.\n        valid_assembly_units <- tolower(c(\"Primary Assembly\",\n                                          \"non-nuclear\",\n                                          levels(ans_assembly_units)))\n        bad_idx <- which(!(lower_case_units %in% valid_assembly_units))\n        if (length(bad_idx) != 0L) {\n            in1string <- paste0(assembly.units[bad_idx], collapse=\", \")\n            stop(wmsg(\"invalid Assembly Unit(s): \", in1string))\n        }\n        keep_idx <- which(tolower(ans_assembly_units) %in% lower_case_units)\n        ans <- S4Vectors:::extract_data_frame_rows(ans, keep_idx)\n    }\n    ans\n}\n\n### Return a 10-column data.frame with columns \"SequenceName\" (character),\n### \"SequenceRole\" (factor),  \"AssignedMolecule\" (factor), \"GenBankAccn\"\n### (character), \"Relationship\" (factor), \"RefSeqAccn\" (character),\n### \"AssemblyUnit\" (factor), \"SequenceLength\" (integer), \"UCSCStyleName\"\n### (character), and \"circular\" (logical).\ngetChromInfoFromNCBI <- function(assembly,\n    assembled.molecules.only=FALSE,\n    assembly.units=NULL,\n    recache=FALSE,\n    as.Seqinfo=FALSE)\n{\n    if (!isSingleString(assembly))\n        stop(wmsg(\"'assembly' must be a single string\"))\n    if (!isTRUEorFALSE(assembled.molecules.only))\n        stop(wmsg(\"'assembled.molecules.only' must be TRUE or FALSE\"))\n    if (!is.null(assembly.units)) {\n        if (!is.character(assembly.units))\n            stop(wmsg(\"'assembly.units' must be a character vector or NULL\"))\n        stop_if_not_primary_key(assembly.units, \"'assembly.units'\")\n    }\n    if (!isTRUEorFALSE(recache))\n        stop(wmsg(\"'recache' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(as.Seqinfo))\n        stop(wmsg(\"'as.Seqinfo' must be TRUE or FALSE\"))\n\n    ## First see if the user supplied the accession of a registered assembly\n    ## instead of the name of the assembly.\n    NCBI_assembly_info <- find_NCBI_assembly_info_for_accession(assembly)\n    if (!is.null(NCBI_assembly_info)) {\n        ## Yes s/he did.\n        accession <- assembly\n        circ_seqs <- NCBI_assembly_info$circ_seqs\n    } else {\n        ## No s/he didn't.\n        ## Now see if s/he supplied the name of a registered assembly.\n        accession <- .lookup_NCBI_assembly2accession(assembly)\n        if (!is.null(accession)) {\n            ## Yes s/he did.\n            if (length(accession) > 1L) {\n                in1string <- paste0(accession, collapse=\", \")\n                warning(wmsg(\"Assembly \", assembly, \" is mapped to more \",\n                             \"than one assembly (\", in1string, \"). \",\n                             \"The first one was selected.\"))\n                accession <- accession[[1L]]\n            }\n            NCBI_assembly_info <-\n                find_NCBI_assembly_info_for_accession(accession)\n            circ_seqs <- NCBI_assembly_info$circ_seqs\n        } else {\n            ## No s/he didn't.\n            ## So now we just assume that 'assembly' is an assembly accession\n            ## (an unregistered one).\n            accession <- assembly\n            circ_seqs <- NULL\n        }\n    }\n    if (is.null(NCBI_assembly_info)) {\n        assembly_name <- assembly\n    } else {\n        assembly_name <- NCBI_assembly_info$assembly\n    }\n\n    ans <- .get_NCBI_chrom_info_from_accession(accession,\n                assembly_name=assembly_name,\n                circ_seqs=circ_seqs,\n                assembled.molecules.only=assembled.molecules.only,\n                assembly.units=assembly.units,\n                recache=recache)\n\n    if (!as.Seqinfo) {\n        attr(ans, \"NCBI_assembly_info\") <- NCBI_assembly_info\n        return(ans)\n    }\n    Seqinfo(seqnames=ans[ , \"SequenceName\"],\n            seqlengths=ans[ , \"SequenceLength\"],\n            isCircular=ans[ , \"circular\"],\n            genome=assembly_name)\n}\n\n",
        "getChromInfoFromUCSC.R": "### =========================================================================\n### getChromInfoFromUCSC()\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .add_NCBI_cols_to_UCSC_chrom_info()\n###\n\n.match_UCSC_seqlevels_to_NCBI_accns <- function(UCSC_seqlevels, NCBI_accns,\n                                                trim.seqlevels=FALSE,\n                                                accn.suffix=\"\")\n{\n    if (trim.seqlevels) {\n        UCSC_seqlevels <- sub(\"_(alt|random|fix)$\", \"\", UCSC_seqlevels)\n        UCSC_seqlevels <- sub(\"^[^_]*_\", \"\", UCSC_seqlevels)\n    }\n    x <- chartr(\"v-\", \"..\", UCSC_seqlevels)\n    x <- paste0(x, accn.suffix)\n    names(x) <- UCSC_seqlevels\n    solid_match2(tolower(x), tolower(NCBI_accns),\n                 x_what=\"UCSC seqlevel\", table_what=\"accession number\")\n}\n\n.match_UCSC_seqlevels_part2_to_NCBI_accns <-\n    function(UCSC_seqlevels, NCBI_accns, part2.auto.version=\"\", accn.prefix=\"\")\n{\n    ans <- rep.int(NA_integer_, length(UCSC_seqlevels))\n    seqlevel_parts <- strsplit(UCSC_seqlevels, \"_\")\n    nparts <- lengths(seqlevel_parts)\n    idx2 <- which(nparts >= 2L)\n    if (length(idx2) == 0L)\n        return(ans)\n    offsets <- c(0L, cumsum(nparts[idx2[-length(idx2)]]))\n    x <- unlist(seqlevel_parts[idx2], use.names=FALSE)[offsets + 2L]\n    x <- chartr(\"v\", \".\", x)\n    unversioned_idx <- grep(\".\", x, fixed=TRUE, invert=TRUE)\n    if (length(unversioned_idx) != 0L)\n        x[unversioned_idx] <- paste0(x[unversioned_idx], part2.auto.version)\n    x <- paste0(accn.prefix, x)\n    names(x) <- UCSC_seqlevels[idx2]\n    ans[idx2] <- solid_match2(tolower(x), tolower(NCBI_accns),\n                              x_what=\"UCSC seqlevel\",\n                              table_what=\"accession number\")\n    ans\n}\n\n### The workhorse behind .add_NCBI_cols_to_UCSC_chrom_info().\n### - All input vectors must be character vectors.\n### - All NCBI input vectors must have the same length.\n### - Vectors 'UCSC_seqlevels' and 'NCBI_seqlevels' must be \"primary\n###   keys\" i.e. must not contain NAs, empty strings, or duplicates.\n###   (No such assumption is made about the other input vectors.)\n### Returns an integer vector parallel to 'UCSC_seqlevels'.\n.map_UCSC_seqlevels_to_NCBI_seqlevels <- function(UCSC_seqlevels,\n                                                  NCBI_seqlevels,\n                                                  NCBI_UCSCStyleName,\n                                                  NCBI_GenBankAccn,\n                                                  NCBI_RefSeqAccn,\n                                                  special_mappings=NULL)\n{\n    stopifnot(is.character(UCSC_seqlevels),\n              is_primary_key(UCSC_seqlevels),\n              is.character(NCBI_seqlevels),\n              is_primary_key(NCBI_seqlevels),\n              is.character(NCBI_UCSCStyleName),\n              is.character(NCBI_GenBankAccn),\n              is.character(NCBI_RefSeqAccn))\n\n    L2R <- rep.int(NA_integer_, length(UCSC_seqlevels))\n    unmapped_idx <- seq_along(L2R)\n\n    ## 1. Handle special mappings.\n    if (!is.null(special_mappings)) {\n        m1 <- match(names(special_mappings), UCSC_seqlevels)\n        if (anyNA(m1))\n            stop(wmsg(\"'names(special_mappings)' contains sequence \",\n                      \"names not found in the UCSC genome\"))\n        m2 <- match(special_mappings, NCBI_seqlevels)\n        if (anyNA(m2))\n            stop(wmsg(\"'special_mappings' contains sequence \",\n                      \"names not found in the NCBI assembly\"))\n        L2R[m1] <- m2\n\n        unmapped_idx <- which(is.na(L2R))\n        if (length(unmapped_idx) == 0L)\n            return(L2R)\n\n        NCBI_UCSCStyleName[m2] <- NA_character_\n    }\n\n    ## 2. We assign based on exact match between 'UCSC_seqlevels'\n    ##    and 'NCBI_UCSCStyleName'.\n    m <- match(UCSC_seqlevels[unmapped_idx], NCBI_UCSCStyleName)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 3. We assign based on exact match (case insensitive) between UCSC\n    ##    and NCBI seqlevels.\n    ucsc_seqlevels <- tolower(UCSC_seqlevels)\n    ncbi_seqlevels <- tolower(NCBI_seqlevels)\n    m <- match(ucsc_seqlevels[unmapped_idx], ncbi_seqlevels)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 4. We assign based on exact match (case insensitive) between UCSC\n    ##    and NCBI seqlevels after removal of the \"chr\" prefix on both sides.\n    nochr_ucsc_seqlevels <- sub(\"^chr\", \"\", ucsc_seqlevels[unmapped_idx])\n    nochr_ncbi_seqlevels <- sub(\"^chr\", \"\", ncbi_seqlevels)\n    m <- match(nochr_ucsc_seqlevels, nochr_ncbi_seqlevels)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 5. We assign based on match between UCSC seqlevels and RefSeq\n    ##    accession numbers.\n    m <- .match_UCSC_seqlevels_to_NCBI_accns(UCSC_seqlevels[unmapped_idx],\n                                             NCBI_RefSeqAccn)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 6. We assign based on match between UCSC seqlevels and GenBank\n    ##    accession numbers.\n    m <- .match_UCSC_seqlevels_to_NCBI_accns(UCSC_seqlevels[unmapped_idx],\n                                             NCBI_GenBankAccn)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 7. We assign based on match between UCSC seqlevels and GenBank\n    ##    accession numbers after adding \".1\" suffix to UCSC seqlevels.\n    m <- .match_UCSC_seqlevels_to_NCBI_accns(UCSC_seqlevels[unmapped_idx],\n                                             NCBI_GenBankAccn,\n                                             accn.suffix=\".1\")\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 8. We assign based on match between UCSC seqlevels and RefSeq\n    ##    accession numbers after trimming the first part (e.g. \"chr1_\")\n    ##    and \"_random\" suffix from the seqlevels.\n    m <- .match_UCSC_seqlevels_to_NCBI_accns(UCSC_seqlevels[unmapped_idx],\n                                             NCBI_RefSeqAccn,\n                                             trim.seqlevels=TRUE)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 9. We assign based on GenBank accession number inferred from part 2 of\n    ##    UCSC seqlevels (after adding automatic suffix \".1\" to the inferred\n    ##    GenBank accession number if it's not versioned).\n    m <- .match_UCSC_seqlevels_part2_to_NCBI_accns(\n                                        UCSC_seqlevels[unmapped_idx],\n                                        NCBI_GenBankAccn,\n                                        part2.auto.version=\".1\")\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 10. We assign based on GenBank accession number inferred from part 2 of\n    ##    UCSC seqlevels (after dropping the version from the GenBank accession\n    ##    numbers provided by NCBI).\n    NCBI_GenBankAccn0 <- sub(\"\\\\.[^.]*$\", \"\", NCBI_GenBankAccn)\n    m <- .match_UCSC_seqlevels_part2_to_NCBI_accns(\n                                        UCSC_seqlevels[unmapped_idx],\n                                        NCBI_GenBankAccn0)\n    L2R[unmapped_idx] <- m\n\n    unmapped_idx <- which(is.na(L2R))\n    if (length(unmapped_idx) == 0L)\n        return(L2R)\n\n    ## 11. We assign based on GenBank accession number inferred from part 2 of\n    ##    UCSC seqlevels after adding AAD prefix to it.\n    m <- .match_UCSC_seqlevels_part2_to_NCBI_accns(\n                                        UCSC_seqlevels[unmapped_idx],\n                                        NCBI_GenBankAccn,\n                                        part2.auto.version=\".1\",\n                                        accn.prefix=\"AAD\")\n    L2R[unmapped_idx] <- m\n\n    L2R\n}\n\n.add_NCBI_cols_to_UCSC_chrom_info <- function(\n    UCSC_chrom_info, assembly_accession,\n    AssemblyUnits=NULL, special_mappings=NULL, unmapped_seqs=NULL,\n    drop_unmapped=FALSE)\n{\n    UCSC_seqlevels <- UCSC_chrom_info[ , \"chrom\"]\n\n    if (length(unmapped_seqs) != 0L) {\n        unmapped_seqs_role <- rep.int(names(unmapped_seqs),\n                                      lengths(unmapped_seqs))\n        unmapped_seqs <- unlist(unmapped_seqs, use.names=FALSE)\n        unmapped_idx <- match(unmapped_seqs, UCSC_seqlevels)\n        stopifnot(!anyNA(unmapped_idx))\n    }\n\n    NCBI_chrom_info <- getChromInfoFromNCBI(assembly_accession,\n                                            assembly.units=AssemblyUnits)\n\n    NCBI_seqlevels     <- NCBI_chrom_info[ , \"SequenceName\"]\n    NCBI_UCSCStyleName <- NCBI_chrom_info[ , \"UCSCStyleName\"]\n    NCBI_GenBankAccn   <- NCBI_chrom_info[ , \"GenBankAccn\"]\n    NCBI_RefSeqAccn    <- NCBI_chrom_info[ , \"RefSeqAccn\"]\n    L2R <- .map_UCSC_seqlevels_to_NCBI_seqlevels(\n                                       UCSC_seqlevels,\n                                       NCBI_seqlevels,\n                                       NCBI_UCSCStyleName,\n                                       NCBI_GenBankAccn,\n                                       NCBI_RefSeqAccn,\n                                       special_mappings=special_mappings)\n    if (length(unmapped_seqs) != 0L)\n        L2R[unmapped_idx] <- NA_integer_\n    L2R_is_NA <- is.na(L2R)\n    mapped_idx <- which(!L2R_is_NA)\n\n    if (isTRUE(drop_unmapped)) {\n        UCSC_chrom_info <-\n            S4Vectors:::extract_data_frame_rows(UCSC_chrom_info, mapped_idx)\n        L2R <- L2R[mapped_idx]\n        mapped_idx <- seq_along(L2R)\n        ## Before we drop the unmapped UCSC seqlevels, we want to make sure\n        ## that all the NCBI seqlevels are reverse mapped. For example, in\n        ## the case of hg38, the chromInfo table at UCSC contains sequences\n        ## that belong to GRCh38.p13 but not to GRCh38. So we want to make\n        ## sure that after we drop these \"foreign sequences\", we are left\n        ## with a one-to-one mapping between UCSC seqlevels and the 455 NCBI\n        ## seqlevels that are in the assembly report for GRCh38.\n        idx <- setdiff(seq_along(NCBI_seqlevels), L2R)\n        if (length(idx) != 0L) {\n            in1string <- paste0(NCBI_seqlevels[idx], collapse=\", \")\n            stop(wmsg(\"no UCSC seqlevel could be mapped to the following \",\n                      \"NCBI seqlevel(s): \", in1string))\n        }\n    } else {\n        unexpectedly_unmapped_idx <-\n            which(L2R_is_NA & !(UCSC_seqlevels %in% unmapped_seqs))\n        if (length(unexpectedly_unmapped_idx) != 0L) {\n            in1string <- paste0(UCSC_seqlevels[unexpectedly_unmapped_idx],\n                                collapse=\", \")\n            stop(wmsg(\"cannot map the following UCSC seqlevel(s) to an \",\n                      \"NCBI seqlevel: \", in1string))\n        }\n    }\n\n    NCBI_chrom_info <- S4Vectors:::extract_data_frame_rows(NCBI_chrom_info, L2R)\n\n    ## NCBI columns \"circular\", \"SequenceLength\", and \"UCSCStyleName\"\n    ## are expected to be redundant with UCSC columns \"circular\", \"size\",\n    ## and \"chrom\", respectively. Let's make sure these 3 NCBI columns\n    ## agree with their UCSC counterpart before we drop them.\n\n    stopifnot(identical(UCSC_chrom_info[mapped_idx, \"circular\"],\n                        NCBI_chrom_info[mapped_idx, \"circular\"]))\n\n    compare_idx <- which(!is.na(NCBI_chrom_info[ , \"SequenceLength\"]))\n    stopifnot(identical(UCSC_chrom_info[compare_idx, \"size\"],\n                        NCBI_chrom_info[compare_idx, \"SequenceLength\"]))\n\n    ## According to the UCSC-style-name column of the assembly report for\n    ## GRCh37.p13 (accession GCF_000001405.25), MT in GRCh37.p13 is mapped\n    ## to chrM in hg19, which is wrong! So we skip this sanity check for\n    ## GCF_000001405.25.\n    if (assembly_accession != \"GCF_000001405.25\") {\n        compare_idx <- which(!is.na(NCBI_chrom_info[ , \"UCSCStyleName\"]))\n        x <- UCSC_chrom_info[compare_idx, \"chrom\"]\n        y <- NCBI_chrom_info[compare_idx, \"UCSCStyleName\"]\n        ## See https://github.com/Bioconductor/GenomeInfoDb/issues/27#issuecomment-871639449\n        if (assembly_accession == \"GCF_000001635.26\") {\n            i1 <- match(\"chr9_KB469738_fix\", x)\n            i2 <- match(\"chr9_KB469738v3_fix\", y)\n            stopifnot(isFALSE(is.na(i1)),\n                      isFALSE(is.na(i2)),\n                      identical(i1, i2))\n            x <- x[-i1]\n            y <- y[-i2]\n        }\n        stopifnot(identical(x, y))\n    }\n\n    drop_columns <- c(\"SequenceLength\", \"UCSCStyleName\", \"circular\")\n    NCBI_chrom_info <- drop_cols(NCBI_chrom_info, drop_columns)\n    colnames(NCBI_chrom_info) <- paste0(\"NCBI.\", colnames(NCBI_chrom_info))\n    ans <- cbind(UCSC_chrom_info, NCBI_chrom_info)\n\n    if (length(unmapped_seqs) != 0L)\n        ans[unmapped_idx, \"NCBI.SequenceRole\"] <- unmapped_seqs_role\n\n    stopifnot(!is.unsorted(ans[ , \"NCBI.SequenceRole\"]))\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .add_ensembl_column()\n###\n\n.fetch_ucscToEnsembl_table <- function(genome,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    col2class <- c(ucsc=\"character\", ensembl=\"character\")\n    fetch_table_dump_from_UCSC(genome, \"ucscToEnsembl\",\n                     col2class=col2class,\n                     goldenPath.url=goldenPath.url)\n}\n\n### Filters and reformats the chromAlias data to so it's returned in the\n### same format as the ucscToEnsembl table (i.e. 2-column data frame with\n### columns \"ucsc\" and \"ensembl\").\n.fetch_ucsc2ensembl_from_chromAlias_table <- function(genome,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    col2class <- c(ensembl=\"character\", ucsc=\"character\", source=\"factor\")\n    chromAlias <- fetch_table_dump_from_UCSC(genome, \"chromAlias\",\n                                   col2class=col2class,\n                                   goldenPath.url=goldenPath.url)\n    ## Filters and reformats.\n    keep_idx <- grep(\"ensembl\", chromAlias[ , \"source\"], fixed=TRUE)\n    ucsc2ensembl <- chromAlias[keep_idx, c(\"ucsc\", \"ensembl\")]\n\n    ## In some **very rare** situations, it seems that the chromAlias table\n    ## can contain ambiguous ucsc-to-ensembl mappings where a given UCSC\n    ## chromosome name is mapped to more than one Ensembl name. For example\n    ## this happens for rn6 where unplaced scaffold chrUn_AABR07022993v1 is\n    ## mapped to Ensembl names AABR07022518.1, AABR07023006.1, AABR07022993.1.\n    ## Note that as of Jan 2020, the chromAlias table for rn6 is the only\n    ## known case of ambiguous ucsc-to-ensembl mapping.\n    if (anyDuplicated(ucsc2ensembl[ , \"ucsc\"])) {\n        ## The disambiguation algorithm below assumes that the ambiguous\n        ## ucsc-to-ensembl mappings are of the form xxYYY-to-ZZZ where\n        ## ZZZ is a GenBank accession, YYY a GenBank accession where the\n        ## dot (\".\") has been replaced with a \"v\" and xx can be any suffix.\n        ## To disambiguate, we only keep mappings where YYY and ZZZ are the\n        ## same (modulo the dot/v substitution).\n        idx <- which(duplicated(ucsc2ensembl[ , \"ucsc\"]) |\n                     duplicated(ucsc2ensembl[ , \"ucsc\"], fromLast=TRUE))\n        ensembl <- chartr(\".\", \"v\", ucsc2ensembl[idx , \"ensembl\"])\n        ucsc <- ucsc2ensembl[idx , \"ucsc\"]\n        ucsc_nc <- nchar(ucsc)\n        ucsc_suffix <- substr(ucsc, ucsc_nc - nchar(ensembl) + 1L, ucsc_nc)\n        ok <- ucsc_suffix == ensembl\n        if (sum(ok) == 0L)\n            stop(wmsg(\"failed to disambiguate 'ucsc2ensembl'\"))\n        if (!all(ucsc %in% ucsc[ok]))\n            stop(wmsg(\"failed to disambiguate 'ucsc2ensembl'\"))\n        if (anyDuplicated(ucsc[ok]))\n            stop(wmsg(\"failed to disambiguate 'ucsc2ensembl'\"))\n        drop_idx <- idx[!ok]\n        ucsc2ensembl <- ucsc2ensembl[-drop_idx, , drop=FALSE]\n    }\n    ucsc2ensembl\n}\n\n.try_to_fetch_ucscToEnsembl <- function(genome,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    message(\"Trying 'ucscToEnsembl' ... \", appendLF=FALSE)\n    ucscToEnsembl <- try(\n        suppressWarnings(\n            .fetch_ucscToEnsembl_table(genome, goldenPath.url=goldenPath.url)\n        ), silent=TRUE)\n    if (inherits(ucscToEnsembl, \"try-error\")) {\n        message(\"FAILED! (table does not exist)\")\n        return(NULL)\n    }\n    message(\"OK\")\n    ucscToEnsembl\n}\n\n.try_to_fetch_ucsc2ensembl_from_chromAlias <- function(genome,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    message(\"Trying 'chromAlias' ... \", appendLF=FALSE)\n    ucsc2ensembl <- try(\n        suppressWarnings(\n            .fetch_ucsc2ensembl_from_chromAlias_table(genome,\n                                                goldenPath.url=goldenPath.url)\n        ), silent=TRUE)\n    if (inherits(ucsc2ensembl, \"try-error\")) {\n        message(\"FAILED! (table does not exist)\")\n        return(NULL)\n    }\n    if (nrow(ucsc2ensembl) == 0L) {\n        message(\"FAILED! (table exists but has no Ensembl information)\")\n        return(NULL)\n    }\n    message(\"OK\")\n    ucsc2ensembl\n}\n\n.fetch_Ensembl_column <- function(UCSC_chroms, genome, table=NA,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    if (identical(table, \"ucscToEnsembl\")) {\n        ucsc2ensembl <- .fetch_ucscToEnsembl_table(genome,\n                                                goldenPath.url=goldenPath.url)\n    } else if (identical(table, \"chromAlias\")) {\n        ucsc2ensembl <- .fetch_ucsc2ensembl_from_chromAlias_table(genome,\n                                                goldenPath.url=goldenPath.url)\n    } else if (identical(table, NA)) {\n        table <- \"ucscToEnsembl\"\n        ucsc2ensembl <- .try_to_fetch_ucscToEnsembl(genome,\n                                      goldenPath.url=goldenPath.url)\n        if (is.null(ucsc2ensembl)) {\n            table <- \"chromAlias\"\n            ucsc2ensembl <- .try_to_fetch_ucsc2ensembl_from_chromAlias(genome,\n                                      goldenPath.url=goldenPath.url)\n            if (is.null(ucsc2ensembl)) {\n                warning(wmsg(\"No Ensembl sequence names could be \",\n                             \"found for UCSC genome \", genome))\n                return(rep.int(NA_character_, length(UCSC_chroms)))\n            }\n        }\n    } else {\n        stop(wmsg(\"supplied 'table' is not supported\"))\n    }\n    oo <- match(UCSC_chroms, ucsc2ensembl[ , \"ucsc\"])\n    if (is.null(table) && anyNA(oo))\n        warning(wmsg(\"incomplete data in '\", table, \"' table for \",\n                     \"UCSC genome \", genome, \": some UCSC sequence \",\n                     \"names are missing\"))\n    ucsc2ensembl[oo , \"ensembl\"]\n}\n\n.add_ensembl_column <- function(UCSC_chrom_info, genome, table=NA,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    ensembl <- .fetch_Ensembl_column(UCSC_chrom_info[ , \"chrom\"],\n                                     genome, table=table,\n                                     goldenPath.url=goldenPath.url)\n    cbind(UCSC_chrom_info, ensembl=ensembl, stringsAsFactors=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### registered_UCSC_genomes()\n###\n\n.parse_script_for_registered_UCSC_genome <- function(script_path)\n{\n    filename <- basename(script_path)\n    if (substr(filename, nchar(filename)-1L, nchar(filename)) != \".R\")\n        stop(wmsg(\"name of genome registration file '\", filename, \"' must \",\n                  \"have extension .R\"))\n    if (grepl(\" \", filename, fixed=TRUE))\n        stop(wmsg(\"name of genome registration file '\", filename, \"' must \",\n                  \"not contain spaces\"))\n\n    ## Placeholders. Will actually get defined when we source the script.\n    ## See README.TXT in inst/registered/UCSC_genomes/ for the list of\n    ## variables.\n    GENOME <- ORGANISM <- ASSEMBLED_MOLECULES <- CIRC_SEQS <- NULL\n    FETCH_ORDERED_CHROM_SIZES <- NCBI_LINKER <- ENSEMBL_LINKER <- NULL\n    source(script_path, local=TRUE)\n\n    stop_if <- function(notok, ...) {\n        if (notok)\n            stop(\"Error in UCSC genome registration file '\", filename,\n                 \"':\\n  \", wmsg(...))\n    }\n\n    ## Check GENOME.\n    stop_if(is.null(GENOME), \"'GENOME' must be defined\")\n    stop_if(!isSingleString(GENOME), \"'GENOME' must be a single string\")\n    target <- substr(filename, 1L, nchar(filename)-2L)\n    stop_if(!identical(target, GENOME), \"'GENOME' must match filename\")\n\n    ## Check ORGANISM.\n    stop_if(is.null(ORGANISM), \"'ORGANISM' must be defined\")\n    stop_if(!isSingleString(ORGANISM), \"'ORGANISM' must be a single string\")\n    stop_if(grepl(\"_\", ORGANISM, fixed=TRUE),\n            \"underscores are not allowed in 'ORGANISM' (use spaces instead)\")\n\n    ## Check ASSEMBLED_MOLECULES.\n    stop_if(is.null(ASSEMBLED_MOLECULES),\n            \"'ASSEMBLED_MOLECULES' must be defined\")\n    stop_if(!is.character(ASSEMBLED_MOLECULES),\n            \"'ASSEMBLED_MOLECULES' must be a character vector\")\n    stop_if(!is_primary_key(ASSEMBLED_MOLECULES),\n            \"'ASSEMBLED_MOLECULES' must \",\n            \"not contain NAs, empty strings, or duplicates\")\n\n    ## Check CIRC_SEQS.\n    stop_if(is.null(CIRC_SEQS),\n            \"'CIRC_SEQS' must be defined\")\n    stop_if(!is.character(CIRC_SEQS),\n            \"'CIRC_SEQS' must be a character vector\")\n    stop_if(anyDuplicated(CIRC_SEQS),\n            \"'CIRC_SEQS' must not contain duplicates\")\n    stop_if(!all(CIRC_SEQS %in% ASSEMBLED_MOLECULES),\n            \"'CIRC_SEQS' must be a subset of 'ASSEMBLED_MOLECULES'\")\n\n    ## Check FETCH_ORDERED_CHROM_SIZES.\n    if (!is.null(FETCH_ORDERED_CHROM_SIZES)) {\n        stop_if(!is.function(FETCH_ORDERED_CHROM_SIZES),\n                \"when defined, 'FETCH_ORDERED_CHROM_SIZES' must be a function\")\n    }\n\n    ## Check NCBI_LINKER.\n    if (!is.null(NCBI_LINKER)) {\n        stop_if(!is.list(NCBI_LINKER),\n                \"when defined, 'NCBI_LINKER' must be a named list\")\n        linker_fields <- names(NCBI_LINKER)\n        stop_if(!is.character(linker_fields),\n                \"when defined, 'NCBI_LINKER' must be a named list\")\n        stop_if(!is_primary_key(linker_fields),\n                \"the names on 'NCBI_LINKER' must \",\n                \"not contain NAs, empty strings, or duplicates\")\n        stop_if(!(\"assembly_accession\" %in% linker_fields),\n                \"'NCBI_LINKER' must have field \\\"assembly_accession\\\"\")\n        accession <- NCBI_LINKER$assembly_accession\n        stop_if(!isSingleString(accession) || accession == \"\",\n                \"\\\"assembly_accession\\\" field in 'NCBI_LINKER' must \",\n                \"be a single non-empty string\")\n        NCBI_assembly_info <- find_NCBI_assembly_info_for_accession(accession)\n        stop_if(is.null(NCBI_assembly_info),\n                \"\\\"assembly_accession\\\" field in 'NCBI_LINKER' must \",\n                \"be associated with a registered NCBI assembly\")\n        stop_if(!identical(ORGANISM, NCBI_assembly_info$organism),\n                \"the NCBI assembly associated with the \\\"assembly_accession\\\" \",\n                \"field in 'NCBI_LINKER' is registered for an organism \",\n                \"(\\\"\", NCBI_assembly_info$organism, \"\\\") that differs \",\n                \"from 'ORGANISM' (\\\"\", ORGANISM, \"\\\")\")\n    }\n\n    ## Check ENSEMBL_LINKER.\n    if (!is.null(ENSEMBL_LINKER)) {\n        stop_if(!isSingleString(ENSEMBL_LINKER) || ENSEMBL_LINKER == \"\",\n                \"when defined, 'ENSEMBL_LINKER' must \",\n                \"be a single non-empty string\")\n    }\n\n    list(GENOME=GENOME,\n         ORGANISM=ORGANISM,\n         ASSEMBLED_MOLECULES=ASSEMBLED_MOLECULES,\n         CIRC_SEQS=CIRC_SEQS,\n         FETCH_ORDERED_CHROM_SIZES=FETCH_ORDERED_CHROM_SIZES,\n         NCBI_LINKER=NCBI_LINKER,\n         ENSEMBL_LINKER=ENSEMBL_LINKER)\n}\n\nregistered_UCSC_genomes <- function(organism=NA)\n{\n    if (!isSingleStringOrNA(organism))\n        stop(wmsg(\"'organism' must be a single string or NA\"))\n    dir_path <- system.file(\"registered\", \"UCSC_genomes\",\n                             package=\"GenomeInfoDb\")\n    file_paths <- list.files(dir_path, pattern=\"\\\\.R$\", full.names=TRUE)\n    assemblies <- lapply(file_paths, .parse_script_for_registered_UCSC_genome)\n\n    colnames <- c(\"organism\", \"genome\", \"NCBI_assembly\",\n                  \"assembly_accession\", \"with_Ensembl\", \"circ_seqs\")\n    make_col <- function(j) {\n        colname <- colnames[[j]]\n        if (colname == \"NCBI_assembly\") {\n            col <- vapply(assemblies,\n                function(assembly_info) {\n                    linker <- assembly_info$NCBI_LINKER\n                    if (is.null(linker))\n                        return(NA_character_)\n                    accession <- linker$assembly_accession\n                    find_NCBI_assembly_info_for_accession(accession)$assembly\n                }, character(1), USE.NAMES=FALSE)\n            return(col)\n        }\n        if (colname == \"assembly_accession\") {\n            col <- vapply(assemblies,\n                function(assembly_info) {\n                    linker <- assembly_info$NCBI_LINKER\n                    if (is.null(linker))\n                        return(NA_character_)\n                    linker$assembly_accession\n                }, character(1), USE.NAMES=FALSE)\n            return(col)\n        }\n        if (colname == \"with_Ensembl\") {\n            col <- vapply(assemblies,\n                function(assembly_info) {\n                    linker <- assembly_info$ENSEMBL_LINKER\n                    !is.null(linker)\n                }, logical(1), USE.NAMES=FALSE)\n            return(col)\n        }\n        COLNAME <- toupper(colname)\n        col0 <- lapply(assemblies, `[[`, COLNAME)\n        if (colname == \"circ_seqs\")\n            return(CharacterList(col0))\n        stopifnot(all(lengths(col0) == 1L))\n        col <- as.character(unlist(col0, use.names=FALSE))\n        if (colname == \"organism\")\n            col <- factor(col)  # order of levels will dictate order\n                                # of rows in final DataFrame\n        col\n    }\n\n    listData <- lapply(setNames(seq_along(colnames), colnames), make_col)\n    DF <- S4Vectors:::new_DataFrame(listData, nrows=length(assemblies))\n    oo <- UCSC.utils:::order_organism_genome_pairs(DF$organism, DF$genome)\n    DF <- DF[oo, , drop=FALSE]\n    if (!is.na(organism)) {\n        keep_idx <- grep(organism, DF$organism, ignore.case=TRUE)\n        DF <- DF[keep_idx, , drop=FALSE]\n    }\n    as.data.frame(DF)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### getChromInfoFromUCSC()\n###\n\n.UCSC_cached_chrom_info <- new.env(parent=emptyenv())\n\n.get_chrom_info_for_unregistered_UCSC_genome <- function(genome,\n    assembled.molecules.only=FALSE,\n    add.ensembl.col=FALSE,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"),\n    recache=FALSE)\n{\n    ans <- .UCSC_cached_chrom_info[[genome]]\n    if (is.null(ans) || recache) {\n        ans <- try(suppressWarnings(\n                       fetch_chrom_sizes_from_UCSC(genome,\n                           goldenPath.url=goldenPath.url)),\n                   silent=TRUE)\n        if (inherits(ans, \"try-error\"))\n            stop(wmsg(\"unknown UCSC genome: \", genome))\n        oo <- orderSeqlevels(ans[ , \"chrom\"])\n        ans <- S4Vectors:::extract_data_frame_rows(ans, oo)\n\n        ## Add columns \"assembled\" and \"circular\".\n        assembled <- rep.int(NA, nrow(ans))\n        circular <- make_circ_flags_from_circ_seqs(ans[ , \"chrom\"])\n        ans <- cbind(ans, assembled=assembled, circular=circular)\n\n        .UCSC_cached_chrom_info[[genome]] <- ans\n    }\n    if (isTRUE(add.ensembl.col)) {\n        warning(wmsg(\"'add.ensembl.col' got ignored for unregistered \",\n                     \"UCSC genome \", genome, \".\"),\n                     \"\\n  \",\n                wmsg(\"Use 'add.ensembl.col=\\\"force\\\"' to try adding \",\n                     \"the \\\"ensembl\\\" column anyway.\"))\n    } else if (identical(add.ensembl.col, \"force\")) {\n        ans <- .add_ensembl_column(ans, genome,\n                                   goldenPath.url=goldenPath.url)\n    }\n    if (assembled.molecules.only)\n        warning(wmsg(\"'assembled.molecules' got ignored for unregistered \",\n                     \"UCSC genome \", genome, \" (don't know what the \",\n                     \"assembled molecules are for an unregistered UCSC \",\n                     \"genome)\"))\n    ans\n}\n\n### Return NULL or a \"raw\" chrom info data.frame, that is, a 4-column\n### data.frame with columns \"chrom\" (character), \"size\" (integer),\n### \"assembled\" (logical), and \"circular\" (logical).\n### The returned data.frame must have one row per assembled molecule.\n.load_stored_amol_info_for_UCSC_genome <-\n    function(GENOME, ASSEMBLED_MOLECULES, CIRC_SEQS)\n{\n    filename <- paste0(GENOME, \".tab\")\n    filepath <- system.file(\"extdata\", \"assembled_molecules_db\", \"UCSC\",\n                            filename, package=\"GenomeInfoDb\")\n    if (identical(filepath, \"\"))\n        return(NULL)\n    ans <- read_UCSC_assembled_molecules_db_table(filepath)\n    expected_circular <- make_circ_flags_from_circ_seqs(ASSEMBLED_MOLECULES,\n                                                        CIRC_SEQS)\n    stopifnot(\n        identical(sapply(ans, class),\n                  c(chrom=\"character\", size=\"integer\", circular=\"logical\")),\n        identical(ans[ , \"chrom\"], ASSEMBLED_MOLECULES),\n        identical(ans[ , \"circular\"], expected_circular)\n    )\n\n    ## Add \"assembled\" column.\n    cbind(ans[ , c(\"chrom\", \"size\")],\n          assembled=rep.int(TRUE, nrow(ans)),\n          circular=ans[ , \"circular\"])\n}\n\n### Return a \"raw\" chrom info data.frame (i.e. 4 core columns only, see above).\n.fetch_raw_chrom_info_from_UCSC <- function(GENOME,\n    ASSEMBLED_MOLECULES,\n    CIRC_SEQS,\n    FETCH_ORDERED_CHROM_SIZES=NULL,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    nb_assembled <- length(ASSEMBLED_MOLECULES)\n\n    ## Obtain chrom sizes from UCSC.\n    if (is.null(FETCH_ORDERED_CHROM_SIZES)) {\n        chrom_sizes <- fetch_chrom_sizes_from_UCSC(GENOME,\n                             goldenPath.url=goldenPath.url)\n        stopifnot(nrow(chrom_sizes) == nb_assembled)\n        oo <- match(ASSEMBLED_MOLECULES, chrom_sizes[ , \"chrom\"])\n        stopifnot(!anyNA(oo))\n        chrom_sizes <- S4Vectors:::extract_data_frame_rows(chrom_sizes, oo)\n    } else {\n        chrom_sizes <- FETCH_ORDERED_CHROM_SIZES(goldenPath.url=goldenPath.url)\n        stopifnot(is.data.frame(chrom_sizes),\n                  identical(sapply(chrom_sizes, class),\n                            c(chrom=\"character\", size=\"integer\")),\n                  identical(head(chrom_sizes[ , \"chrom\"], n=nb_assembled),\n                            ASSEMBLED_MOLECULES),\n                  is_primary_key(chrom_sizes[ , \"chrom\"]))\n    }\n\n    ## Prepare \"assembled\" column.\n    assembled <- logical(nrow(chrom_sizes))\n    assembled[seq_len(nb_assembled)] <- TRUE\n\n    ## Prepare \"circular\" column.\n    circular <- make_circ_flags_from_circ_seqs(chrom_sizes[ , \"chrom\"],\n                                               CIRC_SEQS)\n\n    ## Add \"assembled\" and \"circular\" columns.\n    cbind(chrom_sizes, assembled=assembled, circular=circular)\n}\n\n### Return a \"raw\" chrom info data.frame (i.e. 4 core columns only, see above).\n.get_raw_chrom_info_for_registered_UCSC_genome <- function(GENOME,\n    ASSEMBLED_MOLECULES,\n    CIRC_SEQS,\n    FETCH_ORDERED_CHROM_SIZES=NULL,\n    assembled.molecules.only=FALSE,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"),\n    recache=FALSE)\n{\n    stored_amol_info <- .load_stored_amol_info_for_UCSC_genome(GENOME,\n                                          ASSEMBLED_MOLECULES, CIRC_SEQS)\n    if (!is.null(stored_amol_info) && assembled.molecules.only && !recache)\n        return(stored_amol_info)\n    ans <- .UCSC_cached_chrom_info[[GENOME]]\n    if (is.null(ans) || recache) {\n        ans <- .fetch_raw_chrom_info_from_UCSC(GENOME, ASSEMBLED_MOLECULES,\n                                      CIRC_SEQS, FETCH_ORDERED_CHROM_SIZES,\n                                      goldenPath.url=goldenPath.url)\n        if (!is.null(stored_amol_info)) {\n            assembled_idx <- seq_along(ASSEMBLED_MOLECULES)\n            latest_amol_info <- S4Vectors:::extract_data_frame_rows(ans,\n                                                         assembled_idx)\n            if (!identical(stored_amol_info, latest_amol_info))\n                warning(wmsg(\"The chromosome info obtained from UCSC \",\n                             \"for genome \", GENOME, \" no longer matches \",\n                             \"the records stored in the GenomeInfoDb \",\n                             \"package. Could it be that \", GENOME, \" has \",\n                             \"changed?\"))\n        }\n        .UCSC_cached_chrom_info[[GENOME]] <- ans\n    }\n    ans\n}\n\n.get_NCBI_linker <- function(map.NCBI, linker, GENOME)\n{\n    if (is.list(map.NCBI))\n        return(map.NCBI)\n    if (isFALSE(map.NCBI))\n        return(NULL)\n    if (is.null(linker))\n        warning(wmsg(\"'map.NCBI' got ignored for registered \",\n                     \"UCSC genome \", GENOME, \" (additional NCBI columns \",\n                     \"are only available for registered UCSC genomes \",\n                     \"based on an NCBI assembly)\"))\n    linker\n}\n\n.get_Ensembl_linker <- function(add.ensembl.col, linker, GENOME)\n{\n    if (identical(add.ensembl.col, \"force\"))\n        return(NA)\n    if (isFALSE(add.ensembl.col))\n        return(NULL)\n    if (is.null(linker))\n        warning(wmsg(\"'add.ensembl.col' got ignored for registered \",\n                     \"UCSC genome \", GENOME, \" (genome was registered \",\n                     \"with no Ensembl sequence names linked to it).\"),\n                     \"\\n  \",\n                wmsg(\"Use 'add.ensembl.col=\\\"force\\\"' to try adding \",\n                     \"the \\\"ensembl\\\" column anyway.\"))\n    linker\n}\n\n.get_chrom_info_for_registered_UCSC_genome <- function(script_path,\n    assembled.molecules.only=FALSE,\n    map.NCBI=FALSE,\n    add.ensembl.col=FALSE,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"),\n    recache=FALSE)\n{\n    vars <- .parse_script_for_registered_UCSC_genome(script_path)\n    GENOME <- vars$GENOME\n    ASSEMBLED_MOLECULES <- vars$ASSEMBLED_MOLECULES\n\n    ## Get \"raw\" chrom info (i.e. 4 core columns only).\n    ans <- .get_raw_chrom_info_for_registered_UCSC_genome(GENOME,\n                     ASSEMBLED_MOLECULES, vars$CIRC_SEQS,\n                     FETCH_ORDERED_CHROM_SIZES=vars$FETCH_ORDERED_CHROM_SIZES,\n                     assembled.molecules.only=assembled.molecules.only,\n                     goldenPath.url=goldenPath.url,\n                     recache=recache)\n\n    ## Add NCBI cols.\n    NCBI_linker <- .get_NCBI_linker(map.NCBI, vars$NCBI_LINKER, GENOME)\n    if (!is.null(NCBI_linker))\n        ans <- do.call(.add_NCBI_cols_to_UCSC_chrom_info,\n                       c(list(ans), NCBI_linker))\n\n    ## Add Ensembl col.\n    Ensemb_linker <- .get_Ensembl_linker(add.ensembl.col, vars$ENSEMBL_LINKER,\n                                         GENOME)\n    if (!is.null(Ensemb_linker))\n        ans <- .add_ensembl_column(ans, GENOME, table=Ensemb_linker,\n                                   goldenPath.url=goldenPath.url)\n\n    if (assembled.molecules.only) {\n        assembled_idx <- seq_along(ASSEMBLED_MOLECULES)\n        ans <- S4Vectors:::extract_data_frame_rows(ans, assembled_idx)\n    }\n\n    if (!is.null(NCBI_linker)) {\n        assembly_accession <- NCBI_linker$assembly_accession\n        NCBI_assembly_info <-\n            find_NCBI_assembly_info_for_accession(assembly_accession)\n        attr(ans, \"NCBI_assembly_info\") <- NCBI_assembly_info\n    }\n    ans\n}\n\n.make_Seqinfo_from_UCSC_chrominfo <- function(chrominfo, genome=NA)\n{\n    Seqinfo(seqnames=chrominfo[ , \"chrom\"],\n            seqlengths=chrominfo[ , \"size\"],\n            isCircular=chrominfo[ , \"circular\"],\n            genome=genome)\n}\n\n### By default, return a \"raw\" chrom info data.frame, that is, a 4-column\n### data.frame with columns \"chrom\" (character), \"size\" (integer),\n### \"assembled\" (logical), and \"circular\" (logical).\ngetChromInfoFromUCSC <- function(genome,\n    assembled.molecules.only=FALSE,\n    map.NCBI=FALSE,\n    add.ensembl.col=FALSE,\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"),\n    recache=FALSE,\n    as.Seqinfo=FALSE)\n{\n    if (!isSingleString(genome))\n        stop(wmsg(\"'genome' must be a single string\"))\n    if (!isTRUEorFALSE(assembled.molecules.only))\n        stop(wmsg(\"'assembled.molecules.only' must be TRUE or FALSE\"))\n    if (!(isTRUEorFALSE(map.NCBI) ||\n          is.list(map.NCBI) && !is.null(names(map.NCBI))))\n        stop(wmsg(\"'map.NCBI' must be TRUE or FALSE \",\n                  \"(experts can also supply an \\\"NCBI linker\\\" \",\n                  \"as a named list)\"))\n    if (!(isTRUEorFALSE(add.ensembl.col) ||\n          identical(add.ensembl.col, \"force\")))\n        stop(wmsg(\"'add.ensembl.col' must be TRUE or FALSE \",\n                  \"(experts can also use \\\"force\\\")\"))\n    if (!isSingleString(goldenPath.url))\n        stop(wmsg(\"'goldenPath.url' must be a single string\"))\n    if (!isTRUEorFALSE(recache))\n        stop(wmsg(\"'recache' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(as.Seqinfo))\n        stop(wmsg(\"'as.Seqinfo' must be TRUE or FALSE\"))\n\n    script_name <- paste0(genome, \".R\")\n    script_path <- system.file(\"registered\", \"UCSC_genomes\", script_name,\n                               package=\"GenomeInfoDb\")\n\n    if (identical(script_path, \"\")) {\n        if (!isFALSE(map.NCBI))\n            warning(wmsg(\"'map.NCBI' got ignored for unregistered \",\n                         \"UCSC genome \", genome, \" (additional NCBI columns \",\n                         \"are only available for registered UCSC genomes \",\n                         \"based on an NCBI assembly)\"))\n        ans <- .get_chrom_info_for_unregistered_UCSC_genome(genome,\n                    assembled.molecules.only=assembled.molecules.only,\n                    add.ensembl.col=add.ensembl.col,\n                    goldenPath.url=goldenPath.url,\n                    recache=recache)\n    } else {\n        ans <- .get_chrom_info_for_registered_UCSC_genome(script_path,\n                    assembled.molecules.only=assembled.molecules.only,\n                    map.NCBI=map.NCBI,\n                    add.ensembl.col=add.ensembl.col,\n                    goldenPath.url=goldenPath.url,\n                    recache=recache)\n    }\n\n    if (as.Seqinfo)\n        ans <- .make_Seqinfo_from_UCSC_chrominfo(ans, genome=genome)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### get_and_fix_chrom_info_from_UCSC()\n###\n### A wrapper to getChromInfoFromUCSC() that tries to improve handling of\n### non-registered genomes by:\n### - ordering the sequences based on the heuristic implemented in\n###   rankSeqlevels()/orderSeqlevels()\n### - warning the user about the circularity flags being just a guess\n###   if the caller doesn't supply 'circ_seqs'\n### To use in higher-level functions like makeTxDbFromUCSC() in the\n### GenomicFeatures package.\n\n.warn_about_circularity_guess <- function(genome, circ_seqs,\n                                          warning_tip1=\"\", warning_tip2=\"\")\n{\n    if (length(circ_seqs) == 0L) {\n        guess <- c(\"no sequence in \", genome , \" is circular\")\n    } else if (length(circ_seqs) == 1L) {\n        guess <- c(\"sequence \", circ_seqs, \" is circular\")\n    } else {\n        in1string <- paste(circ_seqs, collapse=\", \")\n        guess <- c(length(circ_seqs), \" sequences (\",\n                   in1string, \") are circular\")\n    }\n    warning(wmsg(\"UCSC genome \", genome, \" is not registered in the \",\n                 \"GenomeInfoDb package (see '?registered_UCSC_genomes'), \",\n                 \"so we made the following guess about this genome: \",\n                 guess, \". \", warning_tip1),\n            \"\\n  \",\n            wmsg(\"If you believe that this guess is incorrect, please \",\n                 \"let us know by opening an issue at:\"),\n            \"\\n      https://github.com/Bioconductor/GenomeInfoDb\\n  \",\n            wmsg(\"In the meantime, you can supply your own list of circular \",\n                 \"sequences (as a character vector) via the 'circ_seqs' \",\n                 \"argument. \", warning_tip2))\n}\n\n### 'warning_tip1' and 'warning_tip2' must be single strings. They will be\n### added to the warning that we will issue if getChromInfoFromUCSC() had\n### to guess the circularity flags.\nget_and_fix_chrom_info_from_UCSC <- function(genome,\n    ...,\n    as.Seqinfo=FALSE,\n    circ_seqs=NULL,\n    warning_tip1=\"\",\n    warning_tip2=\"\")\n{\n    if (!isSingleString(genome))\n        stop(wmsg(\"'genome' must be a single string\"))\n    if (!isTRUEorFALSE(as.Seqinfo))\n        stop(wmsg(\"'as.Seqinfo' must be TRUE or FALSE\"))\n    if (!isSingleString(warning_tip1))\n        stop(wmsg(\"'warning_tip1' must be a single string\"))\n    if (!isSingleString(warning_tip2))\n        stop(wmsg(\"'warning_tip2' must be a single string\"))\n\n    UCSC_genomes <- registered_UCSC_genomes()[ , \"genome\"]\n    is_registered <- genome %in% UCSC_genomes\n\n    ans <- getChromInfoFromUCSC(genome, ..., as.Seqinfo=FALSE)\n    if (!is_registered) {\n        oo <- orderSeqlevels(ans[ , \"chrom\"])\n        ans <- S4Vectors:::extract_data_frame_rows(ans, oo)\n    }\n    seqlevels <- ans[ , \"chrom\"]\n    if (!is.null(circ_seqs)) {\n        ## The user supplied 'circ_seqs', so we use their input to infer the\n        ## circularity flags.\n        ## Note that the user would typically supply 'circ_seqs' when the\n        ## genome is NOT registered. In the case of a registered genome,\n        ## they don't need to do this, because, in this case, the circularity\n        ## flags returned by getChromInfoFromUCSC() should be accurate (they\n        ## were manually curated). However, if the user does supply the\n        ## 'circ_seqs' for a registered genome, we assume that they know\n        ## what they are doing, so we still use their input to replace the\n        ## circularity flags returned by getChromInfoFromUCSC().\n        ans[ , \"circular\"] <- make_circ_flags_from_circ_seqs(\n                                              seqlevels,\n                                              circ_seqs=circ_seqs)\n    } else if (!is_registered) {\n        ## The user did NOT supply 'circ_seqs'. And also because 'genome'\n        ## is NOT a registered UCSC genome, getChromInfoFromUCSC() had to\n        ## guess the circularity flags that it returned in 'ans'. Note\n        ## that this uncertainty about the circularity flags is reflected\n        ## in the presence of NA's instead of FALSE's in 'ans[ , \"circular\"]'.\n        ## In addition to those NA's (which are easy to miss), we also warn\n        ## the user about this guess with an explicit warning.\n        circ_seqs <- seqlevels[which(ans[ , \"circular\"])]\n        .warn_about_circularity_guess(genome, circ_seqs,\n                                      warning_tip1, warning_tip2)\n    }\n\n    if (as.Seqinfo)\n        ans <- .make_Seqinfo_from_UCSC_chrominfo(ans, genome=genome)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### saveAssembledMoleculesInfoFromUCSC()\n###\n### Not intended for the end user.\n### Use case is to add \"assembled molecules info\" for the specified UCSC\n### genomes to the GenomeInfoDb package. The genomes must be **registered**.\n### See README.TXT in GenomeInfoDb/inst/extdata/assembled_molecules_db/UCSC/\n### for more information.\n\n### Vectorized.\nsaveAssembledMoleculesInfoFromUCSC <- function(\n    genomes, dir=\".\",\n    goldenPath.url=getOption(\"UCSC.goldenPath.url\"))\n{\n    if (!is.character(genomes))\n        stop(wmsg(\"'genomes' must be a character vector\"))\n    if (!isSingleString(dir))\n        stop(wmsg(\"'dir' must be a single string specifying the path \",\n                  \"to the directory where to save the RDS file\"))\n    expected_colnames <- c(\"chrom\", \"size\", \"assembled\", \"circular\")\n    for (genome in genomes) {\n        chrominfo <- getChromInfoFromUCSC(genome, assembled.molecules.only=TRUE,\n                                          goldenPath.url=goldenPath.url,\n                                          recache=TRUE)\n        stopifnot(identical(colnames(chrominfo), expected_colnames))\n        chrominfo <- chrominfo[ , -3L]\n        filename <- paste0(genome, \".tab\")\n        filepath <- file.path(dir, filename)\n        write.table(chrominfo, file=filepath,\n                    quote=FALSE, sep=\"\\t\", row.names=FALSE)\n    }\n}\n\n",
        "list_ftp_dir.R": "### =========================================================================\n### list_ftp_dir()\n### -------------------------------------------------------------------------\n\n\n### Strip the \"protocol://\" part (e.g. \"ftp://\" or \"https://\") off the\n### supplied URL, and add the trailing slash to it if missing.\n.normarg_ftp_dir <- function(ftp_dir)\n{\n    stopifnot(isSingleString(ftp_dir))\n    pattern <- \"^[[:alpha:]]*://\"\n    ftp_dir <- sub(pattern, \"\", ftp_dir)\n    ## download.file() will fail if 'ftp_dir' does not have a trailing\n    ## slash, so we append the slash but only if it's missing.\n    nc <- nchar(ftp_dir)\n    last_char <- substr(ftp_dir, nc, nc)\n    if (last_char != \"/\")\n        ftp_dir <- paste0(ftp_dir, \"/\")\n    ftp_dir\n}\n\n.list_ftp_dir <- function(ftp_dir, method)\n{\n    url <- paste0(\"ftp://\", ftp_dir)\n    destfile <- tempfile()\n    download.file(url, destfile, method, quiet=TRUE)\n    readLines(destfile)\n}\n\n.make_matrix_data_from_list <- function(x, min_ncol=0L)\n{\n    stopifnot(is.list(x))\n    x_len <- length(x)\n    x_lens <- lengths(x)\n    ncol <- max(x_lens, min_ncol)\n    if (x_len == 0L) {\n        ans <- character(0)\n    } else {\n        y_lens <- ncol - x_lens\n        x_seqalong <- seq_along(x)\n        f <- rep.int(x_seqalong, y_lens)\n        attributes(f) <- list(levels=as.character(x_seqalong), class=\"factor\")\n        y <- split(character(length(f)), f)\n        collate_subscript <- rep(x_seqalong, each=2L)\n        collate_subscript[2L * x_seqalong] <- x_seqalong + x_len\n        ans <- unlist(c(x, y)[collate_subscript], use.names=FALSE)\n    }\n    attr(ans, \"ncol\") <- ncol\n    ans\n}\n\n### Return a character matrix with 1 row per entry in 'listing', and at least\n### 9 columns (but sometimes more e.g. 11 columns if some entries in 'listing'\n### are symlinks). The file names should always be in the 9th column.\n.ftp_listing_as_matrix <- function(listing)\n{\n    split_listing <- strsplit(listing, split=\"[[:space:]]+\")\n    ans_data <- .make_matrix_data_from_list(split_listing, min_ncol=9L)\n    ans_ncol <- attr(ans_data, \"ncol\")\n    matrix(ans_data, ncol=ans_ncol, byrow=TRUE)\n}\n\n### The keys must be URLs to FTP directories that went thru .normarg_ftp_dir(),\n### that is, without the \"protolol://\" part and with a trailing slash.\n.cached_ftp_dir_listing <- new.env(parent=emptyenv())\n\n### Retrieve the listing of an FTP dir. The result is cached in order to make\n### subsequent calls to list_ftp_dir() on the same 'ftp_dir' faster.\n### If 'long.listing' is TRUE then return a character matrix with 1 row\n### per entry in the FTP dir listing, and at least 9 columns (but sometimes\n### more e.g. 11 columns if the listing contains symlinks). The file names\n### should always be in the 9th column.\n### Note that 'long.listing=TRUE' is similar to option -l of Unix command 'ls'.\nlist_ftp_dir <- function(ftp_dir, subdirs.only=FALSE, long.listing=FALSE,\n                                  recache=FALSE)\n{\n    ftp_dir <- .normarg_ftp_dir(ftp_dir)\n    stopifnot(isTRUEorFALSE(subdirs.only))\n    stopifnot(isTRUEorFALSE(long.listing))\n    stopifnot(isTRUEorFALSE(recache))\n\n    listing <- .cached_ftp_dir_listing[[ftp_dir]]\n    if (is.null(listing) || recache) {\n        listing <- .list_ftp_dir(ftp_dir)\n        .cached_ftp_dir_listing[[ftp_dir]] <- listing\n    }\n\n    if (subdirs.only)\n        listing <- listing[substr(listing, 1L, 1L) == \"d\"]\n    ans <- .ftp_listing_as_matrix(listing)\n    if (!long.listing)\n        ans <- ans[ , 9L]\n    ans\n}\n\n",
        "loadTaxonomyDb.R": "### =========================================================================\n### Helpers to map between taxonomy ID and organism\n### -------------------------------------------------------------------------\n\n### In February 2017 the mapping files in GenomeInfoDb/data/ were moved to the\n### GenomeInfoDbData annotation package.\n\n.TAXONOMY_DB_cache <- new.env(parent=emptyenv())\n\n### Return a data.frame with 3 columns: tax_id, genus, species.\n### Number of rows: 1820543 (as of Jan 30, 2018).\n### TODO: Rename specData dataset -> TAXONOMY_DB in GenomeInfoDbData.\nloadTaxonomyDb <- function()\n{\n    ans <- try(get(\"TAXONOMY_DB\", envir=.TAXONOMY_DB_cache, inherits=FALSE),\n               silent=TRUE)\n    if (!is(ans, \"try-error\"))\n        return(ans)\n    data(specData, package=\"GenomeInfoDbData\", envir=.TAXONOMY_DB_cache)\n    taxdb <- get(\"specData\", envir=.TAXONOMY_DB_cache, inherits=FALSE)\n    stopifnot(identical(colnames(taxdb), c(\"tax_id\", \"genus\", \"species\")),\n              is.integer(taxdb[[\"tax_id\"]]),\n              is.factor(taxdb[[\"genus\"]]),\n              is.character(taxdb[[\"species\"]]))\n    ## Replace NAs in the \"species\" column with emty strings.\n    ## Shouldn't we clean the dataset in GenomeInfoDbData instead?\n    taxdb[[\"species\"]][is.na(taxdb[[\"species\"]])] <- \"\"\n    assign(\"TAXONOMY_DB\", taxdb, envir=.TAXONOMY_DB_cache)\n    taxdb\n}\n\n### NOT exported but used in the GenomicFeatures package.\n### Not vectorized.\nlookup_organism_by_tax_id <- function(tax_id, all=FALSE)\n{\n    stopifnot(isSingleNumber(tax_id))\n    taxdb <- loadTaxonomyDb()\n    ## Find matches.\n    idx <- which(taxdb[[\"tax_id\"]] == tax_id)\n    if (length(idx) == 0L)\n        stop(wmsg(\"Cannot find an organism to match the requested \",\n                  \"taxonomy ID. Please provide the genus and species \",\n                  \"manually.\"))\n    ans <- taxdb[idx, , drop=FALSE]\n    if (nrow(ans) == 1L || all)\n        return(ans)\n    ## When nrow(ans) > 1 and 'all' is FALSE, we first reduce the set of\n    ## entries to keep single word species only, then pick up the first\n    ## entry.\n    idx1 <- which(lengths(strsplit(ans[[\"species\"]], split=\" \")) == 1L)\n    if (length(idx1) >= 1L)\n        ans <- ans[idx1, , drop=FALSE]\n    ans[1L, , drop=FALSE]\n}\n\n### NOT exported but used in the GenomicFeatures package.\n### Not vectorized.\nlookup_tax_id_by_organism <- function(organism)\n{\n    stopifnot(is.character(organism) || is.factor(organism),\n              length(organism) == 1L)\n    if (is.na(organism)) return(NA)\n    taxdb <- loadTaxonomyDb()\n    species <- taxdb[[\"species\"]]\n    organisms <- trimws(paste(taxdb[[\"genus\"]], species))\n    organism <- gsub(\" {2,}\", \" \", organism)\n    organism <- gsub(\",\", \" \", organism, fixed=TRUE)\n    idx <- match(organism, organisms)\n    if (is.na(idx))\n        stop(wmsg(organism, \": unknown organism. \",\n                  \"Please use 'loadTaxonomyDb()' to see viable \",\n                  \"genus/species and taxonomy IDs.\"))\n    as.integer(taxdb[[\"tax_id\"]][[idx]])\n}\n\n### NOT exported but used in the GenomicFeatures package.\n### Vectorized.\ncheck_tax_id <- function(tax_id)\n{\n    stopifnot(is.numeric(tax_id))\n    if (!is.integer(tax_id))\n        tax_id <- as.integer(tax_id)\n    taxdb <- loadTaxonomyDb()\n    bad_idx <- which(!(tax_id %in% taxdb[[\"tax_id\"]]))\n    if (length(bad_idx) != 0L) {\n          bad_ids <- paste0(unique(tax_id[bad_idx]), collapse=\", \")\n          stop(wmsg(\"Unknown taxonomy IDs: \", bad_ids,\n                    \"\\n\\n  These taxonomy IDs are not in our list of valid \",\n                    \"taxonomy IDs. Please check to make sure that the \",\n                    \"supplied taxonomy IDs are legitimate and if so, then \",\n                    \"please tell us about it so that we can update our list.\"))\n    }\n}\n\n",
        "mapGenomeBuilds.R": "listOrganisms <- function(){\n\n    filename <- system.file(package=\"GenomeInfoDb\",  \"extdata\",\n                            \"dataFiles\", \"genomeMappingTbl.csv\")\n    tbl <- read.csv(filename, header=TRUE, stringsAsFactors=FALSE)\n    tbl_names <- unique(tbl[,1:2])\n    rownames(tbl_names) <- NULL\n    tbl_names[,2] = paste0(toupper(substring(tbl_names[,2], 1, 1)),\n                 substring(tbl_names[,2], 2, nchar(tbl_names[,2])))\n    tbl_names\n}\n\ngenomeBuilds <- function(organism, style = c(\"UCSC\", \"Ensembl\")) {\n\n    if (!is.character(organism))\n        stop(\"'organism' must be a character vector\")\n    style <- match.arg(style)\n\n    filename <- system.file(package=\"GenomeInfoDb\",  \"extdata\",\n                            \"dataFiles\", \"genomeMappingTbl.csv\")\n    tbl <- read.csv(filename, header=TRUE, stringsAsFactors=FALSE)\n\n    colkeep <- switch(style,\n                   UCSC=\"ucscID\",\n                   Ensembl=\"ensemblID\"\n               )\n\n    fnd1 <- sapply(tolower(organism), grep, tolower(tbl$commonName))\n    fnd2 <- sapply(tolower(organism), grep, tolower(tbl$organism))\n    fnd <- mapply(c, fnd1, fnd2)\n    notFnd <- names(which(lengths(fnd) == 0))\n    if (length(notFnd))\n        warning(\"'organism' not found: \", paste(notFnd, collapse=\", \"),\n                call.=FALSE)\n\n    if (!missing(organism)){\n        rowkeep <- apply(FUN=any, MARGIN=1, cbind(\n                         tolower(tbl$commonName) %in% tolower(organism),\n                         tolower(tbl$organism) %in% tolower(organism)\n                        ))             \n        tbl <- tbl[rowkeep,c(\"commonName\", \"organism\", colkeep)]\n    }else\n        tbl <- tbl[,c(\"commonName\", \"organism\", colkeep)]\n\n    if (nrow(tbl) == 0L)\n        return(data.frame())\n\n    tbl <- unique(na.omit(tbl))\n    rownames(tbl) <- NULL\n    tbl[,2] = paste0(toupper(substring(tbl[,2], 1, 1)),\n                 substring(tbl[,2], 2, nchar(tbl[,2])))\n    tbl\n}\n\nmapGenomeBuilds <- function(genome, style = c(\"UCSC\", \"Ensembl\") ){\n\n    if (!is.character(genome))\n            stop(\"'genome' must be a character vector\")\n    genome <- tolower(genome)\n    style <- match.arg(style)\n\n    filename <- system.file(package=\"GenomeInfoDb\",  \"extdata\",\n                            \"dataFiles\", \"genomeMappingTbl.csv\")\n    tbl <- read.csv(filename, header=TRUE, stringsAsFactors=FALSE)\n\n    colkeep <- switch(tolower(style),\n                      ucsc=c(\"ucscID\",\"ucscDate\",\"ensemblID\"),\n                      ensembl=c(\"ensemblID\",\"ensemblVersion\", \"ensemblDate\",\n                          \"ucscID\" ))\n\n    fnd = sapply(genome, grep, tolower(c(tbl$ensemblID, tbl$ucscID)))\n    notFnd = names(which(sapply(FUN=length, fnd)==0))\n    if(length(notFnd) != 0L)\n        warning(\"'genome' not found: \", paste(notFnd,collapse=\", \"),\n                call.=FALSE)\n\n    rowkeep <- ((tolower(tbl$ucscID) %in% genome) |\n                (tolower(tbl$ensemblID) %in% genome))\n    if (sum(rowkeep) == 0)\n        return(data.frame())\n    tbl <- tbl[rowkeep, c(\"commonName\", \"organism\", colkeep)]\n\n    rownames(tbl) <- NULL\n    tbl[,2] = paste0(toupper(substring(tbl[,2], 1, 1)),\n                 substring(tbl[,2], 2, nchar(tbl[,2])))\n    tbl\n}\n",
        "rankSeqlevels.R": "### =========================================================================\n### rankSeqlevels()\n### -------------------------------------------------------------------------\n###\n### Assign a unique ID to each unique sequence name passed in 'seqnames'.\n### The returned IDs are guaranteed to span 1:N where N is the number of\n### unique sequence names in 'seqnames'.\n### Also the function tries hard to assign IDs in a way that is consistent\n### with a \"good looking\" order of the sequence names. This \"good looking\"\n### order is roughly defined by the following (complicated and arbitrary)\n### set of rules (rules apply in the order shown below):\n###\n###   1. Every name should fall into exactly 1 of the 5 following \"super\n###      groups\":\n###        (A) starts with CHR\n###        (B) starts with chr\n###        (C) starts with CH\n###        (D) starts with ch\n###        (E) anything else\n###      Names in early super groups are ranked before names in late super\n###      groups.\n###\n###   2. Within each super group, and after the prefix corresponding to the\n###      super group has been dropped (nothing is dropped for super group (E)),\n###      every name should fall into exactly 1 of the 18 following groups:\n###        (a) roman number\n###        (b) \"short\" arabic integer number (i.e. 6 digits or less) possibly\n###            with A, a, B, b, L, or R suffix\n###        (c) W\n###        (d) Z\n###        (e) X\n###        (f) Y\n###        (g) U\n###        (h) M\n###        (i) MT\n###        (j) \"short\" arabic integer number (i.e. 6 digits or less) \"followed\n###            by something\" (not A, a, B, b, L, or R)\n###        (k) W \"followed by something\"\n###        (l) Z \"followed by something\"\n###        (m) X \"followed by something\"\n###        (n) Y \"followed by something\"\n###        (o) U \"followed by something\"\n###        (p) M \"followed by something\"\n###        (q) MT \"followed by something\"\n###        (r) anything else\n###      Names in early groups are ranked before names in late groups.\n###\n###   3. A name in group (b) with A, a, B, b, L, or R suffix, is ranked\n###      right after the name obtained by dropping the suffix.\n###\n###   4. In groups (k-r), ties are broken by looking at the \"followed by\n###      something\" part (or at the entire name for group (r)): collation\n###      defined by LC_COLLATE set to C applies.\n###\n### 'X.is.sexchrom' lets the user control whether X refers to the sexual\n### chromosome or to chromosome with roman number X.\n###\n### Yes, an ugly and messy function, sorry...\n###\n### NOTE: rankSeqlevels() was successfully tested on the BSgenome data\n### packages for hg19, mm10, ce2, dm3, sacCer1, sacCer2, sacCer3 and rheMac2\n### i.e. the IDs returned on the seqnames defined in those packages match the\n### ranks of the seqnames.\n### For example, for hg19, 'rankSeqlevels(seqlevels(Hsapiens))' is identical\n### to 'seq_along(seqlevels(Hsapiens)))'.\n### TODO: Add unit test for rankSeqlevels().\n\n\n### Some simple helpers for low-level string manipulation.\n\n.hasPrefix <- function(x, prefix)\n    substr(x, start=1L, stop=nchar(prefix)) == prefix\n\n.dropPrefix <- function(x, nchar)\n    substr(x, start=nchar+1L, stop=nchar(x))\n\nisRoman <- function(x)\n{\n    suppressWarnings(roman <- utils:::.roman2numeric(x))\n    ans <- logical(length(x))\n    ans[!is.na(roman) & toupper(x) == x] <- TRUE\n    ans\n}\n    \n.REGEXP0 <- \"[1-9][0-9]*\"\n.REGEXP1 <- \"[0-9]*\"\n\n.getNbPart <- function(x)\n{\n    pattern <- paste0(\"^(\", .REGEXP1, \")(.*)$\")\n    sub(pattern, \"\\\\1\", x)\n}\n\n.getPostNbPart <- function(x)\n{\n    pattern <- paste0(\"^(\", .REGEXP1, \")(.*)$\")\n    sub(pattern, \"\\\\2\", x)\n}\n\n.isShortNb <- function(x, abc=\"\")\n{\n    pattern <- paste0(\"^\", .REGEXP0, abc, \"$\")\n    is_nb <- grepl(pattern, x)\n    prefix <- .getNbPart(x)\n    is_nb & nchar(prefix) <= 6L\n}\n\n### rankSeqlevels()\n\nrankSeqlevels <- function(seqnames, X.is.sexchrom=NA)\n{\n    if (is.character(seqnames))\n        seqnames <- factor(seqnames)\n    else if (!is.factor(seqnames))\n        stop(\"'seqnames' must be a character vector or factor\")\n    if (!is.logical(X.is.sexchrom) || length(X.is.sexchrom) != 1L)\n        stop(\"'X.is.sexchrom' must be a single logical\")\n    seqlevels <- levels(factor(seqnames))  # unique seqnames\n    \n    ## Set LC_COLLATE to C so our calls to as.integer(factor(...)) below\n    ## return the same thing for everybody (i.e. for every user on any machine\n    ## in any country).\n    prev_locale <- Sys.getlocale(\"LC_COLLATE\")\n    Sys.setlocale(\"LC_COLLATE\", \"C\")\n    on.exit(Sys.setlocale(\"LC_COLLATE\", prev_locale))\n    \n    ## Provisional ids.\n    prov_ids <- rep.int(NA_integer_, length(seqlevels))\n    last_prov_id <- 0L\n    \n    ## 'i' indices of elements in 'prov_ids' to set.\n    ## 'ints' integer vector of length > 0 with no NAs. Is recycled to the\n    ## length of 'i'.\n    makeAndAssignProvIds <- function(i, ints=0L)\n    {\n        new_prov_ids <- last_prov_id + ints - min(ints) + 1L\n        prov_ids2 <- prov_ids\n        prov_ids2[i] <- new_prov_ids\n        last_prov_id2 <- max(new_prov_ids)\n        assign(\"prov_ids\", prov_ids2, inherits=TRUE)\n        assign(\"last_prov_id\", last_prov_id2, inherits=TRUE)\n    }\n    \n    assignProvIdsForSuperGroup <- function(seqlevels, prefix)\n    {\n        sgidx <- which(is.na(prov_ids) & .hasPrefix(seqlevels, prefix))\n        if (length(sgidx) == 0L)\n            return()\n        sgsuffix <- seqlevels[sgidx]\n        sgsuffix <- .dropPrefix(sgsuffix, nchar(prefix))\n        is_nb <- .isShortNb(sgsuffix)\n        is_nbA <- .isShortNb(sgsuffix, abc=\"A\")\n        is_nba <- .isShortNb(sgsuffix, abc=\"a\")\n        is_nbB <- .isShortNb(sgsuffix, abc=\"B\")\n        is_nbb <- .isShortNb(sgsuffix, abc=\"b\")\n        is_nbL <- .isShortNb(sgsuffix, abc=\"L\")\n        is_nbR <- .isShortNb(sgsuffix, abc=\"R\")\n        is_nb_with_suffix <- is_nb | is_nbA | is_nba | is_nbB | is_nbb |\n                                                       is_nbL | is_nbR\n        is_nbxxx <- .isShortNb(sgsuffix, abc=\".*\") & !is_nb_with_suffix\n        is_W <- sgsuffix == \"W\"\n        is_Z <- sgsuffix == \"Z\"\n        is_X <- sgsuffix == \"X\"\n        is_Y <- sgsuffix == \"Y\"\n        if (is.na(X.is.sexchrom)) {\n            if (any(is_X)) {\n                X_is_seXual <- any(is_Y) ||\n                    any(is_nb_with_suffix) ||\n                    any(is_nbxxx)\n            } else {\n                X_is_seXual <- TRUE  # or FALSE, won't make any difference\n            }\n        } else {\n            X_is_seXual <- X.is.sexchrom\n        }\n        is_seXual <- is_X & X_is_seXual\n        is_roman <- isRoman(sgsuffix) & !is_seXual\n        is_U <- sgsuffix == \"U\"\n        is_MT <- sgsuffix == \"MT\"\n        is_M <- sgsuffix == \"M\"\n        is_Wxxx <- .hasPrefix(sgsuffix, \"W\") & !is_W & !is_roman\n        is_Zxxx <- .hasPrefix(sgsuffix, \"Z\") & !is_Z & !is_roman\n        is_Xxxx <- .hasPrefix(sgsuffix, \"X\") & !is_X & !is_roman\n        is_Yxxx <- .hasPrefix(sgsuffix, \"Y\") & !is_Y & !is_roman\n        is_Uxxx <- .hasPrefix(sgsuffix, \"U\") & !is_U & !is_roman\n        is_MTxxx <- .hasPrefix(sgsuffix, \"MT\") & !is_MT & !is_roman\n        is_Mxxx <- .hasPrefix(sgsuffix, \"M\") & !is_M &\n            !is_MT & !is_MTxxx & !is_roman\n        ## The groups below must define a partitioning of the current super\n        ## group i.e. any element in 'sgsuffix' must fall in exactly 1 group.\n        is_xxx <- !is_roman & !is_nb_with_suffix &\n            !is_W & !is_Z & !is_seXual & !is_Y & !is_U & !is_M & !is_MT &\n            !is_nbxxx &\n            !is_Wxxx & !is_Zxxx  & !is_Xxxx & !is_Yxxx &\n                                   !is_Uxxx & !is_Mxxx & !is_MTxxx\n        ## Group (a).\n        if (any(is_roman)) {\n            gsuffix <- sgsuffix[is_roman]\n            ints <- as.integer(utils:::.roman2numeric(gsuffix))\n            makeAndAssignProvIds(sgidx[is_roman], ints=ints)\n        }\n        ## Group (b).\n        if (any(is_nb_with_suffix)) {\n            gsuffix <- sgsuffix[is_nb_with_suffix]\n            isnb_idx <- which(is_nb[is_nb_with_suffix])\n            isnbA_idx <- which(is_nbA[is_nb_with_suffix])\n            isnba_idx <- which(is_nba[is_nb_with_suffix])\n            isnbB_idx <- which(is_nbB[is_nb_with_suffix])\n            isnbb_idx <- which(is_nbb[is_nb_with_suffix])\n            isnbL_idx <- which(is_nbL[is_nb_with_suffix])\n            isnbR_idx <- which(is_nbR[is_nb_with_suffix])\n            nb_ints <- as.integer(gsuffix[isnb_idx])\n            gsuffixA <- gsuffix[isnbA_idx]\n            nbA_ints <- as.integer(substr(gsuffixA,\n                                          start=1L,\n                                          stop=nchar(gsuffixA)-1L))\n            gsuffixa <- gsuffix[isnba_idx]\n            nba_ints <- as.integer(substr(gsuffixa,\n                                          start=1L,\n                                          stop=nchar(gsuffixa)-1L))\n            gsuffixB <- gsuffix[isnbB_idx]\n            nbB_ints <- as.integer(substr(gsuffixB,\n                                          start=1L,\n                                          stop=nchar(gsuffixB)-1L))\n            gsuffixb <- gsuffix[isnbb_idx]\n            nbb_ints <- as.integer(substr(gsuffixb,\n                                          start=1L,\n                                          stop=nchar(gsuffixb)-1L))\n            gsuffixL <- gsuffix[isnbL_idx]\n            nbL_ints <- as.integer(substr(gsuffixL,\n                                          start=1L,\n                                          stop=nchar(gsuffixL)-1L))\n            gsuffixR <- gsuffix[isnbR_idx]\n            nbR_ints <- as.integer(substr(gsuffixR,\n                                          start=1L,\n                                          stop=nchar(gsuffixR)-1L))\n            ints <- integer(length(gsuffix))\n            ints[isnb_idx] <- 7L * nb_ints\n            ints[isnbA_idx] <- 7L * nbA_ints + 1L\n            ints[isnba_idx] <- 7L * nba_ints + 2L\n            ints[isnbB_idx] <- 7L * nbB_ints + 3L\n            ints[isnbb_idx] <- 7L * nbb_ints + 4L\n            ints[isnbL_idx] <- 7L * nbL_ints + 5L\n            ints[isnbR_idx] <- 7L * nbR_ints + 6L\n            makeAndAssignProvIds(sgidx[is_nb_with_suffix], ints=ints)\n        }\n        ## Group (c).\n        if (any(is_W))\n            makeAndAssignProvIds(sgidx[is_W])\n        ## Group (d).\n        if (any(is_Z))\n            makeAndAssignProvIds(sgidx[is_Z])\n        ## Group (e).\n        if (any(is_seXual))\n            makeAndAssignProvIds(sgidx[is_seXual])\n        ## Group (f).\n        if (any(is_Y))\n            makeAndAssignProvIds(sgidx[is_Y])\n        ## Group (g).\n        if (any(is_U))\n            makeAndAssignProvIds(sgidx[is_U])\n        ## Group (h).\n        if (any(is_M))\n            makeAndAssignProvIds(sgidx[is_M])\n        ## Group (i).\n        if (any(is_MT))\n            makeAndAssignProvIds(sgidx[is_MT])\n        ## Group (j).\n        if (any(is_nbxxx)) {\n            gsuffix <- sgsuffix[is_nbxxx]\n            ints1 <- as.integer(.getNbPart(gsuffix))\n            ints2 <- as.integer(factor(.getPostNbPart(gsuffix)))\n            ints <- (max(ints2) + 1L) * ints1 + ints2\n            makeAndAssignProvIds(sgidx[is_nbxxx], ints=ints)\n        }\n        ## Group (k).\n        if (any(is_Wxxx)) {\n            gsuffix <- sgsuffix[is_Wxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 1L)))\n            makeAndAssignProvIds(sgidx[is_Wxxx], ints=ints)\n        }\n        ## Group (l).\n        if (any(is_Zxxx)) {\n            gsuffix <- sgsuffix[is_Zxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 1L)))\n            makeAndAssignProvIds(sgidx[is_Zxxx], ints=ints)\n        }\n        ## Group (m).\n        if (any(is_Xxxx)) {\n            gsuffix <- sgsuffix[is_Xxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 1L)))\n            makeAndAssignProvIds(sgidx[is_Xxxx], ints=ints)\n        }\n        ## Group (n).\n        if (any(is_Yxxx)) {\n            gsuffix <- sgsuffix[is_Yxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 1L)))\n            makeAndAssignProvIds(sgidx[is_Yxxx], ints=ints)\n        }\n        ## Group (o).\n        if (any(is_Uxxx)) {\n            gsuffix <- sgsuffix[is_Uxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 1L)))\n            makeAndAssignProvIds(sgidx[is_Uxxx], ints=ints)\n        }\n        ## Group (p).\n        if (any(is_Mxxx)) {\n            gsuffix <- sgsuffix[is_Mxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 1L)))\n            makeAndAssignProvIds(sgidx[is_Mxxx], ints=ints)\n        }\n        ## Group (q).\n        if (any(is_MTxxx)) {\n            gsuffix <- sgsuffix[is_MTxxx]\n            ints <- as.integer(factor(.dropPrefix(gsuffix, 2L)))\n            makeAndAssignProvIds(sgidx[is_MTxxx], ints=ints)\n        }\n        ## Group (r).\n        if (any(is_xxx)) {\n            gsuffix <- sgsuffix[is_xxx]\n            ints <- as.integer(factor(gsuffix))\n            makeAndAssignProvIds(sgidx[is_xxx], ints=ints)\n        }\n    }\n    \n    ## Longest prefixes first.\n    assignProvIdsForSuperGroup(seqlevels, \"CHR\")\n    assignProvIdsForSuperGroup(seqlevels, \"chr\")\n    assignProvIdsForSuperGroup(seqlevels, \"CH\")\n    assignProvIdsForSuperGroup(seqlevels, \"ch\")\n    assignProvIdsForSuperGroup(seqlevels, \"\")\n    \n    ## Seqlevel ids.\n    seqlevel_ids <- integer(length(prov_ids))\n    oo <- order(prov_ids)\n    seqlevel_ids[oo] <- seq_len(length(seqlevel_ids))\n    \n    ## Seqname ids.\n    seqlevel_ids[as.integer(seqnames)]\n}\n\norderSeqlevels <- \n  function(seqnames, X.is.sexchrom=NA)\n  {\n    if (missing(seqnames))\n      seqnames <- character()\n    order(rankSeqlevels(seqnames, X.is.sexchrom))\n  }\n\n",
        "seqinfo.R": "### =========================================================================\n### The seqinfo() (and releated) generic getters and setters\n### -------------------------------------------------------------------------\n\n\nnormarg_new2old <- function(new2old, new_N, old_N,\n                            new_what=\"the supplied 'seqinfo'\",\n                            old_what=\"the current 'seqinfo'\")\n{\n    if (!is.numeric(new2old))\n        stop(wmsg(\"'new2old' must be NULL or an integer vector\"))\n    if (length(new2old) != new_N)\n        stop(wmsg(\"when not NULL, 'new2old' must \",\n                  \"have the length of \", new_what))\n    if (!is.integer(new2old))\n        new2old <- as.integer(new2old)\n    min_new2old <- suppressWarnings(min(new2old, na.rm=TRUE))\n    if (min_new2old != Inf) {\n        if (min_new2old < 1L)\n            stop(wmsg(\"when not NULL, 'new2old' must \",\n                      \"contain positive values or NAs\"))\n        if (max(new2old, na.rm=TRUE) > old_N)\n            stop(wmsg(\"'new2old' cannot contain values \",\n                      \"greater than the length of \", old_what))\n    }\n    if (any(duplicated(new2old) & !is.na(new2old)))\n        stop(wmsg(\"non-NA values in 'new2old' must be unique\"))\n    new2old\n}\n\n### Validate and reverse the 'new2old' mapping.\n.reverse_new2old <- function(new2old, new_N, old_N,\n                             new_what=\"the supplied 'seqinfo'\",\n                             old_what=\"the current 'seqinfo'\")\n{\n    if (is.null(new2old))\n        return(NULL)\n    new2old <- normarg_new2old(new2old, new_N, old_N, new_what, old_what)\n    S4Vectors:::reverseIntegerInjection(new2old, old_N)\n}\n\n### The dangling seqlevels in 'x' are those seqlevels that the user wants to\n### drop but are in use.\ngetDanglingSeqlevels <- function(x, new2old=NULL,\n                            pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n                            new_seqlevels)\n{\n    pruning.mode <- match.arg(pruning.mode)\n    if (!is.character(new_seqlevels) || any(is.na(new_seqlevels)))\n        stop(wmsg(\"the supplied 'seqlevels' must be a character vector \",\n                  \"with no NAs\"))\n    if (is.null(new2old))\n        return(character(0))\n    new_N <- length(new_seqlevels)\n    old_seqlevels <- seqlevels(x)\n    old_N <- length(old_seqlevels)\n    old2new <- .reverse_new2old(new2old, new_N, old_N,\n                                new_what=\"the supplied 'seqlevels'\",\n                                old_what=\"the current 'seqlevels'\")\n    seqlevels_to_drop <- old_seqlevels[is.na(old2new)]\n    seqlevels_in_use <- seqlevelsInUse(x)\n    dangling_seqlevels <- intersect(seqlevels_to_drop, seqlevels_in_use)\n    if (length(dangling_seqlevels) != 0L && pruning.mode == \"error\")\n        stop(wmsg(\"The following seqlevels are to be dropped but are \",\n                  \"currently in use (i.e. have ranges on them): \",\n                  paste(dangling_seqlevels, collapse = \", \"), \".\\n\",\n                  \"Please use the 'pruning.mode' argument to control how \",\n                  \"to prune 'x', that is, how to remove the ranges in 'x' \",\n                  \"that are on these sequences. For example, do something \",\n                  \"like:\"),\n             \"\\n    seqlevels(x, pruning.mode=\\\"coarse\\\") <- new_seqlevels\",\n             \"\\n  or:\",\n             \"\\n    keepSeqlevels(x, new_seqlevels, pruning.mode=\\\"coarse\\\")\",\n             \"\\n  See ?seqinfo for a description of the pruning modes.\")\n    dangling_seqlevels\n}\n\n### Compute the new seqnames resulting from new seqlevels.\n### Assumes that 'seqnames(x)' is a 'factor' Rle (which is true if 'x' is a\n### GRanges or GAlignments object, but not if it's a GRangesList object),\n### and returns a 'factor' Rle of the same length (and same runLength vector).\n### Always used in the context of the seqinfo() setter i.e. 'new_seqlevels'\n### comes from 'seqlevels(value)' where 'value' is the supplied Seqinfo object.\nmakeNewSeqnames <- function(x, new2old=NULL, new_seqlevels)\n{\n    ## Should never happen.\n    stopifnot(is.character(new_seqlevels), all(!is.na(new_seqlevels)))\n    new_N <- length(new_seqlevels)\n    old_N <- length(seqlevels(x))\n    x_seqnames <- seqnames(x)\n    if (!is.null(new2old)) {\n        old2new <- .reverse_new2old(new2old, new_N, old_N,\n                                    new_what=\"the supplied Seqinfo object\",\n                                    old_what=\"seqinfo(x)\")\n        tmp <- runValue(x_seqnames)\n        levels(tmp) <- new_seqlevels[old2new]\n        runValue(x_seqnames) <- factor(as.character(tmp), levels=new_seqlevels)\n        return(x_seqnames)\n    }\n    if (new_N >= old_N &&\n        identical(new_seqlevels[seq_len(old_N)], seqlevels(x)))\n    {\n        levels(x_seqnames) <- new_seqlevels\n        return(x_seqnames)\n    }\n    SEQLEVELS_ARE_NOT_THE_SAME <- c(\n        \"The seqlevels in the supplied Seqinfo object \",\n        \"are not the same as the seqlevels in 'x'. \"\n    )\n    if (length(intersect(seqlevels(x), new_seqlevels)) == 0L)\n        stop(wmsg(SEQLEVELS_ARE_NOT_THE_SAME,\n                  \"Please use the 'new2old' argument to specify the \",\n                  \"mapping between the formers and the latters.\"))\n    if (setequal(seqlevels(x), new_seqlevels))\n        stop(wmsg(\"The seqlevels in the supplied Seqinfo object \",\n                  \"are not in the same order as the seqlevels in 'x'. \",\n                  \"Please reorder the seqlevels in 'x' with:\"),\n             \"\\n\\n\",\n             \"    seqlevels(x) <- seqlevels(new_seqinfo)\\n\\n  \",\n             wmsg(\"before calling the 'seqinfo()' setter.\"),\n             \"\\n  \",\n             wmsg(\"For any more complicated mapping between the new \",\n                  \"and old seqlevels (e.g. for a mapping that will \",\n                  \"result in the renaming of some seqlevels in 'x'), \",\n                  \"please use the 'new2old' argument.\"))\n    if (all(seqlevels(x) %in% new_seqlevels))\n        stop(wmsg(SEQLEVELS_ARE_NOT_THE_SAME,\n                  \"To map them to the seqlevels of the same name in 'x', \",\n                  \"the easiest way is to propagate them to 'x' with:\"),\n             \"\\n\\n\",\n             \"    seqlevels(x) <- seqlevels(new_seqinfo)\\n\\n  \",\n             wmsg(\"before calling the 'seqinfo()' setter.\"),\n             \"\\n  \",\n             wmsg(\"For any more complicated mapping, please use \",\n                  \"the 'new2old' argument.\"))\n    stop(wmsg(SEQLEVELS_ARE_NOT_THE_SAME,\n              \"To map them to the seqlevels of the same name in 'x', \",\n              \"the easiest way is to propagate them to 'x' with:\"),\n         \"\\n\\n\",\n         \"    seqlevels(x) <- seqlevels(new_seqinfo)\\n\\n  \",\n         wmsg(\"before calling the 'seqinfo()' setter. \",\n\t      \"Note that you might need to specify a pruning mode \",\n              \"(via the 'pruning.mode' argument) if this operation \",\n              \"will drop seqlevels that are in use in 'x'.\"),\n         \"\\n  \",\n         wmsg(\"For any more complicated mapping, please use \",\n              \"the 'new2old' argument.\"))\n}\n\n### Return -3L for \"renaming\" mode, -2L for \"strict subsetting\" mode (no new\n### seqlevels added), -1L for \"extended subsetting\" mode (new seqlevels added),\n### or an integer vector containing the mapping from the new to the old\n### seqlevels for \"general\" mode (i.e. a combination of renaming and/or\n### subsetting). Note that the vector describing the \"general\" mode is\n### guaranteed to contain no negative values.\ngetSeqlevelsReplacementMode <- function(new_seqlevels, old_seqlevels)\n{\n    if (!is.character(new_seqlevels)\n     || anyNA(new_seqlevels)\n     || anyDuplicated(new_seqlevels))\n        stop(wmsg(\"the supplied 'seqlevels' must be a character vector \",\n                  \"with no NAs and no duplicates\"))\n    nsl_names <- names(new_seqlevels)\n    if (!is.null(nsl_names)) {\n        nonempty_names <- nsl_names[!(nsl_names %in% c(NA, \"\"))]\n        if (any(duplicated(nonempty_names)) ||\n            length(setdiff(nonempty_names, old_seqlevels)) != 0L)\n            stop(wmsg(\"the names of the supplied 'seqlevels' contain \",\n                      \"duplicates or invalid sequence levels\"))\n        return(match(nsl_names, old_seqlevels))\n    }\n    if (all(new_seqlevels %in% old_seqlevels))\n        return(-2L)\n    if (length(new_seqlevels) != length(old_seqlevels))\n        return(-1L)\n    is_renamed <- new_seqlevels != old_seqlevels\n    tmp <- intersect(new_seqlevels[is_renamed], old_seqlevels[is_renamed])\n    if (length(tmp) != 0L)\n        return(-1L)\n    return(-3L)\n}\n\n### Returns a logical vector of the same length as 'new_seqinfo' indicating\n### whether the length or circularity flag of the corresponding sequence\n### have changed. Assumes that the 'new2old' mapping is valid (see\n### .reverse_new2old() function above for what this means exactly).\n### NAs in 'new2old' are propagated to the result.\nsequenceGeometryHasChanged <- function(new_seqinfo, old_seqinfo, new2old=NULL)\n{\n    ans_len <- length(new_seqinfo)\n    if (is.null(new2old)) {\n        idx1 <- idx2 <- seq_len(ans_len)\n    } else {\n        idx1 <- which(!is.na(new2old))\n        idx2 <- new2old[idx1]\n    }\n    new_seqlengths <- seqlengths(new_seqinfo)[idx1]\n    old_seqlengths <- seqlengths(old_seqinfo)[idx2]\n    new_isCircular <- isCircular(new_seqinfo)[idx1]\n    old_isCircular <- isCircular(old_seqinfo)[idx2]\n    hasNotChanged <- function(x, y)\n        (is.na(x) & is.na(y)) | (is.na(x) == is.na(y) & x == y)\n    ans <- logical(ans_len)\n    ans[] <- NA\n    ans[idx1] <- !(hasNotChanged(new_seqlengths, old_seqlengths) &\n                   hasNotChanged(new_isCircular, old_isCircular))\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqinfo() getter and setter\n###\n\nsetGeneric(\"seqinfo\", function(x) standardGeneric(\"seqinfo\"))\n\nsetGeneric(\"seqinfo<-\", signature=\"x\",\n    function(x, new2old=NULL,\n             pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n             value)\n        standardGeneric(\"seqinfo<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqnames() getter and setter\n###\n\nsetGeneric(\"seqnames\", function(x) standardGeneric(\"seqnames\"))\n\nsetGeneric(\"seqnames<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"seqnames<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlevels() getter and setter\n###\n\nsetGeneric(\"seqlevels\", function(x) standardGeneric(\"seqlevels\"))\n\n### Default \"seqlevels\" method works on any object 'x' with a working\n### \"seqinfo\" method.\nsetMethod(\"seqlevels\", \"ANY\", function(x) seqlevels(seqinfo(x)))\n\nsetGeneric(\"seqlevels<-\", signature=\"x\",\n    function(x,\n             pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n             value)\n        standardGeneric(\"seqlevels<-\")\n)\n\n### Default \"seqlevels<-\" method works on any object 'x' with working\n### \"seqinfo\" and \"seqinfo<-\" methods.\nsetReplaceMethod(\"seqlevels\", \"ANY\",\n    function(x,\n             pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n             value)\n    {\n        ## Make the new Seqinfo object.\n        x_seqinfo <- seqinfo(x)\n        seqlevels(x_seqinfo) <- value\n        ## Map the new sequence levels to the old ones.\n        new2old <- getSeqlevelsReplacementMode(value, seqlevels(x))\n        if (identical(new2old, -3L)) {\n            ## \"renaming\" mode\n            new2old <- seq_along(value)\n        } else if (identical(new2old, -2L) || identical(new2old, -1L)) {\n            ## \"subsetting\" mode\n            new2old <- match(value, seqlevels(x))\n        }\n        ## Do the replacement.\n        seqinfo(x, new2old=new2old, pruning.mode=pruning.mode) <- x_seqinfo\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### sortSeqlevels()\n###\n\nsetGeneric(\"sortSeqlevels\", signature=\"x\",\n    function(x, X.is.sexchrom=NA) standardGeneric(\"sortSeqlevels\")\n)\n\nsetMethod(\"sortSeqlevels\", \"character\",\n    function(x, X.is.sexchrom=NA)\n    {\n        x[order(rankSeqlevels(x, X.is.sexchrom=X.is.sexchrom))]\n    }\n)\n\nsetMethod(\"sortSeqlevels\", \"ANY\",\n    function(x, X.is.sexchrom=NA)\n    {\n        seqlevels(x) <- sortSeqlevels(seqlevels(x),\n                                      X.is.sexchrom=X.is.sexchrom)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlevelsInUse() getter\n###\n\nsetGeneric(\"seqlevelsInUse\", function(x) standardGeneric(\"seqlevelsInUse\"))\n\n### Covers GenomicRanges, SummarizedExperiment, GAlignments, and any object\n### for which the seqnames are returned as a factor-Rle.\nsetMethod(\"seqlevelsInUse\", \"Vector\",\n    function(x)\n    {\n        f <- runValue(seqnames(x))\n        levels(f)[tabulate(f, nbins=nlevels(f)) != 0L]\n    }\n)\n\n### Covers GRangesList and GAlignmentsList objects.\nsetMethod(\"seqlevelsInUse\", \"CompressedList\",\n    function(x) seqlevelsInUse(x@unlistData)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlevels0() getter\n###\n### Currently applicable to TxDb objects only.\n###\n\nsetGeneric(\"seqlevels0\", function(x) standardGeneric(\"seqlevels0\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlengths() getter and setter\n###\n\nsetGeneric(\"seqlengths\", function(x) standardGeneric(\"seqlengths\"))\n\n### Default \"seqlengths\" method works on any object 'x' with a working\n### \"seqinfo\" method.\nsetMethod(\"seqlengths\", \"ANY\", function(x) seqlengths(seqinfo(x)))\n\nsetGeneric(\"seqlengths<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"seqlengths<-\")\n)\n\n### Default \"seqlengths<-\" method works on any object 'x' with working\n### \"seqinfo\" and \"seqinfo<-\" methods.\nsetReplaceMethod(\"seqlengths\", \"ANY\",\n    function(x, value)\n    {\n        seqlengths(seqinfo(x)) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isCircular() getter and setter\n###\n\nsetGeneric(\"isCircular\", function(x) standardGeneric(\"isCircular\"))\n\n### Default \"isCircular\" method works on any object 'x' with a working\n### \"seqinfo\" method.\nsetMethod(\"isCircular\", \"ANY\", function(x) isCircular(seqinfo(x)))\n\nsetGeneric(\"isCircular<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"isCircular<-\")\n)\n\n### Default \"isCircular<-\" method works on any object 'x' with working\n### \"seqinfo\" and \"seqinfo<-\" methods.\nsetReplaceMethod(\"isCircular\", \"ANY\",\n    function(x, value)\n    {\n        isCircular(seqinfo(x)) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### genome() getter and setter\n###\n\nsetGeneric(\"genome\", function(x) standardGeneric(\"genome\"))\n\n### Default \"genome\" method works on any object 'x' with a working\n### \"seqinfo\" method.\nsetMethod(\"genome\", \"ANY\", function(x) genome(seqinfo(x)))\n\nsetGeneric(\"genome<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"genome<-\")\n)\n\n### Default \"genome<-\" method works on any object 'x' with working\n### \"seqinfo\" and \"seqinfo<-\" methods.\nsetReplaceMethod(\"genome\", \"ANY\",\n    function(x, value)\n    {\n        genome(seqinfo(x)) <- value\n        x\n    }\n)\n\n",
        "seqlevels-wrappers.R": "### =========================================================================\n### Convenience wrappers to the seqlevels() getter and setter\n### -------------------------------------------------------------------------\n\nkeepSeqlevels <- function(x, value,\n                          pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"))\n{\n    if (is(x, \"BSgenome\"))\n        stop(\"seqlevels cannot be dropped from a BSgenome object\")\n    if (!is.null(names(value)))\n        warning(\"the names on the vector of supplied seqlevels were ignored\")\n    value <- as.character(value)\n    is_invalid <- !(value %in% seqlevels(x))\n    if (any(is_invalid))\n        stop(wmsg(\"invalid seqlevels: \",\n                  paste(unique(value[is_invalid]), collapse=\", \")))\n    seqlevels(x, pruning.mode=pruning.mode) <- value\n    x\n}\n\ndropSeqlevels <- function(x, value,\n                          pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"))\n{\n    if (is(x, \"BSgenome\"))\n        stop(\"seqlevels cannot be dropped from a BSgenome object\")\n    if (!is.null(names(value)))\n        warning(\"the names on the vector of supplied seqlevels were ignored\")\n    keep_seqlevels <- setdiff(seqlevels(x), as.character(value))\n    seqlevels(x, pruning.mode=pruning.mode) <- keep_seqlevels\n    x\n}\n\nrenameSeqlevels <- function(x, value)\n{\n    nms <- names(value)\n    ## unnamed\n    if (is.null(nms)) {\n        if (length(value) != length(seqlevels(x)))\n            stop(\"unnamed 'value' must be the same length as seqlevels(x)\")\n        names(value) <- seqlevels(x)\n    ## named\n    } else {\n        if (any(nomatch <- !nms %in% seqlevels(x)))\n            warning(\"invalid seqlevels \", \n                    paste(sQuote(nms[nomatch]), collapse=\", \"), \" ignored\")\n        if (length(value) != length(seqlevels(x))) {\n            level <- seqlevels(x)\n            idx <- match(level, nms)\n            level[!is.na(idx)] <- value[na.omit(idx)]\n            value <- level\n        } \n    } \n    seqlevels(x) <- value \n    x \n}\n\n## Currently applies to TxDb only.\nrestoreSeqlevels <- function(x)\n{\n    seqlevels(x) <- seqlevels0(x) \n    x\n}\n\nstandardChromosomes <- function(x, species=NULL)\n{\n    ori_seqlevels <- seqlevels(x)\n    if(!length(ori_seqlevels))\n        return(character())\n\n    ## guess at style\n    guess <- .guessSpeciesStyle(ori_seqlevels)\n    if (!any(is.na(guess)))\n        style <- unique(guess$style)\n    else\n        return(character())\n    if (length(style) > 1)\n        style <- style[1]\n\n    standard <- character()\n    if (is.null(species)) {\n        possible <- genomeStyles()\n        ## extractSeqlevels will fail if no style-species match; \n        ## must check style match first\n        standard <- unique(unlist(\n            Map(function(name, data) {\n                if (style %in% colnames(data))\n                    intersect(ori_seqlevels, extractSeqlevels(name, style))\n            }, name=names(possible), data=possible)))\n        ## preserve order\n        standard <- ori_seqlevels[ori_seqlevels %in% standard]\n        if (!length(standard))\n            stop(paste0(\"cannot determine standard chromosomes; \",\n                        \"try specifying 'species' argument\"))\n    } else {\n        standard <- extractSeqlevels(species, style)\n        standard <- intersect(ori_seqlevels,standard)\n    }\n    standard \n}\n\nkeepStandardChromosomes <-\n    function(x, species=NULL, pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"))\n{\n    standard <- standardChromosomes(x, species)\n    keepSeqlevels(x, standard, pruning.mode=pruning.mode)\n}\n",
        "seqlevelsStyle.R": "### =========================================================================\n### seqlevelsStyle() and related low-level utilities\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .set_seqlevelsStyle_from_seqlevels_and_genome()\n###\n### This is the workhorse behing the seqlevelsStyle() setter for Seqinfo\n### objects.\n###\n\n### 'genome' must be a single string.\n### Return \"NCBI\", \"UCSC\", or a character NA.\n.is_NCBI_assembly_or_UCSC_genome <- function(genome)\n{\n    NCBI_assemblies <- registered_NCBI_assemblies()\n    if (genome %in% NCBI_assemblies[ , \"assembly\"])\n        return(\"NCBI\")\n    UCSC_genomes <- registered_UCSC_genomes()\n    if (genome %in% UCSC_genomes[ , \"genome\"])\n        return(\"UCSC\")\n    ## We try getChromInfoFromUCSC(). It will succeed if genome is a valid\n    ## (unregistered) UCSC genome, and will fail otherwise.\n    ## Note that getChromInfoFromUCSC() uses an in-memory caching mechanism\n    ## so will be fast and won't need internet access if the chromosome\n    ## information for 'genome' is already in the cache. If 'genome' is not\n    ## in getChromInfoFromUCSC's cache, getChromInfoFromUCSC() will try to\n    ## fetch the chromosome sizes from UCSC with fetch_chrom_sizes_from_UCSC()\n    ## and will fail if 'genome' is an unknown UCSC genome. This is the only\n    ## situation where internet is accessed.\n    chrominfo <- try(getChromInfoFromUCSC(genome), silent=TRUE)\n    if (!inherits(chrominfo, \"try-error\"))\n        return(\"UCSC\")\n    NA_character_\n}\n\n### A RefSeq accession begins with 2 or 3 upper case letters. Note that\n### the 3-letter prefix is rare e.g. chromosome 2 in NCBI33 (hg15) has\n### accession GPC_000001061.1.\n.is_RefSeq_accession <- function(seqnames)\n    grepl(\"^[A-Z][A-Z][A-Z]?_[0-9]+\\\\.[0-9]+$\", seqnames)\n\n.get_seqlevelsStyle_for_NCBI_seqlevels <- function(seqlevels)\n{\n    is_refseq <- .is_RefSeq_accession(seqlevels)\n    if (all(is_refseq))\n        return(\"RefSeq\")\n    if (any(is_refseq))\n        return(c(\"RefSeq\", \"NCBI\"))\n    \"NCBI\"\n}\n\n### Will map GRCh38 and any GRCh38 patch level to hg38. This will allow\n### us to switch the style of stuff like SNPlocs.Hsapiens.dbSNP144.GRCh38\n### (based on GRCh38.p2) to UCSC.\n.map_NCBI_assembly_to_UCSC_genome <- function(assembly)\n{\n    stopifnot(isSingleString(assembly))\n    UCSC_genomes <- registered_UCSC_genomes()\n    NCBI_assemblies <- UCSC_genomes[ , \"NCBI_assembly\"]\n    idx <- match(assembly, NCBI_assemblies)\n    if (!is.na(idx))\n        return(UCSC_genomes[idx, \"genome\"])\n    ## Remove patch level suffix (e.g. \".p2\")\n    base_assembly <- sub(\"^(.*)(\\\\.p[0-9]+)$\", \"\\\\1\", assembly)\n    NCBI_base_assemblies <- sub(\"^(.*)(\\\\.p[0-9]+)$\", \"\\\\1\", NCBI_assemblies)\n    idx <- match(base_assembly, NCBI_base_assemblies)\n    UCSC_genomes[idx, \"genome\"]\n}\n\n### Will map hg38 to GRCh38.p14 because that's what hg38 is officially based\n### on at the moment (as of Jan 31, 2023, used to be GRCh38.p13 before that).\n### See https://genome.ucsc.edu/cgi-bin/hgGateway?db=hg38\n### Note that this is not written in stone and the UCSC folks might\n### change this at any time in the future.\n### IMPORTANT: A round trip thru .map_NCBI_assembly_to_UCSC_genome() and\n### .map_UCSC_genome_to_NCBI_assembly() is in general a no-op **except**\n### for NCBI assemblies with patch levels! For example the round trip will\n### map any GRCh38 patch level to GRCh38.p14.\n.map_UCSC_genome_to_NCBI_assembly <- function(genome)\n{\n    stopifnot(isSingleString(genome))\n    UCSC_genomes <- registered_UCSC_genomes()\n    idx <- match(genome, UCSC_genomes[ , \"genome\"])\n    UCSC_genomes[idx, \"NCBI_assembly\"]\n}\n\n.map_NCBI_or_RefSeq_seqlevels_to_UCSC <- function(seqlevels, new_genome)\n{\n    chrominfo <- getChromInfoFromUCSC(new_genome, map.NCBI=TRUE)\n    UCSC_seqlevels <- chrominfo[ , \"chrom\"]\n    SequenceName <- chrominfo[ , \"NCBI.SequenceName\"]\n    RefSeqAccn <- chrominfo[ , \"NCBI.RefSeqAccn\"]\n    m <- match(seqlevels, SequenceName)\n    m2 <- match(seqlevels, RefSeqAccn)\n    m[is.na(m)] <- m2[is.na(m)]\n    UCSC_seqlevels[m]\n}\n\n### Returns the new seqlevels in a named character vector parallel\n### to 'seqlevels'. The returned vector will contain NA's for input\n### seqlevels that could not be mapped, and the names on those elements\n### will be set to \"\". The names on the non-NA elements (mapped seqlevels)\n### will be set to the NCBI assembly associated with 'genome'.\n.map_UCSC_seqlevels_to_NCBI_or_RefSeq <- function(seqlevels, genome, new_style)\n{\n    chrominfo <- getChromInfoFromUCSC(genome, map.NCBI=TRUE)\n    UCSC_seqlevels <- chrominfo[ , \"chrom\"]\n    if (new_style == \"NCBI\") {\n        NCBI_seqlevels <- chrominfo[ , \"NCBI.SequenceName\"]\n    } else {\n        NCBI_seqlevels <- chrominfo[ , \"NCBI.RefSeqAccn\"]\n    }\n    m <- match(seqlevels, UCSC_seqlevels)\n    new_seqlevels <- NCBI_seqlevels[m]\n\n    ## Set names (new genome) on 'new_seqlevels'.\n    new_genome <- character(length(new_seqlevels))\n    NCBI_assembly_info <- attributes(chrominfo)$NCBI_assembly_info\n    new_genome[!is.na(new_seqlevels)] <- NCBI_assembly_info$assembly\n    setNames(new_seqlevels, new_genome)\n}\n\n### UGLY HACK! We need to special-case hg38 because it contains 2 sequences\n### that do NOT belong to GRCh38.p14. But they can be found in GRCh38.p13!\n.hg38_FOREIGN_ASSEMBLY <- \"GRCh38.p13\"\n.hg38_FOREIGN_MAPPINGS <- c(chr11_KQ759759v1_fix=\"KQ759759.1\",\n                            chr22_KQ759762v1_fix=\"KQ759762.1\")\n\n.map_NCBI_or_RefSeq_seqlevels_to_hg38 <- function(seqlevels)\n{\n    new_seqlevels <- .map_NCBI_or_RefSeq_seqlevels_to_UCSC(seqlevels, \"hg38\")\n\n    ## Take care of the foreign sequences. Note that they are not\n    ## necessarily present in 'seqlevels'.\n    chrominfo <- getChromInfoFromNCBI(.hg38_FOREIGN_ASSEMBLY)\n    foreign_idx <- match(.hg38_FOREIGN_MAPPINGS, chrominfo[ , \"GenBankAccn\"])\n    stopifnot(!anyNA(foreign_idx))  # sanity check\n    foreign_SequenceName <- chrominfo[foreign_idx, \"SequenceName\"]\n    foreign_RefSeqAccn <- chrominfo[foreign_idx, \"RefSeqAccn\"]\n    m <- match(seqlevels, foreign_SequenceName)\n    m2 <- match(seqlevels, foreign_RefSeqAccn)\n    m[is.na(m)] <- m2[is.na(m)]\n    new_seqlevels2 <- names(.hg38_FOREIGN_MAPPINGS)[m]\n\n    ## Merge 'new_seqlevels2' into 'new_seqlevels'.\n    idx2 <- which(!is.na(new_seqlevels2))\n    stopifnot(all(is.na(new_seqlevels[idx2])))  # sanity check\n    new_seqlevels[idx2] <- new_seqlevels2[idx2]\n    new_seqlevels\n}\n\n.map_hg38_seqlevels_to_NCBI_or_RefSeq <- function(seqlevels, new_style)\n{\n    new_seqlevels <- .map_UCSC_seqlevels_to_NCBI_or_RefSeq(\n                                         seqlevels, \"hg38\", new_style)\n\n    ## Take care of the foreign sequences. Note that they are not\n    ## necessarily present in 'seqlevels'.\n    chrominfo <- getChromInfoFromNCBI(.hg38_FOREIGN_ASSEMBLY)\n    foreign_idx <- match(.hg38_FOREIGN_MAPPINGS, chrominfo[ , \"GenBankAccn\"])\n    stopifnot(!anyNA(foreign_idx))  # sanity check\n    m <- match(seqlevels, names(.hg38_FOREIGN_MAPPINGS))\n    if (new_style == \"NCBI\") {\n        NCBI_seqlevels <- chrominfo[ , \"SequenceName\"]\n    } else {\n        NCBI_seqlevels <- chrominfo[ , \"RefSeqAccn\"]\n    }\n    new_seqlevels2 <- NCBI_seqlevels[foreign_idx[m]]\n\n    ## Merge 'new_seqlevels2' into 'new_seqlevels'.\n    idx2 <- which(!is.na(new_seqlevels2))\n    stopifnot(all(is.na(new_seqlevels[idx2])))  # sanity check\n    new_seqlevels[idx2] <- new_seqlevels2[idx2]\n    names(new_seqlevels)[idx2] <- .hg38_FOREIGN_ASSEMBLY\n    new_seqlevels\n}\n\n### 'genome' must be a single string or NA.\n### Return a 2-column DataFrame with 1 row per element in 'seqlevels'.\n### The columns contain the (possibly) modified seqlevels and genome\n### associated with each seqname.\n.set_seqlevelsStyle_from_seqlevels_and_genome <-\n    function(seqlevels, genome, new_style)\n{\n    ans <- DataFrame(seqlevels=seqlevels, genome=genome)\n    if (is.na(genome) || !(new_style %in% c(\"NCBI\", \"RefSeq\", \"UCSC\"))) {\n        ## Switch style based on seqlevels only. 'genome' is untouched.\n        seqlevelsStyle(ans[ , \"seqlevels\"]) <- new_style\n        return(ans)\n    }\n    old_style <- .is_NCBI_assembly_or_UCSC_genome(genome)\n    if (is.na(old_style)) {\n        ## Switch style based on seqlevels only. 'genome' is untouched.\n        seqlevelsStyle(ans[ , \"seqlevels\"]) <- new_style\n        return(ans)\n    }\n    if (old_style == \"NCBI\")\n        old_style <- .get_seqlevelsStyle_for_NCBI_seqlevels(seqlevels)\n    ## 'old_style' can be c(\"RefSeq\", \"NCBI\") so we cannot use == here.\n    if (identical(new_style, old_style))\n        return(ans)  # no-op\n\n    ## The user wants to switch between styles NCBI, RefSeq, and UCSC.\n    ## We want to make sure that this switch is **reversible** i.e. that\n    ## switching back to the original style restores the original seqlevels\n    ## and genome. Note that this is not always possible e.g. switching stuff\n    ## based on GRCh38.p2 to UCSC then back to NCBI or RefSeq will set the\n    ## genome to GRCh38.p14. See .map_UCSC_genome_to_NCBI_assembly() above\n    ## in this file.\n    if (new_style == \"UCSC\") {\n        ## 'old_style' is \"NCBI\" or \"RefSeq\" or c(\"RefSeq\", \"NCBI\") i.e. the            ## user wants to switch from NCBI or RefSeq to UCSC style.\n        new_genome <- .map_NCBI_assembly_to_UCSC_genome(genome)\n        if (is.na(new_genome)) {\n            ## 'genome' is an NCBI assembly that this not linked to a UCSC\n            ## genome. Note that we could still switch the style based on\n            ## seqlevels only. However, since we cannot also switch the genome,\n            ## this would result in a non-reversible operation because trying\n            ## to switch back to NCBI would then be a no-op.\n            warning(wmsg(\"cannot switch \", genome, \"'s seqlevels \",\n                         \"to \", new_style, \" style\"))\n            return(ans)\n        }\n        ## UGLY HACK!\n        if (new_genome == \"hg38\") {\n            new_seqlevels <- .map_NCBI_or_RefSeq_seqlevels_to_hg38(seqlevels)\n        } else {\n            new_seqlevels <- .map_NCBI_or_RefSeq_seqlevels_to_UCSC(\n                                                 seqlevels, new_genome)\n        }\n    } else if (identical(old_style, \"UCSC\")) {\n        ## 'new_style' is \"NCBI\" or \"RefSeq\" i.e. the user wants to switch\n        ## from UCSC to NCBI or RefSeq style.\n        new_genome <- .map_UCSC_genome_to_NCBI_assembly(genome)\n        if (is.na(new_genome)) {\n            ## 'genome' is an UCSC genome that this not based on an NCBI\n            ## assembly. Note that we could still switch the style based on\n            ## seqlevels only. However, since we cannot also switch the genome,\n            ## this would result in a non-reversible operation because trying\n            ## to switch back to UCSC would then be a no-op.\n            warning(wmsg(\"cannot switch \", genome, \"'s seqlevels \",\n                         \"from \", old_style, \" to \", new_style, \" style\"))\n            return(ans)\n        }\n        ## UGLY HACK!\n        if (genome == \"hg38\") {\n            new_seqlevels <- .map_hg38_seqlevels_to_NCBI_or_RefSeq(\n                                                 seqlevels, new_style)\n        } else {\n            new_seqlevels <- .map_UCSC_seqlevels_to_NCBI_or_RefSeq(\n                                                 seqlevels, genome, new_style)\n        }\n        new_genome <- names(new_seqlevels)[!is.na(new_seqlevels)]\n    } else {\n        ## The user wants to switch from NCBI to RefSeq style or vice-versa.\n        ## This does NOT touch the genome.\n        chrominfo <- getChromInfoFromNCBI(genome)\n        SequenceName <- chrominfo[ , \"SequenceName\"]\n        RefSeqAccn <- chrominfo[ , \"RefSeqAccn\"]\n        if (new_style == \"RefSeq\") {\n            ## 'old_style' is \"NCBI\" or c(\"RefSeq\", \"NCBI\").\n            m <- match(seqlevels, SequenceName)\n            new_seqlevels <- RefSeqAccn[m]\n        } else {\n            ## 'old_style' is \"RefSeq\" or c(\"RefSeq\", \"NCBI\")\n            ## and 'new_style' is \"NCBI\".\n            m <- match(seqlevels, RefSeqAccn)\n            new_seqlevels <- SequenceName[m]\n        }\n        new_genome <- genome\n    }\n    ## Switch seqlevels **and** genome.\n    replace_idx <- which(!is.na(new_seqlevels))\n    if (length(replace_idx) == 0L) {\n        ## Can happen if the current seqlevels don't match the current genome\n        ## e.g.:\n        ##   gr <- GRanges(\"chrA:1-10\")\n        ##   genome(gr) <- \"GRCh38\"\n        ##   seqlevelsStyle(gr) <- \"RefSeq\"\n        warning(wmsg(\"cannot switch \", genome, \"'s seqlevels \",\n                     \"from \", paste(old_style, collapse=\"/\"), \" \",\n                     \"to \", new_style, \" style\"))\n        return(ans)\n    }\n    if (length(replace_idx) < length(new_seqlevels))\n        warning(wmsg(\"cannot switch some \", genome, \"'s seqlevels \",\n                     \"from \", paste(old_style, collapse=\"/\"), \" \",\n                     \"to \", new_style, \" style\"))\n    ans[replace_idx, \"seqlevels\"] <- new_seqlevels[replace_idx]\n    ans[replace_idx, \"genome\"] <- new_genome\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlevelsStyle() generic getter and setter\n###\n\nsetGeneric(\"seqlevelsStyle\",\n    function(x) standardGeneric(\"seqlevelsStyle\")\n)\n\nsetGeneric(\"seqlevelsStyle<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"seqlevelsStyle<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlevelsStyle() getter and setter methods for Seqinfo objects\n###\n\n.get_genome_as_factor <- function(x)\n{\n    ## genome(x) can be a mix of several genomes (including NAs).\n    x_genome <- unname(genome(x))\n    factor(x_genome, levels=unique(x_genome),\n           exclude=character(0))  # keep NA in levels\n}\n\n### 'genome' must be a single string or NA.\n### Tries to get the style first based on 'genome', then based on 'seqlevels'.\n### Can return more than 1 style.\n.get_seqlevelsStyle_from_seqlevels_and_genome <- function(seqlevels, genome)\n{\n    if (is.na(genome))\n        return(seqlevelsStyle(seqlevels))  # can return more than 1 style\n    ans <- .is_NCBI_assembly_or_UCSC_genome(genome)\n    if (is.na(ans))\n        return(seqlevelsStyle(seqlevels))  # can return more than 1 style\n    if (ans == \"NCBI\")\n        ans <- .get_seqlevelsStyle_for_NCBI_seqlevels(seqlevels)\n    ans\n}\n\n.normarg_seqlevelsStyle <- function(seqlevelsStyle)\n{\n    if (!(is.character(seqlevelsStyle) && length(seqlevelsStyle) >= 1L))\n        stop(wmsg(\"the supplied seqlevels style must be a single string\"))\n    if (length(seqlevelsStyle) > 1L) {\n        warning(wmsg(\"more than one seqlevels style supplied, \",\n                     \"using the 1st one only\"))\n        seqlevelsStyle <- seqlevelsStyle[[1L]]\n    }\n    if (is.na(seqlevelsStyle))\n        stop(wmsg(\"the supplied seqlevels style cannot be NA\"))\n    seqlevelsStyle\n}\n\n.get_Seqinfo_seqlevelsStyle <- function(x)\n{\n    x_genome <- .get_genome_as_factor(x)\n    if (length(x_genome) == 0L)\n        stop(wmsg(\"no seqlevels present in this object\"))\n    genome2seqlevels <- split(seqlevels(x), x_genome)\n    genome2style <- mapply(.get_seqlevelsStyle_from_seqlevels_and_genome,\n                           genome2seqlevels, names(genome2seqlevels),\n                           SIMPLIFY=FALSE, USE.NAMES=FALSE)\n    unique(unlist(genome2style, use.names=FALSE))\n}\n\n.set_Seqinfo_seqlevelsStyle <- function(x, value)\n{\n    value <- .normarg_seqlevelsStyle(value)\n    x_genome <- .get_genome_as_factor(x)\n    if (length(x_genome) == 0L)\n        return(x)\n    genome2seqlevels <- split(seqlevels(x), x_genome)\n    genome2DF <- mapply(.set_seqlevelsStyle_from_seqlevels_and_genome,\n                        genome2seqlevels, names(genome2seqlevels),\n                        MoreArgs=list(value),\n                        SIMPLIFY=FALSE, USE.NAMES=FALSE)\n    DF <- unsplit(as(genome2DF, \"CompressedDataFrameList\"), x_genome)\n    seqlevels(x) <- DF[ , \"seqlevels\"]\n    genome(x) <- DF[ , \"genome\"]\n    x\n}\n\nsetMethod(\"seqlevelsStyle\", \"Seqinfo\", .get_Seqinfo_seqlevelsStyle)\n\nsetReplaceMethod(\"seqlevelsStyle\", \"Seqinfo\", .set_Seqinfo_seqlevelsStyle)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default seqlevelsStyle() getter and setter methods\n###\n\n### Works on any object 'x' with a working seqinfo() getter.\nsetMethod(\"seqlevelsStyle\", \"ANY\", function(x) seqlevelsStyle(seqinfo(x)))\n\n### Works on any object 'x' with a working seqinfo() getter and setter.\nsetReplaceMethod(\"seqlevelsStyle\", \"ANY\",\n     function (x, value)\n     {\n         x_seqinfo <- seqinfo(x)\n         seqlevelsStyle(x_seqinfo) <- value\n         seqinfo(x, new2old=seq_along(x_seqinfo)) <- x_seqinfo\n         x\n     }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqlevelsStyle() getter and setter methods for character vectors\n###\n\n.getDatadir <- function()\n{\n    system.file(package = \"GenomeInfoDb\",\"extdata\",\"dataFiles\")\n}\n\n.getNamedFiles <- function()\n{\n    filePath <- .getDatadir()\n    files <- dir(filePath, full.names=TRUE, pattern =\".txt$\")\n    setNames(files, sub(\".txt$\", \"\", basename(files)))\n}\n\n.supportedSeqnameMappings <- function()\n{\n    dom <-  lapply(.getNamedFiles(), read.table, header=TRUE, sep=\"\\t\",\n                   stringsAsFactors=FALSE)\n    lapply(dom, function(x) {x[,-c(1:3)] })\n}\n\n.normalize_organism <- function(organism)\n{\n    parts <- CharacterList(strsplit(organism, \"_| \"))\n    parts_eltNROWS <- elementNROWS(parts)\n    ## If 3 parts or more (e.g. \"Canis_lupus_familiaris\") then remove part 2.\n    idx3 <- which(parts_eltNROWS >= 3L)\n    if (length(idx3) != 0L)\n        parts[idx3] <- parts[idx3][rep.int(list(-2L), length(idx3))]\n    unstrsplit(parts, sep=\"_\")\n}\n\n.guessSpeciesStyle <- function(seqnames)\n{\n    zz <- .supportedSeqnameMappings()\n    got2 <- lapply(zz ,function(y) lapply(y, function(z)\n        sum(z %in% seqnames)) )\n    unlistgot2 <- unlist(got2, recursive=TRUE,use.names=TRUE)\n\n    if (max(unlistgot2) == 0) {\n       ans <- NA\n    }else{\n        ##vec is in format \"Homo_sapiens.UCSC\"\n        vec <- names(which(unlistgot2==max(unlistgot2)))\n        organism <- .normalize_organism(sub(\"(.*?)[.].*\", \"\\\\1\", vec))\n        style <- gsub(\"^[^.]+.\",\"\", vec)\n        ans <- list(species=organism, style=style)\n    }\n    ans\n}\n\nsetMethod(\"seqlevelsStyle\", \"character\",\n    function(x)\n{\n    if (length(x) == 0L)\n        stop(wmsg(\"no seqlevels present in this object\"))\n\n    seqlevels <- unique(x)\n    ans <- .guessSpeciesStyle(seqlevels)\n\n    ## 3 cases -\n    ## 1. if no style found - ans is na - stop with message\n    ## 2. if multiple styles returned then print message saying that it could\n    ##    be any of these styles\n    ## 3. if one style returned - hurray!\n\n    if(length(ans)==1){\n        if(is.na(ans)){\n            if (all(.is_RefSeq_accession(seqlevels)))\n                return(\"RefSeq\")\n            txt <- \"The style does not have a compatible entry for the\n            species supported by Seqname. Please see\n            genomeStyles() for supported species/style\"\n            stop(paste(strwrap(txt, exdent=2), collapse=\"\\n\"))\n        }\n    }\n    unique(ans$style)\n})\n\n.replace_seqlevels_style <- function(x_seqlevels, value)\n{\n    renaming_maps <- mapSeqlevels(x_seqlevels, value, drop=FALSE)\n    if (nrow(renaming_maps) == 0L) {\n        msg <- c(\"found no sequence renaming map compatible \",\n                 \"with seqname style \\\"\", value, \"\\\" for this object\")\n        stop(msg)\n    }\n    ## Use 1st best renaming map.\n    if (nrow(renaming_maps) != 1L) {\n        msg <- c(\"found more than one best sequence renaming map \",\n                 \"compatible with seqname style \\\"\", value, \"\\\" for \",\n                 \"this object, using the first one\")\n        warning(msg)\n        renaming_maps <- renaming_maps[1L, , drop=FALSE]\n    }\n    new_seqlevels <- as.vector(renaming_maps)\n    na_idx <- which(is.na(new_seqlevels))\n    new_seqlevels[na_idx] <- x_seqlevels[na_idx]\n    new_seqlevels\n}\n\nsetReplaceMethod(\"seqlevelsStyle\", \"character\",\n    function (x, value)\n    {\n        value <- .normarg_seqlevelsStyle(value)\n        x_seqlevels <- unique(x)\n        new_seqlevels <- .replace_seqlevels_style(x_seqlevels, value)\n        new_seqlevels[match(x, x_seqlevels)]\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other user-facing low-level utilities related to the seqlevelsStyle()\n### getter and setter methods for character vectors:\n###   - genomeStyles()\n###   - extractSeqlevels()\n###   - extractSeqlevelsByGroup()\n###   - mapSeqlevels()\n###   - seqlevelsInGroup()\n\n.isSupportedSeqnamesStyle <- function(organism, style)\n{\n    organism <- .normalize_organism(organism)\n    possible <- lapply(.getNamedFiles(), scan, nlines=1, what=character(),\n                       quiet=TRUE)\n    availStyles <- possible[[organism]]\n    style %in% availStyles[-which(availStyles %in% c(\"circular\",\"auto\",\"sex\"))]\n}\n\n.getDataInFile <- function(organism)\n{\n    organism2 <- .normalize_organism(organism)\n    filename <- paste0(.getDatadir(), \"/\", organism2, \".txt\")\n    if (file.exists(filename)) {\n        read.table(filename, header=TRUE, sep=\"\\t\", stringsAsFactors=FALSE)\n    } else {\n        stop(\"Organism \", organism, \" is not supported by GenomeInfoDb\")\n    }\n\n}\n\n.supportedSeqlevelsStyles <- function()\n{\n    dom <- lapply(.getNamedFiles(), scan, nlines=1, what=character(),\n                  quiet=TRUE)\n    lapply(dom, function(x) {x[!(x %in% c(\"circular\",\"auto\",\"sex\"))] })\n}\n\ngenomeStyles <- function(species)\n{\n    if (missing(species))\n        lapply(.getNamedFiles(), read.table, header=TRUE, sep=\"\\t\",\n           stringsAsFactors=FALSE)\n    else\n        .getDataInFile(species)\n}\n\nextractSeqlevels <- function(species, style)\n{\n    if (missing(species) || missing(style))\n        stop(\"'species' or 'style' missing\")\n\n    if(.isSupportedSeqnamesStyle(species, style))\n    {\n        data <- .getDataInFile(species)\n        result <- as.vector(data[,which( names(data) %in% style)])\n    }else{\n        stop(\"The style specified by '\",style,\n             \"' does not have a compatible entry for the species \",species)}\n    result\n}\n\nextractSeqlevelsByGroup <- function(species, style, group)\n{\n    if (missing(species) || missing(style) || missing(group))\n        stop(\"'species', 'style', and / or 'group' missing\")\n\n    logic <-sapply(species, function(x) .isSupportedSeqnamesStyle(x, style))\n\n    if(all(logic))\n    {\n        data <- .getDataInFile(species)\n        if (group!=\"all\"){\n            colInd <- which(names(data)%in% group)\n            Ind <- which(data[,colInd]==1)\n            result <- as.vector(data[Ind,which( names(data) %in% style)])\n        }\n        else{\n            result <- as.vector(data[,which( names(data) %in% style)])\n        }\n    }else{\n        stop(\"The style specified by '\",style,\n             \"' does not have a compatible entry for the species \",species)}\n    result\n}\n\nmapSeqlevels <- function(seqnames, style, best.only=TRUE, drop=TRUE)\n{\n    if (!is.character(seqnames))\n        stop(\"'seqnames' must be a character vector\")\n    if (!isSingleString(style))\n        stop(\"the supplied seqlevels style must be a single string\")\n    if (!isTRUEorFALSE(best.only))\n        stop(\"'best.only' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(drop))\n        stop(\"'drop' must be TRUE or FALSE\")\n    supported_styles <- .supportedSeqlevelsStyles()\n    tmp <- unlist(supported_styles, use.names = FALSE)\n    compatible_species <- rep.int(names(supported_styles),\n                                  sapply(supported_styles,NROW))\n    compatible_species <- compatible_species[tolower(tmp) ==\n                                                 tolower(style)]\n    if (length(compatible_species) == 0L)\n        stop(\"supplied seqname style \\\"\", style, \"\\\" is not supported\")\n    seqname_mappings <- .supportedSeqnameMappings()\n    ans <- lapply(compatible_species, function(species) {\n        mapping <- seqname_mappings[[species]]\n        names(mapping) <- tolower(names(mapping))\n        to_seqnames <- as.character(mapping[[tolower(style)]])\n        lapply(mapping, function(from_seqnames)\n            to_seqnames[match(seqnames, from_seqnames)])\n    })\n    ans_ncol <- length(seqnames)\n    ans <- matrix(unlist(ans, use.names = FALSE), ncol = ans_ncol, byrow = TRUE)\n    colnames(ans) <- seqnames\n    score <- rowSums(!is.na(ans))\n    idx <- score != 0L\n    if (best.only)\n        idx <- idx & (score == max(score))\n    ans <- ans[idx, , drop = FALSE]\n    ans <- as.matrix(unique(as.data.frame(ans, stringsAsFactors = FALSE)))\n    if (nrow(ans) == 1L && drop)\n        ans <- drop(ans)\n    else rownames(ans) <- NULL\n    ans\n}\n\nseqlevelsInGroup <-\n    function(seqnames, group=c(\"all\", \"auto\", \"sex\", \"circular\"),\n             species, style)\n{\n    group <- match.arg(group)\n    if (missing(species) && missing(style)) {\n        ## guess the species and / or style for the object\n        ans <- .guessSpeciesStyle(seqnames)\n        species<- ans$species\n        style <- unique(unlist(ans$style))\n    }\n\n    logic <-sapply(species, function(x) .isSupportedSeqnamesStyle(x, style))\n\n    if (all(logic)) {\n        seqvec <- sapply(unlist(species), function(x)\n            extractSeqlevelsByGroup( x, style, group))\n        unique(unlist(seqvec))[na.omit(match(seqnames, unique(unlist(seqvec))))]\n    } else {\n        txt <- paste0( \"The style specified by \", sQuote(style),\n                       \" does not have a compatible entry for the species \",\n                       sQuote(species))\n        stop(paste(strwrap(txt, exdent=2), collapse=\"\\n\"))\n    }\n}\n\n",
        "utils.R": "### =========================================================================\n### Miscellaneous low-level utils\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, nothing in this file is exported.\n###\n\n\nis_single_value <- function(x)\n{\n    is.vector(x) && is.atomic(x) && length(x) == 1L\n}\n\nis_primary_key <- function(x)\n{\n    !anyNA(x) && all(nzchar(x)) && !anyDuplicated(x)\n}\n\nstop_if_not_primary_key <- function(x, x_what=\"'x'\")\n{\n    if (!is_primary_key(x))\n        stop(wmsg(x_what, \" must not contain NAs, \",\n                  \"empty strings, or duplicates\"))\n}\n\n### 'x' must be a matrix-like or data-frame-like object.\ndrop_cols <- function(x, columns=character(0))\n{\n    stopifnot(is.character(columns))\n    if (length(columns) == 0L)\n        return(x)\n    drop_idx <- match(columns, colnames(x))\n    stopifnot(!anyNA(drop_idx))\n    x[ , -drop_idx, drop=FALSE]\n}\n\n### 'x' must be a matrix-like or data-frame-like object.\nrename_cols <- function(x, old=character(0), new=character(0))\n{\n    stopifnot(is.character(old),\n              is.character(new),\n              length(old) == length(new))\n    if (length(old) == 0L)\n        return(x)\n    rename_idx <- match(old, colnames(x))\n    stopifnot(!anyNA(rename_idx))\n    colnames(x)[rename_idx] <- new\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### solid_match() and solid_match2()\n###\n\n.one_to_many_msg <- function(culprits, from_what, to_what)\n{\n    culprits_names <- names(culprits)\n    if (!is.null(culprits_names))\n        culprits <- culprits_names\n    in1string <- paste0(unique(culprits), collapse=\", \")\n    c(from_what, \"(s) matched to more than 1 \", to_what, \": \", in1string)\n}\n\n### Like base::match() but:\n###   1. NA is never matched (incomparable).\n###   2. Raises an error if some elements in 'x' can be matched to more\n###      than one element in 'table' (one-to-many mapping).\n### IMPORTANT NOTE: The fast implementation below doesn't work if 'x'\n### contains duplicates so we check this. This means that we cannot use\n### it in join_dfs() below!\nsolid_match <- function(x, table,\n                        x_what=\"'x' element\", table_what=\"'table' element\")\n{\n    ## We only support atomic vectors (this is unlike base::match()\n    ## where 'x' and 'table' each can be a NULL or a list).\n    stopifnot(is.vector(x), is.atomic(x),\n              !anyDuplicated(x, incomparables=NA),\n              is.vector(table), is.atomic(table))\n    revm <- match(table, x, incomparables=NA)  # reverse match\n    ambig_idx <- which(duplicated(revm, incomparables=NA_integer_))\n    if (length(ambig_idx) != 0L) {\n        uidx <- unique(revm[ambig_idx])\n        stop(wmsg(.one_to_many_msg(x[uidx], x_what, table_what)))\n    }\n    ans <- rep.int(NA_integer_, length(x))\n    ok <- !is.na(revm)\n    ans[revm[ok]] <- which(ok)\n    ans\n}\n\n### Like base::match() but:\n###   1. NA is never matched (incomparable).\n###   2. Raises an error if the forward or reverse mapping is one-to-many.\nsolid_match2 <- function(x, table,\n                         x_what=\"'x' element\", table_what=\"'table' element\")\n{\n    ## We only support atomic vectors (this is unlike base::match()\n    ## where 'x' and 'table' each can be a NULL or a list).\n    stopifnot(is.vector(x), is.atomic(x),\n              is.vector(table), is.atomic(table))\n    hits <- findMatches(x, table, incomparables=NA)\n    q_hits <- queryHits(hits)\n    s_hits <- subjectHits(hits)\n    q_ambig_idx <- which(duplicated(q_hits))\n    if (length(q_ambig_idx) != 0L) {\n        uidx <- unique(q_hits[q_ambig_idx])\n        stop(wmsg(.one_to_many_msg(x[uidx], x_what, table_what)))\n    }\n    s_ambig_idx <- which(duplicated(s_hits))\n    if (length(s_ambig_idx) != 0L) {\n        uidx <- unique(s_hits[s_ambig_idx])\n        stop(wmsg(.one_to_many_msg(table[uidx], table_what, x_what)))\n    }\n    ans <- rep.int(NA_integer_, length(x))\n    ans[q_hits] <- s_hits\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### JOIN two data.frames\n###\n### In typical base R fashion, merge.data.frame() does all kinds of weird\n### things with the column names and is very inefficient. Plus, independently\n### of how 'sort' is set, the order of the rows in the result does not make\n### sense. The order of the columns doesn't either.\n###\n### join_dfs() below does NOT mess around with the column names, preserves\n### the order of the rows of the left data.frame, does not shuffle the\n### columns around (left and right columns stay on the left and right,\n### respectively, and in their original order), and is about 3x-4x faster\n### than merge.data.frame()!\n\n.do_join <- function(Ldf, Rdf, L2R)\n{\n    #stopifnot(is.integer(L2R),\n    #          length(L2R) == nrow(Ldf),\n    #          all(L2R >= 1L, na.rm=TRUE),\n    #          all(L2R <= nrow(Rdf), na.rm=TRUE))\n    cbind(Ldf, S4Vectors:::extract_data_frame_rows(Rdf, L2R))\n}\n\n### Performs an SQL INNER JOIN by default. Also by default the right column\n### of the join ('Rcolumn') is not included in the result.\n### IMPORTANT NOTE: It will mimic the behavior of an SQL JOIN (INNER or LEFT)\n### **only** if the right column contains unique values! (UNIQUE constraint\n### in SQL). If not, then values in the left column ('Lcolumn') will only\n### get mapped to their first match in the right column ('Rcolumn').\n### Comparison with merge.data.frame():\n### - INNER JOIN (join_dfs is about 3x faster):\n###     join_dfs(df1, df2, Lcolumn, Rcolumn)\n###     merge(df1, df2, by.x=Lcolumn, by.y=Rcolumn, sort=FALSE)\n### - LEFT JOIN (join_dfs is about 4x faster):\n###     join_dfs(df1, df2, Lcolumn, Rcolumn, left.join=TRUE)\n###     merge(df1, df2, by.x=Lcolumn, by.y=Rcolumn, sort=FALSE, all.x=TRUE)\njoin_dfs <- function(Ldf, Rdf, Lcolumn, Rcolumn,\n                     left.join=FALSE, keep.Rcol=FALSE)\n{\n    stopifnot(is.data.frame(Ldf),\n              is.data.frame(Rdf),\n              isSingleString(Lcolumn),\n              isSingleString(Rcolumn))\n    ## Values in the left column only get mapped to their first match in\n    ## the right column.\n    L2R <- match(Ldf[ , Lcolumn], Rdf[ , Rcolumn])\n    if (!left.join) {\n        ## Drop rows in 'Ldf' that are not mapped.\n        drop_idx <- which(is.na(L2R))\n        if (length(drop_idx) != 0L) {\n            Ldf <- S4Vectors:::extract_data_frame_rows(Ldf, -drop_idx)\n            L2R <- L2R[-drop_idx]\n        }\n    }\n    if (!keep.Rcol)\n        Rdf <- drop_cols(Rdf, Rcolumn)\n    .do_join(Ldf, Rdf, L2R)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### simple_read_table() and fetch_table_from_url()\n###\n\n### Remove occurences of \"\\r\\\\\\n\" or \"\\r\" from a file. This is the kind of\n### stuff that can be found in table dumps from Ensembl release < 99, and\n### that breaks utils::read.table().\n.clean_file <- function(infile, outfile=\"\", n=25000L)\n{\n    stopifnot(isSingleInteger(n), n >= 3L)\n    CR_byte <- charToRaw(\"\\r\")\n    BSOL_byte <- charToRaw(\"\\\\\")\n    EOL_byte <- charToRaw(\"\\n\")\n    GZIP_MAGIC_NUMBER <- as.raw(c(0x1F, 0x8B))\n    if (identical(readBin(infile, what=raw(), n=2L), GZIP_MAGIC_NUMBER)) {\n        con1 <- gzfile(infile, \"rb\")\n    } else {\n        con1 <- file(infile, \"rb\")\n    }\n    on.exit(close(con1))\n    if (nzchar(outfile)) {\n        con2 <- file(outfile, \"wb\")\n        on.exit(close(con2), add=TRUE)\n    }\n    carryover <- raw(0)\n    while (TRUE) {\n        bytes <- c(carryover, readBin(con1, what=raw(), n=n))\n        if (length(bytes) == 0L)\n            break\n        idx1 <- which(bytes == CR_byte)\n        if (length(idx1) != 0L) {\n            last_CR_idx <- idx1[[length(idx1)]]\n            if (last_CR_idx > length(bytes) - 2L) {\n                carryover <- bytes[last_CR_idx:length(bytes)]\n                bytes <- bytes[1:(last_CR_idx-1L)]\n                idx1 <- idx1[-length(idx1)]\n            } else {\n                carryover <- raw(0)\n            }\n        }\n        if (length(idx1) != 0L) {\n            idx2 <- which(bytes[idx1 + 1L] == BSOL_byte &\n                          bytes[idx1 + 2L] == EOL_byte)\n            idx1 <- c(idx1, idx1[idx2] + 1L, idx1[idx2] + 2L)\n            bytes <- bytes[-idx1]\n        }\n        if (nzchar(outfile)) {\n            writeBin(bytes, con2)\n        } else {\n            cat(rawToChar(bytes))\n        }\n    }\n}\n\n### Provides a simpler interface to read.table().\nsimple_read_table <- function(file,\n                              header=FALSE, colnames=NULL, col2class=NULL,\n                              nrows=-1L, skip=0L,\n                              sep=\"\\t\", quote=\"\", comment.char=\"\",\n                              remove_CRs=FALSE)\n{\n    if (is.null(col2class))\n        col2class <- NA\n    if (remove_CRs) {\n        outfile <- tempfile()\n        .clean_file(file, outfile)\n        file <- outfile\n    }\n    ## Prepare args to pass to read.table().\n    args <- list(file, header=header, sep=sep, quote=quote, row.names=NULL,\n                 na.strings=c(\"NA\", \"na\"), colClasses=col2class, nrows=nrows,\n                 skip=skip, comment.char=comment.char, stringsAsFactors=FALSE)\n    if (!is.null(colnames))\n        args$col.names <- colnames\n    do.call(read.table, args)\n}\n\n### Used by fetch_assembly_report(), fetch_table_dump_from_Ensembl_FTP(),\n### getChromInfoFromNCBI(), getChromInfoFromUCSC(), and more...\n### Calling read.table() directly on an URL tends to be unreliable. For\n### example getChromInfoFromNCBI(\"CIEA01\") was randomly failing for me with\n### a \"line 18564 did not have 10 elements\" error (exact line number would\n### vary) when getChromInfoFromNCBI() was calling read.table() on the URL\n### of the NCBI assembly report. In my experience, the 2-step approach\n### \"first download the file, then call read.table() on the local file\"\n### seems to be a lot more reliable! This is what fetch_table_from_url()\n### does.\n### Same interface as simple_read_table() above.\nfetch_table_from_url <- function(url, ...)\n{\n    destfile <- tempfile()\n    ## download.file() will not necessarily remove the destination file\n    ## in case of an error. See ?download.file\n    on.exit(unlink(destfile))\n    code <- suppressWarnings(download.file(url, destfile, quiet=TRUE))\n    if (code != 0L)\n        stop(wmsg(\"download failed\"))\n    simple_read_table(destfile, ...)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other stuff\n###\n\n### Global character vector to hold default names for circular sequences.\n### This is exported!\nDEFAULT_CIRC_SEQS <- c(\n    ## Mitochondrial genome\n    \"chrM\", \"chrMT\", \"MT\", \"MtDNA\", \"mit\", \"Mito\", \"mitochondrion\",\n    \"dmel_mitochondrion_genome\",\n    ## Chloroplast genome\n    \"Pltd\", \"ChrC\", \"Pt\", \"chloroplast\", \"Chloro\",\n    ## Plasmid (yeast)\n    \"2micron\", \"2-micron\", \"2uM\"\n)\n\n### AFAIK UCSC doesn't flag circular sequences.\n### As of Sep 21, 2010 (Ensembl release 59), Ensembl was still not flagging\n### circular sequences in their db (see this thread for the details\n### http://lists.ensembl.org/pipermail/dev/2010-September/000139.html),\n### NOT exported but used in the txdbmaker package.\nmake_circ_flags_from_circ_seqs <- function(seqlevels, circ_seqs=NULL)\n{\n    if (!is.character(seqlevels))\n        stop(wmsg(\"'seqlevels' must be a character vector\"))\n    if (is.null(circ_seqs)) {\n        ## The user did NOT specify the 'circ_seqs' argument.\n        seqlevels <- tolower(seqlevels)\n        circ_seqs <- tolower(DEFAULT_CIRC_SEQS)\n        circ_flags <- rep.int(NA, length(seqlevels))\n        circ_flags[seqlevels %in% circ_seqs] <- TRUE\n    } else {\n        ## The user specified the 'circ_seqs' argument.\n        if (!is.character(circ_seqs) ||\n            any(circ_seqs %in% c(NA_character_, \"\")))\n            stop(wmsg(\"'circ_seqs' must be a character vector with no NAs \",\n                      \"and no empty strings\"))\n        bad_circ_seqs <- setdiff(circ_seqs, seqlevels)\n        if (length(bad_circ_seqs) != 0L) {\n            in1string <- paste0(bad_circ_seqs, collapse=\", \")\n            stop(wmsg(\"'circ_seqs' contains unrecognized chromosome names: \",\n                      in1string))\n        }\n        circ_flags <- seqlevels %in% circ_seqs\n    }\n    circ_flags\n}\n\n### Note that, strictly speaking, mergeNamedAtomicVectors() is not\n### commutative, i.e., in general 'z1 <- mergeNamedAtomicVectors(x, y)' is\n### not identical to 'z2 <- mergeNamedAtomicVectors(y, x)'. However 'z1' and\n### 'z2' are both guaranteed to have unique names and to contain the same set\n### of name/value pairs (but typically not in the same order).\nmergeNamedAtomicVectors <- function(x, y, what=c(\"key\", \"values\"))\n{\n    if (!is.atomic(x) || !is.atomic(y) || typeof(x) != typeof(y))\n        stop(\"'x' and 'y' must be atomic vectors of the same type\")\n    x_names <- names(x)\n    y_names <- names(y)\n    if (is.null(x_names) || is.null(y_names))\n        stop(\"'x' and 'y' must have names\")\n    ans_names <- union(x_names, y_names)\n    if (any(ans_names %in% c(NA_character_, \"\")))\n        stop(\"some names in 'x' or 'y' are NA or the empty string\")\n    ## Note sure why but subsetting by name is *very* slow when the character\n    ## vector used as subscript contains a lot of \"invalid\" names. I already\n    ## reported this issue twice on the R-devel mailing list (in July 2010 and\n    ## May 2013) with no answer so far.\n    #ans <- x[ans_names]  # very slow :-(\n    ans <- x[match(ans_names, x_names)]  # much faster :-)\n    ## Some of 'ans' names can be NA. This is because subsetting a named\n    ## vector 'x' by a character vector 'i' returns a vector whose names\n    ## are 'i' except for the values in 'i' that are not in 'names(x)'.\n    ## So we need to fix this.\n    names(ans) <- ans_names\n    #ans2 <- y[ans_names]  # very slow :-(\n    ans2 <- y[match(ans_names, y_names)]  # much faster :-)\n    idx <- which(ans != ans2)\n    if (length(idx) != 0L) {\n        msg <- c(what[1L], ifelse(length(idx) >= 2, \"s\", \"\"), \" \",\n                 paste(ans_names[idx], collapse=\", \"), \" \",\n                 ifelse(length(idx) >= 2, \"have\", \"has\"),\n                 \" incompatible \", what[2L], \":\\n  - in 'x': \",\n                 paste(ans[idx], collapse=\", \"), \"\\n  - in 'y': \",\n                 paste(ans2[idx], collapse=\", \"))\n        stop(msg)\n    }\n    idx <- is.na(ans) & !is.na(ans2)\n    ans[idx] <- ans2[idx]\n    ans\n}\n\n",
        "zzz.R": ".onLoad <- function(libname, pkgname)\n{\n    UCSC.goldenPath.url <- \"https://hgdownload.soe.ucsc.edu/goldenPath\"\n    options(list(UCSC.goldenPath.url=UCSC.goldenPath.url))\n}\n\n.test <- function() BiocGenerics:::testPackage(\"GenomeInfoDb\")\n\n"
    },
    "S4Vectors": {
        "Annotated-class.R": "### =========================================================================\n### Annotated objects\n### -------------------------------------------------------------------------\n\nsetClass(\"Annotated\", representation(\"VIRTUAL\", metadata = \"list\"))\n\nsetGeneric(\"metadata\", function(x, ...) standardGeneric(\"metadata\"))\nsetMethod(\"metadata\", \"Annotated\",\n          function(x) {\n              if (is.null(x@metadata) || is.character(x@metadata))\n                  list(metadata = x@metadata)\n              else\n                  x@metadata\n          })\n\nsetGeneric(\"metadata<-\",\n           function(x, ..., value) standardGeneric(\"metadata<-\"))\nsetReplaceMethod(\"metadata\", \"Annotated\",\n                 function(x, value) {\n                     if (!is.list(value))\n                         stop(\"replacement 'metadata' value must be a list\")\n                     if (!length(value))\n                         names(value) <- NULL # instead of character()\n                     x@metadata <- value\n                     x\n                 })\n",
        "DataFrame-class.R": "### =========================================================================\n### DataFrame objects\n### -------------------------------------------------------------------------\n\n\n### DataFrame extends List and the List elements are considered to be the\n### columns of the DataFrame object. This follows the data.frame/list model\n### from base R.\nsetClass(\"DataFrame\",\n    contains=c(\"RectangularData\", \"List\"),\n    representation(\"VIRTUAL\")\n)\n\n## Add DataFrame to the DataFrame_OR_NULL union.\nsetIs(\"DataFrame\", \"DataFrame_OR_NULL\")\n\n\n## DFrame is a concrete DataFrame subclass for representation of in-memory\n## DataFrame objects. It inherits the \"listData\" slot from the SimpleList\n## class, as well as some of its methods e.g. names(), as.list() and lapply().\n## NOTE: Normal data.frames always have rownames (sometimes as integers),\n## but we allow the rownames to be NULL for efficiency. This means that we\n## need to store the number of rows (nrows).\nsetClass(\"DFrame\",\n    contains=c(\"DataFrame\", \"SimpleList\"),\n    representation(\n        rownames=\"character_OR_NULL\",\n        nrows=\"integer\"\n    ),\n    prototype(\n        rownames=NULL,\n        nrows=0L,\n        listData = structure(list(), names=character())\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### vertical_slot_names() and horizontal_slot_names()\n###\n\nsetMethod(\"vertical_slot_names\", \"DFrame\",\n    function(x) \"rownames\"\n)\n\nsetMethod(\"horizontal_slot_names\", \"DFrame\",\n    function(x) parallel_slot_names(x)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\nsetMethod(\"updateObject\", \"DataFrame\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## class attribute.\n        if (class(object) == \"DataFrame\") {\n            ## Starting with S4Vectors 0.23.19, all DataFrame instances need\n            ## to be replaced with DFrame instances. Note that this is NOT a\n            ## change of the internals, only a change of the class attribute.\n            if (verbose)\n                message(\"[updateObject] Setting class attribute of DataFrame \",\n                        \"instance to \\\"DFrame\\\" ... \", appendLF=FALSE)\n            class(object) <- class(new(\"DFrame\"))\n            if (verbose)\n                message(\"OK\")\n        } else {\n            if (verbose)\n                message(\"[updateObject] \", class(object), \" object \",\n                        \"is current.\\n\",\n                        \"[updateObject] Nothing to update.\")\n        }\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\n### Note that DataFrame extends List so the length of a DataFrame derivative\n### is the length of its underlying List.\nsetMethod(\"ncol\", \"DataFrame\", function(x) length(x))\n\n### Note that DataFrame extends List so the names of a DataFrame derivative\n### are the names of its underlying List.\nsetMethod(\"colnames\", \"DataFrame\",\n    function(x, do.NULL=TRUE, prefix=\"col\")\n    {\n        if (!(identical(do.NULL, TRUE) && identical(prefix, \"col\")))\n            stop(wmsg(\"argument 'do.NULL' and 'prefix' are not supported\"))\n        names(x)\n    }\n)\n\n### BACKWARD COMPATIBILITY WITH OLD DataFrame INSTANCES:\n### We shouldn't need this! We define these 2 methods only for backward\n### compatibility with old serialized DataFrame instances (which have\n### the \"listData\" slot). Without these methods, length() and names() (and\n### therefore ncol(), dim(), colnames(), and dimnames()) are broken on\n### these objects.\nsetMethod(\"length\", \"DataFrame\", function(x) length(x@listData))\nsetMethod(\"names\", \"DataFrame\", function(x) names(x@listData))\n\n### BACKWARD COMPATIBILITY WITH OLD DataFrame INSTANCES:\n### DataFrame derivatives don't have the \"nrows\" slot in general, only DFrame\n### objects have it. So the nrow() method below only makes sense for DFrame\n### objects. However, we still define it for DataFrame objects for backward\n### compatibility with old serialized DataFrame instances (which have the\n### \"nrows\" slot). If we don't do this, we get an infinite recursion when\n### calling nrow() on these objects:\n###   > nrow(x)\n###   Error: C stack usage  7979284 is too close to the limit\n### TODO: Remove this hack once all the old serialized DataFrame instances\n### laying around have been updated with updateObject(). This might take\n### years (best case scenario) or forever (worst case scenario).\nsetMethod(\"nrow\", \"DataFrame\", function(x) x@nrows)\n\n### BACKWARD COMPATIBILITY WITH OLD DataFrame INSTANCES:\n### DataFrame derivatives don't have the \"rownames\" slot in general, only\n### DFrame objects have it. So the rownames() method below only makes sense\n### for DFrame objects. However, we still define it for DataFrame\n### objects for backward compatibility with old serialized DataFrame\n### instances (which have the \"rownames\" slot). If we don't do this, we\n### get an infinite recursion when calling rownames() these objects:\n###   > rownames(x)\n###   Error: C stack usage  7975540 is too close to the limit\n### TODO: Remove this hack once all the old serialized DataFrame instances\n### laying around have been updated with updateObject(). This might take\n### years (best case scenario) or forever (worst case scenario).\nsetMethod(\"rownames\", \"DataFrame\",\n          function(x, do.NULL = TRUE, prefix = \"row\")\n          {\n            rn <- x@rownames\n            if (is.null(rn) && !do.NULL) {\n              nr <- NROW(x)\n              if (nr > 0L)\n                rn <- paste(prefix, seq_len(nr), sep = \"\")\n              else\n                rn <- character(0L)\n            }\n            rn\n          })\n\nsetReplaceMethod(\"rownames\", \"DFrame\",\n                 function(x, value)\n                 {\n                   if (!is.null(value)) {\n                     if (anyMissing(value))\n                       stop(\"missing values not allowed in rownames\")\n                     if (length(value) != nrow(x))\n                       stop(\"invalid rownames length\")\n                     if (!is(value, \"XStringSet\"))\n                       value <- as.character(value)\n                   }\n                   x@rownames <- value\n                   x\n                 })\n\nsetReplaceMethod(\"colnames\", \"DataFrame\",\n                 function(x, value)\n                 {\n                   if (!is.character(value))\n                       stop(\"'value' must be a character vector \",\n                            \"in colnames(x) <- value\")\n                   if (length(value) > length(x))\n                     stop(\"more column names than columns\")\n                   names(x) <- value\n                   x\n                 })\n\n### Only difference with the \"dimnames<-\" method for RectangularData\n### objects is that the replacement value is not allowed to be NULL.\nsetReplaceMethod(\"dimnames\", \"DataFrame\",\n    function(x, value)\n    {\n        if (!(is.list(value) && length(value) == 2L))\n            stop(wmsg(\"dimnames replacement value must be a list of length 2\"))\n        callNextMethod()  # call method for RectangularData objects\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid.DataFrame.rownames <- function(x)\n{\n  if (is.null(rownames(x)))\n    return(NULL)\n  if (length(rownames(x)) != nrow(x))\n    return(\"number of row names and number of rows differ\")\n  NULL\n}\n\n.valid.DataFrame.names <- function(x)\n{\n  if (is.null(names(x)))\n    return(\"column names should not be NULL\")\n  if (length(names(x)) != ncol(x))\n    return(\"number of columns and number of column names differ\")\n  NULL\n}\n\n.OLD_DATAFRAME_INSTANCE_MSG <- c(\n    \"Note that starting with BioC 3.10, the class attribute \",\n    \"of all DataFrame **instances** should be set to \",\n    \"\\\"DFrame\\\". Please update this object \",\n    \"with 'updateObject(object, verbose=TRUE)' and \",\n    \"re-serialize it.\"\n)\n\n.valid.DataFrame <- function(x)\n{\n  ## class() is broken when used within a validity method. See:\n  ##   https://stat.ethz.ch/pipermail/r-devel/2019-August/078337.html\n  #if (class(x) == \"DataFrame\")\n  #  return(paste(.OLD_DATAFRAME_INSTANCE_MSG, collapse=\"\"))\n  c(.valid.DataFrame.rownames(x),\n    .valid.DataFrame.names(x))\n}\n\nsetValidity2(\"DataFrame\", .valid.DataFrame)\n\n.valid.DFrame.nrow <- function(x)\n{\n  nr <- nrow(x)\n  if (!length(nr) == 1)\n    return(\"length of 'nrows' slot must be 1\")\n  if (nr < 0)\n    return(\"number of rows must be non-negative\")\n  NULL\n}\n\nsetValidity2(\"DFrame\", .valid.DFrame.nrow)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### Low-level constructor. For internal use only.\n### Note that, when supplied, 'nrows' is trusted (except when 'listData' is a\n### data.frame or data-frame-like object).\n### Calling 'new_DataFrame(x)' on an ordinary named list or an ordinary\n### data.frame 'x' will turn it into a DataFrame in the most possibly\n### straightforward way. In particular calling 'as.list()' or 'as.data.frame()'\n### on the returned DataFrame will bring back 'x'.\n### This is unlike 'DataFrame(x)' or 'as(x, \"DataFrame\")' which can do all\n### kind of hard-to-predict mangling to 'x', unless the user does something\n### like 'DataFrame(lapply(x, I))'. Not super convenient or intuitive!\nnew_DataFrame <- function(listData=list(), nrows=NA, what=\"arguments\")\n{\n    stopifnot(is.list(listData))\n    stopifnot(isSingleNumberOrNA(nrows))\n    if (!is.integer(nrows))\n        nrows <- as.integer(nrows)\n    listData_nrow <- nrow(listData)\n    if (is.null(listData_nrow)) {\n        ## 'listData' is NOT a data.frame or data-frame-like object.\n        if (length(listData) == 0L) {\n            if (is.na(nrows))\n                nrows <- 0L\n            names(listData) <- character(0)\n        } else {\n            if (is.na(nrows)) {\n                elt_nrows <- elementNROWS(listData)\n                nrows <- elt_nrows[[1L]]\n                if (!all(elt_nrows == nrows))\n                    stop(wmsg(what, \" imply differing number of rows\"))\n            }\n            if (is.null(names(listData)))\n                names(listData) <- paste0(\"V\", seq_along(listData))\n        }\n    } else {\n        ## 'listData' is a data.frame or data-frame-like object.\n        if (is.na(nrows)) {\n            nrows <- listData_nrow\n        } else if (nrows != listData_nrow) {\n            stop(wmsg(\"the supplied 'nrows' does not match \",\n                      \"the nb of rows in 'listData'\"))\n        }\n        listData <- as.list(listData)\n    }\n    new2(\"DFrame\", nrows=nrows, listData=listData, check=FALSE)\n}\n\nDataFrame <- function(..., row.names = NULL, check.names = TRUE,\n                      stringsAsFactors)\n{\n  ## build up listData, with names from arguments\n  if (!isTRUEorFALSE(check.names))\n    stop(\"'check.names' must be TRUE or FALSE\")\n  if (!missing(stringsAsFactors))\n    warning(\"'stringsAsFactors' is ignored\")\n  nr <- 0\n  listData <- list(...)\n  varlist <- vector(\"list\", length(listData))\n  metadata <- list()\n  if (length(listData) > 0) {\n    if (is(listData[[1L]], getClass(\"Annotated\")))\n        metadata <- metadata(listData[[1L]])\n    dotnames <- names(listData)\n    if (is.null(dotnames)) {\n        dotnames <- rep(\"\", length(listData))\n    }\n    qargs <- as.list(substitute(list(...)))[-1L]\n    varnames <- as.list(dotnames)\n    varnames[dotnames == \"\"] <- list(NULL)\n    nrows <- ncols <- integer(length(varnames))\n    for (i in seq_along(listData)) {\n      var <- listData[[i]]\n      element <- try(as(var, \"DFrame\"), silent = TRUE)\n      if (inherits(element, \"try-error\"))\n        stop(\"cannot coerce class \\\"\", class(var)[[1L]], \"\\\" to a DataFrame\")\n      nrows[i] <- nrow(element)\n      ncols[i] <- ncol(element)\n      varlist[[i]] <- element\n      if (is(var, \"AsIs\")) {\n        listData[[i]] <- drop_AsIs(var)\n      } else {\n        ## The only reason we use suppressWarnings() here is to suppress the\n        ## deprecation warning we get at the moment (BioC 3.14) when calling\n        ## dim() on a DataFrameList derivative. Remove when the dim() method\n        ## for DataFrameList derivatives is gone (note that when this happens,\n        ## dim() will return NULL on a DataFrameList derivative).\n        var_dim <- suppressWarnings(dim(var))\n        var_dims <- try(dims(var), silent=TRUE)\n        if (inherits(var_dims, \"try-error\"))\n            var_dims <- NULL\n        if (ncol(element) > 1L ||\n            is.list(var) && !is.object(var) ||\n            length(var_dim) > 1L ||\n            length(var_dims) > 1L)\n        {\n          if (is.null(varnames[[i]]))\n            varnames[[i]] <- colnames(element)\n          else\n            varnames[[i]] <- paste(varnames[[i]], colnames(element), sep = \".\")\n        }\n      }\n      if (is.null(varnames[[i]])) {\n          varnames[[i]] <- deparse(qargs[[i]])[1L]\n      }\n      if (missing(row.names))\n        row.names <- rownames(element)\n    }\n    mcols <- combine_mcols(varlist)\n    varlist <- lapply(varlist, as.list, use.names = FALSE)\n    nr <- max(nrows)\n    for (i in which((nrows > 0L) & (nrows < nr) & (nr %% nrows == 0L))) {\n      recycle <- rep(seq_len(nrows[i]), length.out = nr)\n      varlist[[i]] <- lapply(varlist[[i]], `[`, recycle, drop=FALSE)\n      nrows[i] <- nr\n    }\n    if (!all(nrows == nr))\n      stop(\"different row counts implied by arguments\")\n    varlist <- unlist(varlist, recursive = FALSE, use.names = FALSE)\n    nms <- as.character(unlist(varnames[ncols > 0L]))\n    if (check.names)\n      nms <- make.names(nms, unique = TRUE)\n    names(varlist) <- nms\n  } else {\n      names(varlist) <- character(0)\n      mcols <- NULL\n  }\n\n  if (!is.null(row.names)) {\n    if (anyMissing(row.names))\n      stop(\"missing values in 'row.names'\")\n    if (length(varlist) && length(row.names) != nr)\n      stop(\"invalid length of row names\")\n    row.names <- as.character(row.names)\n  }\n\n  ans <- new_DataFrame(varlist, nrows=as.integer(max(nr, length(row.names))))\n  ans@rownames <- row.names\n  mcols(ans) <- mcols\n  metadata(ans) <- metadata\n  ans\n}\n\n### Exported. Intended for developers to use in other packages and typically\n### not needed by the end user.\n### 3x faster than new(\"DFrame\", nrows=nrow).\n### 500x faster than DataFrame(matrix(nrow=nrow, ncol=0L)).\nmake_zero_col_DFrame <- function(nrow=0L)\n{\n    stopifnot(isSingleNumber(nrow))\n    if (!is.integer(nrow))\n        nrow <- as.integer(nrow)\n    stopifnot(nrow >= 0L)\n    new2(\"DFrame\", nrows=nrow, check=FALSE)\n}\n\n### Alias for backward compatibility.\n### NOT exported but used in packages IRanges, GenomicRanges,\n### SummarizedExperiment, GenomicAlignments, and maybe more...\nmake_zero_col_DataFrame <- make_zero_col_DFrame\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n### BACKWARD COMPATIBILITY WITH OLD DataFrame INSTANCES:\n### We define the 2 methods below only to make getListElement() and `[[` work\n### on the old DataFrame instances.\nsetMethod(\"getListElement\", \"DataFrame\",\n    function(x, i, exact=TRUE) getListElement(x@listData, i, exact=exact)\n)\nsetMethod(\"[[\", \"DataFrame\", function(x, i, j, ...)\n{\n    if (!missing(j)) {\n        x[[j, ...]][[i]]\n    } else {\n        selectMethod(\"[[\", \"SimpleList\")(x, i, j, ...)\n    }\n})\n\nsetMethod(\"[[\", \"DFrame\", function(x, i, j, ...)\n{\n    if (!missing(j)) {\n        x[[j, ...]][[i]]\n    } else {\n        callNextMethod()\n    }\n})\n\nsetReplaceMethod(\"[[\", \"DFrame\",\n                 function(x, i, j,..., value)\n                 {\n                   nrx <- nrow(x)\n                   lv <- NROW(value)\n                   if (!missing(j) || length(list(...)) > 0)\n                     warning(\"arguments beyond 'i' ignored\")\n                   if (missing(i))\n                     stop(\"subscript is missing\")\n                   if (!is.character(i) && !is.numeric(i))\n                     stop(\"invalid subscript type\")\n                   if (length(i) < 1L)\n                     stop(\"attempt to select less than one element\")\n                   if (length(i) > 1L)\n                     stop(\"attempt to select more than one element\")\n                   if (is.numeric(i) && (i < 1L || i > ncol(x) + 1L))\n                     stop(\"subscript out of bounds\")\n                   if (!is.null(value) && (nrx != lv)) {\n                     if ((nrx == 0) || (lv == 0) || (nrx %% lv != 0))\n                       stop(paste(lv, \"elements in value to replace\",\n                                  nrx, \"elements\"))\n                     else\n                       value <- rep(value, length.out = nrx)\n                   }\n                   callNextMethod(x, i, value=value)\n                 })\n\n### BACKWARD COMPATIBILITY WITH OLD DataFrame INSTANCES:\n### DataFrame derivatives don't have the \"listData\", \"nrows\", or \"rownames\"\n### slots in general, only DFrame objects have them. So the extractROWS()\n### method below only makes sense for DFrame objects. However, we still\n### define it for DataFrame objects for backward compatibility with\n### old serialized DataFrame instances (which have all these slots). If we\n### don't do this, calling extractROWS() on these objects will actually call\n### the method for Vector derivatives which is a no-op on these objects.\n### TODO: Remove this hack once all the old serialized DataFrame instances\n### laying around have been updated with updateObject(). This might take\n### years (best case scenario) or forever (worst case scenario).\nsetMethod(\"extractROWS\", \"DataFrame\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, allow.NAs=TRUE,\n                                             as.NSBS=TRUE)\n        x <- updateObject(x, check=FALSE)\n        slot(x, \"listData\", check=FALSE) <- lapply(as.list(x), extractROWS, i)\n        slot(x, \"nrows\", check=FALSE) <- length(i)\n        if (!is.null(rownames(x)))\n            slot(x, \"rownames\", check=FALSE) <- extractROWS(rownames(x), i)\n        x\n    }\n)\n\n### BACKWARD COMPATIBILITY WITH OLD DataFrame INSTANCES:\n### DataFrame derivatives don't have the \"listData\" slot in general, only\n### DFrame objects have it. So the extractCOLS() method below only makes\n### sense for DFrame objects. However, we still define it for DataFrame\n### objects for backward compatibility with old serialized DataFrame\n### instances (which have all these slots). If we don't do this,\n### calling extractCOLS() on these objects will actually call the\n### method for Vector derivatives which is a no-op on these objects.\n### TODO: Remove this hack once all the old serialized DataFrame instances\n### laying around have been updated with updateObject(). This might take\n### years (best case scenario) or forever (worst case scenario).\nsetMethod(\"extractCOLS\", \"DataFrame\", function(x, i) {\n    ## Remove this call to updateObject() when the signature of this\n    ## extractCOLS() method is changed from DataFrame to DFrame.\n    if (class(x)[[1L]] == \"DataFrame\")\n        x <- updateObject(x, check=FALSE)\n    if (missing(i))\n        return(x)\n    if (!is(i, \"IntegerRanges\")) {\n        xstub <- setNames(seq_along(x), names(x))\n        i <- normalizeSingleBracketSubscript(i, xstub)\n    }\n    new_listData <- extractROWS(x@listData, i)\n    new_mcols <- extractROWS(mcols(x, use.names=FALSE), i)\n    BiocGenerics:::replaceSlots(x, listData=new_listData,\n                                   elementMetadata=new_mcols,\n                                   check=FALSE)\n})\n\nsetMethod(\"[\", \"DataFrame\",\n    function(x, i, j, ..., drop=TRUE)\n    {\n        if (!isTRUEorFALSE(drop))\n            stop(\"'drop' must be TRUE or FALSE\")\n        if (length(list(...)) > 0L)\n            warning(\"parameters in '...' not supported\")\n\n        ## NOTE: matrix-style subsetting by logical matrix not supported.\n        list_style_subsetting <- (nargs() - !missing(drop)) < 3L\n        if (list_style_subsetting || !missing(j)) {\n            if (list_style_subsetting) {\n                if (!missing(drop))\n                    warning(\"'drop' argument ignored by list-style subsetting\")\n                if (missing(i))\n                    return(x)\n                j <- i\n            }\n            x <- extractCOLS(x, j)\n            if (list_style_subsetting)\n                return(x)\n        }\n        if (!missing(i))\n            x <- extractROWS(x, i)\n        if (missing(drop))  # drop by default if only one column left\n            drop <- ncol(x) == 1L\n        if (drop) {\n            ## one column left\n            if (ncol(x) == 1L)\n                return(x[[1L]])\n            ## one row left\n            if (nrow(x) == 1L)\n                return(as(x, \"list\"))\n        }\n        x\n    }\n)\n\n.make_rownames <- function(x, i, nsbs, value)\n{\n    x_nrow <- nrow(x)\n    x_rownames <- rownames(x)\n    if (!missing(i) && is.character(i)) {\n        value_rownames <- i\n    } else {\n        value_rownames <- rownames(value)\n    }\n    nsbs <- as.integer(nsbs)\n    i_max <- max(nsbs, x_nrow)\n    if (i_max <= x_nrow || is.null(x_rownames) && is.null(value_rownames))\n        return(x_rownames)\n    if (is.null(value_rownames))\n        value_rownames <- as.character(nsbs)\n    if (is.null(x_rownames))\n        x_rownames <- as.character(seq_len(x_nrow))\n    replaceROWS(x_rownames, nsbs[nsbs > x_nrow], value_rownames[nsbs > x_nrow])\n}\n\n.subassign_columns <- function(x, nsbs, value) {\n    x_ncol <- ncol(x)\n    value_ncol <- length(value)\n    if (value_ncol > x_ncol)\n        stop(\"provided \", value_ncol, \" variables \",\n             \"to replace \", x_ncol, \" variables\")\n    if (x_ncol != 0L) {\n        if (value_ncol == 0L)\n            stop(\"replacement has length zero\")\n        FUN <- if (nsbs@upper_bound_is_strict) replaceROWS else mergeROWS\n        new_listData <-\n            lapply(structure(seq_len(ncol(x)), names=names(x)),\n                   function(j)\n                       FUN(x[[j]], nsbs,\n                           value[[((j - 1L) %% value_ncol) + 1L]]))\n        slot(x, \"listData\", check=FALSE) <- new_listData\n    }\n    x\n}\n\nsetMethod(\"replaceROWS\", c(\"DFrame\", \"ANY\"),\n          function(x, i, value)\n          {\n              nsbs <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n              if (length(nsbs) == 0L) {\n                  return(x)\n              }\n              .subassign_columns(x, nsbs, value)\n          })\n\nsetMethod(\"mergeROWS\", c(\"DFrame\", \"ANY\"),\n    function(x, i, value)\n    {\n        nsbs <- normalizeSingleBracketSubscript(i, x, allow.append=TRUE,\n                                                as.NSBS=TRUE)\n        if (length(nsbs) == 0L) {\n            return(x)\n        }\n        x <- .subassign_columns(x, nsbs, value)\n        i_max <- max(as.integer(nsbs))\n        x_nrow <- nrow(x)\n        if (i_max > x_nrow) {\n            x@rownames <- .make_rownames(x, i, nsbs, value)\n            x@nrows <- i_max\n        }\n        x\n    }\n)\n\n.make_colnames <- function(x, i, x_len, value) {\n    if (!missing(i) && is.numeric(i) && length(i) > 0L) {\n        appended <- i > x_len\n        if (!is.null(names(value))) {\n            newcn <- names(value)[appended]\n        } else {\n            newcn <- paste0(\"V\", i[appended])\n        }\n        names(x)[i[appended]] <- newcn\n    }\n    names(x)\n}\n\n.append_NAs_to_list_elts <- function(x, na.count=0L)\n{\n    ## Use same trick as in .combine_DFrame_rows().\n    NAs <- Rle(NA, na.count)\n    lapply(setNames(seq_along(x), names(x)),\n        function(i) {\n            tryCatch(\n                bindROWS2(x[[i]], list(NAs)),\n                error=function(err) {\n                    stop(wmsg(\"failed to append NAs to column \",\n                              \"'\", names(x)[[i]], \"':\\n  \",\n                              conditionMessage(err)))\n                }\n            )\n        }\n    )\n}\n\n### Note that:\n### 1. Despite its name, this method can do more than just replacing\n###    existing columns. It can also append new columns (when 'i' contains\n###    indices > 'ncol(x)') or remove columns (when 'value' is NULL).\n### 2. The method usually preserves 'nrow(x)' and 'rownames(x)', except\n###    when 'nrow(value)' > 'nrow(x)', in which case rows of NAs are\n###    added to 'x' to match the number of rows in 'value'.\n.replaceCOLS_DFrame <- function(x, i, value)\n{\n    stopifnot(is.null(value) || is(value, \"DataFrame\"))\n    new_nrow <- x_nrow <- nrow(x)\n    new_rownames <- rownames(x)\n    sl <- as(x, \"SimpleList\")\n    if (!is.null(value)) {\n        value_nrow <- nrow(value)\n        if (value_nrow > x_nrow) {\n            ## Add rows of NAs to 'x'.\n            sl@listData <- .append_NAs_to_list_elts(sl@listData,\n                                                    value_nrow - x_nrow)\n            ri <- seq_len(value_nrow)\n            new_nrow <- value_nrow\n            new_rownames <- .make_rownames(x, ri, ri, value)\n        } else if (x_nrow < value_nrow) {\n            if (value_nrow == 0L || x_nrow %% value_nrow != 0L)\n                stop(wmsg(\"replacement has \", value_nrow, \" rows, \",\n                          \"data has \", x_nrow))\n            ## Add rows to 'value' by recycling its columns.\n            k <- x_nrow %/% value_nrow\n            value <- extractROWS(value, rep.int(seq_len(value_nrow), k))\n        }\n        value <- as(value, \"SimpleList\")\n    }\n    ## Note that this subassignment operation on SimpleList object 'sl' could\n    ## modify its length (e.g. if 'i' contains indices > 'ncol(x)' or 'value'\n    ## is NULL). In this case, the mcols() on 'sl' will get automatically\n    ## adjusted to stay parallel to 'sl'.\n    if (missing(i)) {\n        sl[] <- value\n    } else {\n        sl[i] <- value\n    }\n    if (!is.null(value))\n        names(sl@listData) <- .make_colnames(sl@listData, i, length(x), value)\n    BiocGenerics:::replaceSlots(x, listData=sl@listData,\n                                   elementMetadata=sl@elementMetadata,\n                                   nrows=new_nrow,\n                                   rownames=new_rownames,\n                                   check=FALSE)\n}\n\nsetMethod(\"replaceCOLS\", c(\"DFrame\", \"ANY\"), .replaceCOLS_DFrame)\n\nsetMethod(\"normalizeSingleBracketReplacementValue\", \"DataFrame\",\n          function(value, x)\n          {\n              hasColumns <- is(value, \"DataFrame\") || is.list(value) ||\n                  length(dim(value)) >= 2L\n              if (is.null(value) || (hasColumns && length(value) == 0L))\n                  return(NULL)\n              value <- as(value, \"DataFrame\", strict=FALSE)\n              if (!hasColumns) {\n                  names(value) <- NULL # don't try this at home\n              }\n              value\n          })\n\n.add_missing_columns <- function(x, j) {\n    if (!missing(j)) {\n        j2 <- normalizeSingleBracketSubscript(j, as.list(x),\n                                              allow.append=TRUE)\n        x[j[j2 > ncol(x)]] <- NA\n    }\n    x\n}\n\nsetReplaceMethod(\"[\", \"DataFrame\",\n                 function(x, i, j, ..., value)\n{\n    if (length(list(...)) > 0)\n        warning(\"parameters in '...' not supported\")\n    value <- normalizeSingleBracketReplacementValue(value, x)\n    if (nargs() < 4) {\n        value <- recycleSingleBracketReplacementValue(value, x)\n        replaceCOLS(x, i, value)\n    } else {\n        value <- recycleSingleBracketReplacementValue(value, x, i)\n        if (!missing(i)) {\n            x <- .add_missing_columns(x, j)\n            value <- mergeROWS(extractCOLS(x, j), i, value)\n        }\n        replaceCOLS(x, j, value)\n    }\n})\n\nhasNonDefaultMethod <- function(f, signature) {\n  any(selectMethod(f, signature)@defined != \"ANY\")\n}\n\nhasS3Method <- function(f, signature) {\n  !is.null(getS3method(f, signature, optional=TRUE))\n}\n\ndroplevels.DFrame <- function(x, except=NULL) {\n  canDropLevels <- function(xi) {\n    hasNonDefaultMethod(droplevels, class(xi)[[1L]]) ||\n      hasS3Method(\"droplevels\", class(xi)[[1L]])\n  }\n  drop.levels <- vapply(x, canDropLevels, NA)\n  if (!is.null(except))\n    drop.levels[except] <- FALSE\n  x@listData[drop.levels] <- lapply(x@listData[drop.levels], droplevels)\n  x\n}\nsetMethod(\"droplevels\", \"DFrame\", droplevels.DFrame)\n\nsetMethod(\"rep\", \"DataFrame\", function(x, ...) {\n  x[rep(seq_len(nrow(x)), ...),,drop=FALSE]\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### S3/S4 combo for as.data.frame.DataFrame\n### Same arguments as as.data.frame.matrix().\nas.data.frame.DataFrame <- function(x, row.names=NULL, optional=FALSE,\n                                    make.names=TRUE, ...,\n                                    stringsAsFactors=FALSE)\n{\n    if (!isTRUEorFALSE(make.names))\n        stop(\"'make.names' must be TRUE or FALSE\")\n    if (length(list(...)))\n        warning(\"arguments in '...' ignored\")\n    if (!identical(stringsAsFactors, FALSE))\n        stop(\"'stringsAsFactors' not supported\")\n    if (is.null(row.names)) {\n        row.names <- rownames(x)\n        if (is.null(row.names)) {\n            if (ncol(x) == 0L)\n                row.names <- seq_len(nrow(x))\n        } else {\n            if (make.names)\n                row.names <- make.unique(row.names)\n        }\n    } else {\n        row.names <- as.character(row.names)\n        if (make.names)\n            row.names <- make.names(row.names, unique=TRUE)\n        if (length(row.names) != nrow(x))\n            stop(\"row names supplied are of the wrong length\")\n    }\n    old_option <- getOption(\"stringsAsFactors\")\n    options(stringsAsFactors=FALSE)\n    on.exit(options(stringsAsFactors=old_option))\n    x_colnames <- colnames(x)\n    df_list <- lapply(setNames(seq_along(x), x_colnames),\n        function(j) {\n            col <- x[[j]]\n            if (is.data.frame(col))\n                return(col)\n            if (is(col, \"DataFrame\"))\n                return(as.data.frame(col, optional=optional))\n            ## If 'col is an AtomicList derivative (e.g. IntegerList,\n            ## CharacterList, etc...) or other List derivative that compares\n            ## recursively (i.e. not an IRanges, GRanges, or DNAStringSet,\n            ## etc... object), we turn it into an ordinary list. This is\n            ## because the \"as.data.frame\" method for List objects produces\n            ## this weird data frame:\n            ##   > as.data.frame(IntegerList(11:12, 21:23))\n            ##     group group_name value\n            ##   1     1       <NA>    11\n            ##   2     1       <NA>    12\n            ##   3     2       <NA>    21\n            ##   4     2       <NA>    22\n            ##   5     2       <NA>    23\n            ## which is not what we want here.\n            ## List derivatives that compare recursively should not need this\n            ## because they are expected to override the \"as.data.frame\" method\n            ## for List objects with a method that returns a data.frame with\n            ## one row per list element.\n            if (is(col, \"List\") && pcompareRecursively(col))\n                col <- as.list(col)\n            protect <- !is(col, \"AsIs\") && is.list(col) && !is.object(col)\n            if (protect)\n                col <- I(col)  # set AsIs class to protect column\n            df <- as.data.frame(col, optional=optional)\n            if (protect)\n                df[[1L]] <- unclass(df[[1L]])  # drop AsIs class\n            if (is.null(colnames(col)) && ncol(df) == 1L)\n                colnames(df) <- x_colnames[[j]]\n            df\n        })\n    do.call(data.frame,\n            c(df_list, list(row.names=row.names,\n                            check.names=!optional,\n                            stringsAsFactors=FALSE)))\n}\nsetMethod(\"as.data.frame\", \"DataFrame\", as.data.frame.DataFrame)\n\nsetMethod(\"as.matrix\", \"DataFrame\", function(x) {\n  if (length(x) == 0L)\n    m <- matrix(logical(), nrow = nrow(x), ncol = 0L)\n  else m <- do.call(cbind, as.list(x))\n  rownames(m) <- rownames(x)\n  m\n})\n\nsetAs(\"data.frame\", \"DFrame\",\n      function(from) {\n        rn <- attributes(from)[[\"row.names\"]]\n        if (is.integer(rn))\n          rn <- NULL\n        nr <- nrow(from)\n### FIXME: this should be:\n        ## from <- as.list(from)\n### But unclass() causes deep copy\n        attr(from, \"row.names\") <- NULL\n        class(from) <- NULL\n        ans <- new_DataFrame(from, nrows=nr)\n        ans@rownames <- rn\n        ans\n      })\n\nsetAs(\"data.table\", \"DFrame\",\n    function(from)\n    {\n        df <- data.table:::as.data.frame.data.table(from)\n        as(df, \"DFrame\")\n    }\n)\n\nsetAs(\"table\", \"DFrame\",\n      function(from) {\n        df <- as.data.frame(from)\n        factors <- sapply(df, is.factor)\n        factors[1] <- FALSE\n        do.call(DataFrame, c(df[1], lapply(df[factors], Rle), df[\"Freq\"]))\n      })\n\nsetOldClass(c(\"xtabs\", \"table\"))\nsetAs(\"xtabs\", \"DFrame\",\n      function(from) {\n        class(from) <- \"table\"\n        as(from, \"DFrame\")\n      })\n\n.defaultAsDFrame <- function(from) {\n  if (length(dim(from)) == 2L) {\n    df <- as.data.frame(from, stringsAsFactors=FALSE)\n    if (0L == ncol(from))\n      ## colnames on matrix with 0 columns are 'NULL'\n      names(df) <- character()\n    as(df, \"DFrame\")\n  } else {\n    ans <- new_DataFrame(setNames(list(from), \"X\"), nrows=length(from))\n    ans@rownames <- names(from)\n    ans\n  }\n}\n\nsetAs(\"ANY\", \"DFrame\", .defaultAsDFrame)\n\nsetAs(\"ANY\", \"DataFrame\", function(from) as(from, \"DFrame\"))\nsetAs(\"SimpleList\", \"DataFrame\", function(from) as(from, \"DFrame\"))\n\n.VectorAsDFrame <- function(from) {\n  ans <- .defaultAsDFrame(from)\n  from_mcols <- mcols(from, use.names=FALSE)\n  if (!is.null(from_mcols))\n    ans <- cbind(ans, from_mcols)\n  ans\n}\n\n## overriding the default inheritance-based coercion from methods package\nsetAs(\"SimpleList\", \"DFrame\", .VectorAsDFrame)\nsetAs(\"Vector\", \"DFrame\", .VectorAsDFrame)\n\n## note that any element named 'row.names' will be interpreted differently\n## is this a bug or a feature?\nsetAs(\"list\", \"DFrame\",\n      function(from) {\n        do.call(DataFrame, c(from, list(check.names=is.null(names(from)))))\n      })\n\nsetAs(\"NULL\", \"DFrame\", function(from) as(list(), \"DFrame\"))\n\nsetAs(\"AsIs\", \"DFrame\",\n      function(from) {\n        new_DataFrame(setNames(list(drop_AsIs(from)), \"X\"))\n      })\n\nsetAs(\"ANY\", \"DataFrame_OR_NULL\", function(from) as(from, \"DFrame\"))\n\nsetMethod(\"coerce2\", \"DataFrame\",\n    function(from, to)\n    {\n        to_class <- class(to)[[1L]]\n        ## Is this test equivalent to is.list(from) && !is.object(from)?\n        if (class(from)[[1L]] == \"list\") {\n            ## Turn an ordinary list into a DataFrame in the most possibly\n            ## straightforward way.\n            ans <- new_DataFrame(from, what=\"list elements\")\n            if (is(ans, to_class))\n                return(ans)\n            ans <- as(ans, to_class, strict=FALSE)\n            ## Even though coercion from DataFrame to 'class(to)' \"worked\", it\n            ## can return a broken object. This happens when an automatic\n            ## coercion method gets in the way. The problem with these methods\n            ## is that they often do the wrong thing and don't even bother to\n            ## validate the object they return!\n            ## One possible problem with an automatic coercion method from\n            ## DataFrame to a DataFrame subclass is that it will set the\n            ## elementType slot to \"ANY\" which could be wrong. So we fix this.\n            ans@elementType <- to@elementType\n            validObject(ans)\n            return(ans)\n        }\n        ## Some objects like SplitDataFrameList have a dim() method that\n        ## returns a non-MULL object (a matrix!) even though they don't have\n        ## an array-like (or matrix-like) semantic.\n        from_dim <- dim(from)\n        if (length(from_dim) == 2L && !is.matrix(from_dim)) {\n            if (is(from, to_class))\n                return(from)\n            ans <- as(from, to_class, strict=FALSE)\n            if (!identical(dim(ans), from_dim))\n                stop(wmsg(\"coercion of \", class(from)[[1L]], \" object \",\n                          \"to \", to_class, \" didn't preserve its dimensions\"))\n            ## Try to restore the dimnames if they were lost or altered.\n            from_dimnames <- dimnames(from)\n            if (!identical(dimnames(ans), from_dimnames)) {\n                tmp <- try(`dimnames<-`(ans, value=from_dimnames), silent=TRUE)\n                if (!inherits(tmp, \"try-error\"))\n                    ans <- tmp\n            }\n            return(ans)\n        }\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"classNameForDisplay\", \"DFrame\",\n    function(x) if (class(x) == \"DFrame\") \"DataFrame\" else class(x)\n)\n\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"DataFrame\",\n    function(x)\n    {\n        df <- data.frame(lapply(x, showAsCell), check.names=FALSE,\n                         row.names=NULL)\n        as.matrix(format(df))\n    }\n)\n\nmake_class_info_for_DataFrame_display <- function(x)\n{\n    vapply(x, function(xi) paste0(\"<\", classNameForDisplay(xi), \">\"),\n           character(1), USE.NAMES=FALSE)\n}\n\n.show_DataFrame <- function(x)\n{\n    nhead <- get_showHeadLines()\n    ntail <- get_showTailLines()\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    cat(classNameForDisplay(x), \" with \",\n        x_nrow, \" row\", ifelse(x_nrow == 1L, \"\", \"s\"),\n        \" and \",\n        x_ncol, \" column\", ifelse(x_ncol == 1L, \"\", \"s\"),\n        \"\\n\", sep=\"\")\n    if (x_nrow != 0L && x_ncol != 0L) {\n        x_rownames <- rownames(x)\n        if (x_nrow <= nhead + ntail + 1L) {\n            m <- makeNakedCharacterMatrixForDisplay(x)\n            if (!is.null(x_rownames))\n                rownames(m) <- x_rownames\n        } else {\n            m <- rbind(makeNakedCharacterMatrixForDisplay(head(x, nhead)),\n                       rbind(rep.int(\"...\", x_ncol)),\n                       makeNakedCharacterMatrixForDisplay(tail(x, ntail)))\n            rownames(m) <- make_rownames_for_RectangularData_display(\n                                             x_rownames, x_nrow,\n                                             nhead, ntail)\n        }\n        m <- rbind(make_class_info_for_DataFrame_display(x), m)\n        print(m, quote=FALSE, right=TRUE)\n    }\n    invisible(NULL)\n}\n\nsetMethod(\"show\", \"DataFrame\",\n    function(object)\n    {\n        if (class(object) == \"DataFrame\") {\n            ## Aug 20, 2019: Too early for this warning.\n            #warning(wmsg(.OLD_DATAFRAME_INSTANCE_MSG))\n            object <- updateObject(object, check=FALSE)\n        }\n        .show_DataFrame(object)\n    }\n)\n\nsetMethod(\"showAsCell\", \"DataFrame\", showAsCell_array)\n\n",
        "DataFrame-combine.R": "### =========================================================================\n### Combining DataFrame objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .combine_DFrame_rows()\n###\n### The workhorse behind the rbind() and combineRows() methods for DataFrame\n### objects.\n###\n\n### 'all_colnames' must be a list of colnames vectors (character vectors).\n### Returns an integer matrix describing how each colnames vector aligns to\n### the \"aggregated colnames\". The \"aggregated colnames\" is the vector of\n### colnames obtained by taking the duplicates-preserving union of all the\n### colnames vectors (e.g. the aggregation of c(\"a\", \"b\", \"c\", \"b\") and\n### c(\"e\", \"b\", \"e\", \"a\", \"a\") is c(\"a\", \"b\", \"c\", \"b\", \"e\", \"e\", \"a\")).\n### The returned matrix has one row per colnames vector and one column\n### per \"aggregated colname\". The \"aggregated colnames\" are set as the\n### colnames of the matrix.\n### If 'strict.colnames' is TRUE, all the supplied colnames vectors must be\n### the same (modulo the order of their elements). An error is raised if\n### they are not.\n### If 'strict.colnames' is FALSE, the returned matrix can contain NAs.\n.aggregate_and_align_all_colnames <- function(all_colnames,\n                                              strict.colnames=FALSE,\n                                              what=\"DFrame objects\")\n{\n    stopifnot(is.list(all_colnames),\n              length(all_colnames) >= 1L,\n              isTRUEorFALSE(strict.colnames))\n    ans <- matrix(seq_along(all_colnames[[1L]]), nrow=1L,\n                  dimnames=list(NULL, all_colnames[[1L]]))\n    for (colnames in all_colnames[-1L]) {\n        colnames_hits <- findMatches(colnames, colnames(ans))\n        colnames_map <- selectHits(colnames_hits, select=\"first\", nodup=TRUE)\n        unmapped_idx <- which(is.na(colnames_map))\n        if (strict.colnames) {\n            if (length(colnames) != ncol(ans) || length(unmapped_idx) != 0L)\n                stop(wmsg(\"the \", what, \" to combine \",\n                          \"must have the same column names\"))\n        }\n        mapped_idx <- which(!is.na(colnames_map))\n        colnames_revmap <- rep.int(NA_integer_, ncol(ans))\n        colnames_revmap[colnames_map[mapped_idx]] <- mapped_idx\n        ans <- rbind(ans, matrix(colnames_revmap, nrow=1L))\n        if (length(unmapped_idx) != 0L) {\n            m <- matrix(NA_integer_,\n                        nrow=nrow(ans)-1L, ncol=length(unmapped_idx),\n                        dimnames=list(NULL, colnames[unmapped_idx]))\n            m <- rbind(m, matrix(unmapped_idx, nrow=1L))\n            ans <- cbind(ans, m)\n        }\n    }\n    ans\n}\n\n### 'x' must be a DFrame object or derivative.\n### Behaves like an endomorphism with respect to 'x' i.e. returns an object\n### of the same class as 'x'.\n### NOT exported.\n.combine_DFrame_rows <- function(x, objects=list(), strict.colnames=FALSE,\n                                                    use.names=TRUE, check=TRUE)\n{\n    if (!is(x, \"DFrame\"))\n        stop(wmsg(\"the objects to combine must be \",\n                  \"DFrame objects or derivatives\"))\n    if (!isTRUEorFALSE(strict.colnames))\n        stop(wmsg(\"'strict.colnames' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(use.names))\n        stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(check))\n        stop(wmsg(\"'check' must be TRUE or FALSE\"))\n\n    objects <- prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n    all_nrows <- unlist(lapply(all_objects, nrow), use.names=FALSE)\n    all_colnames <- lapply(all_objects, colnames)\n    colmap <- .aggregate_and_align_all_colnames(all_colnames,\n                                                strict.colnames=strict.colnames)\n    ## Unfortunately there seems to be no way to put colnames on a 0-col\n    ## matrix. So when the 'colmap' matrix has 0 cols, 'colnames(colmap)'\n    ## will always be NULL, even though we'd like it to be 'character(0)'.\n    if (ncol(colmap) == 0L) {\n        ans_colnames <- character(0)\n    } else {\n        ans_colnames <- colnames(colmap)\n    }\n\n    ## Compute 'ans_listData'.\n    ans_listData <- lapply(setNames(seq_along(ans_colnames), ans_colnames),\n        function(j) {\n            all_cols <- lapply(seq_along(all_objects),\n                function(i) {\n                    j2 <- colmap[i, j]\n                    if (is.na(j2)) {\n                        Rle(NA, all_nrows[[i]])\n                    } else {\n                        all_objects[[i]][[j2]]\n                    }\n                }\n            )\n            tryCatch(\n                bindROWS2(all_cols[[1L]], all_cols[-1L]),\n                error=function(err) {\n                    stop(wmsg(\"failed to rbind column '\", ans_colnames[[j]],\n                              \"' across DataFrame objects:\\n  \",\n                              conditionMessage(err)))\n                }\n            )\n        }\n    )\n\n    ## Compute 'ans_nrow'.\n    ans_nrow <- sum(all_nrows)\n\n    ## Compute 'ans_rownames'.\n    if (use.names) {\n        ## Bind the rownames.\n        ans_rownames <- unlist(lapply(all_objects, rownames), use.names=FALSE)\n        if (!is.null(ans_rownames)) {\n            if (length(ans_rownames) != ans_nrow) {\n                ## What we do here is surprising and inconsistent with\n                ## ordinary data frames.\n                ## TODO: Maybe reconsider this?\n                ans_rownames <- NULL  # why?\n            }\n        }\n    } else {\n        ans_rownames <- NULL\n    }\n\n    ## Create 'x0', a 0-row DataFrame derivative of the same class as 'x'\n    ## but with all the additional columns that result from the combining\n    ## operation. Also the original metadata columns on 'x' must propagate\n    ## to 'x0'.\n    x0 <- extractROWS(x, integer(0))\n    if (length(ans_colnames) > ncol(x0)) {\n        ## It doesn't really matter what value we use here as long it's of\n        ## length zero.\n        dummy_col <- normalizeSingleBracketReplacementValue(logical(0), x0)\n        i <- (ncol(x0)+1L):length(ans_colnames)\n        ## If 'x0' carries metadata columns, 'replaceCOLS()' will take care\n        ## of extending them by appending NA-filled rows to 'mcols(x0)'.\n        ## The workhorse behind this process is also '.combine_DFrame_rows()'.\n        ## Also note that we don't care about the colnames of the object\n        ## returned by this call to 'replaceCOLS()' because they're going\n        ## to be ignored anyways.\n        x0 <- replaceCOLS(x0, i, value=dummy_col)\n    }\n    ## Sanity check. Should never fail.\n    stopifnot(ncol(x0) == length(ans_colnames))\n    ## The only reason we created 'x0' is so that we can use it here to\n    ## propagate its class and metadata columns.\n    BiocGenerics:::replaceSlots(x0, listData=ans_listData,\n                                    nrows=ans_nrow,\n                                    rownames=ans_rownames,\n                                    check=check)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### rbind()\n###\n\n### Ignore the 'ignore.mcols' argument!\n.bindROWS_DFrame_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    all_objects <- c(list(x), objects)\n    has_rows <- vapply(all_objects, nrow, integer(1L), USE.NAMES=FALSE) > 0L\n    has_cols <- vapply(all_objects, ncol, integer(1L), USE.NAMES=FALSE) > 0L\n    if (!any(has_rows)) {\n        if (!any(has_cols))\n            return(x)\n        return(all_objects[[which(has_cols)[[1L]]]])\n    }\n    all_objects <- all_objects[has_rows]\n    x <- all_objects[[1L]]\n    if (!is(x, \"DFrame\"))\n        x <- as(x, \"DFrame\")\n    objects <- all_objects[-1L]\n    .combine_DFrame_rows(x, objects,\n                         strict.colnames=TRUE,\n                         use.names=use.names, check=check)\n}\n\n### Defining bindROWS() gives us rbind().\n### FIXME: Note that .bindROWS_DFrame_objects() doesn't work on DataFrame\n### objects in general but only on those that are DFrame objects or\n### derivatives. So this method should really be defined for DFrame\n### objects, not for DataFrame objects.\nsetMethod(\"bindROWS\", \"DataFrame\", .bindROWS_DFrame_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### combineRows()\n###\n\nsetMethod(\"combineRows\", \"DataFrame\",\n    function(x, ...)\n    {\n        objects <- list(...)\n        .combine_DFrame_rows(x, objects, strict.colnames=FALSE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### combineCols() by Aaron Lun\n###\n\n.combine_DFrame_cols <- function(all_df, use.names=TRUE) {\n    # Either all DFs have rownames, or no DFs have rownames. \n    if (use.names) {\n        all_names <- lapply(all_df, rownames)\n\n        checkNames <- function(x) {\n            !is.null(x) && anyDuplicated(x)==0L\n        }\n        if (!all(vapply(all_names, checkNames, TRUE))) {\n            stop(wmsg(\"DataFrames must have non-NULL, non-duplicated rownames when 'use.names=TRUE'\"))\n        }\n\n        common <- Reduce(union, all_names)\n        all_df <- lapply(all_df, function(x) {\n            out <- x[common,,drop=FALSE]\n            rownames(out) <- common\n            out\n        })\n\n    } else {\n        out <- vapply(all_df, nrow, 0L)\n        if (length(unique(out))!=1L) {\n            stop(wmsg(\"DataFrames must have same number of rows when 'use.names=FALSE'\"))\n        }\n    }\n\n    do.call(cbind, all_df)\n}\n\nsetMethod(\"combineCols\", \"DataFrame\",\n    function(x, ..., use.names=TRUE)\n    {\n        all_df <- list(x, ...)\n        .combine_DFrame_cols(all_df, use.names=use.names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### cbind()\n###\n\n### S3/S4 combo for cbind.DataFrame\ncbind.DataFrame <- function(..., deparse.level=1)\n{\n    if (!identical(deparse.level, 1))\n        warning(wmsg(\"the cbind() method for DataFrame objects \",\n                     \"ignores the 'deparse.level' argument\"))\n    ## It's important that the call to DataFrame() below is able to deparse\n    ## the arguments in ... so for example\n    ##   b <- 11:13\n    ##   selectMethod(\"cbind\", \"DataFrame\")(b)\n    ## returns a DataFrame with a column named \"b\".\n    ## This prevents us from calling DataFrame() via do.call() e.g. we can't\n    ## do something like\n    ##   objects <- delete_NULLs(list(...))\n    ##   do.call(DataFrame, c(objects, list(check.names=FALSE)))\n    ## because then DataFrame() wouldn't be able to deparse what was in ...\n    ## and selectMethod(\"cbind\", \"DataFrame\")(b) would produce a DataFrame\n    ## with a column named \"11:13\".\n    DataFrame(..., check.names=FALSE)\n}\nsetMethod(\"cbind\", \"DataFrame\", cbind.DataFrame)\n\n### If we didn't define this method, calling c() on DataFrame objects would\n### call the \"c\" method for Vector objects, which just delegates to bindROWS()\n### so the binding would happen along the rows. This is not what we want so we\n### overwrite the \"c\" method for Vector objects with a method that binds along\n### the columns.\nsetMethod(\"c\", \"DataFrame\",\n    function(x, ..., ignore.mcols=FALSE, recursive=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.mcols))\n            stop(\"'ignore.mcols' must be TRUE or FALSE\")\n        if (!identical(recursive, FALSE))\n            stop(wmsg(\"\\\"c\\\" method for DataFrame objects \",\n                      \"does not support the 'recursive' argument\"))\n        objects <- unname(delete_NULLs(list(x, ...)))\n        ans <- do.call(cbind, objects)\n        if (ignore.mcols)\n            mcols(ans) <- NULL\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### rbind2() and cbind2()\n###\n### H.P. 4/1/2021: Do we need these methods? For what? They're not even\n### exported!\n###\n\nsetMethod(\"rbind2\", c(\"ANY\", \"DataFrame\"), function(x, y, ...) {\n  x <- as(x, \"DataFrame\")\n  rbind(x, y, ...)\n})\nsetMethod(\"rbind2\", c(\"DataFrame\", \"ANY\"), function(x, y, ...) {\n  y <- as(y, \"DataFrame\")\n  rbind(x, y, ...)\n})\nsetMethod(\"rbind2\", c(\"DataFrame\", \"DataFrame\"), function(x, y, ...) {\n  x <- as(x, \"DataFrame\")\n  y <- as(y, \"DataFrame\")\n  rbind(x, y, ...)\n})\nsetMethod(\"cbind2\", c(\"ANY\", \"DataFrame\"), function(x, y, ...) {\n  x <- as(x, \"DataFrame\")\n  cbind(x, y, ...)\n})\nsetMethod(\"cbind2\", c(\"DataFrame\", \"ANY\"), function(x, y, ...) {\n  y <- as(y, \"DataFrame\")\n  cbind(x, y, ...)\n})\nsetMethod(\"cbind2\", c(\"DataFrame\", \"DataFrame\"), function(x, y, ...) {\n  x <- as(x, \"DataFrame\")\n  y <- as(y, \"DataFrame\")\n  cbind(x, y, ...)\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### merge()\n###\n\n.mergeByHits <- function(x, y, by, all.x=FALSE, all.y=FALSE, sort = TRUE,\n                         suffixes = c(\".x\", \".y\"))\n{\n    nm.x <- colnames(x)\n    nm.y <- colnames(y)\n    cnm <- nm.x %in% nm.y\n    if (any(cnm) && nzchar(suffixes[1L]))\n        nm.x[cnm] <- paste0(nm.x[cnm], suffixes[1L])\n    cnm <- nm.y %in% nm.x\n    if (any(cnm) && nzchar(suffixes[2L]))\n        nm.y[cnm] <- paste0(nm.y[cnm], suffixes[2L])\n\n    if (all.x) {\n        x.alone <- which(countLnodeHits(by) == 0L)\n    }\n    x <- x[c(from(by), if (all.x) x.alone), , drop = FALSE]\n    if (all.y) {\n        y.alone <- which(countRnodeHits(by) == 0L)\n        xa <- x[rep.int(NA_integer_, length(y.alone)), , drop = FALSE]\n        x <- rbind(x, xa)\n    }\n    y <- y[c(to(by), if (all.x) rep.int(NA_integer_, length(x.alone)),\n             if (all.y) y.alone), , drop = FALSE]\n\n    cbind(x, y)\n}\n\nsetMethod(\"merge\", c(\"DataFrame\", \"DataFrame\"), function(x, y, by, ...) {\n    if (is(by, \"Hits\")) {\n        return(.mergeByHits(x, y, by, ...))\n    }\n    as(merge(as(x, \"data.frame\"), as(y, \"data.frame\"), by, ...), class(x))\n})\n\nsetMethod(\"merge\", c(\"data.frame\", \"DataFrame\"), function(x, y, ...) {\n  as(merge(x, as(y, \"data.frame\"), ...), class(y))\n})\n\nsetMethod(\"merge\", c(\"DataFrame\", \"data.frame\"), function(x, y, ...) {\n  as(merge(as(x, \"data.frame\"), y, ...), class(x))\n})\n\n",
        "DataFrame-comparison.R": "### =========================================================================\n### Comparing and ordering DataFrame objects\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### sameAsPreviousROW()\n###\n\n# Slightly more efficient than relying on the Vector method,\n# which would need to invoke pcompare() and related checks.\nsetMethod(\"sameAsPreviousROW\", \"DataFrame\", function(x) {\n    is.diff <- lapply(x, FUN=sameAsPreviousROW)\n    Reduce(\"&\", is.diff)\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n\n# Necessary to avoid using match,List,List-method.\nsetMethod(\"match\", c(\"DataFrame\", \"DataFrame\"), function (x, table, nomatch = NA_integer_, incomparables = NULL, ...) {\n    FUN <- selectMethod(\"match\", c(\"Vector\", \"Vector\"))\n    FUN(x, table, nomatch=nomatch, incomparables=incomparables)\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### duplicated() and unique()\n###\n### FIXME: These methods coerce to data.frame which is inefficient and also\n### I'm not sure that this guarantees to achieve the same semantic as\n### selfmatch() and other comparison methods defined in this file when the\n### DataFrame has S4 columns i.e. vector-like objects implemented as S4\n### objects. The semantic of the latter is driven by how comparison/ordering\n### is defined for the individual S4 columns while the semantic of the methods\n### below will ignore that and delagate to the semantic used to compare the\n### rows of an ordinary data.frame.\n### They also issue an annoying warning:\n###   > duplicated(DataFrame(aa=IRanges(c(1:5, 1:0), 6)))\n###   [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n###   Warning message:\n###   In .local(x, row.names, optional, ...) : 'optional' argument was ignored\n\n### S3/S4 combo for duplicated.DataFrame\nduplicated.DataFrame <- function(x, incomparables=FALSE, fromLast=FALSE, ...)\n{\n    duplicated(as(x, \"data.frame\"),\n               incomparables=incomparables, fromLast=fromLast, ...)\n}\nsetMethod(\"duplicated\", \"DataFrame\", duplicated.DataFrame)\n\n### S3/S4 combo for unique.DataFrame\nunique.DataFrame <- unique.data.frame\nsetMethod(\"unique\", \"DataFrame\", unique.DataFrame)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### order() & sort()\n###\n\nsetMethod(\"order\", \"DataFrame\", function(..., na.last = TRUE, decreasing = FALSE, method = c(\"auto\", \"shell\", \"radix\")) {\n    contents <- as.list(cbind(...))\n    do.call(order, c(contents, list(na.last=na.last, decreasing=decreasing, method=method)))\n})\n\n### S3/S4 combo for sort.DataFrame\nsort.DataFrame <- sort.Vector\nsetMethod(\"sort\", \"DataFrame\", sort.DataFrame)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompare()\n###\n\nsetMethod(\"pcompare\", c(\"DataFrame\", \"DataFrame\"), function(x, y) {\n    fields <- colnames(x)\n    N <- max(NROW(x), NROW(y))\n    if (!identical(sort(fields), sort(colnames(y)))) {\n        return(logical(N))\n    }\n\n    compared <- integer(N)\n    for (f in fields) {\n        current <- pcompare(x[[f]], y[[f]])\n        keep <- compared==0L\n        compared[keep] <- current[keep]\n    }\n\n    compared\n})\n\n# Necessary to avoid using Ops for Lists.\nsetMethod(\"==\", c(\"DataFrame\", \"DataFrame\"), function(e1, e2) pcompare(e1, e2) == 0L)\n\nsetMethod(\"<=\", c(\"DataFrame\", \"DataFrame\"), function(e1, e2) pcompare(e1, e2) <= 0L)\n\n",
        "DataFrame-utils.R": "### =========================================================================\n### DataFrame utilities\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Splitting\n###\n\n.relistToClass_DataFrame <- function(x)\n{\n    ## Technically speaking IRanges is not strictly needed for the sole\n    ## purpose of returning class name \"CompressedSplitDFrameList\" but\n    ## we'd rather return the name of a class that actually exists from\n    ## a user point of view.\n    if (!requireNamespace(\"IRanges\", quietly=TRUE))\n        stop(wmsg(\"Couldn't load the IRanges package. Please install \",\n                  \"the IRanges package before you try to relist or \",\n                  \"split a data.frame.\"))\n    \"CompressedSplitDFrameList\"\n}\n\nsetMethod(\"relistToClass\", \"DataFrame\", .relistToClass_DataFrame)\n\nsetMethod(\"relistToClass\", \"data.frame\", .relistToClass_DataFrame)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting based on NA content\n###\n\n### FIXME: na.omit() and na.exclude() set non-slot attributes,\n###        and will fail with things like Rle.\nsetMethod(\"na.omit\", \"DataFrame\",\n          function(object, ...) {\n            attr(object, \"row.names\") <- rownames(object)\n            object.omit <- stats:::na.omit.data.frame(object)\n            attr(object.omit, \"row.names\") <- NULL\n            object.omit\n          })\n\nsetMethod(\"na.exclude\", \"DataFrame\",\n          function(object, ...) {\n            attr(object, \"row.names\") <- rownames(object)\n            object.ex <- stats:::na.exclude.data.frame(object)\n            attr(object.ex, \"row.names\") <- NULL\n            object.ex\n          })\n\nsetMethod(\"is.na\", \"DataFrame\", function(x) {\n  na <- do.call(cbind, lapply(seq(ncol(x)), function(xi) decode(is.na(x[[xi]]))))\n  rownames(na) <- rownames(x)\n  na\n})\n\nsetMethod(\"complete.cases\", \"DataFrame\", function(...) {\n  args <- list(...)\n  if (length(args) == 1) {\n    x <- args[[1L]]\n    rowSums(is.na(x)) == 0\n  } else complete.cases(args[[1L]]) & do.call(complete.cases, args[-1L])\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Transforming\n###\n\nsetReplaceMethod(\"column\", \"DataFrame\", function(x, name, value) {\n    x[,name] <- value\n    x\n})\n\n### S3/S4 combo for transform.DataFrame\ntransform.DataFrame <- transformColumns\nsetMethod(\"transform\", \"DataFrame\", transform.DataFrame)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Statistical routines\n###\n\nsetMethod(\"xtabs\", signature(data = \"DataFrame\"),\n          function(formula = ~., data, subset, na.action, exclude = c(NA, NaN),\n                   drop.unused.levels = FALSE)\n          {\n            data <- as(data, \"data.frame\")\n            callGeneric()\n          })\n\nsetMethod(\"table\", \"DataFrame\", function(...) {\n  table(as.list(cbind(...)))\n})\n\n## TODO: lm, glm, loess, ...\n\n",
        "DataFrameFactor-class.R": "setClass(\"DataFrameFactor\", contains=\"Factor\", slots=c(levels=\"DataFrame\"))\n\nDataFrameFactor <- function(x, levels, index = NULL, ...) {\n    if (is.null(index)) {\n        levels <- sort(unique(x))\n        index <- match(x, levels)\n        names(index) <- rownames(x)\n    }\n    out <- Factor(levels=seq_len(nrow(levels)), index=index, ...)\n    out@levels <- levels\n    as(out, \"DataFrameFactor\")\n}\n\nsetMethod(\"dim\", \"DataFrameFactor\", function(x) c(length(x), ncol(levels(x))))\n\nsetMethod(\"dimnames\", \"DataFrameFactor\", function(x) list(names(x), colnames(levels(x))))\n\nsetMethod(\"$\", \"DataFrameFactor\", function(x, name) levels(x)[as.integer(x),name])\n\nsetMethod(\"[\", \"DataFrameFactor\", function(x, i, j, ..., drop=TRUE) {\n    if (!missing(i)) {\n        x <- callNextMethod()\n    }\n\n    if (!missing(j)) {\n        x@levels <- levels(x)[,j,drop=FALSE]\n    }\n\n    if (drop && ncol(levels(x))==1L) {\n        x <- levels(x)[as.integer(x),1]\n    }\n\n    x\n})\n\nsetMethod(\"show\", \"DataFrameFactor\", function(object) {\n    callNextMethod()\n    coolcat(\"colnames(%i): %s\\n\", colnames(object))\n})\n",
        "DataFrame_OR_NULL-class.R": "### =========================================================================\n### The DataFrame_OR_NULL class\n### -------------------------------------------------------------------------\n\n### At this point the DataFrame class is not defined yet so we cannot\n### include it in the DataFrame_OR_NULL union. We'll add it later with\n### setIs() (see DataFrame-class.R).\n### The reason we need to define DataFrame_OR_NULL so early (i.e. before\n### DataFrame) is because we use it in the definition of the Vector class\n### (for the specification of the elementMetadata slot) so it needs to be\n### defined **before** Vector. However DataFrame extends Vector (via\n### SimpleList and List) so needs to be defined **after** Vector.\n\nsetClassUnion(\"DataFrame_OR_NULL\", \"NULL\")\n\n",
        "Factor-class.R": "### =========================================================================\n### Factor objects\n### -------------------------------------------------------------------------\n###\n### The Factor class serves a similar role as factor in base R except that\n### the levels of a Factor object can be any vector-like object.\n### Note that Factor objects don't support NAs at the moment!\n###\n\nsetClassUnion(\"integer_OR_raw\", c(\"integer\", \"raw\"))\n\nsetClass(\"Factor\",\n    contains=\"Vector\",\n    representation(\n        levels=\"vector_OR_Vector\",  # Will also accept a factor! (see\n                                    # Vector-class.R)\n        index=\"integer_OR_raw\"      # No NAs for now.\n    ),\n    prototype(\n        index=raw(0)\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See Vector-class.R file\n### for what slots should or should not be considered \"parallel\".\nsetMethod(\"parallel_slot_names\", \"Factor\",\n    function(x) c(\"index\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.validate_levels_slot <- function(x)\n{\n    if (!is(x@levels, \"vector_OR_Vector\"))\n        return(\"'levels' slot must be a vector_OR_Vector derivative\")\n    if (anyDuplicated(x@levels))\n        return(\"'levels' slot contains duplicates\")\n    TRUE\n}\n\n.validate_index_slot <- function(x)\n{\n    if (!(is.integer(x@index) || is.raw(x@index)))\n        return(\"'index' slot must be an integer vector or raw vector\")\n    if (length(x@index) == 0L)\n        return(TRUE)\n\n    ## Check that all values in 'index' are >= 1 and <= nlevels.\n    ## We will compute 'min(index)' and 'max(index)' for that\n    ## which is slightly more efficient than doing something\n    ## like 'all(index >= 1L) && all(index <= nlevels)'.\n    ## Also, surprisingly, calling min() and max() separately is much\n    ## faster than using range().\n\n    nlevels <- NROW(x@levels)\n    x_index <- x@index\n    ## min() and max() don't work on raw vectors.\n    if (is.raw(x_index))\n        x_index <- as.integer(x_index)\n    index_min <- min(x_index)\n    ## Factor objects don't support NAs at the moment.\n    if (is.na(index_min))\n        return(c(\"'index' slot contains NAs (but Factor \",\n                 \"objects don't support NAs at the moment)\"))\n    index_max <- max(x_index)\n    if (index_min < 1L || index_max > nlevels)\n        return(\"'index' slot contains out-of-bounds indices\")\n    TRUE\n}\n\n.validate_Factor <- function(x)\n{\n    msg <- .validate_levels_slot(x)\n    if (!isTRUE(msg))\n        return(msg)\n    msg <- .validate_index_slot(x)\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\n\nsetValidity2(\"Factor\", .validate_Factor)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### Kind of follows the naming style of the relistToClass() generic. Yes,\n### ugly names, I know :-/\n### TODO: Maybe rename these generics class_after_relist() and\n### class_after_Factor()? Or target_class_for_relist() and\n### target_class_for_Factor()?\nsetGeneric(\"FactorToClass\", function(x) standardGeneric(\"FactorToClass\"))\n\nsetMethod(\"FactorToClass\", \"vector_OR_Vector\", function(x) \"Factor\")\n\n.infer_Factor_class <- function(x, levels)\n{\n    if (!missing(levels))\n        return(FactorToClass(levels))\n    if (!missing(x))\n        return(FactorToClass(x))\n    stop(wmsg(\"at least 'x' or 'levels' must be specified\"))\n}\n\n### Preserves the names.\n.set_index_storage_mode <- function(index, levels)\n{\n    ## We use `storage.mode<-` instead of as.*(), to preserve the names.\n    if (NROW(levels) <= 255L) {\n        if (storage.mode(index) != \"raw\")\n            storage.mode(index) <- \"raw\"\n    } else {\n        if (storage.mode(index) != \"integer\")\n            storage.mode(index) <- \"integer\"\n    }\n    index\n}\n\n.encode_as_Factor <- function(x, levels, mcols=NULL, Class=\"Factor\")\n{\n    if (missing(levels)) {\n        levels <- unique(x)\n        check <- FALSE\n    } else {\n        check <- TRUE\n    }\n    index <- match(x, levels)\n    if (check && anyNA(index))\n        stop(wmsg(\"Factor objects don't support NAs at the moment so \",\n                  \"every element in 'x' must be represented in 'levels'\"))\n    index <- .set_index_storage_mode(index, levels)\n    x_names <- ROWNAMES(x)\n    if (!is.null(x_names))\n        names(index) <- x_names\n    if (!is.null(mcols)) {\n        mcols <- normarg_mcols(mcols, Class, length(index))\n    } else if (is(x, \"Vector\")) {\n        mcols <- mcols(x, use.names=FALSE)\n    }\n    new2(Class, levels=levels, index=index, elementMetadata=mcols, check=check)\n}\n\n### One of 'x' or 'levels' can be missing, but not both.\n.new_Factor <- function(x, levels, index=NULL, mcols=NULL, Class=\"Factor\")\n{\n    if (is.null(index)) {\n        ## 'index' is not specified.\n        if (!missing(x)) {\n            ans <- .encode_as_Factor(x, levels, mcols=mcols, Class=Class)\n            return(ans)\n        }\n        ## Factor(levels=levels)\n        index <- .set_index_storage_mode(raw(0), levels)\n    } else {\n        ## 'index' is specified.\n        if (!missing(x)) {\n            if (!missing(levels))  # Factor(x, levels, index)\n                stop(wmsg(\"at most two out of the 'x', 'levels', and 'index' \",\n                          \"arguments can be specified\"))\n            ## Factor(x, index=index)\n            levels <- x\n        }\n        if (!is.raw(index)) {\n            if (!is.numeric(index))\n                stop(wmsg(\"'index' must be an integer vector or raw vector\"))\n            ## We use `storage.mode<-` instead of as.integer(), to preserve\n            ## the names.\n            if (storage.mode(index) != \"integer\")\n                storage.mode(index) <- \"integer\"\n        }\n    }\n    mcols <- normarg_mcols(mcols, Class, length(index))\n    new2(Class, levels=levels, index=index, elementMetadata=mcols, check=TRUE)\n}\n\nFactor <- function(x, levels, index=NULL, ...)\n{\n    Class <- .infer_Factor_class(x, levels)\n    if (length(list(...)) == 0L) {\n        mcols <- NULL\n    } else {\n        mcols <- DataFrame(..., check.names=FALSE)\n    }\n    .new_Factor(x, levels, index=index, mcols=mcols, Class=Class)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"names\", \"Factor\", function(x) names(x@index))\n\nsetReplaceMethod(\"names\", \"Factor\",\n    function(x, value)\n    {\n        names(x@index) <- value\n        x\n    }\n)\n\n### base::levels() works out-of-the-box but base::`levels<-` does NOT.\n### Unlike base::`levels<-`, the method below supports reduction of the number\n### of levels.\nsetReplaceMethod(\"levels\", \"Factor\",\n    function(x, value)\n    {\n        x@levels <- value\n        ## We must validate 'x' **before** calling .set_index_storage_mode().\n        ## This will validate the supplied levels, and, in case the number of\n        ## levels went down, will ensure that it remains >= 'max(x@index)'.\n        validObject(x)\n        x@index <- .set_index_storage_mode(x@index, x@levels)\n        x\n    }\n)\n\n### base::nlevels(x) returns 'length(levels(x))' so we need to override it.\nsetMethod(\"nlevels\", \"Factor\", function(x) NROW(x@levels))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### droplevels()\n###\n\n.droplevels.Factor <- function(x)\n{\n    x_nlevels <- nlevels(x)\n    lvl_ranks <- seq_len(x_nlevels)\n    x_index <- .set_index_storage_mode(x@index, lvl_ranks)\n    if (is.raw(x_index))\n        lvl_ranks <- as.raw(lvl_ranks)\n    keep_ix <- which(lvl_ranks %in% x_index)\n    new_levels <- x@levels[keep_ix]\n    new_index <- match(x_index, keep_ix)\n    new_index <- .set_index_storage_mode(new_index, new_levels)\n    names(new_index) <- names(x@index)\n    BiocGenerics:::replaceSlots(x, levels=new_levels,\n                                   index=new_index,\n                                   check=FALSE)\n}\n\n### S3/S4 combo for droplevels.Factor\ndroplevels.Factor <- function(x, ...) .droplevels.Factor(x, ...)\nsetMethod(\"droplevels\", \"Factor\", droplevels.Factor)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unfactor()\n###\n\nsetGeneric(\"unfactor\", signature=\"x\",\n    function(x, use.names=TRUE, ignore.mcols=FALSE) standardGeneric(\"unfactor\")\n)\n\nsetMethod(\"unfactor\", \"factor\",\n    function(x, use.names=TRUE, ignore.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        if (!identical(ignore.mcols, FALSE))\n            warning(wmsg(\"the 'ignore.mcols' argument is ignored \",\n                         \"when calling unfactor() on a factor\"))\n        ans <- as.character(x)\n        if (use.names)\n            names(ans) <- names(x)\n        ans\n    }\n)\n\n### Use same logic as set_unlisted_names() (see R/List-class.R).\n.set_names_on_unfactor_ans <- function(ans, x_names)\n{\n    if (is.null(x_names))\n        return(ans)\n    if (length(dim(ans)) < 2L) {\n        res <- try(names(ans) <- x_names, silent=TRUE)\n        what <- \"names\"\n    } else {\n        res <- try(rownames(ans) <- x_names, silent=TRUE)\n        what <- \"rownames\"\n    }\n    if (is(res, \"try-error\"))\n        warning(wmsg(\"failed to set \", what, \" on the result of unfactor() \",\n                     \"(you can use unfactor(..., use.names=FALSE) to avoid \",\n                     \"this warning)\"))\n    ans\n}\n\nsetMethod(\"unfactor\", \"Factor\",\n    function(x, use.names=TRUE, ignore.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        if (!isTRUEorFALSE(ignore.mcols))\n            stop(wmsg(\"'ignore.mcols' must be TRUE or FALSE\"))\n        ans <- extractROWS(x@levels, as.integer(x@index))\n        if (use.names)\n            ans <- .set_names_on_unfactor_ans(ans, names(x))\n        if (!ignore.mcols && is(ans, \"Vector\"))\n            mcols(ans) <- mcols(x, use.names=FALSE)\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### 'as(x, \"Factor\")' is the same as 'Factor(x)' WITH 2 IMPORTANT EXCEPTIONS:\n###   (1) If 'x' is an ordinary factor, 'as(x, \"Factor\")' returns a Factor\n###       with the same levels, encoding, and names, as 'x'.\n###       Note that after coercing an ordinary factor to Factor, going back\n###       to factor again (with as.factor()) restores the original object\n###       with no loss.\n###   (2) If 'x' is a Factor object, 'as(x, \"Factor\")' is either a no-op\n###       (when 'x' is a Factor **instance**), or a demotion to Factor\n###       (when 'x' is a Factor derivative like GRangesFactor).\nsetAs(\"vector_OR_Vector\", \"Factor\",\n    function(from) .encode_as_Factor(from, Class=FactorToClass(from))\n)\n\n### Implement exception (1) (see above).\nsetAs(\"factor\", \"Factor\",\n    function(from)\n    {\n        if (anyNA(from))\n            stop(wmsg(\"coercing an ordinary factor with NAs to Factor \",\n                      \"is not supported at the moment\"))\n        ans_levels <- levels(from)\n        ans_index <- .set_index_storage_mode(as.integer(from), ans_levels)\n        names(ans_index) <- names(from)\n        ## In order to be as fast as possible and skip validation, we\n        ## don't use 'Factor(levels=ans_levels, index=ans_index)'.\n        new2(\"Factor\", levels=ans_levels, index=ans_index, check=FALSE)\n    }\n)\n\n### Propagates the names.\nsetMethod(\"as.factor\", \"Factor\",\n    function(x)\n    {\n        ans <- as.integer(x)\n        attributes(ans) <- list(levels=as.character(levels(x)),\n                                class=\"factor\",\n                                names=names(x))\n        ans\n    }\n)\n\n### Propagates the names. Note that this is a slight inconsistency with\n### what as.integer() does on an ordinary factor.\nsetMethod(\"as.integer\", \"Factor\",\n    function(x)\n    {\n        index <- x@index\n        ## We use `storage.mode<-` instead of as.integer(), to preserve\n        ## the names.\n        if (storage.mode(index) != \"integer\")\n            storage.mode(index) <- \"integer\"\n        index\n    }\n)\n\n### Propagates the names. Note that this is a slight inconsistency with\n### what as.raw() does on an ordinary factor.\nsetMethod(\"as.raw\", \"Factor\",\n    function(x)\n    {\n        index <- x@index\n        ## We use `storage.mode<-` instead of as.raw(), to preserve\n        ## the names.\n        if (storage.mode(index) != \"raw\")\n            storage.mode(index) <- \"raw\"\n        index\n    }\n)\n\nsetMethod(\"as.character\", \"Factor\",\n    function(x)\n    {\n        ## 'unfactor(as.factor(x))' and 'as.character(unfactor(x))' are\n        ## semantically equivalent. However, depending on whether 'length(x)'\n        ## is > 'nlevels(x)' one will be more performant than the other.\n        if (length(x) > nlevels(x)) {\n            unfactor(as.factor(x))\n        } else {\n            as.character(unfactor(x, ignore.mcols=TRUE))\n        }\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show\n###\n\n.show_Factor <- function(x)\n{\n    cat(summary(x), \"\\n\", sep=\"\")\n    x_levels <- levels(x)\n    x_nlevels <- NROW(x_levels)\n    cat(\"Levels:\", class(x_levels), \"object \")\n    if (length(dim(x_levels)) < 2L) {\n        cat(\"of length\", x_nlevels)\n    } else {\n        cat(\"with\", x_nlevels, if (x_nlevels == 1L) \"row\" else \"rows\")\n    }\n    cat(\"\\n\")\n}\n\nsetMethod(\"show\", \"Factor\", function(object) .show_Factor(object))\n\nsetMethod(\"showAsCell\", \"Factor\",\n    function(object)\n        showAsCell(unfactor(object, use.names=FALSE, ignore.mcols=TRUE))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n### Returns TRUE if Factor objects 'x' and 'y' have the same levels in\n### the same order.\n### Note that using 'identical(x@levels, y@levels)' for this would be too\n### strigent e.g. it would also compare the names or/and metadata columns\n### of 'x@levels' and 'y@levels'. Furthermore, identical() is not reliable\n### in general e.g. it can produce false positives on objects that use\n### external pointers internally like DNAStringSet objects.\n.same_levels <- function(x_levels, y_levels)\n{\n    if (class(x_levels) != class(y_levels))\n        return(FALSE)\n    x_levels_dim <- dim(x_levels)\n    y_levels_dim <- dim(y_levels)\n    if (!identical(x_levels_dim, y_levels_dim))\n        return(FALSE)\n    if (is.null(x_levels_dim) && NROW(x_levels) != NROW(y_levels))\n        return(FALSE)\n    all(x_levels == y_levels)\n}\n\n### We trust that 'x' and 'y' are Factor objects. No need to check this.\n### Does NOT validate the result.\n.concatenate_two_Factor_objects <- function(x, y, use.names=TRUE,\n                                                  ignore.mcols=FALSE)\n{\n    ## 1. Take care of the parallel slots\n\n    ## Use bindROWS_Vector_objects() to concatenate parallel slots \"index\"\n    ## and \"elementMetadata\". Note that the resulting 'ans' can be an invalid\n    ## Factor instance e.g. some indices in 'ans@index' can be wrong if\n    ## 'x' and 'y' don't have the same levels. We'll fix this in 4. below.\n    ans <- bindROWS_Vector_objects(x, list(y), use.names=FALSE,\n                                               ignore.mcols=ignore.mcols,\n                                               check=FALSE)\n\n    ## 2. Expedite a common situation\n\n    if (.same_levels(x@levels, y@levels))\n        return(ans)  # all indices in 'ans@index' are correct\n\n    ## 3. Combine levels of 'x' and 'y'\n\n    m <- match(y@levels, x@levels)\n    na_idx <- which(is.na(m))\n    ans_levels <- bindROWS(x@levels, list(extractROWS(y@levels, na_idx)))\n\n    ## 4. Compute 'ans_index'\n\n    m[na_idx] <- NROW(x@levels) + seq_along(na_idx)\n    new_y_index <- m[as.integer(y@index)]\n\n    x_index <- .set_index_storage_mode(x@index, ans_levels)\n    new_y_index <- .set_index_storage_mode(new_y_index, ans_levels)\n    if (use.names) {\n        names(new_y_index) <- names(y@index)\n    } else {\n        names(x_index) <- NULL\n    }\n    ans_index <- c(x_index, new_y_index)\n\n    BiocGenerics:::replaceSlots(ans, levels=ans_levels,\n                                     index=ans_index,\n                                     check=FALSE)\n}\n\n.bindROWS_Factor_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(ignore.mcols))\n        stop(wmsg(\"'ignore.mcols' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(check))\n        stop(wmsg(\"'check' must be TRUE or FALSE\"))\n\n    objects <- prepare_objects_to_bind(x, objects)\n    for (object in objects)\n        x <- .concatenate_two_Factor_objects(x, object,\n                                             use.names=use.names,\n                                             ignore.mcols=ignore.mcols)\n    if (check)\n        validObject(x)\n    x\n}\n\nsetMethod(\"bindROWS\", \"Factor\", .bindROWS_Factor_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Comparing and ordering\n###\n\n.two_factor_comparison <- function(x, y, unfactored.FUN, combined.FUN, ...) {\n    if (max(length(x), length(y)) < max(length(x@levels), length(y@levels))) {\n        x <- unfactor(x, use.names = FALSE, ignore.mcols = TRUE)\n        y <- unfactor(y, use.names = FALSE, ignore.mcols = TRUE)\n        unfactored.FUN(x, y, ...)\n    } else {\n        if (!.same_levels(x@levels, y@levels)) {\n            combined <- c(x, y)\n            x <- head(combined, length(x))\n            y <- tail(combined, length(y))\n        }\n        combined.FUN(x, y, ...)\n    }\n}\n\nsetMethod(\"pcompare\", c(\"Factor\", \"Factor\"),\n    function(x, y)\n    {\n        .two_factor_comparison(x, y,\n            unfactored.FUN=pcompare,\n            combined.FUN=function(x, y) {\n                i <- xtfrm(x@levels)\n                pcompare(i[as.integer(x)], i[as.integer(y)])\n            }\n        )\n    }\n)\n\nsetMethod(\"match\", c(\"Factor\", \"Factor\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n    {\n        .two_factor_comparison(x, table,\n            unfactored.FUN=match,\n            combined.FUN=function(x, table, ...) {\n                match(as.integer(x), as.integer(table), ...)\n            },\n            nomatch=nomatch, incomparables=incomparables, ...\n        )\n    }\n)\n\nsetMethod(\"selfmatch\", \"Factor\",\n    function(x, ...)\n    {\n        x <- x@index\n        callGeneric()\n    }\n)\n\nsetMethod(\"xtfrm\", \"Factor\", function(x) xtfrm(x@levels)[as.integer(x@index)])\n\n",
        "FilterRules-class.R": "### =========================================================================\n### FilterRules objects\n### -------------------------------------------------------------------------\n\nsetClassUnion(\"expression_OR_function\", c(\"expression\", \"function\"))\n\nsetClass(\"FilterRules\", representation(active = \"logical\"),\n         prototype(elementType = \"expression_OR_function\"),\n         contains = \"SimpleList\")\n\nsetMethod(\"parallel_slot_names\", \"FilterRules\",\n          function(x) c(\"active\", callNextMethod()))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors.\n###\n\nsetGeneric(\"active\", function(x) standardGeneric(\"active\"))\n\nsetMethod(\"active\", \"FilterRules\", function(x) {\n  a <- x@active\n  names(a) <- names(x)\n  a\n})\n\nsetGeneric(\"active<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"active<-\")\n)\n\nsetReplaceMethod(\"active\", \"FilterRules\", function(x, value) {\n  if (is.numeric(value)) {\n    value <- as.integer(value)[!is.na(value)]\n    if (any(value < 1) || any(value > length(x)))\n      stop(\"filter index out of range\")\n    value <- names(x)[value]\n  }\n  if (is.character(value)) {\n    value <- value[!is.na(value)] ## NA's are dropped\n    filterNames <- names(x)\n    if (length(filterNames) == 0)\n      stop(\"there are no filter names\")\n    if (any(!(value %in% filterNames)))\n      stop(\"'value' contains invalid filter names\")\n    x@active <- filterNames %in% value\n    x\n  } else if (is.logical(value)) {\n    nfilters <- length(x)\n    if (length(value) > nfilters)\n      stop(\"length of 'value' must not be greater than that of 'filters'\")\n    if (anyMissing(value))\n      stop(\"'value' cannot contain NA's\")\n    if (nfilters && (nfilters %% length(value) != 0))\n      stop(\"number of filters not a multiple of 'value' length\")\n    x@active <- rep(value, length.out = nfilters)\n    x\n  } else stop(\"unsupported type of 'value'\")\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor.\n###\n\nFilterRules.parseRule <- function(expr) {\n  if (is.character(expr)) {\n    expr <- try(parse(text = expr, srcfile = NULL), silent = TRUE)\n    if (is.character(expr))\n      stop(\"failed to parse filter expression: \", expr)\n    expr\n  } else if (is.language(expr) || is.logical(expr))\n    as.expression(expr)\n  else if (is.function(expr))\n    as(expr, \"FilterClosure\")\n  else stop(\"would not evaluate to logical: \", expr)\n}\n\n## takes logical expressions, character vectors, or functions to parse\n\nFilterRules <- function(exprs = list(), ..., active = TRUE) {\n  exprs <- c(exprs, as.list(substitute(list(...)))[-1L])\n  if (length(names(exprs)) == 0) {\n    funs <- as.logical(sapply(exprs, is.function))\n    nonfuns <- exprs[!funs]\n    names(nonfuns) <- unlist(lapply(nonfuns, deparse))\n    chars <- as.logical(sapply(nonfuns, is.character))\n    names(nonfuns)[chars] <- unlist(nonfuns[chars])\n    names(exprs)[!funs] <- names(nonfuns)\n  }\n  exprs <- lapply(exprs, FilterRules.parseRule)\n\n  active <- rep(active, length.out = length(exprs))\n\n  if (!is.logical(active) || anyMissing(active))\n    stop(\"'active' must be logical without any missing values\")\n  if (length(active) > length(exprs))\n    stop(\"length of 'active' is greater than number of rules\")\n  if (length(exprs) && length(exprs) %% length(active) > 0)\n    stop(\"number of rules must be a multiple of length of 'active'\")\n\n  ans <- new_SimpleList_from_list(\"FilterRules\", exprs,\n                                  active = active)\n  validObject(ans)\n  ans\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"ANY\", \"FilterRules\", function(from) FilterRules(from))\n\n### Coercion from SimpleList to FilterRules works out-of-the-box but silently\n### returns a broken object! The problem is that this coercion is performed by\n### one of the dummy coercion methods that are automatically defined by the\n### methods package and that often do the wrong thing (like here). Furthermore,\n### they don't bother to validate the object they return. So we overwrite it.\nsetAs(\"SimpleList\", \"FilterRules\", function(from) FilterRules(from))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting.\n###\n\nsetReplaceMethod(\"[[\", \"FilterRules\",\n                 function(x, i, j, ..., value)\n                 {\n                   if (!missing(j) || length(list(...)) > 0)\n                     warning(\"arguments beyond 'i' ignored\")\n                   if (missing(i))\n                     stop(\"subscript is missing\")\n                   rule <- FilterRules.parseRule(value)\n                   x <- callNextMethod(x, i, value = rule)\n                   if (is.numeric(i) && is.character(value))\n                     names(x)[i] <- value\n                   active <- x@active ## in case we expanded\n                   names(active) <- names(x)[seq_along(active)]\n                   active[[i]] <- TRUE\n                   names(active) <- NULL\n                   x@active <- active\n                   x\n                 })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Combination\n###\n\nsetMethod(\"&\", c(\"FilterRules\", \"FilterRules\"), function(e1, e2) {\n    c(e1, e2)\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.FilterRules.active <- function(x) {\n  if (length(active(x)) != length(x))\n    \"length of 'active' must match length of 'filters'\"\n  else if (!identical(names(active(x)), names(x)))\n    \"names of 'active' must match those of 'filters'\"\n  else if (anyMissing(active(x)))\n    \"'active' cannot contain NA's\"\n  else NULL\n}\n\n.valid.FilterRules.rules <- function(x) {\n  unlist(lapply(x, function(rule) {\n    if (is.function(rule) && length(formals(rule)) < 1)\n      \"function rule must take at least one parameter\"\n    else NULL\n  }))\n}\n\n.valid.FilterRules <- function(x)\n  c(.valid.FilterRules.active(x), .valid.FilterRules.rules(x))\n\nsetValidity2(\"FilterRules\", .valid.FilterRules)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Evaluating\n###\n\nsetMethod(\"eval\", signature(expr=\"FilterRules\", envir=\"ANY\"),\n          function(expr, envir = parent.frame(),\n                   enclos = if(is.list(envir) || is.pairlist(envir))\n                   parent.frame() else baseenv())\n          {\n            result <- rep.int(TRUE, NROW(envir))\n            rules <- as.list(expr)[active(expr)]\n            for (i in seq_along(rules)) {\n              rule <- rules[[i]]\n              val <- tryCatch(if (is.expression(rule))\n                                  eval(rule, envir, enclos)\n                              else rule(envir),\n                              error = function(e) {\n                                  stop(\"Filter '\", names(rules)[i], \"' failed: \",\n                                       e$message)\n                              })\n              if (is(val, \"Rle\"))\n                val <- as.vector(val)\n              if (!is.logical(val))\n                stop(\"filter rule evaluated to non-logical: \",\n                     names(rules)[i])\n              if ((NROW(envir) == 0L && length(val) > 0L) ||\n                  (NROW(envir) > 0L && length(val) == 0L) || \n                  (NROW(envir) > 0L &&\n                   (max(NROW(envir), length(val)) %%\n                    min(NROW(envir), length(val)) != 0)))\n                stop(\"filter rule evaluated to inconsistent length: \",\n                     names(rule)[i])\n              if (anyNA(val)) {\n                  val[is.na(val)] <- FALSE\n              }\n              if (length(rules) > 1L)\n                envir <- extractROWS(envir, val)\n              result[result] <- val\n            }\n            result\n          })\n\nsetGeneric(\"evalSeparately\",\n           function(expr, envir = parent.frame(),\n                    enclos = if (is.list(envir) ||\n                      is.pairlist(envir)) parent.frame() else baseenv(),\n                    ...)\n           standardGeneric(\"evalSeparately\"))\n\nsetMethod(\"evalSeparately\", \"FilterRules\",\n          function(expr, envir = parent.frame(),\n                   enclos = if (is.list(envir) ||\n                     is.pairlist(envir)) parent.frame() else baseenv(),\n                   serial = FALSE)\n          {\n            if (!isTRUEorFALSE(serial))\n              stop(\"'serial' must be TRUE or FALSE\")\n            inds <- seq_len(length(expr))\n            names(inds) <- names(expr)\n            passed <- rep.int(TRUE, NROW(envir))\n            m <- do.call(cbind, lapply(inds, function(i) {\n              result <- eval(expr[i], envir = envir, enclos = enclos)\n              if (serial) {\n                envir <<- subset(envir, .(result))\n                passed[passed] <<- result\n                passed\n              } else result\n            }))\n            FilterMatrix(matrix = m, filterRules = expr)\n          })\n\nsetGeneric(\"subsetByFilter\",\n           function(x, filter, ...) standardGeneric(\"subsetByFilter\"))\n\nsetMethod(\"subsetByFilter\", c(\"ANY\", \"FilterRules\"), function(x, filter) {\n  extractROWS(x, eval(filter, x))\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Summary\n###\n\nsetMethod(\"summary\", \"FilterRules\",\n          function(object, subject, serial = FALSE, discarded = FALSE,\n                   percent = FALSE)\n          {\n            if (!isTRUEorFALSE(serial))\n              stop(\"'serial' must be TRUE or FALSE\")\n            mat <- evalSeparately(object, subject, serial = serial)\n            summary(mat, discarded = discarded, percent = percent)\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### FilterRule closures\n###\n\nsetClass(\"FilterClosure\", contains = \"function\")\n\nsetClass(\"GenericFilterClosure\", contains = \"FilterClosure\")\n\nsetClass(\"StandardGenericFilterClosure\",\n         contains = c(\"GenericFilterClosure\", \"standardGeneric\"))\n\nsetAs(\"standardGeneric\", \"FilterClosure\", function(from) {\n          new(\"StandardGenericFilterClosure\", from)\n      })\n\nsetAs(\"function\", \"FilterClosure\", function(from) {\n          new(\"FilterClosure\", from)\n      })\n\nsetGeneric(\"params\", function(x, ...) standardGeneric(\"params\"))\n\nsetMethod(\"params\", \"FilterClosure\", \n          function(x) {\n            as.list(environment(x))\n          })\n\nsetMethod(\"show\", \"FilterClosure\", function(object) {\n  p <- params(object)\n  cat(\"filter (\",\n      paste(names(p), \"=\", sapply(p, deparse, control = NULL),\n            collapse = \", \"),\n      \")\\n\", sep = \"\")\n  print(body(object))\n})\n\n### ------------------------------------------------------------------------- \n### FilterResults: coordinates results from multiple filters \n###\n\nsetClass(\"FilterResults\",\n         representation(filterRules = \"FilterRules\"))\n\n.valid.FilterMatrix <- function(object)\n{\n  c(if (!is.logical(object))\n      \"values must be logical\",\n    if (!is.null(names(filterRules)))\n      \"filterRules must not be named\",\n    if (length(object@filterRules) != ncol(object))\n      \"length(filterRules) must equal ncol(object)\") \n}\n\nsetClass(\"FilterMatrix\", \n         contains = c(\"matrix\", \"FilterResults\"),\n         validity = .valid.FilterMatrix)\n\nsetGeneric(\"filterRules\", function(x, ...) standardGeneric(\"filterRules\"))\n\nsetMethod(\"filterRules\", \"FilterResults\", function(x) {\n  setNames(x@filterRules, colnames(x))\n})\n\nsetMethod(\"[\", \"FilterMatrix\", function(x, i, j, ..., drop = TRUE) {\n  if (!missing(i))\n    i <- as.vector(i)\n  if (!missing(j))\n    j <- as.vector(j)\n  ans <- callNextMethod()\n  if (is.matrix(ans)) {\n    filterRules <- filterRules(x)\n    if (!missing(j))\n      filterRules <- filterRules[j]\n    ans <- FilterMatrix(matrix = ans, filterRules = filterRules)\n  }\n  ans\n})\n\nsetMethod(\"rbind\", \"FilterMatrix\", function(..., deparse.level = 1) {\n  args <- list(...)\n  ans <- do.call(rbind, lapply(args, as, \"matrix\"))\n  rulesList <- lapply(args, filterRules)\n  if (any(!sapply(rulesList, identical, rulesList[[1]])))\n    stop(\"cannot rbind filter matrices with non-identical rule sets\")\n  FilterMatrix(matrix = ans, filterRules = rulesList[[1]])\n})\n\nsetMethod(\"cbind\", \"FilterMatrix\", function(..., deparse.level = 1) {\n  args <- list(...)\n  ans <- do.call(cbind, lapply(args, as, \"matrix\"))\n  rules <- do.call(c, lapply(args, function(x) x@filterRules))\n  FilterMatrix(matrix = ans, filterRules = rules)\n})\n\nFilterMatrix <- function(matrix, filterRules) {\n  stopifnot(ncol(matrix) == length(filterRules))  \n  if (is.null(colnames(matrix)))\n    colnames(matrix) <- names(filterRules)\n  else if (!is.null(names(filterRules)) &&\n           !identical(names(filterRules), colnames(matrix)))\n    stop(\"if names(filterRules) and colnames(matrix) are both not NULL,\",\n         \" the names must match\")\n  names(filterRules) <- NULL\n  new(\"FilterMatrix\", matrix, filterRules = filterRules)\n}\n\nsetMethod(\"show\", \"FilterMatrix\", function(object) {\n  cat(class(object), \" (\", nrow(object), \" x \", ncol(object), \")\\n\", sep = \"\")\n  mat <- makePrettyMatrixForCompactPrinting(object)\n  print(mat, quote = FALSE, right = TRUE)\n})\n\nsetMethod(\"summary\", \"FilterResults\",\n          function(object, discarded = FALSE, percent = FALSE)\n          {\n            if (!isTRUEorFALSE(discarded))\n              stop(\"'discarded' must be TRUE or FALSE\")\n            if (!isTRUEorFALSE(percent))\n              stop(\"'percent' must be TRUE or FALSE\")\n            counts <- c(\"<initial>\" = nrow(object), colSums(object),\n                        \"<final>\" = sum(rowSums(object) == ncol(object)))\n            if (discarded) {\n              counts <- nrow(object) - counts\n            }\n            if (percent) {\n              round(counts / nrow(object), 3)\n            } else counts\n          })\n",
        "Hits-class.R": "### =========================================================================\n### Hits objects\n### -------------------------------------------------------------------------\n###\n### The Hits class hierarchy (4 concrete classes):\n###\n###                  Hits    <----    SortedByQueryHits\n###                   ^                      ^\n###                   |                      |\n###                SelfHits  <----  SortedByQuerySelfHits\n###\n\n### Vector of hits between a set of left nodes and a set of right nodes.\nsetClass(\"Hits\",\n    contains=\"Vector\",\n    representation(\n        from=\"integer\",    # integer vector of length N\n        to=\"integer\",      # integer vector of length N\n        nLnode=\"integer\",  # single integer: number of Lnodes (\"left nodes\")\n        nRnode=\"integer\"   # single integer: number of Rnodes (\"right nodes\")\n    ),\n    prototype(\n        nLnode=0L,\n        nRnode=0L\n    )\n)\n\n### A SelfHits object is a Hits object where the left and right nodes are\n### identical.\nsetClass(\"SelfHits\", contains=\"Hits\")\n\n### Hits objects where the hits are sorted by query. Coercion from\n### SortedByQueryHits to IntegerList takes advantage of this and is very fast.\nsetClass(\"SortedByQueryHits\", contains=\"Hits\")\nsetClass(\"SortedByQuerySelfHits\", contains=c(\"SelfHits\", \"SortedByQueryHits\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See Vector-class.R file\n### for what slots should or should not be considered \"parallel\".\nsetMethod(\"parallel_slot_names\", \"Hits\",\n    function(x) c(\"from\", \"to\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetGeneric(\"from\", function(x, ...) standardGeneric(\"from\"))\nsetMethod(\"from\", \"Hits\", function(x) x@from)\n\nsetGeneric(\"to\", function(x, ...) standardGeneric(\"to\"))\nsetMethod(\"to\", \"Hits\", function(x) x@to)\n\nsetGeneric(\"nLnode\", function(x, ...) standardGeneric(\"nLnode\"))\nsetMethod(\"nLnode\", \"Hits\", function(x) x@nLnode)\n\nsetGeneric(\"nRnode\", function(x, ...) standardGeneric(\"nRnode\"))\nsetMethod(\"nRnode\", \"Hits\", function(x) x@nRnode)\n\nsetGeneric(\"nnode\", function(x, ...) standardGeneric(\"nnode\"))\nsetMethod(\"nnode\", \"SelfHits\", function(x) nLnode(x))\n\nsetGeneric(\"countLnodeHits\", function(x, ...) standardGeneric(\"countLnodeHits\"))\n\n.count_Lnode_hits <- function(x) tabulate(from(x), nbins=nLnode(x))\nsetMethod(\"countLnodeHits\", \"Hits\", .count_Lnode_hits)\n\nsetGeneric(\"countRnodeHits\", function(x, ...) standardGeneric(\"countRnodeHits\"))\n\n.count_Rnode_hits <- function(x) tabulate(to(x), nbins=nRnode(x))\nsetMethod(\"countRnodeHits\", \"Hits\", .count_Rnode_hits)\n\n### query/subject API\nqueryHits <- function(x, ...) from(x, ...)\nsubjectHits <- function(x, ...) to(x, ...)\nqueryLength <- function(x, ...) nLnode(x, ...)\nsubjectLength <- function(x, ...) nRnode(x, ...)\ncountQueryHits <- function(x, ...) countLnodeHits(x, ...)\ncountSubjectHits <- function(x, ...) countRnodeHits(x, ...)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid.Hits.nnode <- function(nnode, side)\n{\n    if (!isSingleInteger(nnode) || nnode < 0L) {\n        msg <- wmsg(\"'n\", side, \"node(x)' must be a single non-negative \",\n                    \"integer\")\n        return(msg)\n    }\n    if (!is.null(attributes(nnode))) {\n        msg <- wmsg(\"'n\", side, \"node(x)' must be a single integer with \",\n                    \"no attributes\")\n        return(msg)\n    }\n    NULL\n}\n\n.valid.Hits.from_or_to <- function(from_or_to, nnode, what, side)\n{\n    if (!(is.integer(from_or_to) && is.null(attributes(from_or_to)))) {\n        msg <- wmsg(\"'\", what, \"' must be an integer vector \",\n                    \"with no attributes\")\n        return(msg)\n    }\n    if (anyMissingOrOutside(from_or_to, 1L, nnode)) {\n        msg <- wmsg(\"'\", what, \"' must contain non-NA values \",\n                    \">= 1 and <= 'n\", side, \"node(x)'\")\n        return(msg)\n    }\n    NULL\n}\n\n.valid.Hits <- function(x)\n{\n    c(.valid.Hits.nnode(nLnode(x), \"L\"),\n      .valid.Hits.nnode(nRnode(x), \"R\"),\n      .valid.Hits.from_or_to(from(x), nLnode(x), \"from(x)\", \"L\"),\n      .valid.Hits.from_or_to(to(x), nRnode(x), \"to(x)\", \"R\"))\n}\n\nsetValidity2(\"Hits\", .valid.Hits)\n\n.valid.SelfHits <- function(x)\n{\n    if (nLnode(x) != nRnode(x))\n        return(\"'nLnode(x)' and 'nRnode(x)' must be equal\")\n    NULL\n}\n\nsetValidity2(\"SelfHits\", .valid.SelfHits)\n\n.valid.SortedByQueryHits <- function(x)\n{\n    if (isNotSorted(from(x)))\n        return(\"'queryHits(x)' must be sorted\")\n    NULL\n}\n\nsetValidity2(\"SortedByQueryHits\", .valid.SortedByQueryHits)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructors\n###\n\n### Very low-level constructor. Doesn't try to sort the hits by query.\n.new_Hits <- function(Class, from, to, nLnode, nRnode, mcols)\n{\n    new2(Class, from=from, to=to, nLnode=nLnode, nRnode=nRnode,\n                elementMetadata=mcols,\n                check=TRUE)\n}\n\n### Low-level constructor. Sort the hits by query if Class extends\n### SortedByQueryHits.\nnew_Hits <- function(Class, from=integer(0), to=integer(0),\n                            nLnode=0L, nRnode=0L,\n                            mcols=NULL)\n{\n    if (!isSingleString(Class))\n        stop(\"'Class' must be a single character string\")\n    if (!extends(Class, \"Hits\"))\n        stop(\"'Class' must be the name of a class that extends Hits\")\n\n    if (!(is.numeric(from) && is.numeric(to)))\n        stop(\"'from' and 'to' must be integer vectors\")\n    if (!is.integer(from))\n        from <- as.integer(from)\n    if (!is.integer(to))\n        to <- as.integer(to)\n\n    if (!(isSingleNumber(nLnode) && isSingleNumber(nRnode)))\n        stop(\"'nLnode' and 'nRnode' must be single integers\")\n    if (!is.integer(nLnode))\n        nLnode <- as.integer(nLnode)\n    if (!is.integer(nRnode))\n        nRnode <- as.integer(nRnode)\n\n    mcols <- normarg_mcols(mcols, Class, length(from))\n\n    if (!extends(Class, \"SortedByQueryHits\")) {\n        ## No need to sort the hits by query.\n        ans <- .new_Hits(Class, from, to, nLnode, nRnode, mcols)\n        return(ans)\n    }\n\n    ## Sort the hits by query.\n    if (!is.null(mcols)) {\n        revmap_envir <- new.env(parent=emptyenv())\n    } else {\n        revmap_envir <- NULL\n    }\n    ans <- .Call2(\"Hits_new\", Class, from, to, nLnode, nRnode, revmap_envir,\n                              PACKAGE=\"S4Vectors\")\n    if (!is.null(mcols)) {\n        if (exists(\"revmap\", envir=revmap_envir)) {\n            revmap <- get(\"revmap\", envir=revmap_envir)\n            mcols <- extractROWS(mcols, revmap)\n        }\n        mcols(ans) <- mcols\n    }\n    ans\n}\n\n.make_mcols <- function(...)\n{\n    if (nargs() == 0L)\n        return(NULL)\n    ## We use 'DataFrame(..., check.names=FALSE)' rather than\n    ## 'new_DataFrame(list(...))' because we want to make use of the\n    ## former's ability to deparse unnamed arguments to generate column\n    ## names for them. Unfortunately this means that the user won't be\n    ## able to pass metadata columns named \"row.names\" or \"check.names\"\n    ## because things like '.make_mcols(11:13, row.names=21:23)'\n    ## or '.make_mcols(11:13, check.names=21:23)' won't work as expected.\n    ## The solution would be to have a mid-level DataFrame constructor\n    ## that has no extra arguments after the ellipsis and implements the\n    ## same deparsing mechanism as DataFrame(), and to use it here.\n    DataFrame(..., check.names=FALSE)\n}\n\n### 2 high-level constructors.\n\nHits <- function(from=integer(0), to=integer(0), nLnode=0L, nRnode=0L, ...,\n                 sort.by.query=FALSE)\n{\n    if (!isTRUEorFALSE(sort.by.query))\n        stop(\"'sort.by.query' must be TRUE or FALSE\")\n    Class <- if (sort.by.query) \"SortedByQueryHits\" else \"Hits\"\n    mcols <- .make_mcols(...)\n    new_Hits(Class, from, to, nLnode, nRnode, mcols)\n}\n\nSelfHits <- function(from=integer(0), to=integer(0), nnode=0L, ...,\n                     sort.by.query=FALSE)\n{\n    if (!isTRUEorFALSE(sort.by.query))\n        stop(\"'sort.by.query' must be TRUE or FALSE\")\n    Class <- if (sort.by.query) \"SortedByQuerySelfHits\" else \"SelfHits\"\n    mcols <- .make_mcols(...)\n    new_Hits(Class, from, to, nnode, nnode, mcols)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Conversion from old to new internal representation\n###\n\nsetMethod(\"updateObject\", \"Hits\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (!is(try(object@queryHits, silent=TRUE), \"try-error\")) {\n            object_metadata <- object@metadata\n            object <- new_Hits(\"SortedByQueryHits\", object@queryHits,\n                                                    object@subjectHits,\n                                                    object@queryLength,\n                                                    object@subjectLength,\n                                                    object@elementMetadata)\n            object@metadata <- object_metadata\n        }\n\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### --- Coercion within the Hits class hierarchy ---\n\n### There are 4 classes in the Hits class hierarchy. We want to support back\n### and forth coercion between all of them. That's 12 possible coercions.\n### They can be devided in 3 groups:\n###   - Group A: 5 demotions\n###   - Group B: 5 promotions\n###   - Group C: 2 transversal coercions (from SelfHits to SortedByQueryHits\n###              and vice-versa)\n###\n### Group A: Demotions are taken care of by the \"automatic coercion methods\".\n### (These methods that get automatically defined at run time by the methods\n### package the 1st time a given demotion is requested e.g. when doing\n### as(x, \"Hits\") where 'x' is any Hits derivative.)\n###\n### Group B: The methods package also defines automatic coercion methods for\n### promotions. Unfortunately, these methods almost never get it right. In\n### particular, a serious problem with these automatic promotion methods is\n### that they don't even try to validate the promoted object so they tend to\n### silently produce invalid objects. This means that we need to define\n### methods for all the coercions in group B.\n###\n### Group C: Note that coercions from SelfHits to SortedByQueryHits and\n### vice-versa will actually be taken care of by the coercion methods from\n### Hits to SortedByQueryHits and from Hits to SelfHits, respectively (both\n### defined in group B).\n###\n### So the good news is that we only need to define coercion methods for\n### group B.\n\n.from_Hits_to_SelfHits <- function(from, to)\n{\n    if (nLnode(from) != nRnode(from))\n        stop(wmsg(class(from), \" object to coerce to \", to,\n                  \" must satisfy 'nLnode(x) == nRnode(x)'\"))\n    class(from) <- class(new(to))\n    from\n}\nsetAs(\"Hits\", \"SelfHits\", .from_Hits_to_SelfHits)\nsetAs(\"SortedByQueryHits\", \"SortedByQuerySelfHits\", .from_Hits_to_SelfHits)\n\n### Note that the 'from' and 'to' arguments below are the standard arguments\n### for coercion methods. They should not be confused with the 'from()'\n### and 'to()' accessors for Hits objects!\n.from_Hits_to_SortedByQueryHits <- function(from, to)\n{\n    new_Hits(to, from(from), to(from), nLnode(from), nRnode(from),\n                 mcols(from, use.names=FALSE))\n}\nsetAs(\"Hits\", \"SortedByQueryHits\", .from_Hits_to_SortedByQueryHits)\nsetAs(\"SelfHits\", \"SortedByQuerySelfHits\", .from_Hits_to_SortedByQueryHits)\n\n### 2 possible routes for this coercion:\n###   1. Hits -> SelfHits -> SortedByQuerySelfHits\n###   2. Hits -> SortedByQueryHits -> SortedByQuerySelfHits\n### They are equivalent. However, the 1st route will fail early rather\n### than after a possibly long and expensive coercion from Hits to\n### SortedByQueryHits.\nsetAs(\"Hits\", \"SortedByQuerySelfHits\",\n    function(from) as(as(from, \"SelfHits\"), \"SortedByQuerySelfHits\")\n)\n\n### --- Other coercions ---\n\nsetMethod(\"as.matrix\", \"Hits\",\n    function(x)\n    {\n        ans <- cbind(from=from(x), to=to(x))\n        if (is(x, \"SortedByQueryHits\"))\n            colnames(ans) <- c(\"queryHits\", \"subjectHits\")\n        ans\n    }\n)\n\nsetMethod(\"as.table\", \"Hits\", .count_Lnode_hits)\n\n### FIXME: Coercions of Vector derivatives to DFrame are inconsistent.\n### For some Vector derivatives (e.g. IRanges, GRanges) the object is stored\n### \"as is\" in the 1st column of the returned DFrame, whereas for others (e.g.\n### Hits below) the object is \"dismantled\" into various parallel components\n### that end up in separate columns of the returned DFrame.\nsetAs(\"Hits\", \"DFrame\",\n    function(from)\n    {\n        from_mcols <- mcols(from, use.names=FALSE)\n        if (is.null(from_mcols))\n            from_mcols <- make_zero_col_DFrame(length(from))\n        DataFrame(as.matrix(from), from_mcols, check.names=FALSE)\n    }\n)\n\n### S3/S4 combo for as.data.frame.Hits\nas.data.frame.Hits <- function(x, row.names=NULL, optional=FALSE, ...)\n{\n    x <- as(x, \"DFrame\")\n    as.data.frame(x, row.names=row.names, optional=optional, ...)\n}\nsetMethod(\"as.data.frame\", \"Hits\", as.data.frame.Hits)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n### The \"extractROWS\" method for Vector objects doesn't test the validity of\n### the result so we override it.\nsetMethod(\"extractROWS\", \"SortedByQueryHits\",\n    function(x, i)\n    {\n        ans <- callNextMethod()\n        pbs <- validObject(ans, test=TRUE)\n        if (is.character(pbs))\n            stop(wmsg(\"Problem(s) found when testing validity of \", class(ans),\n                      \" object returned by subsetting operation: \",\n                      paste0(pbs, collapse=\", \"), \". Make sure to use a \",\n                      \"subscript that results in a valid \", class(ans),\n                      \" object.\"))\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"classNameForDisplay\", \"SortedByQueryHits\",\n    function(x) sub(\"^SortedByQuery\", \"\", class(x))\n)\n\n.Hits_summary <- function(object)\n{\n    object_len <- length(object)\n    object_mcols <- mcols(object, use.names=FALSE)\n    object_nmc <- if (is.null(object_mcols)) 0L else ncol(object_mcols)\n    paste0(classNameForDisplay(object), \" object with \", object_len, \" \",\n           ifelse(object_len == 1L, \"hit\", \"hits\"),\n           \" and \", object_nmc, \" metadata \",\n           ifelse(object_nmc == 1L, \"column\", \"columns\"))\n}\n### S3/S4 combo for summary.Hits\nsummary.Hits <- function(object, ...)\n    .Hits_summary(object, ...)\nsetMethod(\"summary\", \"Hits\", summary.Hits)\n\n.from_Hits_to_naked_character_matrix_for_display <- function(x)\n{\n    m <- cbind(from=showAsCell(from(x)),\n               to=showAsCell(to(x)))\n    if (is(x, \"SortedByQueryHits\"))\n        colnames(m) <- c(\"queryHits\", \"subjectHits\")\n    cbind_mcols_for_display(m, x)\n}\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"Hits\",\n    .from_Hits_to_naked_character_matrix_for_display\n)\n\n.show_Hits <- function(x, margin=\"\", print.classinfo=FALSE,\n                                     print.nnode=FALSE)\n{\n    cat(margin, summary(x), \":\\n\", sep=\"\")\n    ## makePrettyMatrixForCompactPrinting() assumes that head() and tail()\n    ## work on 'x'.\n    out <- makePrettyMatrixForCompactPrinting(x)\n    if (print.classinfo) {\n        .COL2CLASS <- c(\n            from=\"integer\",\n            to=\"integer\"\n        )\n        if (is(x, \"SortedByQueryHits\"))\n            names(.COL2CLASS) <- c(\"queryHits\", \"subjectHits\")\n        classinfo <- makeClassinfoRowForCompactPrinting(x, .COL2CLASS)\n        ## A sanity check, but this should never happen!\n        stopifnot(identical(colnames(classinfo), colnames(out)))\n        out <- rbind(classinfo, out)\n    }\n    if (nrow(out) != 0L)\n        rownames(out) <- paste0(margin, \"  \", rownames(out))\n    ## We set 'max' to 'length(out)' to avoid the getOption(\"max.print\")\n    ## limit that would typically be reached when 'showHeadLines' global\n    ## option is set to Inf.\n    print(out, quote=FALSE, right=TRUE, max=length(out))\n    if (print.nnode) {\n        cat(margin, \"  -------\\n\", sep=\"\")\n        if (is(x, \"SortedByQueryHits\")) {\n            cat(margin, \"  queryLength: \", nLnode(x),\n                \" / subjectLength: \", nRnode(x), \"\\n\", sep=\"\")\n        } else {\n            if (is(x, \"SelfHits\")) {\n                cat(margin, \"  nnode: \", nnode(x), \"\\n\", sep=\"\")\n            } else {\n                cat(margin, \"  nLnode: \", nLnode(x),\n                    \" / nRnode: \", nRnode(x), \"\\n\", sep=\"\")\n            }\n        }\n    }\n}\n\nsetMethod(\"show\", \"Hits\",\n    function(object)\n        .show_Hits(object, print.classinfo=TRUE, print.nnode=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.check_that_Hits_objects_are_concatenable <- function(x, objects)\n{\n    objects_nLnode <- vapply(objects, slot, integer(1), \"nLnode\",\n                             USE.NAMES=FALSE)\n    objects_nRnode <- vapply(objects, slot, integer(1), \"nRnode\",\n                             USE.NAMES=FALSE)\n    if (!(all(objects_nLnode == x@nLnode) &&\n          all(objects_nRnode == x@nRnode)))\n        stop(wmsg(\"the objects to concatenate are incompatible Hits \",\n                  \"objects by number of left and/or right nodes\"))\n}\n\n.bindROWS_Hits_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- prepare_objects_to_bind(x, objects)\n    .check_that_Hits_objects_are_concatenable(x, objects)\n    callNextMethod()\n}\n\nsetMethod(\"bindROWS\", \"Hits\", .bindROWS_Hits_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Sorting\n###\n\nsetMethod(\"sort\", \"SortedByQueryHits\",\n          function(x, decreasing = FALSE, na.last = NA, by) {\n    byQueryHits <- missing(by) || is(by, \"formula\") &&\n        all.vars(by)[1L] == \"queryHits\" && !decreasing\n    if (!byQueryHits)\n        x <- as(x, \"Hits\")\n    callNextMethod()\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selectHits()\n###\n\n### Return an integer vector parallel to the query (i.e. of length\n### 'nLnode(hits)') except when select=\"all\", in which case it's a no-op.\n###\n### 'nodup' must be TRUE or FALSE (the default) and can only be set to TRUE\n### when 'select' is \"first\", \"last\" or \"arbitrary\", and when the input hits\n### are sorted by query. When 'nodup=TRUE', a given element in the subject is\n### not allowed to be assigned to more than one element in the query, which is\n### achieved by following a simple \"first come first served\" pairing strategy.\n### So the returned vector is guaranteed to contain unique non-NA values.\n### Note that such vector represents a mapping between the query and subject\n### that is one-to-zero-or-one in *both* directions. So it represents a\n### pairing between the elements in query and subject, where a given element\n### belongs to at most one pair.\n### A note about the \"first come first served\" pairing strategy: This strategy\n### is simple and fast, but, in general, it won't achieve a \"maximal pairing\"\n### (i.e. a pairing with the most possible number of pairs) for a given input\n### Hits object. However it actually does produce a maximal pairing if the\n### Hits object is the result of call to findMatches() (with select=\"all\")'.\n### Also, in that case, this pairing strategy is symetric i.e. the resulting\n### pairs are not affected by switching 'x' and 'table' in the call to\n### findMatches() (or by transposing the input Hits object).\n###\n### Finally note that when 'select' is \"first\" or \"last\" and 'nodup' is FALSE,\n### or when 'select' is \"count\", the output of selectHits() is not affected\n### by the order of the hits in the input Hits object.\nselectHits <- function(hits,\n    select=c(\"all\", \"first\", \"last\", \"arbitrary\", \"count\"),\n    nodup=FALSE,\n    rank)\n{\n    if (!is(hits, \"Hits\"))\n        stop(\"'hits' must be a Hits object\")\n    select <- match.arg(select)\n    if (!isTRUEorFALSE(nodup))\n        stop(wmsg(\"'nodup' must be TRUE or FALSE\"))\n    if (nodup && !(select %in% c(\"first\", \"last\", \"arbitrary\")))\n        stop(wmsg(\"'nodup=TRUE' is only supported when 'select' \",\n                  \"is \\\"first\\\", \\\"last\\\", or \\\"arbitrary\\\"\"))\n    if (!missing(rank) && (!(select %in% c(\"first\", \"last\")) || nodup))\n        stop(wmsg(\"'rank' is only supported when 'select' \",\n                  \"is \\\"first\\\" or \\\"last\\\" and 'nodup' is FALSE\"))\n    if (select == \"all\")\n        return(hits)  # no-op\n\n    hits_from <- from(hits)\n    hits_to <- to(hits)\n    hits_nLnode <- nLnode(hits)\n    hits_nRnode <- nRnode(hits)\n\n    if (!missing(rank)) {\n        r <- rank(hits, ties.method=\"first\", by=rank)\n        revmap <- integer()\n        revmap[r] <- hits_to\n        hits_to <- r\n    }\n    ans <- .Call2(\"select_hits\", hits_from, hits_to, hits_nLnode, hits_nRnode,\n                                 select, nodup,\n                                 PACKAGE=\"S4Vectors\")\n    if (!missing(rank))\n        ans <- revmap[ans]\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### breakTies()\n###\n### Redundant with selectHits. The only difference is that it returns a Hits\n### object. That alone doesn't justify introducing a new verb. Should be\n### controlled via an extra arg to selectHits() e.g. 'as.Hits' (FALSE by\n### default). H.P. -- Oct 16, 2016\n\nbreakTies <- function(x, method=c(\"first\", \"last\"), rank) {\n    if (!is(x, \"Hits\"))\n        stop(\"'x' must be a Hits object\")\n    method <- match.arg(method)\n    to <- selectHits(x, method, rank=rank)\n    .new_Hits(\"SortedByQueryHits\", which(!is.na(to)), to[!is.na(to)],\n              nLnode(x), nRnode(x), NULL)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### revmap()\n###\n\n### NOT exported (but used in IRanges).\n### TODO: Move revmap() generic from AnnotationDbi to S4Vectors. Then split\n### the code below in 2 revmap() methods: one for SortedByQueryHits objects\n### and one for Hits objects.\nrevmap_Hits <- function(x)\n{\n    if (is(x, \"SortedByQueryHits\")) {\n        ## Note that:\n        ## - If 'x' is a valid SortedByQueryHits object (i.e. the hits in it\n        ##   are sorted by query), then 'revmap_Hits(x)' returns a\n        ##   SortedByQueryHits object where hits are \"fully sorted\" i.e.\n        ##   sorted by query first and then by subject.\n        ## - Because revmap_Hits() reorders the hits by query, doing\n        ##   'revmap_Hits(revmap_Hits(x))' brings back 'x' but with the hits\n        ##   in it now \"fully sorted\".\n        return(new_Hits(class(x), to(x), from(x), nRnode(x), nLnode(x),\n                                  mcols(x, use.names=FALSE)))\n    }\n    BiocGenerics:::replaceSlots(x, from=to(x), to=from(x),\n                                   nLnode=nRnode(x), nRnode=nLnode(x),\n                                   check=FALSE)\n}\n\n### FIXME: Replace this with \"revmap\" method for Hits objects.\nt.Hits <- function(x) t(x)\nsetMethod(\"t\", \"Hits\", revmap_Hits)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Remap the left and/or right nodes of a Hits object.\n###\n\n### Returns 'arg' as a NULL, an integer vector, or a factor.\n.normarg_nodes.remapping <- function(arg, side, old.nnode)\n{\n    if (is.null(arg))\n        return(arg)\n    if (!is.factor(arg)) {\n        if (!is.numeric(arg))\n            stop(\"'\" , side, \"nodes.remappping' must be a vector \",\n                 \"of integers\")\n        if (!is.integer(arg))\n            arg <- as.integer(arg)\n    }\n    if (length(arg) != old.nnode)\n        stop(\"'\" , side, \"nodes.remapping' must be of length 'n\",\n             side, \"node(x)'\")\n    arg\n}\n\n.normarg_new.nnode <- function(arg, side, map)\n{\n    if (!isSingleNumberOrNA(arg))\n        stop(\"'new.n\", side, \"node' must be a single number or NA\")\n    if (!is.integer(arg))\n        arg <- as.integer(arg)\n    if (is.null(map))\n        return(arg)\n    if (is.factor(map)) {\n        if (is.na(arg))\n            return(nlevels(map))\n        if (arg < nlevels(map))\n            stop(\"supplied 'new.n\", side, \"node' must \",\n                 \"be >= 'nlevels(\", side, \"nodes.remapping)'\")\n        return(arg)\n    }\n    if (is.na(arg))\n        stop(\"'new.n\", side, \"node' must be specified when \",\n             \"'\" , side, \"s.remapping' is specified and is not a factor\")\n    arg\n}\n\nremapHits <- function(x, Lnodes.remapping=NULL, new.nLnode=NA,\n                         Rnodes.remapping=NULL, new.nRnode=NA,\n                         with.counts=FALSE)\n{\n    if (!is(x, \"SortedByQueryHits\"))\n        stop(\"'x' must be a SortedByQueryHits object\")\n    Lnodes.remapping <- .normarg_nodes.remapping(Lnodes.remapping, \"L\",\n                                                 nLnode(x))\n    new.nLnode <- .normarg_new.nnode(new.nLnode, \"L\", Lnodes.remapping)\n    Rnodes.remapping <- .normarg_nodes.remapping(Rnodes.remapping, \"R\",\n                                                 nRnode(x))\n    new.nRnode <- .normarg_new.nnode(new.nRnode, \"R\", Rnodes.remapping)\n    if (!isTRUEorFALSE(with.counts))\n        stop(\"'with.counts' must be TRUE or FALSE\")\n    x_from <- from(x)\n    if (is.null(Lnodes.remapping)) {\n        if (is.na(new.nLnode))\n            new.nLnode <- nLnode(x)\n    } else {\n        if (is.factor(Lnodes.remapping))\n            Lnodes.remapping <- as.integer(Lnodes.remapping)\n        if (anyMissingOrOutside(Lnodes.remapping, 1L, new.nLnode))\n            stop(wmsg(\"'Lnodes.remapping' cannot contain NAs, or values that \",\n                      \"are < 1, or > 'new.nLnode'\"))\n        x_from <- Lnodes.remapping[x_from]\n    }\n    x_to <- to(x)\n    if (is.null(Rnodes.remapping)) {\n        if (is.na(new.nRnode))\n            new.nRnode <- nRnode(x)\n    } else {\n        if (is.factor(Rnodes.remapping))\n            Rnodes.remapping <- as.integer(Rnodes.remapping)\n        if (anyMissingOrOutside(Rnodes.remapping, 1L, new.nRnode))\n            stop(wmsg(\"'Rnodes.remapping' cannot contain NAs, or values that \",\n                      \"are < 1, or > 'new.nRnode'\"))\n        x_to <- Rnodes.remapping[x_to]\n    }\n    x_mcols <- mcols(x, use.names=FALSE)\n    add_counts <- function(counts) {\n        if (is.null(x_mcols))\n            return(DataFrame(counts=counts))\n        if (\"counts\" %in% colnames(x_mcols))\n            warning(\"'x' has a \\\"counts\\\" metadata column, replacing it\")\n        x_mcols$counts <- counts\n        x_mcols\n    }\n    if (is.null(Lnodes.remapping) && is.null(Rnodes.remapping)) {\n        if (with.counts) {\n            counts <- rep.int(1L, length(x))\n            x_mcols <- add_counts(counts)\n        }\n    } else {\n        sm <- selfmatchIntegerPairs(x_from, x_to)\n        if (with.counts) {\n            counts <- tabulate(sm, nbins=length(sm))\n            x_mcols <- add_counts(counts)\n            keep_idx <- which(counts != 0L)\n        } else {\n            keep_idx <- which(sm == seq_along(sm))\n        }\n        x_from <- x_from[keep_idx]\n        x_to <- x_to[keep_idx]\n        x_mcols <- extractROWS(x_mcols, keep_idx)\n    }\n    new_Hits(class(x), x_from, x_to, new.nLnode, new.nRnode, x_mcols)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SelfHits methods\n###\n### TODO: Make isSelfHit() and isRedundantHit() generic functions with\n### methods for SelfHits objects.\n###\n\n### A \"self hit\" is an edge from a node to itself. For example, the 2nd hit\n### in the SelfHits object below is a self hit (from 3rd node to itself):\n###     SelfHits(c(3, 3, 3, 4, 4), c(2:4, 2:3), 4)\nisSelfHit <- function(x)\n{\n    if (!is(x, \"SelfHits\"))\n        stop(\"'x' must be a SelfHits object\")\n    from(x) == to(x)\n}\n\n### When there is more than 1 edge between 2 given nodes (regardless of\n### orientation), the extra edges are considered to be \"redundant hits\". For\n### example, hits 3, 5, 7, and 8, in the SelfHits object below are redundant\n### hits:\n###     SelftHits(c(3, 3, 3, 3, 3, 4, 4, 4), c(3, 2:4, 2, 2:3, 2), 4, 4)\n### Note that this is regardless of the orientation of the edge so hit 7 (edge\n### 4-3) is considered to be redundant with hit 4 (edge 3-4).\nisRedundantHit <- function(x)\n{\n    if (!is(x, \"SelfHits\"))\n        stop(\"'x' must be a SelfHits object\")\n    duplicatedIntegerPairs(pmin.int(from(x), to(x)),\n                           pmax.int(from(x), to(x)))\n}\n\n### Specialized constructor.\n### Return a SortedByQuerySelfHits object.\n### About 10x faster and uses 4x less memory than my first attempt in pure\n### R below.\n### NOT exported.\nmakeAllGroupInnerHits <- function(group.sizes, hit.type=0L)\n{\n    if (!is.integer(group.sizes))\n        stop(\"'group.sizes' must be an integer vector\")\n    if (!isSingleNumber(hit.type))\n        stop(\"'hit.type' must be a single integer\")\n    if (!is.integer(hit.type))\n        hit.type <- as.integer(hit.type)\n    .Call2(\"make_all_group_inner_hits\", group.sizes, hit.type,\n           PACKAGE=\"S4Vectors\")\n}\n\n### Return a SortedByQuerySelfHits object.\n### NOT exported.\n### TODO: Remove this.\nmakeAllGroupInnerHits.old <- function(GS)\n{\n    NG <- length(GS)  # nb of groups\n    ## First Element In group i.e. first elt associated with each group.\n    FEIG <- cumsum(c(1L, GS[-NG]))\n    GSr <- c(0L, GS[-NG])\n    CGSr2 <- cumsum(GSr * GSr)\n    GS2 <- GS * GS\n    nnode <- sum(GS)  # length of original vector (i.e. before grouping)\n\n    ## Original Group Size Assignment i.e. group size associated with each\n    ## element in the original vector.\n    OGSA <- rep.int(GS, GS)  # is of length 'nnode'\n    ans_from <- rep.int(seq_len(nnode), OGSA)\n    NH <- length(ans_from)  # same as sum(GS2)\n\n    ## Hit Group Assignment i.e. group associated with each hit.\n    HGA <- rep.int(seq_len(NG), GS2)\n    ## Hit Group Size Assignment i.e. group size associated with each hit.\n    HGSA <- GS[HGA]\n    ans_to <- (0:(NH-1L) - CGSr2[HGA]) %% GS[HGA] + FEIG[HGA]\n    SelfHits(ans_from, ans_to, nnode, sort.by.query=TRUE)\n}\n\n",
        "Hits-comparison.R": "### =========================================================================\n### Comparing and ordering hits\n### -------------------------------------------------------------------------\n###\n\n\n.compatible_Hits <- function(x, y)\n{\n    nLnode(x) == nLnode(y) && nRnode(x) == nRnode(y)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompare()\n###\n### Hits are ordered by 'from' first and then by 'to'.\n### This way, the space of hits is totally ordered.\n###\n\nsetMethod(\"pcompare\", c(\"Hits\", \"Hits\"),\n    function(x, y)\n    {\n        if (!.compatible_Hits(x, y))\n            stop(\"'x' and 'y' are incompatible Hits objects \",\n                 \"by number of left and/or right nodes\")\n        pcompareIntegerPairs(from(x), to(x), from(y), to(y))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n\nsetMethod(\"match\", c(\"Hits\", \"Hits\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL,\n                       method=c(\"auto\", \"quick\", \"hash\"))\n    {\n        if (!.compatible_Hits(x, table))\n            stop(\"'x' and 'table' are incompatible Hits objects \",\n                 \"by number of left and/or right nodes\")\n        if (!is.null(incomparables))\n            stop(\"\\\"match\\\" method for Hits objects \",\n                 \"only accepts 'incomparables=NULL'\")\n        matchIntegerPairs(from(x), to(x),\n                          from(table), to(table),\n                          nomatch=nomatch, method=method)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selfmatch()\n###\n### Is this useful? When do we have to deal with duplicated hits in a Hits\n### object? Which function returns that? Would be good to know the use case.\n### If there aren't any (and we don't expect any in the future), maybe we\n### should enforce unicity in the validity method for Hits objects. Then\n### selfmatch(), duplicated(), and unique() become pointless on Hits objects\n### because their output is predictable (and thus they can be implemented\n### in a trivial way that is very fast).\n###\n\n#setMethod(\"selfmatch\", \"Hits\",\n#    function (x, method=c(\"auto\", \"quick\", \"hash\"))\n#        selfmatchIntegerPairs(from(x), to(x), method=method)\n#)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Ordering hits\n###\n### order(), sort(), rank() on Hits objects are consistent with the order\n### on hits implied by pcompare().\n###\n\n### TODO: Maybe add a method for SortedByQueryHits that takes advantage of\n### the fact that Hits objects are already sorted by 'from'.\n### 'na.last' is pointless (Hits objects don't contain NAs) so is ignored.\n### 'method' is also ignored at the moment.\nsetMethod(\"order\", \"Hits\",\n    function(..., na.last=TRUE, decreasing=FALSE,\n                  method=c(\"auto\", \"shell\", \"radix\"))\n    {\n        if (!isTRUEorFALSE(decreasing))\n            stop(\"'decreasing' must be TRUE or FALSE\")\n        ## All arguments in '...' are guaranteed to be Hits objects.\n        args <- list(...)\n        if (length(args) == 1L) {\n            x <- args[[1L]]\n            return(orderIntegerPairs(from(x), to(x), decreasing=decreasing))\n        }\n        order_args <- vector(\"list\", 2L * length(args))\n        idx <- 2L * seq_along(args)\n        order_args[idx - 1L] <- lapply(args, from)\n        order_args[idx] <- lapply(args, to)\n        do.call(order, c(order_args, list(decreasing=decreasing)))\n    }\n)\n\n",
        "Hits-setops.R": "### =========================================================================\n### Set operations\n### -------------------------------------------------------------------------\n###\n### The methods below are endomorphisms with respect to their first argument\n### 'x'. They propagate the names and metadata columns.\n###\n\n### The default method for Vector objects works fine except when 'x' is a\n### SortedByQueryHits object, in which case the result of the union needs\n### to be sorted again.\nsetMethod(\"union\", c(\"SortedByQueryHits\", \"Hits\"),\n    function(x, y)\n    {\n        ans_class <- class(x)\n        x <- as(x, \"Hits\")\n        as(callNextMethod(), ans_class)  # sort, and restore original class\n    }\n)\n\n",
        "HitsList-class.R": "### =========================================================================\n### HitsList objects\n### -------------------------------------------------------------------------\n\n\n### FIXME: Rename this class SimpleHitsList and make HitsList a virtual\n### class that SimpleHitsList (and possibly CompressedHitsList, defined in\n### IRanges) extend directly.\nsetClass(\"HitsList\",\n    contains=\"SimpleList\",\n    representation(\n        subjectOffsets=\"integer\"\n    ),\n    prototype=prototype(elementType=\"Hits\")\n)\n\nsetClass(\"SelfHitsList\",\n    contains=\"HitsList\",\n    prototype=prototype(elementType=\"SelfHits\")\n)\n\nsetClass(\"SortedByQueryHitsList\",\n    contains=\"HitsList\",\n    prototype=prototype(elementType=\"SortedByQueryHits\")\n)\n\nsetClass(\"SortedByQuerySelfHitsList\",\n    contains=c(\"SelfHitsList\", \"SortedByQueryHitsList\"),\n    prototype=prototype(elementType=\"SortedByQuerySelfHits\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetGeneric(\"space\", function(x, ...) standardGeneric(\"space\"))\n\nsetMethod(\"space\", \"HitsList\",\n          function(x) {\n            space <- names(x)\n            if (!is.null(space))\n              space <-\n                rep.int(space, sapply(as.list(x, use.names = FALSE), length))\n            space\n          })\n\nsetMethod(\"from\", \"HitsList\", function(x) {\n  as.matrix(x)[,1L,drop=TRUE]\n})\n\nsetMethod(\"to\", \"HitsList\", function(x) {\n  as.matrix(x)[,2L,drop=TRUE]\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### This constructor always returns a SortedByQueryHitsList instance at the\n### moment.\n### TODO: Maybe add the 'sort.by.query' argument to let the user choose\n### between getting a HitsList or SortedByQueryHitsList instance.\nHitsList <- function(list_of_hits, subject)\n{\n  subjectOffsets <- c(0L, head(cumsum(sapply(subject, length)), -1))\n  subjectToQuery <- seq_along(list_of_hits)\n  if (!is.null(names(list_of_hits)) && !is.null(names(subject)))\n    subjectToQuery <- match(names(list_of_hits), names(subject))\n  subjectOffsets <- subjectOffsets[subjectToQuery]\n  new_SimpleList_from_list(\"SortedByQueryHitsList\", list_of_hits,\n                           subjectOffsets = subjectOffsets)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n.from_HitsList_SortedByQueryHitsList <- function(from)\n{\n    class(from) <- class(new(\"SortedByQueryHitsList\"))  # temporarily broken\n                                                        # instance!\n    from@elementType <- \"SortedByQueryHits\"\n    from@listData <- lapply(from@listData, as, \"SortedByQueryHits\")\n    from  # now fixed :-)\n}\nsetAs(\"HitsList\", \"SortedByQueryHitsList\",.from_HitsList_SortedByQueryHitsList)\n\n### Of course we want 'as(SortedByQueryHitsList, \"HitsList\", strict=FALSE)'\n### to do the right thing (i.e. to be a no-op), but, unfortunately, as()\n### won't do that if the coerce,SortedByQueryHitsList,HitsList method\n### is defined, because, in this case, as() will **always** call the method,\n### EVEN WHEN strict=FALSE AND THE OBJECT TO COERCE ALREADY DERIVES\n### FROM THE TARGET CLASS! (This is a serious flaw in as() current\n### design/implementation but I wouldn't be surprised if someone argued\n### that this is a feature and working as intended.)\n### Anyway, a workaround is to support the 'strict=FALSE' case at the level\n### of the coerce() method itself. However setAs() doesn't let us do that\n### so this is why we use setMethod(\"coerce\", ...) to define these methods.\n.from_SortedByQueryHitsList_to_HitsList <-\n    function(from, to=\"HitsList\", strict=TRUE)\n{\n    if (!isTRUEorFALSE(strict))\n        stop(\"'strict' must be TRUE or FALSE\")\n    if (!strict)\n        return(from)\n    class(from) <- class(new(\"HitsList\"))  # temporarily broken instance!\n    from@elementType <- \"Hits\"\n    from@listData <- lapply(from@listData, as, \"Hits\")\n    from  # now fixed :-)\n}\nsetMethod(\"coerce\", c(\"SortedByQueryHitsList\", \"HitsList\"),\n    .from_SortedByQueryHitsList_to_HitsList\n)\n\n## return as.matrix as on Hits, with indices adjusted\n\nsetMethod(\"as.matrix\", \"HitsList\", function(x) {\n  mats <- lapply(x, as.matrix)\n  mat <- do.call(rbind, mats)\n  rows <- c(0L, head(cumsum(sapply(x, nLnode)), -1))\n  nr <- sapply(mats, nrow)\n  mat + cbind(rep.int(rows, nr), rep.int(x@subjectOffsets, nr))\n})\n\n## count up the matches for each left node in every matching\n\nsetMethod(\"as.table\", \"HitsList\", function(x, ...) {\n  counts <- unlist(lapply(x, as.table))\n  as.table(array(counts, length(counts), list(range = seq_along(counts))))\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going from Hits to HitsList with splitAsList() and family (i.e. relist()\n### and extractList())\n###\n\nsetMethod(\"relistToClass\", \"Hits\",\n    function(x) \"HitsList\")\n\nsetMethod(\"relistToClass\", \"SortedByQueryHits\",\n    function(x) \"SortedByQueryHitsList\")\n\nsetMethod(\"splitAsList\", c(\"SortedByQueryHits\", \"ANY\"),\n    function(x, f, drop=FALSE)\n    {\n        ans_class <- relistToClass(x)\n        x <- as(x, \"Hits\")\n        as(callNextMethod(), ans_class)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other methods\n###\n\nt.HitsList <- function(x) t(x)\nsetMethod(\"t\", \"HitsList\", function(x) {\n  x@elements <- lapply(as.list(x, use.names = FALSE), t)\n  x\n})\n\n### TODO: many convenience methods\n\n",
        "LLint-class.R": "### =========================================================================\n### LLint objects\n### -------------------------------------------------------------------------\n###\n### The LLint class is a container for storing a vector of \"large integers\"\n### (i.e. long long int in C). It supports NAs.\n###\n\n\n### We don't support names for now. We will when we need them.\nsetClass(\"LLint\", representation(bytes=\"raw\"))\n\nsetClassUnion(\"integer_OR_LLint\", c(\"integer\", \"LLint\"))\n\nis.LLint <- function(x) is(x, \"LLint\")\n\nBYTES_PER_LLINT <- .Machine$sizeof.longlong\n\nsetMethod(\"length\", \"LLint\",\n    function(x) length(x@bytes) %/% BYTES_PER_LLINT\n)\n\n### Called from the .onLoad() hook in zzz.R\nmake_NA_LLint_ <- function()\n{\n    ans_bytes <- .Call2(\"make_RAW_from_NA_LLINT\", PACKAGE=\"S4Vectors\")\n    new2(\"LLint\", bytes=ans_bytes, check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n.from_logical_to_LLint <- function(from)\n{\n    .Call2(\"new_LLint_from_LOGICAL\", from, PACKAGE=\"S4Vectors\")\n}\nsetAs(\"logical\", \"LLint\", .from_logical_to_LLint)\n\n.from_integer_to_LLint <- function(from)\n{\n    .Call2(\"new_LLint_from_INTEGER\", from, PACKAGE=\"S4Vectors\")\n}\nsetAs(\"integer\", \"LLint\", .from_integer_to_LLint)\n\n.from_numeric_to_LLint <- function(from)\n{\n    .Call2(\"new_LLint_from_NUMERIC\", from, PACKAGE=\"S4Vectors\")\n}\nsetAs(\"numeric\", \"LLint\", .from_numeric_to_LLint)\n\n.from_character_to_LLint <- function(from)\n{\n    .Call2(\"new_LLint_from_CHARACTER\", from, PACKAGE=\"S4Vectors\")\n}\nsetAs(\"character\", \"LLint\", .from_character_to_LLint)\n\nas.LLint <- function(x) as(x, \"LLint\")\n\n### S3/S4 combo for as.logical.LLint\n.from_LLint_to_logical <- function(x)\n{\n    .Call2(\"new_LOGICAL_from_LLint\", x, PACKAGE=\"S4Vectors\")\n}\nas.logical.LLint <- function(x, ...) .from_LLint_to_logical(x, ...)\nsetMethod(\"as.logical\", \"LLint\", as.logical.LLint)\n\n### S3/S4 combo for as.integer.LLint\n.from_LLint_to_integer <- function(x)\n{\n    .Call2(\"new_INTEGER_from_LLint\", x, PACKAGE=\"S4Vectors\")\n}\nas.integer.LLint <- function(x, ...) .from_LLint_to_integer(x, ...)\nsetMethod(\"as.integer\", \"LLint\", as.integer.LLint)\n\n### S3/S4 combo for as.numeric.LLint\n.from_LLint_to_numeric <- function(x)\n{\n    .Call2(\"new_NUMERIC_from_LLint\", x, PACKAGE=\"S4Vectors\")\n}\nas.numeric.LLint <- function(x, ...) .from_LLint_to_numeric(x, ...)\nsetMethod(\"as.numeric\", \"LLint\", as.numeric.LLint)\n\n### S3/S4 combo for as.character.LLint\n.from_LLint_to_character <- function(x)\n{\n    .Call2(\"new_CHARACTER_from_LLint\", x, PACKAGE=\"S4Vectors\")\n}\nas.character.LLint <- function(x, ...) .from_LLint_to_character(x, ...)\nsetMethod(\"as.character\", \"LLint\", as.character.LLint)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.MAX_VECTOR_LENGTH <- 2^52  # see R_XLEN_T_MAX in Rinternals.h\n\n### Return a single double value.\n.normarg_vector_length <- function(length=0L, max_length=.MAX_VECTOR_LENGTH)\n{\n    if (is.LLint(length)) {\n        if (length(length) != 1L || is.na(length) || length < as.LLint(0L))\n            stop(\"invalid 'length' argument\")\n        if (length > as.LLint(max_length))\n            stop(\"'length' is too big\")\n        return(as.double(length))\n    }\n    if (!isSingleNumber(length) || length < 0L)\n        stop(\"invalid 'length' argument\")\n    if (is.integer(length)) {\n        length <- as.double(length)\n    } else {\n        length <- trunc(length)\n    }\n    if (length > max_length)\n        stop(\"'length' is too big\")\n    length\n}\n\nLLint <- function(length=0L)\n{\n    max_length <- .MAX_VECTOR_LENGTH / BYTES_PER_LLINT\n    length <- .normarg_vector_length(length, max_length=max_length)\n    ans_bytes <- raw(length * BYTES_PER_LLINT)\n    new2(\"LLint\", bytes=ans_bytes, check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Displaying\n###\n\n.show_LLint <- function(x)\n{\n    x_len <- length(x)\n    if (x_len == 0L) {\n        cat(class(x), \"(0)\\n\", sep=\"\")\n        return()\n    }\n    cat(class(x), \" of length \", x_len, \":\\n\", sep=\"\")\n    print(as.character(x), quote=FALSE, na.print=\"NA\")\n    return()\n}\n\nsetMethod(\"show\", \"LLint\", function(object) .show_LLint(object))\n\nsetMethod(\"showAsCell\", \"LLint\", function(object) as.character(object))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n### Arguments 'use.names' and 'ignore.mcols' are ignored.\n.bindROWS_LLint_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    if (!is.list(objects))\n        stop(\"'objects' must be a list\")\n    all_objects <- c(list(x), unname(objects))\n\n    ## If one of the objects to combine is a character vector, then all the\n    ## objects are coerced to character and combined.\n    if (any(vapply(all_objects, is.character, logical(1), USE.NAMES=FALSE))) {\n        ans <- unlist(lapply(all_objects, as.character), use.names=FALSE)\n        return(ans)\n    }\n\n    ## If one of the objects to combine is a double vector, then all the\n    ## objects are coerced to double and combined.\n    if (any(vapply(all_objects, is.double, logical(1), USE.NAMES=FALSE))) {\n        ans <- unlist(lapply(all_objects, as.double), use.names=FALSE)\n        return(ans)\n    }\n\n    ## Concatenate \"bytes\" slots.\n    bytes_list <- lapply(all_objects,\n        function(object) {\n            if (is.null(object))\n                return(NULL)\n            if (is.logical(object) || is.integer(object))\n                object <- as.LLint(object)\n            if (is.LLint(object))\n                return(object@bytes)\n            stop(wmsg(\"cannot combine LLint objects \",\n                      \"with objects of class \", class(object)))\n        }\n    )\n    ans_bytes <- unlist(bytes_list, use.names=FALSE)\n\n    new2(\"LLint\", bytes=ans_bytes, check=check)\n}\n\nsetMethod(\"bindROWS\", \"LLint\", .bindROWS_LLint_objects)\n\n### Thin wrapper around bindROWS().\nsetMethod(\"c\", \"LLint\",\n    function (x, ..., recursive=FALSE)\n    {\n        if (!identical(recursive, FALSE))\n            stop(\"\\\"c\\\" method for LLint objects \",\n                 \"does not support the 'recursive' argument\")\n        bindROWS(x, list(...))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is.na(), anyNA()\n###\n\nsetMethod(\"is.na\", \"LLint\", function(x) is.na(as.logical(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Operations from \"Ops\" group\n###\n\nsetMethod(\"Ops\", c(\"LLint\", \"LLint\"),\n    function(e1, e2)\n    {\n        .Call(\"LLint_Ops\", .Generic, e1, e2, PACKAGE=\"S4Vectors\")\n    }\n)\n\n### If one operand is LLint and the other one is integer, then the latter\n### is coerced to LLint.\n### If one operand is LLint and the other one is double, then the former\n### is coerced to double.\nsetMethod(\"Ops\", c(\"LLint\", \"numeric\"),\n    function(e1, e2)\n    {\n        if (is.integer(e2)) {\n            e2 <- as.LLint(e2)\n        } else {\n            ## Suppress \"non reversible coercion to double\" warning.\n            e1 <- suppressWarnings(as.double(e1))\n        }\n        callGeneric()\n    }\n)\n\nsetMethod(\"Ops\", c(\"numeric\", \"LLint\"),\n    function(e1, e2)\n    {\n        if (is.integer(e1)) {\n            e1 <- as.LLint(e1)\n        } else {\n            ## Suppress \"non reversible coercion to double\" warning.\n            e2 <- suppressWarnings(as.double(e2))\n        }\n        callGeneric()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Operations from \"Summary\" group\n###\n\nsetMethod(\"Summary\", \"LLint\",\n    function(x, ..., na.rm=FALSE)\n    {\n        if (length(list(...)) != 0L)\n            stop(wmsg(\"\\\"\", .Generic, \"\\\" method for LLint objects \",\n                      \"takes only one object\"))\n        if (!isTRUEorFALSE(na.rm))\n            stop(\"'na.rm' must be TRUE or FALSE\")\n        .Call(\"LLint_Summary\", .Generic, x, na.rm=na.rm, PACKAGE=\"S4Vectors\")\n    }\n)\n\n",
        "List-class.R": "### =========================================================================\n### List objects\n### -------------------------------------------------------------------------\n###\n### List objects are Vector objects with \"[[\", \"elementType\" and\n### \"elementNROWS\" methods.\n###\n\nsetClass(\"List\",\n    contains=\"Vector\",\n    representation(\n        \"VIRTUAL\",\n        elementType=\"character\"\n    ),\n    prototype(elementType=\"ANY\")\n)\n\nsetClassUnion(\"list_OR_List\", c(\"list\", \"List\"))  # list-like objects\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods\n###\n\nsetGeneric(\"elementType\", function(x, ...) standardGeneric(\"elementType\"))\nsetMethod(\"elementType\", \"List\", function(x) x@elementType)\nsetMethod(\"elementType\", \"vector\", function(x) storage.mode(x))\n\nsetGeneric(\"elementNROWS\", function(x) standardGeneric(\"elementNROWS\"))\n\nsetMethod(\"elementNROWS\", \"ANY\", sapply_NROW)\n\n### Used in the SGSeq package!\nquick_togroup <- function(x) map_inner_ROWS_to_list_elements(elementNROWS(x))\n\nsetMethod(\"elementNROWS\", \"List\",\n    function(x)\n    {\n        y <- as.list(x)\n        if (length(y) == 0L) {\n            ans <- integer(0)\n            ## We must return a named integer(0) if 'x' is named\n            names(ans) <- names(x)\n            return(ans)\n        }\n        if (length(dim(y[[1L]])) < 2L)\n            return(elementNROWS(y))\n        return(sapply(y, NROW))\n    }\n)\n\nsetGeneric(\"isEmpty\", function(x) standardGeneric(\"isEmpty\"))\nsetMethod(\"isEmpty\", \"ANY\",\n          function(x)\n          {\n              if (is.atomic(x))\n                  return(length(x) == 0L)\n              if (!is(x, \"list_OR_List\"))\n                  stop(\"isEmpty() is not defined for objects of class \",\n                       class(x)[[1L]])\n              ## Recursive definition\n              if (length(x) == 0L)\n                  return(TRUE)\n              all(vapply(x, isEmpty, logical(1L)))\n          })\n### A List object is considered empty iff all its elements are empty.\nsetMethod(\"isEmpty\", \"List\", function(x) all(elementNROWS(x) == 0L))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nList <- function(...)\n{\n    args <- list(...)\n    if (length(args) == 1L && is.list(args[[1L]])) \n        args <- args[[1L]]\n    as(args, \"List\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"show\", \"List\",\n          function(object)\n          {\n              lo <- length(object)\n              cat(classNameForDisplay(object), \" of length \", lo,\n                  \"\\n\", sep = \"\")\n              if (!is.null(names(object)))\n                cat(labeledLine(\"names\", names(object)))\n          })\n\nsetMethod(\"showAsCell\", \"List\", showAsCell_list)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unlist()\n###\n\n### 'inner_names' and 'outer_names' can be either NULL or character vectors.\n### If both are character vectors, then they must have the same length.\n.make_unlisted_names <- function(inner_names, outer_names)\n{\n    if (is.null(outer_names))\n        return(inner_names)\n    if (is.null(inner_names))\n        return(outer_names)\n    ## Replace missing outer names with inner names.\n    no_outer <- is.na(outer_names) | outer_names == \"\"\n    if (any(no_outer)) {\n        idx <- which(no_outer)\n        outer_names[idx] <- inner_names[idx]\n    }\n    ## Paste *outer* and *inner* names together when both are present.\n    no_inner <- is.na(inner_names) | inner_names == \"\"\n    both <- !(no_outer | no_inner)\n    if (any(both)) {\n        idx <- which(both)\n        outer_names[idx] <- paste(outer_names[idx], inner_names[idx], sep=\".\")\n    }\n    outer_names\n}\n\n### 'unlisted_x' is assumed to have the *inner* names of 'x' on it.\nset_unlisted_names <- function(unlisted_x, x)\n{\n    x_names <- names(x)\n    if (is.null(x_names))\n        return(unlisted_x)\n    inner_names <- ROWNAMES(unlisted_x)\n    outer_names <- rep.int(x_names, elementNROWS(x))\n    unlisted_names <- .make_unlisted_names(inner_names, outer_names)\n    if (length(dim(unlisted_x)) < 2L) {\n        res <- try(names(unlisted_x) <- unlisted_names, silent=TRUE)\n        what <- \"names\"\n    } else {\n        res <- try(rownames(unlisted_x) <- unlisted_names, silent=TRUE)\n        what <- \"rownames\"\n    }\n    if (is(res, \"try-error\"))\n        warning(\"failed to set \", what, \" on the \",\n                \"unlisted \", class(x)[[1L]], \" object\")\n    unlisted_x\n}\n\n### If 'use.names' is FALSE or 'x' has no *outer* names, then we propagate\n### the *inner* names on the unlisted object. Note that this deviates from\n### base::unlist() which doesn't propagate any names (outer or inner) when\n### 'use.names' is FALSE.\n### Otherwise (i.e. if 'use.names' is TRUE and 'x' has *outer* names), the\n### names we propagate are obtained by pasting the *outer* and *inner* names\n### together. Note that, unlike base::unlist(), we never mangle the *outer*\n### names when they have no corresponding *inner* names (a terrible feature\n### of base::unlist()).\nsetMethod(\"unlist\", \"List\",\n    function(x, recursive=TRUE, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        if (length(x) == 0L) {\n            elt_type <- elementType(x)\n            if (isVirtualClass(elt_type))\n                return(NULL)\n            return(new(elt_type))\n        }\n        xx <- unname(as.list(x))\n        if (length(dim(xx[[1L]])) < 2L) {\n            ## This propagates the *inner* names of 'x'.\n            unlisted_x <- do.call(c, xx)\n        } else {\n            ## This propagates the *inner* names of 'x'.\n            unlisted_x <- do.call(rbind, xx)\n        }\n        if (use.names)\n            unlisted_x <- set_unlisted_names(unlisted_x, x)\n        unlisted_x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n### Returns TRUE iff 'i' contains positive values that are compatible\n### with the shape of 'x'. NAs are allowed.\n.is_valid_NL_subscript <- function(i, x)\n{\n    unlisted_i <- unlist(i, use.names=FALSE)\n    if (!is.integer(unlisted_i))\n        unlisted_i <- as.integer(unlisted_i)\n    if (any(unlisted_i < 1L, na.rm=TRUE))\n        return(FALSE)\n    x_eltNROWS <- elementNROWS(x)\n    i_eltNROWS <- elementNROWS(i)\n    if (any(unlisted_i > rep.int(x_eltNROWS, i_eltNROWS), na.rm=TRUE))\n        return(FALSE)\n    return(TRUE)\n}\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n### Returns the name of one of the 3 supported fast paths (\"LL\", \"NL\", \"RL\")\n### or NA if no fast path can be used.\n.select_fast_path <- function(i, x)\n{\n    ## LEPType (List Element Pseudo-Type): same as \"elementType\" except for\n    ## RleList objects.\n    if (is(i, \"RleList\")) {\n        i_runvals <- runValue(i)\n        i_LEPType <- elementType(i_runvals)\n    } else {\n        i_LEPType <- elementType(i)\n    }\n    if (extends(i_LEPType, \"logical\")) {\n        ## 'i' is a List of logical vectors or logical-Rle objects.\n        ## We select the \"LL\" fast path (\"Logical List\").\n        return(\"LL\")\n    }\n    if (extends(i_LEPType, \"numeric\")) {\n        ## 'i' is a List of numeric vectors or numeric-Rle objects.\n        if (is(i, \"RleList\")) {\n            i2 <- i_runvals\n        } else {\n            i2 <- i\n        }\n        if (.is_valid_NL_subscript(i2, x)) {\n            ## We select the \"NL\" fast path (\"Number List\").\n            return(\"NL\")\n        }\n    }\n    if (extends(i_LEPType, \"IntegerRanges\")) {\n        ## 'i' is a List of IntegerRanges objects.\n        ## We select the \"RL\" fast path (\"IntegerRanges List\").\n        return(\"RL\")\n    }\n    return(NA_character_)\n}\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n### Truncate or recycle each list element of 'i' to the length of the\n### corresponding element in 'x'.\n.adjust_elt_lengths <- function(i, x)\n{\n    x_eltNROWS <- unname(elementNROWS(x))\n    i_eltNROWS <- unname(elementNROWS(i))\n    idx <- which(x_eltNROWS != i_eltNROWS)\n    ## FIXME: This is rough and doesn't follow exactly the truncate-or-recycle\n    ## semantic of normalizeSingleBracketSubscript() on a logical vector or\n    ## logical-Rle object.\n    for (k in idx)\n        i[[k]] <- rep(i[[k]], length.out=x_eltNROWS[k])\n    return(i)\n}\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length),\n### and 'i' is a List of logical vectors or logical-Rle objects.\n.unlist_LL_subscript <- function(i, x)\n{\n    i <- .adjust_elt_lengths(i, x)\n    unlist(i, use.names=FALSE)\n}\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length),\n### and 'i' is a List of numeric vectors or numeric-Rle objects.\n.unlist_NL_subscript <- function(i, x)\n{\n    offsets <- c(0L, end(IRanges::PartitioningByEnd(x))[-length(x)])\n    i <- i + offsets\n    unlist(i, use.names=FALSE)\n}\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length),\n### and 'i' is a List of IntegerRanges objects.\n.unlist_RL_subscript <- function(i, x)\n{\n    unlisted_i <- unlist(i, use.names=FALSE)\n    offsets <- c(0L, end(IRanges::PartitioningByEnd(x))[-length(x)])\n    IRanges::shift(unlisted_i, shift=rep.int(offsets, elementNROWS(i)))\n}\n\n### Fast subset by List of logical vectors or logical-Rle objects.\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n### Propagate 'names(x)' only. Caller is responsible for propagating 'mcols(x)'\n### and 'metadata(x)'.\n.fast_subset_List_by_LL <- function(x, i)\n{\n    ## Unlist 'x' and 'i'.\n    unlisted_x <- unlist(x, use.names=FALSE)\n    unlisted_i <- .unlist_LL_subscript(i, x)\n\n    ## Subset.\n    unlisted_ans <- extractROWS(unlisted_x, unlisted_i)\n\n    ## Relist.\n    group <- rep.int(seq_along(x), elementNROWS(x))\n    group <- extractROWS(group, unlisted_i)\n    ans_partitioning <- IRanges::PartitioningByEnd(group, NG=length(x),\n                                                   names=names(x))\n    relist(unlisted_ans, ans_partitioning)\n}\n\n### Fast subset by List of numeric vectors or numeric-Rle objects.\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n### Propagate 'names(x)' only. Caller is responsible for propagating 'mcols(x)'\n### and 'metadata(x)'.\n.fast_subset_List_by_NL <- function(x, i)\n{\n    ## Unlist 'x' and 'i'.\n    unlisted_x <- unlist(x, use.names=FALSE)\n    unlisted_i <- .unlist_NL_subscript(i, x)\n\n    ## Subset.\n    unlisted_ans <- extractROWS(unlisted_x, unlisted_i)\n\n    ## Relist.\n    ans_breakpoints <- cumsum(unname(elementNROWS(i)))\n    ans_partitioning <- IRanges::PartitioningByEnd(ans_breakpoints,\n                                                   names=names(x))\n    relist(unlisted_ans, ans_partitioning)\n}\n\n### Fast subset by List of IntegerRanges objects.\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n### Propagate 'names(x)' only. Caller is responsible for propagating 'mcols(x)'\n### and 'metadata(x)'.\n.fast_subset_List_by_RL <- function(x, i)\n{\n    i_eltNROWS <- elementNROWS(i)\n    if (all(i_eltNROWS == 1L)) {\n        unlisted_i <- unlist(i, use.names=FALSE)\n        return(IRanges::windows(x, unlisted_i))\n    }\n\n    ## Unlist 'x' and 'i'.\n    unlisted_x <- unlist(x, use.names=FALSE)\n    unlisted_i <- .unlist_RL_subscript(i, x)\n\n    ## Subset.\n    unlisted_ans <- extractROWS(unlisted_x, unlisted_i)\n\n    ## Relist.\n    ans_breakpoints <- cumsum(unlist(sum(width(i)), use.names=FALSE))\n    ans_partitioning <- IRanges::PartitioningByEnd(ans_breakpoints,\n                                                   names=names(x))\n    relist(unlisted_ans, ans_partitioning)\n}\n\n### Subset a List object by a list-like subscript.\nsubset_List_by_List <- function(x, i)\n{\n    li <- length(i)\n    if (is.null(names(i))) {\n        lx <- length(x)\n        if (li > lx)\n            stop(\"list-like subscript is longer than \",\n                 \"list-like object to subset\")\n        if (li < lx)\n            x <- x[seq_len(li)]\n    } else {\n        if (is.null(names(x)))\n            stop(\"cannot subscript an unnamed list-like object \",\n                 \"by a named list-like object\")\n        if (!identical(names(i), names(x))) {\n            i2x <- match(names(i), names(x))\n            if (anyMissing(i2x))\n                stop(\"list-like subscript has names not in \",\n                     \"list-like object to subset\")\n            x <- x[i2x]\n        }\n    }\n    ## From here, 'x' and 'i' are guaranteed to have the same length.\n    if (li == 0L)\n        return(x)\n    if (!is(x, \"SimpleList\")) {\n        ## We'll try to take a fast path.\n        if (is(i, \"List\")) {\n            fast_path <- .select_fast_path(i, x)\n        } else {\n            i2 <- as(i, \"List\")\n            i2_elttype <- elementType(i2)\n            if (length(i2) == li && all(sapply(i, is, i2_elttype))) {\n                fast_path <- .select_fast_path(i2, x)\n                if (!is.na(fast_path))\n                    i <- i2\n            } else {\n                fast_path <- NA_character_\n            }\n        }\n        if (!is.na(fast_path)) {\n            fast_path_FUN <- switch(fast_path,\n                                    LL=.fast_subset_List_by_LL,\n                                    NL=.fast_subset_List_by_NL,\n                                    RL=.fast_subset_List_by_RL)\n            ans <- as(fast_path_FUN(x, i), class(x))  # fast path\n            ## Propagate 'metadata(x)' and 'mcols(x)'.\n            metadata(ans) <- metadata(x)\n            mcols(ans) <- mcols(x, use.names=FALSE)\n            return(ans)\n        }\n    }\n    ## Slow path (loops over the list elements of 'x').\n    for (k in seq_len(li))\n        x[[k]] <- extractROWS(x[[k]], i[[k]])\n    return(x)\n}\n\n.adjust_value_length <- function(value, i_len)\n{\n    value_len <- length(value)\n    if (value_len == i_len)\n        return(value)\n    if (i_len %% value_len != 0L)\n        warning(\"number of values supplied is not a sub-multiple \",\n                \"of the number of values to be replaced\")\n    rep(value, length.out=i_len)\n}\n\n### Assume 'x' and 'i' are parallel List objects (i.e. same length).\n.fast_lsubset_List_by_List <- function(x, i, value)\n{\n    ## Unlist 'x', 'i', and 'value'.\n    unlisted_x <- unlist(x, use.names=FALSE)\n    fast_path <- .select_fast_path(i, x)\n    unlist_subscript_FUN <- switch(fast_path,\n                                   LL=.unlist_LL_subscript,\n                                   NL=.unlist_NL_subscript,\n                                   RL=.unlist_RL_subscript)\n    unlisted_i <- unlist_subscript_FUN(i, x)\n    if (length(value) != 1L) {\n        value <- .adjust_value_length(value, length(i))\n        value <- .adjust_elt_lengths(value, i)\n    }\n    unlisted_value <- unlist(value, use.names=FALSE)\n\n    ## Subset.\n    unlisted_ans <- replaceROWS(unlisted_x, unlisted_i, unlisted_value)\n\n    ## Relist.\n    ans <- as(relist(unlisted_ans, x), class(x))\n    metadata(ans) <- metadata(x)\n    ans\n}\n\nlsubset_List_by_List <- function(x, i, value)\n{\n    lx <- length(x)\n    li <- length(i)\n    if (li == 0L) {\n        ## Surprisingly, in that case, `[<-` on standard vectors does not\n        ## even look at 'value'. So neither do we...\n        return(x)\n    }\n    lv <- length(value)\n    if (lv == 0L)\n        stop(\"replacement has length zero\")\n    value <- normalizeSingleBracketReplacementValue(value, x)\n    if (is.null(names(i))) {\n        if (li != lx)\n            stop(\"when list-like subscript is unnamed, it must have the \",\n                 \"length of list-like object to subset\")\n        if (!is(x, \"SimpleList\")) {\n            ## We'll try to take a fast path.\n            if (is(i, \"List\")) {\n                fast_path <- .select_fast_path(i, x)\n            } else {\n                i2 <- as(i, \"List\")\n                i2_elttype <- elementType(i2)\n                if (length(i2) == li && all(sapply(i, is, i2_elttype))) {\n                    fast_path <- .select_fast_path(i2, x)\n                    if (!is.na(fast_path))\n                        i <- i2\n                } else {\n                    fast_path <- NA_character_\n                }\n            }\n            if (!is.na(fast_path))\n                return(.fast_lsubset_List_by_List(x, i, value))  # fast path\n        }\n        i2x <- seq_len(li)\n    } else {\n        if (is.null(names(x)))\n            stop(\"cannot subset an unnamed list-like object \",\n                 \"by a named list-like subscript\")\n        i2x <- match(names(i), names(x))\n        if (anyMissing(i2x))\n            stop(\"list-like subscript has names not in \",\n                 \"list-like object to subset\")\n        if (anyDuplicated(i2x))\n            stop(\"list-like subscript has duplicated names\")\n    }\n    value <- .adjust_value_length(value, li)\n    ## Slow path (loops over the list elements of 'x').\n    for (k in seq_len(li))\n        x[[i2x[k]]] <- replaceROWS(x[[i2x[k]]], i[[k]], value[[k]])\n    return(x)\n}\n\nsetMethod(\"[\", \"List\",\n    function(x, i, j, ..., drop=TRUE)\n    {\n        if (length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        if (missing(i) || !is(i, \"list_OR_List\") || is(i, \"IntegerRanges\")) {\n            ans <- subset_along_ROWS(x, i, drop=drop)\n        } else {\n            ans <- subset_List_by_List(x, i)\n        }\n        if (!missing(j))\n            mcols(ans) <- mcols(ans, use.names=FALSE)[ , j, drop=FALSE]\n        ans\n    }\n)\n\nsetReplaceMethod(\"[\", \"List\",\n    function(x, i, j, ..., value)\n    {\n        if (!missing(j) || length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        if (!missing(i) && is(i, \"list_OR_List\") && !is(i, \"IntegerRanges\"))\n            return(lsubset_List_by_List(x, i, value))\n        callNextMethod(x, i, value=value)\n    }\n)\n\nsetMethod(\"[[\", \"List\",\n    function(x, i, j, ...)\n    {\n        dotArgs <- list(...)\n        if (length(dotArgs) > 0L)\n            dotArgs <- dotArgs[names(dotArgs) != \"exact\"]\n        if (!missing(j) || length(dotArgs) > 0L)\n            stop(\"incorrect number of subscripts\")\n        ## '...' is either empty or contains only the 'exact' arg.\n        getListElement(x, i, ...)\n    }\n)\n\nsetMethod(\"$\", \"List\", function(x, name) x[[name, exact=FALSE]])\n\nsetReplaceMethod(\"[[\", \"List\",\n    function(x, i, j, ..., value)\n    {\n        if (!missing(j) || length(list(...)) > 0)\n            stop(\"invalid replacement\")\n        setListElement(x, i, value)\n    }\n)\n\nsetReplaceMethod(\"$\", \"List\",\n                 function(x, name, value) {\n                   x[[name]] <- value\n                   x\n                 })\n\nsetMethod(\"setListElement\", \"List\", setListElement_default)\n\nsetMethod(\"getListElement\", \"List\",\n          function(x, i) getListElement(as.list(x), i))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"List\", \"list\", function(from) as.list(from))\n\n.as.list.List <- function(x, use.names=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    ans <- lapply(x, identity)\n    if (!use.names)\n        names(ans) <- NULL\n    ans\n}\nsetMethod(\"as.list\", \"List\", .as.list.List)\n\nsetMethod(\"parallelVectorNames\", \"List\",\n          function(x) setdiff(callNextMethod(), c(\"group\", \"group_name\")))\n\nlistClassName <- function(impl, element.type) {\n  if (is.null(impl))\n    impl <- \"\"\n  listClass <- paste0(impl, \"List\")\n  if (!is.null(element.type)) {\n    cl <- c(element.type, names(getClass(element.type)@contains))\n    cl <- capitalize(cl)\n    listClass <- c(paste0(cl, \"List\"), paste0(cl, \"Set\"),\n                   paste0(impl, cl, \"List\"), listClass)\n  }\n  clExists <- which(sapply(listClass, isClass) &\n                    sapply(listClass, extends, paste0(impl, \"List\")))\n  listClass[[clExists[[1L]]]]\n}\n\nsetAs(\"ANY\", \"List\", function(from) {\n  ## since list is directed to SimpleList, we assume 'from' is non-list-like\n  relist(from, IRanges::PartitioningByEnd(seq_along(from), names=names(from)))\n})\n\n## Special cased, because integer extends ANY (somehow) and numeric,\n## so ambiguities are introduced due to method caching.\nsetAs(\"integer\", \"List\", getMethod(coerce, c(\"ANY\", \"List\")))\n\n.make_group_and_group_name <- function(x_eltNROWS, group_name.as.factor=FALSE)\n{\n    if (!isTRUEorFALSE(group_name.as.factor))\n        stop(\"'group_name.as.factor' must be TRUE or FALSE\")\n    group <- rep.int(seq_along(x_eltNROWS), x_eltNROWS)\n    x_names <- names(x_eltNROWS)\n    if (is.null(x_names)) {\n        group_name <- rep.int(NA_character_, length(group))\n        if (group_name.as.factor)\n            group_name <- factor(group_name, levels=character(0))\n    } else {\n        group_name <- rep.int(x_names, x_eltNROWS)\n        if (group_name.as.factor)\n            group_name <- factor(group_name, levels=unique(x_names))\n    }\n    data.frame(group=group, group_name=group_name, stringsAsFactors=FALSE)\n}\n\n.as.data.frame.List <- \n    function(x, row.names=NULL, optional=FALSE, ..., value.name=\"value\",\n             use.outer.mcols=FALSE, group_name.as.factor=FALSE)\n{\n    if (!isSingleString(value.name))\n        stop(\"'value.name' must be a single string\")\n    if (!isTRUEorFALSE(use.outer.mcols))\n        stop(\"'use.outer.mcols' must be TRUE or FALSE\")\n    ans <- as.data.frame(unlist(x, use.names=FALSE),\n                         row.names=row.names, optional=optional, ...)\n    if (ncol(ans) == 1L)\n        colnames(ans)[1L] <- value.name\n    group_and_group_name <- .make_group_and_group_name(elementNROWS(x),\n                                                       group_name.as.factor)\n    ans <- cbind(group_and_group_name, ans)\n    if (use.outer.mcols) {\n        x_mcols <- mcols(x, use.names=FALSE)\n        if (length(x_mcols) != 0L) {\n            extra_cols <- as.data.frame(x_mcols)\n            extra_cols <- extract_data_frame_rows(extra_cols, ans[[1L]])\n            ans <- cbind(ans, extra_cols)\n        }\n    }\n    ans\n}\nsetMethod(\"as.data.frame\", \"List\", .as.data.frame.List)\n\n",
        "List-comparison.R": "### =========================================================================\n### Comparing and ordering List objects\n### -------------------------------------------------------------------------\n###\n\n\n### Method signatures for binary comparison operators.\n.OP2_SIGNATURES <- list(\n    c(\"List\", \"List\"),\n    c(\"List\", \"list\"),\n    c(\"list\", \"List\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompareRecursively()\n###\n### NOT exported!\n###\n### By default, List objects pcompare recursively. Exceptions to the rule\n### (e.g. IntegerRanges, XStringList, etc...) must define a\n### \"pcompareRecursively\" method that returns FALSE.\n###\n\nsetGeneric(\"pcompareRecursively\",\n    function(x) standardGeneric(\"pcompareRecursively\")\n)\n\nsetMethod(\"pcompareRecursively\", \"List\", function(x) TRUE)\nsetMethod(\"pcompareRecursively\", \"list\", function(x) TRUE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .op1_apply() and .op2_apply() internal helpers\n###\n\n### Apply a unary operator.\n.op1_apply <- function(OP1, x, ..., ANS_CONSTRUCTOR)\n{\n    comp_rec_x <- pcompareRecursively(x)\n    if (!comp_rec_x) {\n        OP1_Vector_method <- selectMethod(OP1, \"Vector\")\n        return(OP1_Vector_method(x, ...))\n    }\n    compress_ans <- !is(x, \"SimpleList\")\n    ## Note that we should just be able to do\n    ##   y <- lapply(x, OP1, ...)\n    ## instead of the extremely obfuscated form below (which, in a bug-free\n    ## world, should be equivalent to the simple form above).\n    ## However, because of a regression in R 3.4.2, using the simple form\n    ## above doesn't seem to work properly if OP1 is a generic function with\n    ## dispatch on ... (e.g. order()). The form below seems to work though,\n    ## so we use it as a temporary workaround.\n    y <- lapply(x, function(xi) do.call(OP1, list(xi, ...)))\n    ANS_CONSTRUCTOR(y, compress=compress_ans)\n}\n\n### Apply a binary operator.\n.op2_apply <- function(OP2, x, y, ..., ANS_CONSTRUCTOR)\n{\n    comp_rec_x <- pcompareRecursively(x)\n    comp_rec_y <- pcompareRecursively(y)\n    if (!(comp_rec_x || comp_rec_y)) {\n        OP2_Vector_method <- selectMethod(OP2, c(\"Vector\", \"Vector\"))\n        return(OP2_Vector_method(x, y, ...))\n    }\n    if (!comp_rec_x)\n        x <- list(x)\n    if (!comp_rec_y)\n        y <- list(y)\n    compress_ans <- !((is(x, \"SimpleList\") || is.list(x)) &&\n                      (is(y, \"SimpleList\") || is.list(y)))\n    x_len <- length(x)\n    y_len <- length(y)\n    if (x_len == 0L || y_len == 0L) {\n        ans <- ANS_CONSTRUCTOR(compress=compress_ans)\n    } else {\n        ans <- ANS_CONSTRUCTOR(mapply(OP2, x, y, MoreArgs=list(...),\n                                      SIMPLIFY=FALSE, USE.NAMES=FALSE),\n                               compress=compress_ans)\n    }\n    ## 'ans' is guaranteed to have the length of 'x' or 'y'.\n    x_names <- names(x)\n    y_names <- names(y)\n    if (!(is.null(x_names) && is.null(y_names))) {\n        ans_len <- length(ans)\n        if (x_len != y_len) {\n            if (x_len == ans_len) {\n                ans_names <- x_names\n            } else {\n                ans_names <- y_names\n            }\n        } else {\n            if (is.null(x_names)) {\n                ans_names <- y_names\n            } else {\n                ans_names <- x_names\n            }\n        }\n        names(ans) <- ans_names\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Element-wise (aka \"parallel\") comparison of 2 List objects.\n###\n\nsetMethods(\"pcompare\", .OP2_SIGNATURES,\n           function(x, y) .op2_apply(pcompare, x, y, ANS_CONSTRUCTOR=IRanges::IntegerList)\n)\n\nsetMethods(\"==\", .OP2_SIGNATURES,\n           function(e1, e2) .op2_apply(`==`, e1, e2, ANS_CONSTRUCTOR=IRanges::LogicalList)\n)\n\nsetMethods(\"<=\", .OP2_SIGNATURES,\n           function(e1, e2) .op2_apply(`<=`, e1, e2, ANS_CONSTRUCTOR=IRanges::LogicalList)\n)\n\n### The remaining comparison binary operators (!=, >=, <, >) will work\n### out-of-the-box on List objects thanks to the \"!\" methods below and to the\n### methods for Vector objects.\nsetMethod(\"!\", \"List\",\n    function(x)\n    {\n        if (is(x, \"RleList\")) {\n            ANS_CONSTRUCTOR <- IRanges::RleList\n        } else {\n            ANS_CONSTRUCTOR <- IRanges::LogicalList\n        }\n        .op1_apply(`!`, x, ANS_CONSTRUCTOR=ANS_CONSTRUCTOR)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n\nsetMethods(\"match\", .OP2_SIGNATURES,\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n    {\n        if (is(x, \"RleList\")) {\n            ANS_CONSTRUCTOR <- IRanges::RleList\n        } else {\n            ANS_CONSTRUCTOR <- IRanges::IntegerList\n        }\n        .op2_apply(match, x, table,\n                   nomatch=nomatch, incomparables=incomparables, ...,\n                   ANS_CONSTRUCTOR=ANS_CONSTRUCTOR)\n    }\n)\n\n### 2 of the 3 \"match\" methods defined above have signatures List,list and\n### List,List and therefore are more specific than the 2 methods below.\n### So in the methods below 'table' is guaranteed to be a vector that is not\n### a list or a Vector that is not a List.\nsetMethods(\"match\", list(c(\"List\", \"vector\"), c(\"List\", \"Vector\")),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL, ...)\n    {\n        match(x, list(table),\n              nomatch=nomatch, incomparables=incomparables, ...)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### duplicated() & unique()\n###\n\n.duplicated.List <- function(x, incomparables=FALSE,\n                               fromLast=FALSE, ...)\n{\n    .op1_apply(duplicated, x,\n               incomparables=incomparables, fromLast=fromLast, ...,\n               ANS_CONSTRUCTOR=IRanges::LogicalList)\n}\nsetMethod(\"duplicated\", \"List\", .duplicated.List)\n\n.unique.List <- function(x, incomparables=FALSE, ...)\n{\n    if (!pcompareRecursively(x)) {\n        return(callNextMethod())\n    }\n    i <- !duplicated(x, incomparables=incomparables, ...)  # LogicalList\n    x[i]\n}\nsetMethod(\"unique\", \"List\", .unique.List)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### %in%\n###\n\n### The \"%in%\" method for Vector objects calls is.na() internally.\nsetMethod(\"is.na\", \"List\",\n    function(x)\n    {\n        if (is(x, \"RleList\")) {\n            ANS_CONSTRUCTOR <- IRanges::RleList\n        } else {\n            ANS_CONSTRUCTOR <- IRanges::LogicalList\n        }\n        .op1_apply(is.na, x, ANS_CONSTRUCTOR=ANS_CONSTRUCTOR)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### order() and related methods.\n###\n\nsetMethod(\"order\", \"List\",\n    function(..., na.last=TRUE, decreasing=FALSE,\n                  method=c(\"auto\", \"shell\", \"radix\"))\n    {\n        args <- list(...)\n        if (length(args) != 1L)\n            stop(\"\\\"order\\\" method for List objects \",\n                 \"can only take one input object\")\n        .op1_apply(order, args[[1L]],\n                   na.last=na.last, decreasing=decreasing, method=method,\n                   ANS_CONSTRUCTOR=IRanges::IntegerList)\n    }\n)\n\n### S3/S4 combo for sort.List\n.sort_List <- function(x, decreasing=FALSE, na.last=NA, by)\n{\n    if (!missing(by) || !pcompareRecursively(x))\n        return(callNextMethod())\n    i <- order(x, na.last=na.last, decreasing=decreasing)  # IntegerList\n    x[i]\n}\nsort.List <- function(x, decreasing=FALSE, ...)\n    .sort_List(x, decreasing=decreasing, ...)\nsetMethod(\"sort\", \"List\", .sort_List)\n\nsetMethod(\"rank\", \"List\",\n    function(x, na.last=TRUE,\n             ties.method=c(\"average\", \"first\", \"random\", \"max\", \"min\"))\n    {\n        .op1_apply(rank, x,\n                   na.last=na.last, ties.method=ties.method,\n                   ANS_CONSTRUCTOR=IRanges::IntegerList)\n    }\n)\n\nsetMethod(\"is.unsorted\", \"List\", function(x, na.rm = FALSE, strictly = FALSE) {\n              vapply(x, is.unsorted, logical(1L), na.rm=na.rm,\n                     strictly=strictly)\n          })\n\n",
        "List-utils.R": "### =========================================================================\n### Common operations on List objects\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Looping on List objects\n###\n\nsetMethod(\"lapply\", \"List\",\n    function(X, FUN, ...)\n    {\n        FUN <- match.fun(FUN)\n        ii <- setNames(seq_along(X), names(X))\n        lapply(ii, function(i) FUN(X[[i]], ...))\n    }\n)\n\n.sapplyDefault <- base::sapply\nenvironment(.sapplyDefault) <- topenv()\nsetMethod(\"sapply\", \"List\", .sapplyDefault)\n\n### Turn ordinary list 'ans' into an object of the same class as list-like\n### object 'X'. Preserve the length and names of 'ans'. Propagate the metadata\n### and metadata columns from 'X'.\n.make_endoapply_ans <- function(ans, X)\n{\n    ans <- coerce2(ans, X)\n    if (is(X, \"Vector\")) {\n        metadata(ans) <- metadata(X)\n        mcols(ans) <- mcols(X, use.names=FALSE)\n    }\n    ans\n}\n\nendoapply <- function(X, FUN, ...)\n{\n    ans <- lapply(X, FUN, ...)\n    .make_endoapply_ans(ans, X)\n}\n\nsetGeneric(\"revElements\", signature=\"x\",\n    function(x, i) standardGeneric(\"revElements\")\n)\n\n### These 2 methods explain the concept of revElements() but they are not\n### efficient because they loop over the elements of 'x[i]'.\n### There is a fast method for CompressedList objects though.\nsetMethod(\"revElements\", \"list\",\n    function(x, i)\n    {\n        x[i] <- lapply(x[i], revROWS)\n        x\n    }\n)\n\nsetMethod(\"revElements\", \"List\",\n    function(x, i)\n    {\n        x[i] <- endoapply(x[i], revROWS)\n        x\n    }\n)\n\nmendoapply <- function(FUN, ..., MoreArgs=NULL)\n{\n    arg1 <- list(...)[[1L]]\n    ans <- mapply(FUN, ..., MoreArgs=MoreArgs, SIMPLIFY=FALSE)\n    .make_endoapply_ans(ans, arg1)\n}\n\n### Element-wise c() for list-like objects.\n### This is a fast mapply(c, ..., SIMPLIFY=FALSE) but with the following\n### differences:\n###   1) pc() ignores the supplied objects that are NULL.\n###   2) pc() does not recycle its arguments. All the supplied objects must\n###      have the same length.\n###   3) If one of the supplied objects is a List object, then pc() returns a\n###      List object.\n###   4) pc() always returns a homogenous list or List object, that is, an\n###      object where all the list elements have the same type.\npc <- function(...)\n{\n    args <- unname(list(...))\n    args <- args[!sapply_isNULL(args)]\n    if (length(args) == 0L)\n        return(list())\n    if (length(args) == 1L)\n        return(args[[1L]])\n    args_NROWS <- elementNROWS(args)\n    if (!all(args_NROWS == args_NROWS[[1L]]))\n        stop(\"all the objects to combine must have the same length\")\n\n    ans_as_List <- any(vapply(args, is, logical(1), \"List\", USE.NAMES=FALSE))\n    SPLIT.FUN <- if (ans_as_List) splitAsList else split\n    ans_unlisted <- do.call(c, lapply(args, unlist, use.names=FALSE))\n    f <- structure(unlist(lapply(args, quick_togroup), use.names=FALSE),\n                   levels=as.character(seq_along(args[[1L]])),\n                   class=\"factor\")\n    setNames(SPLIT.FUN(ans_unlisted, f), names(args[[1L]]))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Functional programming methods\n###\n\n### Copy+pasted to disable forced as.list() coercion\n.ReduceDefault <- function(f, x, init, right = FALSE, accumulate = FALSE) \n{\n    mis <- missing(init)\n    len <- length(x)\n    if (len == 0L) \n        return(if (mis) NULL else init)\n    f <- match.fun(f)\n#    if (!is.vector(x) || is.object(x)) \n#        x <- as.list(x)\n    ind <- seq_len(len)\n    if (mis) {\n        if (right) {\n            init <- x[[len]]\n            ind <- ind[-len]\n        }\n        else {\n            init <- x[[1L]]\n            ind <- ind[-1L]\n        }\n    }\n    if (!accumulate) {\n        if (right) {\n            for (i in rev(ind)) init <- f(x[[i]], init)\n        }\n        else {\n            for (i in ind) init <- f(init, x[[i]])\n        }\n        init\n    }\n    else {\n        len <- length(ind) + 1L\n        out <- vector(\"list\", len)\n        if (mis) {\n            if (right) {\n                out[[len]] <- init\n                for (i in rev(ind)) {\n                    init <- f(x[[i]], init)\n                    out[[i]] <- init\n                }\n            }\n            else {\n                out[[1L]] <- init\n                for (i in ind) {\n                    init <- f(init, x[[i]])\n                    out[[i]] <- init\n                }\n            }\n        }\n        else {\n            if (right) {\n                out[[len]] <- init\n                for (i in rev(ind)) {\n                    init <- f(x[[i]], init)\n                    out[[i]] <- init\n                }\n            }\n            else {\n                for (i in ind) {\n                    out[[i]] <- init\n                    init <- f(init, x[[i]])\n                }\n                out[[len]] <- init\n            }\n        }\n        if (all(lengths(out) == 1L)) \n            out <- unlist(out, recursive = FALSE)\n        out\n    }\n}\n\nsetMethod(\"Reduce\", \"List\", .ReduceDefault)\n\n### Presumably to avoid base::lapply coercion to list.\n.FilterDefault <- base::Filter\nenvironment(.FilterDefault) <- topenv()\nsetMethod(\"Filter\", \"List\", .FilterDefault)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Evaluating.\n###\n\nsetMethod(\"within\", \"List\",\n          function(data, expr, ...)\n          {\n            ## cannot use active bindings here, as they break for replacement\n            enclos <- top_prenv(expr)\n            e <- list2env(as.list(data), parent=enclos)\n            safeEval(substitute(expr), e, enclos)\n            l <- mget(ls(e), e)\n            l <- delete_NULLs(l)\n            nD <- length(del <- setdiff(names(data), (nl <- names(l))))\n            for (nm in nl)\n              data[[nm]] <- l[[nm]]\n            for (nm in del)\n              data[[nm]] <- NULL\n            data\n          })\n\nsetMethod(\"do.call\", c(\"ANY\", \"List\"),\n          function (what, args, quote = FALSE, envir = parent.frame()) {\n            args <- as.list(args)\n            callGeneric()\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Factors.\n###\n\ndroplevels.List <- function(x, ...) droplevels(x, ...)\n.droplevels.List <- function(x, except = NULL) \n{\n  ix <- vapply(x, Has(levels), logical(1L))\n  ix[except] <- FALSE\n  x[ix] <- lapply(x[ix], droplevels)\n  x\n}\n\nsetMethod(\"droplevels\", \"List\", .droplevels.List)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Summarizing.\n###\n\nsetMethod(\"anyNA\", \"List\", function(x, recursive=FALSE) {\n    stopifnot(isTRUEorFALSE(recursive))\n    if (recursive) {\n        anyNA(as.list(x), recursive=TRUE)\n    } else {\n        callNextMethod()\n    }\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Matrix construction\n###\n\n.normBindArgs <- function(..., deparse.level=1L) {\n    stopifnot(isSingleNumber(deparse.level),\n              deparse.level >= 0L,\n              deparse.level <= 2L)\n    args <- list(...)\n    if (deparse.level > 0L) {\n        exprs <- as.list(substitute(list(...)))[-1L]\n        genName <- if (is.null(names(args))) TRUE else names(args) == \"\"\n        if (deparse.level == 1L && any(genName))\n            genName <- genName & vapply(exprs, is.name, logical(1L))\n        if (any(genName)) {\n            if (is.null(names(args)))\n                names(args) <- rep(\"\", length(args))\n            names(args)[genName] <- as.character(exprs[genName])\n        }\n    }\n    args\n}\n\nsetMethod(\"rbind\", \"List\", function(..., deparse.level=1L) {\n    args <- .normBindArgs(..., deparse.level=deparse.level)\n    do.call(rbind, lapply(args, as.list))\n})\n\n### S3/S4 combo for cbind.List\ncbind.List <- function(..., deparse.level=1L) {\n    args <- .normBindArgs(..., deparse.level=deparse.level)\n    do.call(cbind, lapply(args, as.list))\n}\nsetMethod(\"cbind\", \"List\", cbind.List)\n\n",
        "Pairs-class.R": "### =========================================================================\n### Pairs objects\n### -------------------------------------------------------------------------\n###\n### Two parallel vectors. Could result from \"dereferencing\" a Hits.\n###\n\nsetClass(\"Pairs\",\n         contains=\"Vector\",\n         representation(first=\"ANY\",\n                        second=\"ANY\",\n                        NAMES=\"character_OR_NULL\"),\n         prototype(first=logical(0L),\n                   second=logical(0L),\n                   elementMetadata=DataFrame()))\n\nsetMethod(\"parallel_slot_names\", \"Pairs\", function(x)\n    c(\"first\", \"second\", \"NAMES\", callNextMethod()))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetGeneric(\"first\", function(x, ...) standardGeneric(\"first\"))\nsetGeneric(\"second\", function(x, ...) standardGeneric(\"second\"))\n\nsetMethod(\"first\", \"Pairs\", function(x) x@first)\nsetMethod(\"second\", \"Pairs\", function(x) x@second)\n\nsetGeneric(\"first<-\", function(x, ..., value) standardGeneric(\"first<-\"),\n           signature=\"x\")\nsetGeneric(\"second<-\", function(x, ..., value) standardGeneric(\"second<-\"),\n           signature=\"x\")\n\nsetReplaceMethod(\"first\", \"Pairs\", function(x, value) {\n                     x@first <- value\n                     x\n                 })\nsetReplaceMethod(\"second\", \"Pairs\", function(x, value) {\n                     x@second <- value\n                     x\n                 })\n\nsetMethod(\"names\", \"Pairs\", function(x) x@NAMES)\nsetReplaceMethod(\"names\", \"Pairs\", function(x, value) {\n                     x@NAMES <- value\n                     x\n                 })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nPairs <- function(first, second, ..., names = NULL, hits = NULL) {\n    if (!is.null(hits)) {\n        stopifnot(is(hits, \"Hits\"),\n                  queryLength(hits) == length(first),\n                  subjectLength(hits) == length(second))\n        first <- first[queryHits(hits)]\n        second <- second[subjectHits(hits)]\n    }\n    stopifnot(NROW(first) == NROW(second),\n              is.null(names) || length(names) == NROW(first))\n    if (!missing(...)) {\n        elementMetadata <- DataFrame(...)\n    } else {\n        elementMetadata <- make_zero_col_DFrame(NROW(first))\n    }\n    new(\"Pairs\", first=first, second=second, NAMES=names,\n                 elementMetadata=elementMetadata)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Comparison\n### \n\nsetMethod(\"order\", \"Pairs\", function (..., na.last = TRUE, decreasing = FALSE, \n    method = c(\"auto\", \"shell\", \"radix\"))\n{\n    collected <- lapply(list(...), FUN=function(x) list(first(x), second(x)))\n    do.call(order, c(unlist(collected, recursive=TRUE), \n        list(na.last=na.last, decreasing=decreasing, method=method)))\n})\n\nsetMethod(\"sameAsPreviousROW\", \"Pairs\", function(x) {\n    N <- length(x)\n    if (N==0L) {\n        return(logical(0))\n    }\n    a1 <- first(x)\n    a2 <- second(x)\n    c(FALSE, a1[-1L]==a1[-N] & a2[-1L]==a2[-N])\n})\n\nsetMethod(\"pcompare\", c(\"Pairs\", \"Pairs\"), function(x, y) {\n    ans1 <- pcompare(first(x), first(y))\n    ans2 <- pcompare(second(x), second(y))\n    ifelse(ans1!=0, ans1, ans2)\n})\n\nsetMethod(\"match\", c(\"Pairs\", \"Pairs\"),\n          function(x, table, nomatch = NA_integer_, incomparables = NULL, ...) {\n              if (!is.null(incomparables))\n                  stop(\"'incomparables' must be NULL\")\n              hits <- intersect(findMatches(first(x), first(table), ...),\n                                findMatches(second(x), second(table), ...))\n              ans <- selectHits(hits, \"first\")\n              if (!identical(nomatch, NA_integer_)) {\n                  ans[is.na(ans)] <- nomatch\n              }\n              ans\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coerce\n### \n### We use 'zipup' and 'zipdown' because '(un)zip' already taken by utils.\n###\n\nsetGeneric(\"zipup\", function(x, y, ...) standardGeneric(\"zipup\"))\n\nsetMethod(\"zipup\", c(\"ANY\", \"ANY\"), function(x, y) {\n              stopifnot(NROW(x) == NROW(y))\n              linear <- bindROWS(x, list(y))\n              collate_subscript <- make_XYZxyz_to_XxYyZz_subscript(NROW(x))\n              linear <- extractROWS(linear, collate_subscript)\n              names <- if (!is.null(ROWNAMES(x))) ROWNAMES(x) else ROWNAMES(y)\n              p <- IRanges::PartitioningByWidth(rep(2L, NROW(x)), names=names)\n              relist(linear, p)\n          })\n\nsetMethod(\"zipup\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n              zipped <- zipup(first(x), second(x), ...)\n              names(zipped) <- names(x)\n              mcols(zipped) <- mcols(x, use.names=FALSE)\n              zipped\n          })\n\nsetGeneric(\"zipdown\", function(x, ...) standardGeneric(\"zipdown\"))\n\nsetMethod(\"zipdown\", \"ANY\", function(x) {\n              stopifnot(all(lengths(x) == 2L))\n              p <- IRanges::PartitioningByEnd(x)\n              v <- unlist(x, use.names=FALSE)\n              Pairs(extractROWS(v, start(p)), extractROWS(v, end(p)),\n                    names=names(x))\n          })\n\nsetMethod(\"zipdown\", \"List\", function(x) {\n              unzipped <- callNextMethod()\n              mcols(unzipped) <- mcols(x, use.names=FALSE)\n              unzipped\n          })\n\nsetAs(\"Pairs\", \"DFrame\", function(from) {\n          df <- DataFrame(first=first(from), second=second(from),\n                          mcols(from, use.names=FALSE), check.names=FALSE)\n          df$names <- names(from)\n          df\n      })\n\nsetMethod(\"as.data.frame\", \"Pairs\",\n          function (x, row.names = NULL, optional = FALSE, ...) {\n              as.data.frame(as(x, \"DataFrame\"), optional=optional,\n                            row.names=row.names, ...)\n          })\n\nsetAs(\"list_OR_List\", \"Pairs\",\n          function(from) {\n              zipdown(from)\n     })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Utilities\n###\n\nsetMethod(\"t\", \"Pairs\", function(x) {\n    tx <- x\n    first(tx) <- second(x)\n    second(tx) <- first(x)\n    tx\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show\n###\n\n.from_Pairs_to_naked_character_matrix_for_display <- function(x)\n{\n    m <- cbind(first=showAsCell(first(x)),\n               second=showAsCell(second(x)))\n    cbind_mcols_for_display(m, x)\n}\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"Pairs\",\n    .from_Pairs_to_naked_character_matrix_for_display\n)\n\nshowPairs <- function(x, margin = \"\", print.classinfo = FALSE) {\n    x_class <- class(x)\n    x_len <- length(x)\n    x_mcols <- mcols(x, use.names=FALSE)\n    x_nmc <- if (is.null(x_mcols)) \n                 0L\n             else ncol(x_mcols)\n    cat(x_class, \" object with \", x_len, \" pair\",\n        ifelse(x_len ==  1L, \"\", \"s\"), \" and \", x_nmc, \" metadata column\",\n        ifelse(x_nmc == 1L, \"\", \"s\"), \":\\n\", sep = \"\")\n    out <- makePrettyMatrixForCompactPrinting(x)\n    if (print.classinfo) {\n        .COL2CLASS <- c(first = class(first(x)), second = class(second(x)))\n        classinfo <- makeClassinfoRowForCompactPrinting(x, .COL2CLASS)\n        stopifnot(identical(colnames(classinfo), colnames(out)))\n        out <- rbind(classinfo, out)\n    }\n    if (nrow(out) != 0L) \n        rownames(out) <- paste0(margin, rownames(out))\n    print(out, quote = FALSE, right = TRUE, max = length(out))\n}\n\nsetMethod(\"show\", \"Pairs\", function(object) {\n              showPairs(object, margin = \"  \", print.classinfo = TRUE)\n          })\n",
        "RectangularData-class.R": "### =========================================================================\n### RectangularData objects\n### -------------------------------------------------------------------------\n###\n### RectangularData is a virtual class with no slots to be extended by\n### classes that aim at representing objects with a rectangular shape.\n### Current RectangularData derivatives are DataFrame, DelayedMatrix,\n### SummarizedExperiment, and Assays objects.\n### RectangularData derivatives are expected to support the 2D API: at\n### least 'dim()', but also typically 'dimnames()', `[` (the 2D form\n### 'x[i, j]'), 'bindROWS()', and 'bindCOLS()'.\n###\n\nsetClass(\"RectangularData\", representation(\"VIRTUAL\"))\n\n.validate_RectangularData <- function(x)\n{\n    x_dim <- try(dim(x), silent=TRUE)\n    if (inherits(x_dim, \"try-error\"))\n        return(\"'dim(x)' must work\")\n    if (!(is.vector(x_dim) && is.numeric(x_dim)))\n        return(\"'dim(x)' must return a numeric vector\")\n    if (length(x_dim) != 2L)\n        return(\"'x' must have exactly 2 dimensions\")\n    TRUE\n}\n\nsetValidity2(\"RectangularData\", .validate_RectangularData)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### vertical_slot_names() and horizontal_slot_names()\n###\n### For internal use only.\n###\n\n### vertical_slot_names() must return the names of all the slots in\n### RectangularData derivative 'x' that are **parallel** to its 1st\n### dimension. Slot \"foo\" in 'x' is considered to be parallel to its\n### 1st dimension if it's guaranteed to contain a value that is either\n### NULL or such that 'NROW(x@foo)' is equal to 'nrow(x)' and the i-th\n### ROW in 'x@foo' is associated with the i-th row in 'x'.\nsetGeneric(\"vertical_slot_names\",\n    function(x) standardGeneric(\"vertical_slot_names\")\n)\n\n### horizontal_slot_names() must return the names of all the slots in\n### RectangularData derivative 'x' that are **parallel** to its 2nd\n### dimension. Slot \"bar\" in 'x' is considered to be parallel to its\n### 2nd dimension if it's guaranteed to contain a value that is either\n### NULL or such that 'NROW(x@bar)' is equal to 'ncol(x)' and the j-th\n### ROW in 'x@bar' is associated with the j-th col in 'x'.\nsetGeneric(\"horizontal_slot_names\",\n    function(x) standardGeneric(\"horizontal_slot_names\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"dim\", \"RectangularData\", function(x) c(nrow(x), ncol(x)))\n\nsimplify_NULL_dimnames <- function(dimnames)\n{\n    if (all(sapply_isNULL(dimnames)))\n        return(NULL)\n    dimnames\n}\n\nsetMethod(\"dimnames\", \"RectangularData\",\n    function(x)\n    {\n        ans <- list(rownames(x), colnames(x))\n        simplify_NULL_dimnames(ans)\n    }\n)\n\nsetReplaceMethod(\"dimnames\", \"RectangularData\",\n    function(x, value)\n    {\n        if (is.null(value)) {\n            new_rownames <- new_colnames <- NULL\n        } else {\n            if (!(is.list(value) && length(value) == 2L))\n                stop(wmsg(\"dimnames replacement value must \",\n                          \"be NULL or a list of length 2\"))\n            new_rownames <- value[[1L]]\n            new_colnames <- value[[2L]]\n        }\n        rownames(x) <- new_rownames\n        colnames(x) <- new_colnames\n        x\n    }\n)\n\nsetGeneric(\"ROWNAMES\", function(x) standardGeneric(\"ROWNAMES\"))\n\nsetMethod(\"ROWNAMES\", \"ANY\",\n    function (x) if (length(dim(x)) != 0L) rownames(x) else names(x)\n)\n\nsetMethod(\"ROWNAMES\", \"RectangularData\", function(x) rownames(x))\n\nsetGeneric(\"ROWNAMES<-\", function(x, value) standardGeneric(\"ROWNAMES<-\"))\n\nsetReplaceMethod(\"ROWNAMES\", \"ANY\",\n                 function (x, value) {\n                     if (length(dim(x)) != 0L)\n                         rownames(x) <- value\n                     else names(x) <- value\n                     x\n                 })\n\nsetReplaceMethod(\"ROWNAMES\", \"RectangularData\", function(x, value) {\n    rownames(x) <- value\n    x\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nhead.RectangularData <- utils::head.matrix\nsetMethod(\"head\", \"RectangularData\", head.RectangularData)\n\ntail.RectangularData <- utils::tail.matrix\nsetMethod(\"tail\", \"RectangularData\", tail.RectangularData)\n\nsetMethod(\"subset\", \"RectangularData\",\n    function(x, subset, select, drop=FALSE, ...)\n    {\n        i <- evalqForSubset(subset, x, ...)\n        j <- evalqForSelect(select, x, ...)\n        x[i, j, drop=drop]\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Binding\n###\n\n### S3/S4 combo for rbind.RectangularData\nrbind.RectangularData <- function(..., deparse.level=1)\n{\n    if (!identical(deparse.level, 1))\n        warning(wmsg(\"the rbind() method for RectangularData objects \",\n                     \"ignores the 'deparse.level' argument\"))\n    objects <- list(...)\n    bindROWS(objects[[1L]], objects=objects[-1L])\n}\nsetMethod(\"rbind\", \"RectangularData\", rbind.RectangularData)\n\n### S3/S4 combo for cbind.RectangularData\ncbind.RectangularData <- function(..., deparse.level=1)\n{\n    if (!identical(deparse.level, 1))\n        warning(wmsg(\"the cbind() method for RectangularData objects \",\n                     \"ignores the 'deparse.level' argument\"))\n    objects <- list(...)\n    bindCOLS(objects[[1L]], objects=objects[-1L])\n}\nsetMethod(\"cbind\", \"RectangularData\", cbind.RectangularData)\n\n### Two additional generic functions to bind rectangular objects by rows\n### or columns. Unlike rbind() or cbind(), these will handle cases involving\n### differences in the colnames or rownames of their input objects by adding\n### the missing rows or columns and filling them with NAs.\n\nsetGeneric(\"combineRows\",\n    function(x, ...) standardGeneric(\"combineRows\")\n)\n\nsetGeneric(\"combineCols\",\n    function(x, ..., use.names=TRUE) standardGeneric(\"combineCols\")\n)\n\n### Finally, a more specialized function by Aaron Lun. Implemented on top\n### of combineCols() and expected to work on any input objects for which\n### combineCols() works.\n### Unlike with combineCols(), the ncol() of combineUniqueCols's output is not\n### equal to the sum of the ncols() of its inputs. As such, it is a separate\n### function rather than being an option in combineCols().\ncombineUniqueCols <- function(x, ..., use.names=TRUE)\n{\n    if (missing(x)) {\n        all_objects <- list(...)\n    } else {\n        all_objects <- list(x, ...)\n    }\n\n    combined <- do.call(combineCols, c(all_objects, list(use.names=use.names)))\n    if (is.null(colnames(combined))) {\n        return(combined)\n    }\n\n    # Unnamed columns are never considered duplicates of each other.\n    retain <- !duplicated(colnames(combined)) | colnames(combined)==\"\"\n    combined <- combined[,retain,drop=FALSE]\n\n    all_colnames <- lapply(all_objects, colnames)\n    object_indices <- rep(seq_along(all_colnames), lengths(all_colnames))\n    col_indices <- sequence(lengths(all_colnames))\n\n    all_colnames <- unlist(all_colnames)\n    objects_by_colname <- split(object_indices, all_colnames)\n    col_by_colname <- split(col_indices, all_colnames)\n    dupped <- names(objects_by_colname)[lengths(objects_by_colname) > 1]\n\n    dupped <- setdiff(dupped, \"\")\n\n    for (d in dupped) {\n        object_affected <- objects_by_colname[[d]]\n        col_affected <- col_by_colname[[d]]\n        reference <- combined[,d]\n        first_object <- object_affected[1]\n\n        if (use.names) {\n            filled <- rownames(combined) %in% rownames(all_objects[[first_object]])\n\n            for (i in seq_along(object_affected)[-1]) {\n                i_object <- object_affected[i]\n                i_col <- col_affected[i]\n                cur_object <- all_objects[[i_object]]\n                replacements <- cur_object[,i_col]\n\n                candidates <- match(rownames(cur_object), rownames(combined))\n                overlapped <- filled[candidates]\n                previous <- extractROWS(reference, candidates)\n\n                # Only doing the replacement if the overlaps are identical.\n                # Incidentally, this also checks for the right type. We could\n                # be more aggressive and do a partial replacement, but\n                # something is probably already wrong if this warning fires.\n                if (!identical(extractROWS(previous, overlapped), extractROWS(replacements, overlapped))) {\n                    warning(wmsg(\"different values for shared rows in multiple instances of column '\",\n                        d, \"', ignoring this column in \", class(all_objects[[i_object]]), \" \", i_object))\n                } else {\n                    reference <- replaceROWS(reference, candidates, replacements)\n                    filled[candidates] <- TRUE\n                }\n            }\n\n            # Can't use 'combined[ , j] <- col' to replace the column of a\n            # data-frame-like object!\n            # See https://github.com/Bioconductor/S4Vectors/issues/100\n            if (is.data.frame(combined) || is(combined, \"DataFrame\")) {\n                combined[[d]] <- reference\n            } else {\n                # Expected to work on any rectangular object (e.g. matrix,\n                # dgCMatrix, DelayedMatrix, SummarizedExperiment, etc...)\n                # except data-frame-like objects.\n                combined[ , d] <- reference\n            }\n\n        } else {\n            for (i in seq_along(object_affected)[-1]) {\n                i_object <- object_affected[i]\n                i_col <- col_affected[i]\n                if (!identical(all_objects[[i_object]][,i_col], reference)) {\n                    # In this case, the warning is only emitted if they are not identical.\n                    warning(wmsg(\"different values in multiple instances of column '\",\n                        d, \"', ignoring this column in \", class(all_objects[[i_object]]), \" \", i_object))\n                }\n            }\n        }\n    }\n\n    combined\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### make_rownames_for_RectangularData_display()\n###\n\n### NOT exported but used in package RNAmodR.\nmake_rownames_for_RectangularData_display <-\n    function(x_rownames, nrow, nhead, ntail)\n{\n    p1 <- ifelse(nhead == 0L, 0L, 1L)\n    p2 <- ifelse(ntail == 0L, 0L, ntail - 1L)\n    s1 <- s2 <- character(0)\n    if (is.null(x_rownames)) {\n        if (nhead > 0L)\n            s1 <- paste0(as.character(p1:nhead))\n        if (ntail > 0L)\n            s2 <- paste0(as.character((nrow-p2):nrow))\n    } else {\n        if (nhead > 0L)\n            s1 <- paste0(head(x_rownames, nhead))\n        if (ntail > 0L)\n            s2 <- paste0(tail(x_rownames, ntail))\n    }\n    c(s1, \"...\", s2)\n}\n\n",
        "Rle-class.R": "### =========================================================================\n### Rle objects\n### -------------------------------------------------------------------------\n###\n\n\nsetClass(\"Rle\",\n    contains=\"Vector\",\n    representation(\n        values=\"vector_OR_factor\",\n        lengths=\"integer_OR_LLint\"\n    ),\n    prototype(\n        values=logical(0),\n        lengths=integer(0)\n    )\n)\n\n \n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"length\", \"Rle\",\n    function(x) as.double(.Call2(\"Rle_length\", x, PACKAGE=\"S4Vectors\"))\n)\n\nsetGeneric(\"runLength\", signature = \"x\",\n           function(x) standardGeneric(\"runLength\"))\nsetMethod(\"runLength\", \"Rle\", function(x) x@lengths)\n \nsetGeneric(\"runValue\", signature = \"x\",\n           function(x) standardGeneric(\"runValue\"))\nsetMethod(\"runValue\", \"Rle\", function(x) x@values)\n\nsetGeneric(\"nrun\", signature = \"x\", function(x) standardGeneric(\"nrun\"))\nsetMethod(\"nrun\", \"Rle\", function(x) length(runLength(x)))\n\nsetMethod(\"start\", \"Rle\", function(x) .Call2(\"Rle_start\", x, PACKAGE=\"S4Vectors\"))\nsetMethod(\"end\", \"Rle\", function(x) .Call2(\"Rle_end\", x, PACKAGE=\"S4Vectors\"))\nsetMethod(\"width\", \"Rle\", function(x) runLength(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid_Rle <- function(x)\n{\n    msg <- NULL\n    msg <- c(msg, .Call2(\"Rle_valid\", x, PACKAGE=\"S4Vectors\"))\n    ## Too expensive so commented out for now. Maybe do this in C?\n    #run_values <- runValues(x)\n    #if (length(run_values) >= 2 && is.atomic(run_values) &&\n    #    any(run_values[-1L] == run_values[-length(run_values)]))\n    #    msg <- c(msg, \"consecutive runs must have different values\")\n    msg\n}\n\nsetValidity2(\"Rle\", .valid_Rle)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### Low-level constructor.\nnew_Rle <- function(values=logical(0), lengths=NULL)\n{\n    if (!is(values, \"vector_OR_factor\"))\n        stop(\"Rle of type '\", typeof(values), \"' is not supported\")\n    if (!is.null(lengths)) {\n        if (!(is.numeric(lengths) || is.LLint(lengths)))\n            stop(\"'lengths' must be NULL or a numeric or LLint vector\")\n        if (anyNA(lengths))\n            stop(\"'lengths' cannot contain NAs\")\n        if (is.double(lengths)) {\n            suppressWarnings(lengths <- as.LLint(lengths))\n            if (anyNA(lengths))\n                stop(\"Rle vector is too long\")\n        }\n        if (length(lengths) == 1L)\n            lengths <- rep.int(lengths, length(values))\n    }\n    .Call2(\"Rle_constructor\", values, lengths, PACKAGE=\"S4Vectors\")\n}\n\nsetGeneric(\"Rle\", signature=\"values\",\n    function(values=logical(0), lengths=NULL) standardGeneric(\"Rle\")\n)\n\nsetMethod(\"Rle\", \"ANY\",\n    function(values=logical(0), lengths=NULL) new_Rle(values, lengths)\n)\n\nsetMethod(\"Rle\", \"Rle\",\n    function(values=logical(0), lengths=NULL)\n    {\n        if (!missing(lengths))\n            stop(wmsg(\"'lengths' cannot be supplied when calling Rle() \",\n                      \"on an Rle object\"))\n        values\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setters\n###\n\nsetGeneric(\"runLength<-\", signature=\"x\",\n           function(x, value) standardGeneric(\"runLength<-\"))\nsetReplaceMethod(\"runLength\", \"Rle\",\n                 function(x, value) Rle(runValue(x), value))\n         \nsetGeneric(\"runValue<-\", signature=\"x\",\n           function(x, value) standardGeneric(\"runValue<-\"))\nsetReplaceMethod(\"runValue\", \"Rle\",\n                 function(x, value) Rle(value, runLength(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"ANY\", \"Rle\", function(from) Rle(from))\n\nsetAs(\"Rle\", \"vector\", function(from) as.vector(from))\nsetAs(\"Rle\", \"logical\", function(from) as.logical(from))\nsetAs(\"Rle\", \"integer\", function(from) as.integer(from))\nsetAs(\"Rle\", \"numeric\", function(from) as.numeric(from))\nsetAs(\"Rle\", \"complex\", function(from) as.complex(from))\nsetAs(\"Rle\", \"character\", function(from) as.character(from))\nsetAs(\"Rle\", \"raw\", function(from) as.raw(from))\nsetAs(\"Rle\", \"factor\", function(from) as.factor(from))\nsetAs(\"Rle\", \"list\", function(from) as.list(from))\n\nas.vector.Rle <- function(x, mode)\n  rep.int(as.vector(runValue(x), mode), runLength(x))\nsetMethod(\"as.vector\", \"Rle\", as.vector.Rle)\nsetMethod(\"as.factor\", \"Rle\", function(x) rep.int(as.factor(runValue(x)), runLength(x)))\n\nasFactorOrFactorRle <- function(x) {\n  if (is(x, \"Rle\")) {\n    runValue(x) <- as.factor(runValue(x))\n    x\n  } else {\n    as.factor(x)\n  }\n}\n\n### S3/S4 combo for as.list.Rle\nas.list.Rle <- function(x, ...) as.list(as.vector(x), ...)\nsetMethod(\"as.list\", \"Rle\", as.list.Rle)\n\nsetGeneric(\"decode\", function(x, ...) standardGeneric(\"decode\"))\nsetMethod(\"decode\", \"ANY\", identity)\n\ndecodeRle <- function(x) rep.int(runValue(x), runLength(x))\nsetMethod(\"decode\", \"Rle\", decodeRle)\n\n.as.data.frame.Rle <- function(x, row.names=NULL, optional=FALSE, ...)\n{\n    value <- decodeRle(x)\n    as.data.frame(value, row.names=row.names,\n                  optional=optional, ...)\n}\nsetMethod(\"as.data.frame\", \"Rle\", .as.data.frame.Rle)\n\ngetStartEndRunAndOffset <- function(x, start, end) {\n    .Call2(\"Rle_getStartEndRunAndOffset\", x, start, end, PACKAGE=\"S4Vectors\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting workhorses\n###\n### These are the low-level functions that do the real work of subsetting an\n### Rle object. The final coercion to class(x) is to make sure that they act\n### like an endomorphism on objects that belong to a subclass of Rle (the\n### VariantAnnotation package defines Rle subclasses).\n### Note that they drop the metadata columns!\n###\n\n### TODO: Support NAs in 'pos'.\nextract_positions_from_Rle <- function(x, pos, method=0L, decoded=FALSE)\n{\n    if (!is.integer(pos))\n        stop(\"'pos' must be an integer vector\")\n    if (!isTRUEorFALSE(decoded))\n        stop(\"'decoded' must be TRUE or FALSE\")\n    #ans <- .Call2(\"Rle_extract_positions\", x, pos, method, PACKAGE=\"S4Vectors\")\n    mapped_pos <- map_positions_to_runs(runLength(x), pos, method=method)\n    ans <- runValue(x)[mapped_pos]\n    if (decoded)\n        return(ans)\n    as(Rle(ans), class(x))  # so the function is an endomorphism\n}\n\nextract_range_from_Rle <- function(x, start, end)\n{\n    ans <- .Call2(\"Rle_extract_range\", x, start, end, PACKAGE=\"S4Vectors\")\n    as(ans, class(x))  # so the function is an endomorphism\n}\n\n### NOT exported but used in IRanges package (by \"extractROWS\" method with\n### signature Rle,RangesNSBS).\nextract_ranges_from_Rle <- function(x, start, width, method=0L, as.list=FALSE)\n{\n    method <- normarg_method(method)\n    if (!isTRUEorFALSE(as.list))\n        stop(\"'as.list' must be TRUE or FALSE\")\n    ans <- .Call2(\"Rle_extract_ranges\", x, start, width, method, as.list,\n                                        PACKAGE=\"S4Vectors\")\n    ## The function must act like an endomorphism.\n    x_class <- class(x)\n    if (!as.list)\n        return(as(ans, x_class))\n    ## 'ans' is a list of Rle instances.\n    if (x_class == \"Rle\")\n        return(ans)\n    lapply(ans, as, x_class)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"extractROWS\", c(\"Rle\", \"ANY\"),\n    function (x, i) \n    {\n        i <- normalizeSingleBracketSubscript(i, x, allow.NAs=TRUE, as.NSBS=TRUE)\n        callGeneric()\n    }\n)\n\nsetMethod(\"extractROWS\", c(\"Rle\", \"RangeNSBS\"),\n    function(x, i)\n    {\n        range <- i@subscript\n        range_start <- range[[1L]]\n        range_end <- range[[2L]]\n        ans <- extract_range_from_Rle(x, range_start, range_end)\n        mcols(ans) <- extractROWS(mcols(x, use.names=FALSE), i)\n        ans\n    }\n)\n\nsetMethod(\"extractROWS\", c(\"Rle\", \"NSBS\"),\n    function(x, i)\n    {\n        ans <- extract_positions_from_Rle(x, as.integer(i))\n        mcols(ans) <- extractROWS(mcols(x, use.names=FALSE), i)\n        ans\n    }\n)\n\nsetMethod(\"[\", \"Rle\",\n    function(x, i, j, ..., drop=getOption(\"dropRle\", default=FALSE))\n    {\n        if (!missing(j) || length(list(...)) > 0)\n            stop(\"invalid subsetting\")\n        if (!missing(i))\n            x <- extractROWS(x, i)\n        if (drop)\n            x <- decodeRle(x)\n        x\n    }\n)\n\n### The replaced elements in 'x' must get their metadata columns from 'value'.\n### See this thread on bioc-devel:\n###   https://stat.ethz.ch/pipermail/bioc-devel/2015-November/008319.html\nsetMethod(\"replaceROWS\", c(\"Rle\", \"ANY\"),\n    function(x, i, value)\n    {\n        ## FIXME: Right now, the subscript 'i' is turned into an IRanges\n        ## object so we need stuff that lives in the IRanges package for this\n        ## to work. This is ugly/hacky and needs to be fixed (thru a redesign\n        ## of this method).\n        if (!requireNamespace(\"IRanges\", quietly=TRUE))\n            stop(\"Couldn't load the IRanges package. You need to install \",\n                 \"the IRanges\\n  package in order to replace values in \",\n                 \"an Rle object.\")\n\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        lv <- length(value)\n        if (lv != 1L) {\n            ans <- Rle(replaceROWS(decodeRle(x), i, as.vector(value)))\n            mcols(ans) <- replaceROWS(mcols(x, use.names=FALSE), i,\n                                      mcols(value, use.names=FALSE))\n            return(ans)\n        }\n\n        ## From here, 'value' is guaranteed to be of length 1.\n\n        ## TODO: Maybe make this the coercion method from NSBS to IntegerRanges.\n        if (is(i, \"RangesNSBS\")) {\n            ir <- i@subscript\n        } else {\n            ir <- as(as.integer(i), \"IRanges\")\n        }\n        ir <- IRanges::reduce(ir)\n        if (length(ir) == 0L)\n            return(x)\n\n        isFactorRle <- is.factor(runValue(x))\n        value <- normalizeSingleBracketReplacementValue(value, x)\n        value2 <- as.vector(value)\n        if (isFactorRle) {\n            value2 <- factor(value2, levels=levels(x))\n            dummy_value <- factor(levels(x), levels=levels(x))\n        }\n        if (anyMissingOrOutside(start(ir), 1L, length(x)) ||\n            anyMissingOrOutside(end(ir), 1L, length(x)))\n            stop(\"some ranges are out of bounds\")\n\n        valueWidths <- width(ir)\n        ir <- IRanges::gaps(ir, start=1, end=length(x))\n        k <- length(ir)\n        start <- start(ir)\n        end <- end(ir)\n\n        info <- getStartEndRunAndOffset(x, start, end)\n        runStart <- info[[\"start\"]][[\"run\"]]\n        offsetStart <- info[[\"start\"]][[\"offset\"]]\n        runEnd <- info[[\"end\"]][[\"run\"]]\n        offsetEnd <- info[[\"end\"]][[\"offset\"]]\n\n        if ((length(ir) == 0L) || (start(ir)[1L] != 1L)) {\n            k <- k + 1L\n            runStart <- c(1L, runStart)\n            offsetStart <- c(0L, offsetStart)\n            runEnd <- c(0L, runEnd)\n            offsetEnd <- c(0L, offsetEnd)\n        } \n        if ((length(ir) > 0L) && (end(ir[length(ir)]) != length(x))) {\n            k <- k + 1L\n            runStart <- c(runStart, 1L)\n            offsetStart <- c(offsetStart, 0L)\n            runEnd <- c(runEnd, 0L)\n            offsetEnd <- c(offsetEnd, 0L)\n        }\n\n        subseqs <- vector(\"list\", length(valueWidths) + k)\n        if (k > 0L) {\n            if (isFactorRle) {\n                subseqs[seq(1L, length(subseqs), by=2L)] <-\n                    lapply(seq_len(k), function(i) {\n                           ans <- .Call2(\"Rle_window_aslist\",\n                                         x, runStart[i], runEnd[i],\n                                         offsetStart[i], offsetEnd[i],\n                                         PACKAGE=\"S4Vectors\")\n                           ans[[\"values\"]] <- dummy_value[ans[[\"values\"]]]\n                           ans})\n            } else {\n                subseqs[seq(1L, length(subseqs), by=2L)] <-\n                    lapply(seq_len(k), function(i)\n                           .Call2(\"Rle_window_aslist\",\n                                  x, runStart[i], runEnd[i],\n                                  offsetStart[i], offsetEnd[i],\n                                  PACKAGE=\"S4Vectors\"))\n            }\n        }\n        if (length(valueWidths) > 0L) {\n            subseqs[seq(2L, length(subseqs), by=2L)] <-\n                lapply(seq_len(length(valueWidths)), function(i)\n                       list(values=value2,\n                            lengths=valueWidths[i]))\n        }\n        values <- unlist(lapply(subseqs, \"[[\", \"values\"))\n        if (isFactorRle)\n            values <- dummy_value[values]\n        ans <- Rle(values, unlist(lapply(subseqs, \"[[\", \"lengths\")))\n        mcols(ans) <- replaceROWS(mcols(x, use.names=FALSE), i,\n                                  mcols(value, use.names=FALSE))\n        ans\n    }\n)\n\nsetReplaceMethod(\"[\", c(\"Rle\", \"ANY\"),\n    function(x, i, j,..., value)\n    {\n        if (!missing(j) || length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        li <- length(i)\n        if (li == 0L) {\n            ## Surprisingly, in that case, `[<-` on standard vectors does not\n            ## even look at 'value'. So neither do we...\n            return(x)\n        }\n        lv <- length(value)\n        if (lv == 0L)\n            stop(\"replacement has length zero\")\n        replaceROWS(x, i, value)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting an object by an Rle subscript.\n###\n### See R/subsetting-utils.R for more information.\n###\n\nsetClass(\"RleNSBS\",      # not exported\n    contains=\"NSBS\",\n    representation(\n        subscript=\"Rle\"  # integer-Rle\n    ),\n    prototype(\n        ## Calling Rle(integer(0)) below causes the following error at\n        ## installation time:\n        ##     Error in .Call(.NAME, ..., PACKAGE = PACKAGE) : \n        ##       \"Rle_constructor\" not available for .Call() for package\n        ##       \"S4Vectors\"\n        ##     Error : unable to load R code in package ‘S4Vectors’\n        ##     ERROR: lazy loading failed for package ‘S4Vectors’\n        #subscript=Rle(integer(0))\n        subscript=new2(\"Rle\", values=integer(0),\n                              lengths=integer(0),\n                              check=FALSE)\n    )\n)\n\n### Construction methods.\n### Supplied arguments are trusted so we don't check them!\n\nsetMethod(\"NSBS\", \"Rle\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        x_NROW <- NROW(x)\n        i_vals <- runValue(i)\n        if (is.logical(i_vals) && length(i_vals) != 0L) {\n            if (anyNA(i_vals))\n                stop(\"subscript contains NAs\")\n            if (length(i) < x_NROW)\n                i <- rep(i, length.out=x_NROW)\n            ## The coercion method from Rle to NormalIRanges is defined in the\n            ## IRanges package.\n            if (requireNamespace(\"IRanges\", quietly=TRUE)) {\n                i <- as(i, \"NormalIRanges\")\n                ## This will call the \"NSBS\" method for IntegerRanges objects\n                ## defined in the IRanges package and return a RangesNSBS, or\n                ## RangeNSBS, or NativeNSBS object.\n                return(callGeneric())\n            }\n            warning(wmsg(\n                \"Couldn't load the IRanges package. Installing this package \",\n                \"will enable efficient subsetting by a logical-Rle object \",\n                \"so is higly recommended.\"\n            ))\n            i <- which(i)\n            return(callGeneric())  # will return a NativeNSBS object\n        }\n        i_vals <- NSBS(i_vals, x, exact=exact,\n                                  strict.upper.bound=strict.upper.bound,\n                                  allow.NAs=allow.NAs)\n        runValue(i) <- as.integer(i_vals)\n        new2(\"RleNSBS\", subscript=i,\n                        upper_bound=x_NROW,\n                        upper_bound_is_strict=strict.upper.bound,\n                        has_NAs=i_vals@has_NAs,\n                        check=FALSE)\n    }\n)\n\n### Other methods.\n\nsetMethod(\"as.integer\", \"RleNSBS\", function(x) decodeRle(x@subscript))\n\nsetMethod(\"length\", \"RleNSBS\", function(x) length(x@subscript))\n\nsetMethod(\"anyDuplicated\", \"RleNSBS\",\n    function(x, incomparables=FALSE, ...) anyDuplicated(x@subscript)\n)\n\nsetMethod(\"isStrictlySorted\", \"RleNSBS\",\n    function(x) isStrictlySorted(x@subscript)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting an Rle object by an Rle subscript.\n###\n\n### Simplified version of rep.int() for Rle objects. Handles only the case\n### where 'times' has the length of 'x'.\n.rep_times_Rle <- function(x, times)\n{\n    breakpoints <- end(x)\n    if (length(times) != last_or(breakpoints, 0L))\n        stop(\"invalid 'times' argument\")\n    runLength(x) <- groupsum(times, breakpoints)\n    x\n}\n\nsetMethod(\"extractROWS\", c(\"Rle\", \"RleNSBS\"),\n    function(x, i)\n    {\n        rle <- i@subscript\n        .rep_times_Rle(extractROWS(x, runValue(rle)), runLength(rle))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other subsetting-related operations\n###\n\n### S3/S4 combo for rev.Rle\nrev.Rle <- function(x)\n{\n    x@values <- rev(runValue(x))\n    x@lengths <- rev(runLength(x))\n    x\n}\nsetMethod(\"rev\", \"Rle\", rev.Rle)\n\nsetMethod(\"rep.int\", \"Rle\",\n    function(x, times)\n    {\n        if (!is.numeric(times))\n            stop(\"invalid 'times' argument\")\n        if (!is.integer(times))\n            times <- as.integer(times)\n        if (anyMissingOrOutside(times, 0L))\n            stop(\"invalid 'times' argument\")\n\n        x_len <- length(x)\n        times_len <- length(times)\n        if (times_len == x_len)\n            return(.rep_times_Rle(x, times))\n        if (times_len != 1L)\n            stop(\"invalid 'times' argument\")\n        ans <- Rle(rep.int(runValue(x), times),\n                   rep.int(runLength(x), times))\n        as(ans, class(x))  # so the function is an endomorphism\n    }\n)\n\nsetMethod(\"rep\", \"Rle\",\n          function(x, times, length.out, each)\n          {\n              usedEach <- FALSE\n              if (!missing(each) && length(each) > 0) {\n                  each <- as.integer(each[1L])\n                  if (!is.na(each)) {\n                      if (each < 0)\n                          stop(\"invalid 'each' argument\")\n                      usedEach <- TRUE\n                      if (each == 0)\n                          x <- new2(class(x), values=runValue(x)[0L],\n                                              check=FALSE)\n                      else\n                          x@lengths <- each[1L] * runLength(x)\n                  }\n              }\n              if (!missing(length.out) && length(length.out) > 0) {\n                  n <- length(x)\n                  length.out <- as.integer(length.out[1L])\n                  if (!is.na(length.out)) {\n                      if (length.out == 0) {\n                          x <- new2(class(x), values=runValue(x)[0L],\n                                              check=FALSE)\n                      } else if (length.out < n) {\n                          x <- window(x, 1, length.out)\n                      } else if (length.out > n) {\n                          if (n == 0) {\n                              x <- Rle(rep(runValue(x), length.out=1),\n                                       length.out)\n                          } else {\n                              x <-\n                                window(rep.int(x, ceiling(length.out / n)),\n                                       1, length.out)\n                          }\n                      }\n                  }\n              } else if (!missing(times)) {\n                  if (usedEach && length(times) != 1)\n                      stop(\"invalid 'times' argument\")\n                  x <- rep.int(x, times)\n              }\n              x\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.bindROWS_Rle_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ## 1. Take care of the parallel slots\n\n    ## Call method for Vector objects to concatenate all the parallel\n    ## slots (only \"elementMetadata\" in the case of Rle) and stick them\n    ## into 'ans'. Note that the resulting 'ans' can be an invalid object\n    ## because its \"elementMetadata\" slot can be longer (i.e. have more rows)\n    ## than 'ans' itself so we use 'check=FALSE' to skip validation.\n    ans <- callNextMethod(x, objects, use.names=use.names,\n                                      ignore.mcols=ignore.mcols,\n                                      check=FALSE)\n\n    ## 2. Take care of the non-parallel slots\n\n    ## Concatenate the \"values\" slots.\n    values_list <- lapply(all_objects, slot, \"values\")\n    tmp_values <- unlist(values_list, recursive=FALSE)\n\n    ## Concatenate the \"lengths\" slots.\n    lengths_list <- lapply(all_objects, slot, \"lengths\")\n    tmp_lengths <- unlist(lengths_list, recursive=FALSE)\n\n    tmp <- Rle(tmp_values, tmp_lengths)\n    BiocGenerics:::replaceSlots(ans, values=tmp@values,\n                                     lengths=tmp@lengths,\n                                     check=check)\n}\n\nsetMethod(\"bindROWS\", \"Rle\", .bindROWS_Rle_objects)\n\nsetMethod(\"append\", c(\"Rle\", \"vector\"),\n          function (x, values, after = length(x)) {\n              append(x, Rle(values), after)\n          })\n\nsetMethod(\"append\", c(\"vector\", \"Rle\"),\n          function (x, values, after = length(x)) {\n              append(Rle(x), values, after)\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other methods.\n###\n\nsetMethod(\"%in%\", \"Rle\",\n          function(x, table)\n              new_Rle(runValue(x) %in% table, runLength(x)))\n\nsetGeneric(\"findRun\", signature = \"vec\",\n           function(x, vec) standardGeneric(\"findRun\"))\n\nsetMethod(\"findRun\", signature = c(vec = \"Rle\"),\n          function(x, vec) {\n            runs <- findIntervalAndStartFromWidth(as.integer(x),\n                                         runLength(vec))[[\"interval\"]]\n            runs[is.na(runs) | x == 0 | x > length(vec)] <- NA\n            runs\n          })\n\nsetMethod(\"is.na\", \"Rle\",\n          function(x)\n              new_Rle(is.na(runValue(x)), runLength(x)))\n\nsetMethod(\"anyNA\", \"Rle\",\n          function(x)\n              anyNA(runValue(x)))\n\nsetMethod(\"sameAsPreviousROW\", \"Rle\", function(x) {\n    is.same <- !logical(length(x))\n    is.same[start(x)] <- sameAsPreviousROW(runValue(x))\n    is.same\n})\n\nsetMethod(\"is.finite\", \"Rle\",\n          function(x)\n              new_Rle(is.finite(runValue(x)), runLength(x)))\n\nsetMethod(\"match\", c(\"ANY\", \"Rle\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL)\n    {\n        m <- match(x, runValue(table), incomparables=incomparables)\n        ans <- start(table)[m]\n        ## 'as.integer(nomatch)[1L]' seems to mimic how base::match() treats\n        ## the 'nomatch' argument.\n        nomatch <- as.integer(nomatch)[1L]\n        if (!is.na(nomatch))\n            ans[is.na(ans)] <- nomatch\n        ans\n    }\n)\n\nsetMethod(\"match\", c(\"Rle\", \"ANY\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL)\n    {\n        x_run_lens <- runLength(x)\n        x <- runValue(x)\n        m <- callGeneric()\n        Rle(m, x_run_lens)\n    }\n)\n\nsetMethod(\"match\", c(\"Rle\", \"Rle\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL)\n    {\n        x_run_lens <- runLength(x)\n        x <- runValue(x)\n        m <- callGeneric()\n        Rle(m, x_run_lens)\n    }\n)\n\n.duplicated.Rle <- function(x, incomparables=FALSE, fromLast=FALSE)\n    stop(\"no \\\"duplicated\\\" method for Rle objects yet, sorry\")\nsetMethod(\"duplicated\", \"Rle\", .duplicated.Rle)\n\n### S3/S4 combo for anyDuplicated.Rle\nanyDuplicated.Rle <- function(x, incomparables=FALSE, ...)\n    any(runLength(x) != 1L) || anyDuplicated(runValue(x))\nsetMethod(\"anyDuplicated\", \"Rle\", anyDuplicated.Rle)\n\n.unique.Rle <- function(x, incomparables=FALSE, ...)\n    unique(runValue(x), incomparables=incomparables, ...)\nsetMethod(\"unique\", \"Rle\", .unique.Rle)\n\nsetMethod(\"order\", \"Rle\",\n          function(..., na.last=TRUE, decreasing=FALSE,\n                   method=c(\"auto\", \"shell\", \"radix\"))\n{\n    args <- list(...)\n    if (length(args) == 1L) {\n        x <- args[[1L]]\n        o <- order(runValue(x), na.last=na.last, decreasing=decreasing,\n                   method=method)\n        sequence(width(x)[o], from=start(x)[o])\n    } else {\n        args <- lapply(unname(args), decodeRle)\n        do.call(order, c(args, list(na.last=na.last,\n                                    decreasing=decreasing,\n                                    method=method)))\n    }\n})\n\nsetMethod(\"is.unsorted\", \"Rle\",\n          function(x, na.rm = FALSE, strictly = FALSE)\n          {\n              ans <- is.unsorted(runValue(x), na.rm = na.rm, strictly = strictly)\n              if (strictly && !ans)\n                  ans <- any(runLength(x) > 1L)\n              ans\n          })\n\nsetMethod(\"isStrictlySorted\", \"Rle\",\n    function(x) all(runLength(x) == 1L) && isStrictlySorted(runValue(x))\n)\n\n### S3/S4 combo for sort.Rle\nsort.Rle <- function(x, decreasing=FALSE, na.last=NA, ...)\n{\n    if (is.na(na.last)) {\n        if (anyNA(runValue(x)))\n            x <- x[!is.na(x)]\n    }\n    ord <- base::order(runValue(x), na.last=na.last, decreasing=decreasing)\n    new_Rle(runValue(x)[ord], runLength(x)[ord])\n}\nsetMethod(\"sort\", \"Rle\", sort.Rle)\n\nsetMethod(\"rank\", \"Rle\", function (x, na.last = TRUE,\n                                   ties.method = c(\"average\", \"first\", \n                                     \"random\", \"max\", \"min\"))\n          {\n              ties.method <- match.arg(ties.method)\n              if (ties.method == \"min\" || ties.method == \"first\") {\n                  callNextMethod()\n              } else {\n                  x <- as.vector(x)\n                  ans <- callGeneric()\n                  if (ties.method %in% c(\"average\", \"max\", \"min\")) {\n                      Rle(ans)\n                  } else {\n                      ans\n                  }\n              }\n          })\n\nsetMethod(\"xtfrm\", \"Rle\", function(x) {\n    initialize(x, values=xtfrm(runValue(x)))\n})\n\nsetMethod(\"table\", \"Rle\", \n    function(...)\n    {\n        ## Currently only 1 Rle is supported. An approach for multiple \n        ## Rle's could be disjoin(), findRun() to find matches, then \n        ## xtabs(length ~ value ...).\n        x <- sort(list(...)[[1L]]) \n        if (is.factor(runValue(x))) {\n            dn <- levels(x)\n            tab <- integer(length(dn))\n            tab[dn %in% runValue(x)] <- runLength(x)\n            dims <- length(dn)\n        } else {\n            dn <- as.character(runValue(x)) \n            tab <- runLength(x) \n            dims <- nrun(x)\n        }\n        ## Adjust 'dn' for consistency with base::table\n        if (length(dn) == 0L)\n            dn <- NULL\n        dn <- list(dn)\n        names(dn) <- .list.names(...) \n        y <- array(tab, dims, dimnames=dn)\n        class(y) <- \"table\"\n        y \n    }\n)\n\n.list.names <- function(...) {\n    l <- as.list(substitute(list(...)))[-1L]\n    deparse.level <- 1 \n    nm <- names(l)\n    fixup <- if (is.null(nm))\n        seq_along(l)\n    else nm == \"\"\n    dep <- vapply(l[fixup], function(x) switch(deparse.level +\n        1, \"\", if (is.symbol(x)) as.character(x) else \"\",\n        deparse(x, nlines = 1)[1L]), \"\")\n    if (is.null(nm))\n        dep\n    else {\n        nm[fixup] <- dep\n        nm\n    }\n}\n\n### Not exported? Broken on numeric-Rle and factor-Rle. H.P. -- Oct 16, 2016\nsetMethod(\"tabulate\", \"Rle\",\n          function (bin, nbins = max(bin, 1L, na.rm = TRUE)) {\n              tabulate2(runValue(bin), nbins, runLength(bin))\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Set methods\n###\n### The return values of these do not have any duplicated values, so\n### it would obviously be more efficient to return plain vectors. That\n### might violate user expectations though.\n###\n\nsetMethod(\"union\", c(\"Rle\", \"Rle\"), function(x, y) {\n  Rle(union(runValue(x), runValue(y)))\n})\n\nsetMethod(\"union\", c(\"ANY\", \"Rle\"), function(x, y) {\n  Rle(union(as.vector(x), runValue(y)))\n})\n\nsetMethod(\"union\", c(\"Rle\", \"ANY\"), function(x, y) {\n  Rle(union(runValue(x), as.vector(y)))\n})\n\nsetMethod(\"intersect\", c(\"Rle\", \"Rle\"), function(x, y) {\n  Rle(intersect(runValue(x), runValue(y)))\n})\n\nsetMethod(\"intersect\", c(\"ANY\", \"Rle\"), function(x, y) {\n  Rle(intersect(as.vector(x), runValue(y)))\n})\n\nsetMethod(\"intersect\", c(\"Rle\", \"ANY\"), function(x, y) {\n  Rle(intersect(runValue(x), as.vector(y)))\n})\n\nsetMethod(\"setdiff\", c(\"Rle\", \"Rle\"), function(x, y) {\n  Rle(setdiff(runValue(x), runValue(y)))\n})\n\nsetMethod(\"setdiff\", c(\"ANY\", \"Rle\"), function(x, y) {\n  Rle(setdiff(as.vector(x), runValue(y)))\n})\n\nsetMethod(\"setdiff\", c(\"Rle\", \"ANY\"), function(x, y) {\n  Rle(setdiff(runValue(x), as.vector(y)))\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method\n###\n\nsetMethod(\"show\", \"Rle\",\n          function(object)\n          {\n              lo <- length(object)\n              nr <- nrun(object)\n              halfWidth <- getOption(\"width\") %/% 2L\n              cat(classNameForDisplay(runValue(object)),\n                  \"-Rle of length \", as.character(as.LLint(lo)),\n                  \" with \", nr, ifelse(nr == 1, \" run\\n\", \" runs\\n\"), sep = \"\")\n              first <- max(1L, halfWidth)\n              showMatrix <-\n                rbind(showAsCell(head(runLength(object), first)),\n                      showAsCell(head(runValue(object), first)))\n              if (nr > first) {\n                  last <- min(nr - first, halfWidth)\n                  showMatrix <-\n                    cbind(showMatrix,\n                          rbind(showAsCell(tail(runLength(object), last)),\n                                showAsCell(tail(runValue(object), last))))\n              }\n              if (is.character(runValue(object))) {\n                  showMatrix[2L,] <-\n                    paste(\"\\\"\", showMatrix[2L,], \"\\\"\", sep = \"\")\n              }\n              showMatrix <- format(showMatrix, justify = \"right\")\n              cat(labeledLine(\"  Lengths\", showMatrix[1L,], count = FALSE))\n              cat(labeledLine(\"  Values \", showMatrix[2L,], count = FALSE))\n              if (is.factor(runValue(object)))\n                  cat(labeledLine(\"Levels\", levels(object)))\n          })\n\n",
        "Rle-utils.R": "### =========================================================================\n### Common operations on Rle objects\n### -------------------------------------------------------------------------\n###\n\n \n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Group generic methods\n###\n\n.sumprodRle <- function(e1, e2, na.rm = FALSE)\n{\n    n1 <- length(e1)\n    n2 <- length(e2)\n    if (n1 == 0 || n2 == 0) {\n        ends <- integer(0)\n        which1 <- integer(0)\n        which2 <- integer(0)\n    } else {\n        n <- max(n1, n2)\n        if (max(n1, n2) %% min(n1, n2) != 0)\n            warning(\"longer object length is not a multiple of shorter object length\")\n        if (n1 < n)\n            e1 <- rep(e1, length.out = n)\n        if (n2 < n)\n            e2 <- rep(e2, length.out = n)\n        # ends <- sort(unique(c(end(e1), end(e2))))\n        ends <- sortedMerge(end(e1), end(e2))\n        which1 <- findIntervalAndStartFromWidth(ends, runLength(e1))[[\"interval\"]]\n        which2 <- findIntervalAndStartFromWidth(ends, runLength(e2))[[\"interval\"]]\n    }\n    lengths <- diffWithInitialZero(ends)\n    values <- runValue(e1)[which1] * runValue(e2)[which2]\n    sum(lengths * values, na.rm = na.rm)\n}\n\nsetMethod(\"Ops\", signature(e1 = \"Rle\", e2 = \"Rle\"),\n          function(e1, e2)\n          {\n              n1 <- length(e1)\n              n2 <- length(e2)\n              if (n1 == 0 || n2 == 0) {\n                  ends <- integer(0)\n                  which1 <- integer(0)\n                  which2 <- integer(0)\n              } else {\n                  n <- max(n1, n2)\n                  if (max(n1, n2) %% min(n1, n2) != 0)\n                      warning(\"longer object length is not a multiple of shorter object length\")\n                  if (n1 < n)\n                      e1 <- rep(e1, length.out = n)\n                  if (n2 < n)\n                      e2 <- rep(e2, length.out = n)\n                  # ends <- sort(unique(c(end(e1), end(e2))))\n                  ends <- sortedMerge(end(e1), end(e2))\n                  which1 <- findIntervalAndStartFromWidth(ends, runLength(e1))[[\"interval\"]]\n                  which2 <- findIntervalAndStartFromWidth(ends, runLength(e2))[[\"interval\"]]\n              }\n              new_Rle(callGeneric(runValue(e1)[which1], runValue(e2)[which2]),\n                      diffWithInitialZero(ends))\n          })\n\nsetMethod(\"Ops\", signature(e1 = \"Rle\", e2 = \"vector\"),\n          function(e1, e2) callGeneric(e1, Rle(e2)))\n\nsetMethod(\"Ops\", signature(e1 = \"vector\", e2 = \"Rle\"),\n          function(e1, e2) callGeneric(Rle(e1), e2))\n\nsetMethod(\"Math\", \"Rle\",\n          function(x)\n              switch(.Generic,\n                     cumsum =\n                     {\n                         whichZero <- which(runValue(x) == 0)\n                         widthZero <- runLength(x)[whichZero]\n                         startZero <- cumsum(c(1L, runLength(x)))[whichZero]\n                         y <- x\n                         y@lengths[y@values == 0] <- 1L\n                         values <- cumsum(as.vector(y))\n                         lengths <- rep.int(1L, length(values))\n                         lengths[startZero - c(0L, cumsum(head(widthZero, -1) - 1L))] <- widthZero\n                         new_Rle(values, lengths)\n                     },\n                     cumprod =\n                     {\n                         whichOne <- which(runValue(x) == 0)\n                         widthOne <- runLength(x)[whichOne]\n                         startOne <- cumsum(c(1L, runLength(x)))[whichOne]\n                         y <- x\n                         y@lengths[y@values == 0] <- 1L\n                         values <- cumprod(as.vector(y))\n                         lengths <- rep.int(1L, length(values))\n                         lengths[startOne - c(0L, cumsum(head(widthOne, -1) - 1L))] <- widthOne\n                         new_Rle(values, lengths)\n                     },\n                     new_Rle(callGeneric(runValue(x)), runLength(x))))\n\nsetMethod(\"Math2\", \"Rle\",\n          function(x, digits)\n          {\n              if (missing(digits))\n                  digits <- ifelse(.Generic == \"round\", 0, 6)\n              new_Rle(callGeneric(runValue(x), digits = digits), runLength(x))\n          })\n\nsetMethod(\"Summary\", \"Rle\",\n    function(x, ..., na.rm = FALSE)\n    {\n        switch(.Generic,\n        all =, any =, min =, max =, range =\n            callGeneric(runValue(x), ..., na.rm=na.rm),\n        sum = \n            withCallingHandlers({\n                sum(runValue(x) * runLength(x), ..., na.rm=na.rm)\n            }, warning=function(warn) {\n                msg <- conditionMessage(warn)\n                exp <- gettext(\"integer overflow - use sum(as.numeric(.))\",\n                               domain=\"R\")\n                if (msg == exp) {\n                    msg <- sub(\"sum\\\\(as.numeric\\\\(.\\\\)\\\\)\",\n                               \"runValue(.) <- as.numeric(runValue(.))\", msg)\n                    warning(simpleWarning(msg, conditionCall(warn)))\n                    invokeRestart(\"muffleWarning\")\n                } else {\n                    warn\n                }\n            }), \n        prod = prod(runValue(x) ^ runLength(x), ..., na.rm=na.rm))\n    }\n) \n\nsetMethod(\"Complex\", \"Rle\",\n          function(z)\n              new_Rle(callGeneric(runValue(z)), runLength(z)))\n\n### S3/S4 combo for summary.Rle\nsummary.Rle <- function(object, ..., digits) \n{\n    value <-\n        if (is.logical(runValue(object))) \n            c(ValueMode = \"logical\", {\n                tb <- table(object, exclude = NULL)\n                if (!is.null(n <- dimnames(tb)[[1L]]) && any(iN <- is.na(n)))\n                    dimnames(tb)[[1L]][iN] <- \"NA's\"\n                tb\n            })\n        else if (is.numeric(runValue(object))) {\n            nas <- is.na(object)\n            object <- object[!nas]\n            qq <- quantile(object)\n            qq <- c(qq[1L:3L], mean(object), qq[4L:5L])\n            if (!missing(digits)) \n                qq <- signif(qq, digits)\n            names(qq) <-\n                c(\"Min.\", \"1st Qu.\", \"Median\", \"Mean\", \"3rd Qu.\", \"Max.\")\n            if (any(nas)) \n                c(qq, `NA's` = sum(nas))\n            else\n                qq\n        }\n        else\n            c(Length = length(object),\n              Class = class(object),\n              ValueMode = mode(runValue(object)))\n    class(value) <- c(\"summaryDefault\", \"table\")\n    value\n}\nsetMethod(\"summary\", \"Rle\", summary.Rle)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other logical data methods\n###\n\nsetMethod(\"!\", \"Rle\", function(x) new_Rle(!runValue(x), runLength(x)))\n\nsetMethod(\"which\", \"Rle\",\n          function(x, arr.ind = FALSE) {\n              if (!is.logical(runValue(x)))\n                  stop(\"argument to 'which' is not logical\")\n              ok <- runValue(x)\n              ok[is.na(ok)] <- FALSE\n              sequence(width(x)[ok], from=start(x)[ok])\n          })\n\nsetMethod(\"which.max\", \"Rle\",\n          function(x) {\n            start(x)[which.max(runValue(x))]\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other numerical data methods\n###\n\ndiff.Rle <- function(x, ...) diff(x, ...)\n.diff.Rle <- function(x, lag = 1, differences = 1)\n{\n    if (!isSingleNumber(lag) || lag < 1L ||\n        !isSingleNumber(differences) || differences < 1L) \n        stop(\"'lag' and 'differences' must be integers >= 1\")\n    lag <- as.integer(lag)\n    differences <- as.integer(differences)\n    if (lag * differences >= length(x))\n        return(Rle(vector(class(runValue(x)))))\n    for (i in seq_len(differences)) {\n        n <- length(x)\n        x <- window(x, 1L + lag, n) - window(x, 1L, n - lag)\n    }\n    x\n}\nsetMethod(\"diff\", \"Rle\", .diff.Rle)\n\n.psummary.Rle <- function(FUN, ..., MoreArgs = NULL) {\n    args <- list(...)\n    ends <- end(args[[1L]])\n    if (length(args) > 1) {\n        for (i in 2:length(args))\n            ends <- sortedMerge(ends, end(args[[i]]))\n    }\n    new_Rle(do.call(FUN,\n                c(lapply(args,\n                         function(x) {\n                             runs <- findIntervalAndStartFromWidth(ends,\n                                         runLength(x))[[\"interval\"]]\n                             runValue(x)[runs]\n                         }),\n                 MoreArgs)),\n            diffWithInitialZero(ends))\n}\n\nsetMethod(\"pmax\", \"Rle\", function(..., na.rm = FALSE)\n            .psummary.Rle(pmax, ..., MoreArgs = list(na.rm = na.rm)))\n\nsetMethod(\"pmin\", \"Rle\", function(..., na.rm = FALSE)\n            .psummary.Rle(pmin, ..., MoreArgs = list(na.rm = na.rm)))\n\nsetMethod(\"pmax.int\", \"Rle\", function(..., na.rm = FALSE)\n            .psummary.Rle(pmax.int, ..., MoreArgs = list(na.rm = na.rm)))\n\nsetMethod(\"pmin.int\", \"Rle\", function(..., na.rm = FALSE)\n            .psummary.Rle(pmin.int, ..., MoreArgs = list(na.rm = na.rm)))\n\n### S3/S4 combo for mean.Rle\n.mean.Rle <- function(x, na.rm = FALSE)\n{\n    if (is.integer(runValue(x)))\n        runValue(x) <- as.double(runValue(x))\n    if (na.rm)\n        n <- length(x) - sum(runLength(x)[is.na(runValue(x))])\n    else\n        n <- length(x)\n    sum(x, na.rm = na.rm) / n\n}\nmean.Rle <- function(x, ...) .mean.Rle(x, ...)\nsetMethod(\"mean\", \"Rle\", .mean.Rle)\n\nsetMethod(\"var\", signature = c(x = \"Rle\", y = \"missing\"),\n          function(x, y = NULL, na.rm = FALSE, use)\n          {\n              if (na.rm)\n                  n <- length(x) - sum(runLength(x)[is.na(runValue(x))])\n              else\n                  n <- length(x)\n              centeredValues <- runValue(x) - mean(x, na.rm = na.rm)\n              sum(runLength(x) * centeredValues * centeredValues,\n                  na.rm = na.rm) / (n - 1)\n          })\n\nsetMethod(\"var\", signature = c(x = \"Rle\", y = \"Rle\"),\n          function(x, y = NULL, na.rm = FALSE, use)\n          {\n              # Direct change to slots for fast computation\n              x@values <- runValue(x) - mean(x, na.rm = na.rm)\n              y@values <- runValue(y) - mean(y, na.rm = na.rm)\n              z <- x * y\n              if (na.rm)\n                  n <- length(z) - sum(runLength(z)[is.na(runValue(z))])\n              else\n                  n <- length(z)\n              sum(z, na.rm = na.rm) / (n - 1)\n          })\n\nsetMethod(\"cov\", signature = c(x = \"Rle\", y = \"Rle\"),\n          function(x, y = NULL, use = \"everything\",\n                   method = c(\"pearson\", \"kendall\", \"spearman\"))\n          {\n              use <-\n                match.arg(use,\n                          c(\"all.obs\", \"complete.obs\", \"pairwise.complete.obs\",\n                            \"everything\", \"na.or.complete\"))\n              method <- match.arg(method)\n              if (method != \"pearson\")\n                  stop(\"only 'pearson' method is supported for Rle objects\")\n              na.rm <-\n                use %in% c(\"complete.obs\", \"pairwise.complete.obs\", \"na.or.complete\")\n              if (use == \"all.obs\" && (anyMissing(x) || anyMissing(y)))\n                  stop(\"missing observations in cov/cor\")\n              var(x, y, na.rm = na.rm)\n          })\n\nsetMethod(\"cor\", signature = c(x = \"Rle\", y = \"Rle\"),\n          function(x, y = NULL, use = \"everything\",\n                   method = c(\"pearson\", \"kendall\", \"spearman\"))\n          {\n              use <-\n                match.arg(use,\n                          c(\"all.obs\", \"complete.obs\", \"pairwise.complete.obs\",\n                            \"everything\", \"na.or.complete\"))\n              method <- match.arg(method)\n              if (method != \"pearson\")\n                  stop(\"only 'pearson' method is supported for Rle objects\")\n              na.rm <-\n                use %in% c(\"complete.obs\", \"pairwise.complete.obs\", \"na.or.complete\")\n              isMissing <- is.na(x) | is.na(y)\n              if (any(isMissing)) {\n                  if (use == \"all.obs\") {\n                      stop(\"missing observations in cov/cor\")\n                  } else if (na.rm) {\n                      x <- x[!isMissing]\n                      y <- y[!isMissing]\n                  }\n              }\n              # Direct change to slots for fast computation\n              x@values <- runValue(x) - mean(x, na.rm = na.rm)\n              y@values <- runValue(y) - mean(y, na.rm = na.rm)\n              .sumprodRle(x, y, na.rm = na.rm) /\n                  (sqrt(sum(runLength(x) * runValue(x) * runValue(x),\n                            na.rm = na.rm)) *\n                   sqrt(sum(runLength(y) * runValue(y) * runValue(y),\n                            na.rm = na.rm)))\n         })\n\nsetMethod(\"sd\", signature = c(x = \"Rle\"),\n          function(x, na.rm = FALSE) sqrt(var(x, na.rm = na.rm)))\n\n### S3/S4 combo for median.Rle\n### FIXME: code duplication needed for S3 / S4 dispatch\n### We intercept the case where a single NA must be returned because\n### median.default() wouldn't be able to handle it (would choke on\n### x[NA_integer_] because Rle objects don't support that).\nmedian.Rle <- function(x, na.rm = FALSE, ...)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    is_na <- is.na(x)\n    if ((na.rm && all(is_na)) || (!na.rm && any(is_na)))\n        return(runValue(x)[NA_integer_])\n    ans <- NextMethod(\"median\")\n    if (is(ans, \"Rle\"))\n        ans <- decodeRle(ans)\n    ans\n}\nsetMethod(\"median\", \"Rle\", \n    function(x, na.rm = FALSE)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    is_na <- is.na(x)\n    if ((na.rm && all(is_na)) || (!na.rm && any(is_na)))\n        return(runValue(x)[NA_integer_])\n    ans <- callNextMethod()\n    if (is(ans, \"Rle\"))\n        ans <- decodeRle(ans)\n    ans\n})\n\n### FIXME: Remove this in R 3.5\nquantile.Rle <- \n    function(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE,\n             type = 7, ...)\n{\n    if (na.rm)\n        x <- x[!is.na(x)]\n    oldOption <- getOption(\"dropRle\")\n    options(\"dropRle\" = TRUE)\n    on.exit(options(\"dropRle\" = oldOption))\n    NextMethod(\"quantile\", na.rm=FALSE)\n}\n\n### FIXME: Remove this in R 3.5\nsetMethod(\"mad\", \"Rle\",\n          function(x, center = median(x), constant = 1.4826, na.rm = FALSE,\n                   low = FALSE, high = FALSE)\n          {\n              if (na.rm)\n                  x <- x[!is.na(x)]\n              oldOption <- getOption(\"dropRle\")\n              options(\"dropRle\" = TRUE)\n              on.exit(options(\"dropRle\" = oldOption))\n              callNextMethod(x=x, center=center, constant=constant,\n                             na.rm=FALSE, low=FALSE, high=FALSE)\n          })\n\nsetMethod(\"IQR\", \"Rle\",\n          function(x, na.rm = FALSE)\n              diff(quantile(x, c(0.25, 0.75), na.rm = na.rm, names = FALSE)))\n\n### FIXME: Remove this in R 3.5\nsetMethod(\"smoothEnds\", \"Rle\", function(y, k = 3)\n          {\n              oldOption <- getOption(\"dropRle\")\n              options(\"dropRle\" = TRUE)\n              on.exit(options(\"dropRle\" = oldOption))\n              callNextMethod(y = y, k = k)\n          })\n\nsetGeneric(\"runmean\", signature=\"x\",\n           function(x, k, endrule = c(\"drop\", \"constant\"), ...)\n               standardGeneric(\"runmean\"))\n\nsetMethod(\"runmean\", \"Rle\",\n          function(x, k, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n          {\n              sums <- runsum(x, k, endrule, na.rm)\n              if (na.rm) {\n                  d <- Rle(rep(1L, length(x)))\n                  d[is.na(x)] <- 0L \n                  sums / runsum(d, k, endrule, na.rm)\n              } else {\n                  sums / k\n              }\n          })\n\nsetMethod(\"runmed\", \"Rle\",\n          function(x, k, endrule = c(\"median\", \"keep\", \"drop\", \"constant\"),\n                   algorithm = NULL, print.level = 0)\n          {\n              if (!all(is.finite(as.vector(x))))\n                  stop(\"NA/NaN/Inf not supported in runmed,Rle-method\")\n              endrule <- match.arg(endrule)\n              n <- length(x)\n              k <- normargRunK(k = k, n = n, endrule = endrule)\n              i <- (k + 1L) %/% 2L\n              ans <- runq(x, k = k, i = i)\n              if (endrule == \"constant\") {\n                  runLength(ans)[1L] <- runLength(ans)[1L] + (i - 1L)\n                  runLength(ans)[nrun(ans)] <-\n                    runLength(ans)[nrun(ans)] + (i - 1L)\n              } else if (endrule != \"drop\") {\n                  ans <- c(head(x, i - 1L), ans, tail(x, i - 1L))\n                  if (endrule == \"median\") {\n                      ans <- smoothEnds(ans, k = k)\n                  }\n              }\n              ans\n          })\n\nsetGeneric(\"runsum\", signature=\"x\",\n           function(x, k, endrule = c(\"drop\", \"constant\"), ...)\n               standardGeneric(\"runsum\"))\n\nsetMethod(\"runsum\", \"Rle\",\n          function(x, k, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n          {\n              endrule <- match.arg(endrule)\n              n <- length(x)\n              k <- normargRunK(k = k, n = n, endrule = endrule)\n              ans <- .Call2(\"Rle_runsum\", x, as.integer(k), as.logical(na.rm), \n                            PACKAGE=\"S4Vectors\")\n              if (endrule == \"constant\") {\n                  j <- (k + 1L) %/% 2L\n                  runLength(ans)[1L] <- runLength(ans)[1L] + (j - 1L)\n                  runLength(ans)[nrun(ans)] <-\n                    runLength(ans)[nrun(ans)] + (j - 1L)\n              }\n              ans\n          })\n\nsetGeneric(\"runwtsum\", signature=\"x\",\n           function(x, k, wt, endrule = c(\"drop\", \"constant\"), ...)\n               standardGeneric(\"runwtsum\"))\n\nsetMethod(\"runwtsum\", \"Rle\",\n          function(x, k, wt, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n          {\n              endrule <- match.arg(endrule)\n              n <- length(x)\n              k <- normargRunK(k = k, n = n, endrule = endrule)\n              ans <-\n                .Call2(\"Rle_runwtsum\", x, as.integer(k), as.numeric(wt),\n                      as.logical(na.rm), PACKAGE=\"S4Vectors\")\n              if (endrule == \"constant\") {\n                  j <- (k + 1L) %/% 2L\n                  runLength(ans)[1L] <- runLength(ans)[1L] + (j - 1L)\n                  runLength(ans)[nrun(ans)] <-\n                    runLength(ans)[nrun(ans)] + (j - 1L)\n              }\n              ans\n          })\n\nsetGeneric(\"runq\", signature=\"x\",\n           function(x, k, i, endrule = c(\"drop\", \"constant\"), ...)\n               standardGeneric(\"runq\"))\n\nsetMethod(\"runq\", \"Rle\",\n          function(x, k, i, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n          {\n              endrule <- match.arg(endrule)\n              n <- length(x)\n              k <- normargRunK(k = k, n = n, endrule = endrule)\n              ans <-\n                .Call2(\"Rle_runq\", x, as.integer(k), as.integer(i), \n                      as.logical(na.rm), PACKAGE=\"S4Vectors\")\n              if (endrule == \"constant\") {\n                  j <- (k + 1L) %/% 2L\n                  runLength(ans)[1L] <- runLength(ans)[1L] + (j - 1L)\n                  runLength(ans)[nrun(ans)] <-\n                    runLength(ans)[nrun(ans)] + (j - 1L)\n              }\n              ans\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other character data methods\n###\n\nsetMethod(\"nchar\", \"Rle\",\n    function(x, type=\"chars\", allowNA=FALSE, keepNA=NA)\n        new_Rle(nchar(runValue(x), type=type, allowNA=allowNA, keepNA=keepNA),\n                runLength(x))\n)\n\nsetMethod(\"substr\", \"Rle\",\n          function(x, start, stop)\n          {\n              if (is.factor(runValue(x))) {\n                  levels(x) <- substr(levels(x), start = start, stop = stop)\n              } else {\n                  runValue(x) <- substr(runValue(x), start = start, stop = stop)\n              }\n              x\n          })\nsetMethod(\"substring\", \"Rle\",\n          function(text, first, last = 1000000L)\n          {\n              if (is.factor(runValue(text))) {\n                  levels(text) <-\n                    substring(levels(text), first = first, last = last)\n              } else {\n                  runValue(text) <-\n                    substring(runValue(text), first = first, last = last)\n              }\n              text\n          })\n\nsetMethod(\"chartr\", c(old = \"ANY\", new = \"ANY\", x = \"Rle\"),\n          function(old, new, x)\n          {\n              if (is.factor(runValue(x))) {\n                  levels(x) <- chartr(old = old, new = new, levels(x))\n              } else {\n                  runValue(x) <- chartr(old = old, new = new, runValue(x))\n              }\n              x\n          })\nsetMethod(\"tolower\", \"Rle\",\n          function(x) {\n              if (is.factor(runValue(x))) {\n                  levels(x) <- tolower(levels(x))\n              } else {\n                  runValue(x) <- tolower(runValue(x))\n              }\n              x\n          })\nsetMethod(\"toupper\", \"Rle\",\n          function(x)\n          {\n              if (is.factor(runValue(x))) {\n                  levels(x) <- toupper(levels(x))\n              } else {\n                  runValue(x) <- toupper(runValue(x))\n              }\n              x\n          })\n\nsetMethod(\"sub\", signature = c(pattern = \"ANY\", replacement = \"ANY\", x = \"Rle\"),\n          function(pattern, replacement, x, ignore.case = FALSE,\n                   perl = FALSE, fixed = FALSE, useBytes = FALSE)\n          {\n              if (is.factor(runValue(x))) {\n                  levels(x) <-\n                    sub(pattern = pattern, replacement = replacement,\n                        x = levels(x), ignore.case = ignore.case,\n                        perl = perl, fixed = fixed, useBytes = useBytes)\n              } else {\n                  runValue(x) <-\n                    sub(pattern = pattern, replacement = replacement,\n                        x = runValue(x), ignore.case = ignore.case,\n                        perl = perl, fixed = fixed, useBytes = useBytes)\n              }\n              x\n          })\nsetMethod(\"gsub\", signature = c(pattern = \"ANY\", replacement = \"ANY\", x = \"Rle\"),\n          function(pattern, replacement, x, ignore.case = FALSE,\n                   perl = FALSE, fixed = FALSE, useBytes = FALSE)\n          {\n              if (is.factor(runValue(x))) {\n                  levels(x) <-\n                    gsub(pattern = pattern, replacement = replacement,\n                         x = levels(x), ignore.case = ignore.case,\n                         perl = perl, fixed = fixed, useBytes = useBytes)\n              } else {\n                  runValue(x) <-\n                    gsub(pattern = pattern, replacement = replacement,\n                         x = runValue(x), ignore.case = ignore.case,\n                         perl = perl, fixed = fixed, useBytes = useBytes)\n              }\n              x\n          })\n\n.pasteTwoRles <- function(e1, e2, sep = \" \", collapse = NULL)\n{\n    n1 <- length(e1)\n    n2 <- length(e2)\n    if (n1 == 0 || n2 == 0) {\n        ends <- integer(0)\n        which1 <- integer(0)\n        which2 <- integer(0)\n    } else {\n        n <- max(n1, n2)\n        if (max(n1, n2) %% min(n1, n2) != 0)\n            warning(\"longer object length is not a multiple of shorter object length\")\n        if (n1 < n)\n            e1 <- rep(e1, length.out = n)\n        if (n2 < n)\n            e2 <- rep(e2, length.out = n)\n        # ends <- sort(unique(c(end(e1), end(e2))))\n        ends <- sortedMerge(end(e1), end(e2))\n        which1 <- findIntervalAndStartFromWidth(ends, runLength(e1))[[\"interval\"]]\n        which2 <- findIntervalAndStartFromWidth(ends, runLength(e2))[[\"interval\"]]\n    }\n    if (is.null(collapse) &&\n        is.factor(runValue(e1)) && is.factor(runValue(e2))) {\n        levelsTable <-\n          expand.grid(levels(e2), levels(e1), KEEP.OUT.ATTRS = FALSE,\n                      stringsAsFactors = FALSE)\n        values <-\n          structure((as.integer(runValue(e1)[which1]) - 1L) * nlevels(e2) +\n                    as.integer(runValue(e2)[which2]),\n                    levels =\n                    paste(levelsTable[[2L]], levelsTable[[1L]], sep = sep),\n                    class = \"factor\")\n    } else {\n        values <-\n          paste(runValue(e1)[which1], runValue(e2)[which2], sep = sep,\n                collapse = collapse)\n    }\n    new_Rle(values, diffWithInitialZero(ends))\n}\n\nsetMethod(\"paste\", \"Rle\",\n          function(..., sep = \" \", collapse = NULL)\n          {\n              args <- list(...)\n              ans <- args[[1L]]\n              if (length(args) > 1) {\n                  for (i in 2:length(args)) {\n                      ans <-\n                        .pasteTwoRles(ans, args[[i]], sep = sep,\n                                      collapse = collapse)\n                  }\n              }\n              ans\n          })\n\nsetMethod(\"grepl\", c(\"ANY\", \"Rle\"),\n          function(pattern, x, ignore.case = FALSE, perl = FALSE,\n                   fixed = FALSE, useBytes = FALSE) {\n              v <- grepl(pattern, runValue(x), ignore.case, perl, fixed,\n                         useBytes)\n              Rle(v, runLength(x))\n          })\n\nsetMethod(\"grep\", c(\"ANY\", \"Rle\"),\n          function(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,\n                   fixed = FALSE, useBytes = FALSE, invert = FALSE) {\n              if (isTRUE(value)) {\n                  v <- grep(pattern, x, ignore.case, perl, value=TRUE, fixed,\n                            useBytes, invert)\n                  Rle(v, runLength(x))\n              } else { # obviously inefficient\n                  Rle(callNextMethod())\n              }\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other factor data methods\n###\n\n### S3/S4 combo for levels.Rle\nlevels.Rle <- function(x) levels(runValue(x))\nsetMethod(\"levels\", \"Rle\", levels.Rle)\n\nsetReplaceMethod(\"levels\", \"Rle\",\n                 function(x, value) {\n                     levels(x@values) <- value\n                     if (anyDuplicated(value))\n                         x <- new_Rle(runValue(x), runLength(x))\n                     x\n                 })\n\ndroplevels.Rle <- function(x, ...) droplevels(x, ...)\n.droplevels.Rle <- function(x) {\n  if (!is.factor(runValue(x))) {\n    stop(\"levels can only be dropped when runValue(x) is a factor\")\n  }\n  runValue(x) <- droplevels(runValue(x))\n  x\n}\nsetMethod(\"droplevels\", \"Rle\", .droplevels.Rle)\n\n",
        "S4-utils.R": "### =========================================================================\n### Some low-level S4 classes and utilities\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Not S4 utilities strictly speaking but I don't have a better place to put\n### this at the moment\n###\n\n### Override base::I() with a less broken one. This is an ugly hack and\n### hopefully it is temporary only!\n### See https://stat.ethz.ch/pipermail/r-devel/2020-October/080038.html\n### for the full story.\n### Must be idempotent i.e. 'I(I(x))' must be identical to 'I(x)' for\n### any 'x'.\nI <- function(x)\n{\n    if (isS4(x)) {\n        x_class <- class(x)\n        new_classes <- unique.default(c(\"AsIs\", x_class))\n        attr(new_classes, \"package\") <- attr(x_class, \"package\")\n        structure(x, class=new_classes)\n    } else {\n        class(x) <- unique.default(c(\"AsIs\", oldClass(x)))\n        x\n    }\n}\n\nsetAs(\"ANY\", \"AsIs\", function(from) I(from))\n\n### Implement the revert of I() i.e. 'drop_AsIs(I(x))' should be identical\n### to 'x' for any 'x'. Must be idempotent i.e. 'drop_AsIs(drop_AsIs(x))'\n### must be identical to 'drop_AsIs(x)' for any 'x'.\n### NOT exported.\ndrop_AsIs <- function(x)\n{\n    x_classes <- class(x)\n    new_class <- x_classes[x_classes != \"AsIs\"]\n    attr(new_class, \"package\") <- attr(x_classes, \"package\")\n    class(x) <- new_class\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some convenient union classes\n###\n\nsetClassUnion(\"character_OR_NULL\", c(\"character\", \"NULL\"))\n\n### WARNING: The behavior of is.vector(), is( , \"vector\"), is.list(), and\n### is( ,\"list\") makes no sense:\n###   1. is.vector(matrix()) is FALSE but is(matrix(), \"vector\") is TRUE.\n###   2. is.list(data.frame()) is TRUE but is(data.frame(), \"list\") is FALSE.\n###   3. is(data.frame(), \"list\") is FALSE but extends(\"data.frame\", \"list\")\n###      is TRUE.\n###   4. is.vector(data.frame()) is FALSE but is.list(data.frame()) and\n###      is.vector(list()) are both TRUE. In other words: a data frame is a\n###      list and a list is a vector but a data frame is not a vector.\n###   5. I'm sure there is more but you get it!\n### Building our software on top of such a mess won't give us anything good.\n### For example, it's not too surprising that the union class we define below\n### is broken:\n###   6. is(data.frame(), \"vector_OR_factor\") is TRUE even though\n###      is(data.frame(), \"vector\") and is(data.frame(), \"factor\") are both\n###      FALSE.\n### Results above obtained with R-3.1.2 and R-3.2.0.\n### TODO: Be brave and report this craziness to the R bug tracker.\nsetClassUnion(\"vector_OR_factor\", c(\"vector\", \"factor\"))\n\n### NOT exported but used in the IRanges package.\nATOMIC_TYPES <- c(\"logical\", \"integer\", \"numeric\", \"complex\",\n                  \"character\", \"raw\")\n\nsetClassUnion(\"atomic\", ATOMIC_TYPES)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion utilities\n###\n\n### We define the coercion method below as a workaround to the following\n### bug in R:\n###\n###   setClass(\"A\", representation(stuff=\"numeric\"))\n###   setMethod(\"as.vector\", \"A\", function(x, mode=\"any\") x@stuff)\n###\n###   a <- new(\"A\", stuff=3:-5)\n###   > as.vector(a)\n###   [1]  3  2  1  0 -1 -2 -3 -4 -5\n###   > as(a, \"vector\")\n###   Error in as.vector(from) : \n###     no method for coercing this S4 class to a vector\n###   > selectMethod(\"coerce\", c(\"A\", \"vector\"))\n###   Method Definition:\n###\n###   function (from, to, strict = TRUE) \n###   {\n###       value <- as.vector(from)\n###       if (strict) \n###           attributes(value) <- NULL\n###       value\n###   }\n###   <environment: namespace:methods>\n###\n###   Signatures:\n###           from  to      \n###   target  \"A\"   \"vector\"\n###   defined \"ANY\" \"vector\"\n###   > setAs(\"ANY\", \"vector\", function(from) as.vector(from))\n###   > as(a, \"vector\")\n###   [1]  3  2  1  0 -1 -2 -3 -4 -5\n###\n###   ML: The problem is that the default coercion method is defined\n###   in the methods namespace, which does not see the as.vector()\n###   generic we define. Solution in this case would probably be to\n###   make as.vector a dispatching primitive like as.character(), but\n###   the \"mode\" argument makes things complicated.\nsetAs(\"ANY\", \"vector\", function(from) as.vector(from))\n\ncoercerToClass <- function(class) {\n  if (extends(class, \"vector\"))\n    .as <- get(paste0(\"as.\", class))\n  else .as <- function(from) as(from, class)\n  function(from) {\n    to <- .as(from)\n    if (!is.null(names(from)) && is.null(names(to))) {\n      names(to) <- names(from)\n    }\n    to\n  }\n}\n\n### A version of coerce() that tries to do a better job at coercing to an\n### S3 class. Dispatch on the 2nd argument only!\nsetGeneric(\"coerce2\", signature=\"to\",\n    function(from, to) standardGeneric(\"coerce2\")\n)\n\n### TODO: Should probably use coercerToClass() internally (but coercerToClass()\n### would first need to be improved).\nsetMethod(\"coerce2\", \"ANY\",\n    function(from, to)\n    {\n        to_class <- class(to)\n        if (is(from, to_class))\n            return(from)\n        if (is.data.frame(to)) {\n            ans <- as.data.frame(from, check.names=FALSE,\n                                       stringsAsFactors=FALSE)\n        } else {\n            S3coerceFUN <- try(match.fun(paste0(\"as.\", to_class)),\n                               silent=TRUE)\n            if (!inherits(S3coerceFUN, \"try-error\")) {\n                ans <- S3coerceFUN(from)\n            } else {\n                ans <- as(from, to_class, strict=FALSE)\n            }\n        }\n        if (length(ans) != length(from))\n            stop(wmsg(\"coercion of \", class(from), \" object to \", to_class,\n                      \" didn't preserve its length\"))\n        ## Try to restore the names if they were lost (e.g. by as.integer())\n        ## or altered (e.g. by as.data.frame(), which will alter names equal\n        ## to the empty string even if called with 'check.names=FALSE').\n        if (!identical(names(ans), names(from))) {\n            tmp <- try(`names<-`(ans, value=names(from)), silent=TRUE)\n            if (!inherits(tmp, \"try-error\"))\n                ans <- tmp\n        }\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### setValidity2(), new2()\n###\n### Give more contol over when object validation should happen.\n###\n\n.validity_options <- new.env(hash=TRUE, parent=emptyenv())\n\nassign(\"debug\", FALSE, envir=.validity_options)\nassign(\"disabled\", FALSE, envir=.validity_options)\n\ndebugValidity <- function(debug)\n{\n    if (missing(debug))\n        return(get(\"debug\", envir=.validity_options))\n    debug <- isTRUE(debug)\n    assign(\"debug\", debug, envir=.validity_options)\n    debug\n}\n\ndisableValidity <- function(disabled)\n{\n    if (missing(disabled))\n        return(get(\"disabled\", envir=.validity_options))\n    disabled <- isTRUE(disabled)\n    assign(\"disabled\", disabled, envir=.validity_options)\n    disabled\n}\n\n### A slightly modified version of wmsg() that is better suited for formatting\n### the problem description strings returned by validity methods.\n### NOT exported.\nwmsg2 <- function(...)\n    paste0(\"\\n    \",\n           paste0(strwrap(paste0(c(...), collapse=\"\")), collapse=\"\\n    \"))\n\nsetValidity2 <- function(Class, method, where=topenv(parent.frame()))\n{\n    setValidity(Class,\n        function(object)\n        {\n            if (disableValidity())\n                return(TRUE)\n            if (debugValidity()) {\n                whoami <- paste(\"validity method for\", Class, \"object\")\n                cat(\"[debugValidity] Entering \", whoami, \"\\n\", sep=\"\")\n                on.exit(cat(\"[debugValidity] Leaving \", whoami, \"\\n\", sep=\"\"))\n            }\n            desc_strings <- method(object)\n            if (isTRUE(desc_strings) || length(desc_strings) == 0L)\n                return(TRUE)\n            vapply(desc_strings, wmsg2, character(1), USE.NAMES=FALSE)\n        },\n        where=where\n    )\n}\n\nnew2 <- function(..., check=TRUE)\n{\n    if (!isTRUEorFALSE(check))\n        stop(\"'check' must be TRUE or FALSE\")\n    old_val <- disableValidity()\n    on.exit(disableValidity(old_val))\n    disableValidity(!check)\n    new(...)\n}\n\n### 'signatures' must be a list of character vectors. To use when many methods\n### share the same implementation.\nsetMethods <- function(f, signatures=list(), definition,\n                       where=topenv(parent.frame()), ...)\n{\n    for (signature in signatures)\n        setMethod(f, signature=signature, definition, where=where, ...)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### setReplaceAs()\n###\n### Supplying a \"coerce<-\" method to the 'replace' argument of setAs() is\n### optional but supplying a \"coerce\" method (thru the 'def' argument) is not.\n### However there are legitimate situations where we want to define a\n### \"coerce<-\" method only. setReplaceAs() can be used for that.\n###\n\n### Same interface as setAs() (but no 'replace' argument).\n### NOT exported.\nsetReplaceAs <- function(from, to, def, where=topenv(parent.frame()))\n{\n    ## Code below taken from setAs() and slightly adapted.\n\n    args <- formalArgs(def)\n    if (identical(args, c(\"from\", \"to\", \"value\"))) {\n        method <- def\n    } else {\n        if (length(args) != 2L) \n            stop(gettextf(\"the method definition must be a function of 2 \",\n                          \"arguments, got %d\", length(args)), domain=NA)\n        def <- body(def)\n        if (!identical(args, c(\"from\", \"value\"))) {\n            ll <- list(quote(from), quote(value))\n            names(ll) <- args\n            def <- substituteDirect(def, ll)\n            warning(gettextf(\"argument names in method definition changed \",\n                             \"to agree with 'coerce<-' generic:\\n%s\",\n                             paste(deparse(def), sep=\"\\n    \")), domain=NA)\n        }\n        method <- eval(function(from, to, value) NULL)\n        functionBody(method, envir=.GlobalEnv) <- def\n    }\n    setMethod(\"coerce<-\", c(from, to), method, where=where)\n}\n\n### We also provide 2 canonical \"coerce<-\" methods that can be used when the\n### \"from class\" is a subclass of the \"to class\". They do what the methods\n### automatically generated by the methods package are expected to do except\n### that the latter are broken. See\n###     https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16421\n### for the bug report.\n\n### Naive/straight-forward implementation (easy to understand so it explains\n### the semantic of canonical \"coerce<-\").\ncanonical_replace_as <- function(from, to, value)\n{\n    for (what in slotNames(to))\n        slot(from, what) <- slot(value, what)\n    from\n}\n\n### Does the same as canonical_replace_as() but tries to generate only one\n### copy of 'from' instead of one copy each time one of its slots is modified.\ncanonical_replace_as_2 <- function(from, to, value)\n{\n    firstTime <- TRUE\n    for (what in slotNames(to)) {\n        v <- slot(value, what)\n        if (firstTime) {\n            slot(from, what, FALSE) <- v\n            firstTime <- FALSE\n        } else {\n            `slot<-`(from, what, FALSE, v)\n        }\n    }\n    from\n}\n\n### Usage (assuming B is a subclass of A):\n###\n###   setReplaceAs(\"B\", \"A\", canonical_replace_as_2)\n###\n### Note that this is used in the VariantAnnotation package.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Manipulating the prototype of an S4 class.\n###\n\n### Gets or sets the default value of the given slot of the given class by\n### reading or altering the prototype of the class. setDefaultSlotValue() is\n### typically used in the .onLoad() hook of a package when the DLL of the\n### package needs to be loaded *before* the default value of a slot can be\n### computed.\n### NOT exported.\ngetDefaultSlotValue <- function(classname, slotname, where=.GlobalEnv)\n{\n    classdef <- getClass(classname, where=where)\n    if (!(slotname %in% names(attributes(classdef@prototype))))\n        stop(\"prototype for class \\\"\", classname, \"\\\" \",\n             \"has no \\\"\", slotname, \"\\\" attribute\")\n    attr(classdef@prototype, slotname, exact=TRUE)\n}\n\n### NOT exported.\nsetDefaultSlotValue <- function(classname, slotname, value, where=.GlobalEnv)\n{\n    classdef <- getClass(classname, where=where)\n    if (!(slotname %in% names(attributes(classdef@prototype))))\n        stop(\"prototype for class \\\"\", classname, \"\\\" \",\n             \"has no \\\"\", slotname, \"\\\" attribute\")\n    attr(classdef@prototype, slotname) <- value\n    assignClassDef(classname, classdef, where=where)\n    ## Re-compute the complete definition of the class. methods::setValidity()\n    ## does that after calling assignClassDef() so we do it too.\n    resetClass(classname, classdef, where=where)\n}\n\n### NOT exported.\nsetPrototypeFromObject <- function(classname, object, where=.GlobalEnv)\n{\n    classdef <- getClass(classname, where=where)\n    if (class(object) != classname)\n        stop(\"'object' must be a \", classname, \" instance\")\n    object_attribs <- attributes(object)\n    object_attribs$class <- NULL\n    ## Sanity check.\n    stopifnot(identical(names(object_attribs),\n                        names(attributes(classdef@prototype))))\n    attributes(classdef@prototype) <- object_attribs\n    assignClassDef(classname, classdef, where=where)\n    ## Re-compute the complete definition of the class. methods::setValidity()\n    ## does that after calling assignClassDef() so we do it too.\n    resetClass(classname, classdef, where=where)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n### allEqualsS4: just a hack that auomatically digs down\n### deeply nested objects to detect differences.\n###\n\n.allEqualS4 <- function(x, y) {\n  eq <- all.equal(x, y)\n  canCompareS4 <- !isTRUE(eq) && isS4(x) && isS4(y) && class(x) == class(y)\n  if (canCompareS4) {\n    child.diffs <- mapply(.allEqualS4, attributes(x), attributes(y),\n                          SIMPLIFY=FALSE)\n    child.diffs$class <- NULL\n    dfs <- mapply(function(d, nm) {\n      if (!is.data.frame(d)) {\n        data.frame(comparison = I(list(d)))\n      } else d\n    }, child.diffs, names(child.diffs), SIMPLIFY=FALSE)\n    do.call(rbind, dfs)\n  } else {\n    eq[1]\n  }\n}\n\n### NOT exported.\nallEqualS4 <- function(x, y) {\n  eq <- .allEqualS4(x, y)\n  setNames(eq$comparison, rownames(eq))[sapply(eq$comparison, Negate(isTRUE))]\n}\n\n",
        "SimpleList-class.R": "### =========================================================================\n### SimpleList objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"SimpleList\",\n    contains=\"List\",\n    representation(\n        listData=\"list\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See Vector-class.R file\n### for what slots should or should not be considered \"parallel\".\nsetMethod(\"parallel_slot_names\", \"SimpleList\",\n    function(x) c(\"listData\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\nsetMethod(\"updateObject\", \"SimpleList\",\n    function(object, ..., verbose=FALSE)\n    {\n        object@listData <- lapply(object@listData,\n            function(x) {\n                if (is(x, \"Vector\"))\n                    x <- updateObject(x, ..., verbose=verbose)\n                x\n            }\n        )\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"names\", \"SimpleList\", function(x) names(x@listData))\n\nsetReplaceMethod(\"names\", \"SimpleList\",\n    function(x, value)\n    {\n        names(x@listData) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### Low-level. NOT exported.\n### Stuff to put in elementMetadata slot can be passed either with\n###   new_SimpleList_from_list(..., elementMetadata=somestuff)\n### or with\n###   new_SimpleList_from_list(..., mcols=somestuff)\n### The latter is the new recommended form.\nnew_SimpleList_from_list <- function(Class, x, ..., mcols)\n{\n    if (!extends(Class, \"SimpleList\"))\n        stop(\"class \", Class, \" must extend SimpleList\")\n    if (!is.list(x))\n        stop(\"'x' must be a list\")\n    if (is.array(x)) { # drop any unwanted dimensions\n        tmp_names <- names(x)\n        dim(x) <- NULL # clears the names\n        names(x) <- tmp_names\n    }\n    class(x) <- \"list\"\n    proto <- new(Class)\n    ans_elementType <- elementType(proto)\n    if (is(S4Vectors::mcols(proto, use.names=FALSE), \"DataFrame\"))\n        mcols <- make_zero_col_DFrame(length(x))\n    if (!all(sapply(x, function(xi) extends(class(xi), ans_elementType))))\n        stop(\"all elements in 'x' must be \", ans_elementType, \" objects\")\n    if (missing(mcols))\n        return(new2(Class, listData=x, ..., check=FALSE))\n    new2(Class, listData=x, ..., elementMetadata=mcols, check=FALSE)\n}\n\nSimpleList <- function(...)\n{\n    args <- list(...)\n    ## The extends(class(x), \"list\") test is NOT equivalent to is.list(x) or\n    ## to is(x, \"list\") or to inherits(x, \"list\"). Try for example with\n    ## x <- data.frame() or x <- matrix(list()). We use the former below\n    ## because it seems to closely mimic what the methods package uses for\n    ## checking the \"listData\" slot of the SimpleList object that we try to\n    ## create later with new(). For example if we were using is.list() instead\n    ## of extends(), the test would pass on matrix(list()) but new() then would\n    ## fail with the following message:\n    ## Error in validObject(.Object) :\n    ##   invalid class “SimpleList” object: invalid object for slot \"listData\"\n    ##   in class \"SimpleList\": got class \"matrix\", should be or extend class\n    ##   \"list\"\n    if (length(args) == 1L && extends(class(args[[1L]]), \"list\"))\n        args <- args[[1L]]\n    new2(\"SimpleList\", listData=args, check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid.SimpleList.listData <- function(x)\n{\n    elementTypeX <- elementType(x)\n    if (!all(sapply(as.list(x),\n                    function(xi) extends(class(xi), elementTypeX))))\n        return(paste(\"the 'listData' slot must be a list containing\",\n                     elementTypeX, \"objects\"))\n    NULL\n}\n.valid.SimpleList <- function(x)\n{\n    c(.valid.SimpleList.listData(x))\n}\nsetValidity2(\"SimpleList\", .valid.SimpleList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### classNameForDisplay()\n###\n\nsetMethod(\"classNameForDisplay\", \"SimpleList\",\n    function(x) sub(\"^Simple\", \"\", class(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"getListElement\", \"SimpleList\",\n    function(x, i, exact=TRUE)\n        getListElement(x@listData, i, exact=exact)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Looping\n###\n\nsetMethod(\"lapply\", \"SimpleList\",\n    function(X, FUN, ...) lapply(as.list(X), match.fun(FUN), ...)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### Unfortunately, not all SimpleList subclasses (e.g. BamFileList or\n### ExperimentList) support coercion from an ordinary list (even though\n### they probably should), so the default \"coerce2\" method will fail to\n### convert an ordinary list to one of these classes. The good news is that\n### coercion from SimpleList to one of these classes does work. For example:\n###\n###   library(Rsamtools)\n###   as(list(), \"BamFileList\")           # error\n###   as(SimpleList(), \"BamFileList\")     # works\n###\n###   library(MultiAssayExperiment)\n###   as(list(), \"ExperimentList\")        # error\n###   as(SimpleList(), \"ExperimentList\")  # works\n###\n### So when the default \"coerce2\" method fails to coerce an ordinary list,\n### we wrap the list in a SimpleList instance and try again. Note that this\n### should help in general because it brings 'from' a little bit closer to\n### 'class(to)'.\nsetMethod(\"coerce2\", \"SimpleList\",\n    function(from, to)\n    {\n        ans <- try(callNextMethod(), silent=TRUE)\n        if (!inherits(ans, \"try-error\"))\n            return(ans)\n        if (!is.list(from))\n            stop(wmsg(attr(ans, \"condition\")$message))\n        ## We use the SimpleList() constructor function to wrap 'from' in a\n        ## SimpleList instance instead of coercion to SimpleList (which is\n        ## too high level and tries to be too smart).\n        from <- SimpleList(from)\n        to_mcols <- mcols(to, use.names=FALSE)\n        mcols(from) <- to_mcols[rep.int(NA_integer_, length(from)), ,\n                                drop=FALSE]\n        ans <- callNextMethod()\n        ## Even though coercion from SimpleList to 'class(to)' \"worked\", it\n        ## can return a broken object. This happens when an automatic coercion\n        ## method gets in the way. For example:\n        ##\n        ##   selectMethod(\"coerce\", c(\"SimpleList\", \"BamFileList\"))\n        ##\n        ## shows one of these methods (it's not coming from the Rsamtools or\n        ## S4Vectors package). The problem with these methods is that they\n        ## often do the wrong thing and don't even bother to validate the\n        ## object they return!\n        ## One known problem with the automatic coercion method from SimpleList\n        ## to one of its subclass is that it will set the elementType slot to\n        ## \"ANY\" which will be wrong in general. So we fix this.\n        ans@elementType <- to@elementType\n        validObject(ans)\n        ans\n    }\n)\n\n### S3/S4 combo for as.list.SimpleList\n.as.list.SimpleList <- function(x, use.names=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    ans <- x@listData\n    if (!use.names)\n        names(ans) <- NULL\n    ans\n}\nas.list.SimpleList <- function(x, ...) .as.list.SimpleList(x, ...)\nsetMethod(\"as.list\", \"SimpleList\", as.list.SimpleList)\n\n### NOT exported but used in IRanges.\ncoerceToSimpleList <- function(from, element.type)\n{\n    if (missing(element.type)) {\n        if (is(from, \"List\")) {\n            element.type <- from@elementType\n        } else if (is.list(from)) {\n            element.type <- lowestListElementClass(from)\n        } else {\n            element.type <- class(from)\n        }\n        coerce_list_elts <- FALSE\n    } else {\n        coerce_list_elts <- TRUE\n    }\n    SimpleListClass <- listClassName(\"Simple\", element.type)\n    if (is(from, SimpleListClass))\n        return(from)\n    listData <- as.list(from)\n    if (coerce_list_elts)\n        listData <- lapply(listData, coercerToClass(element.type))\n    ans <- new_SimpleList_from_list(SimpleListClass, listData)\n    if (is(from, \"List\"))\n        mcols(ans) <- mcols(from)\n    ans\n}\n\nsetAs(\"ANY\", \"SimpleList\", function(from) {\n  coerceToSimpleList(from)\n})\n\nsetAs(\"list\", \"List\", function(from) {\n  coerceToSimpleList(from)\n})\n\nsetMethod(\"as.env\", \"SimpleList\",\n          function(x, enclos = parent.frame(2), tform = identity) {\n              makeEnvForNames(x, names(x), enclos, tform)\n          })\n\nmakeEnvForNames <- function(x, nms, enclos = parent.frame(2),\n                             tform = identity)\n{\n    env <- new.env(parent = enclos)\n    lapply(nms,\n           function(col) {\n               colFun <- function() {\n                   val <- tform(x[[col]])\n                   rm(list=col, envir=env)\n                   assign(col, val, env)\n                   val\n               }\n               makeActiveBinding(col, colFun, env)\n           })\n    addSelfRef(x, env)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unique()\n###\n\n### TODO: easily generalized to List\n.unique.SimpleList <- function(x, incomparables=FALSE, ...) {\n    as(lapply(x, unique, incomparables=incomparables, ...), class(x))\n}\nsetMethod(\"unique\", \"SimpleList\", .unique.SimpleList)\n\n",
        "TransposedDataFrame-class.R": "### =========================================================================\n### TransposedDataFrame objects\n### -------------------------------------------------------------------------\n\n\n### TransposedDataFrame extends List and the List elements are considered to\n### be the rows of the TransposedDataFrame object. This means that the length\n### of a TransposedDataFrame object which is the length of its underlying\n### List is its number of rows.\nsetClass(\"TransposedDataFrame\",\n    contains=c(\"RectangularData\", \"List\"),\n    slots=c(data=\"DataFrame\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Transposition\n###\n### Note that transposing a DataFrame derivative is currently the only way\n### to construct a TransposedDataFrame object. We don't provide a dedicated\n### constructor function.\n###\n### An important property of transposition is that it preserves the length\n### and names of the object.\n###\n\n### S3/S4 combo for t.DataFrame\nt.DataFrame <- function(x)\n{\n    x_mcols <- mcols(x, use.names=FALSE)\n    if (!is.null(x_mcols))\n        mcols(x) <- NULL\n    new2(\"TransposedDataFrame\", data=x,\n                                elementMetadata=x_mcols,\n                                check=FALSE)\n}\nsetMethod(\"t\", \"DataFrame\", t.DataFrame)\n\n### S3/S4 combo for t.TransposedDataFrame\nt.TransposedDataFrame <- function(x)\n{\n    ans <- x@data\n    mcols(ans) <- mcols(x, use.names=FALSE)\n    ans\n}\nsetMethod(\"t\", \"TransposedDataFrame\", t.TransposedDataFrame)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"nrow\", \"TransposedDataFrame\", function(x) ncol(x@data))\nsetMethod(\"ncol\", \"TransposedDataFrame\", function(x) nrow(x@data))\n\nsetMethod(\"rownames\", \"TransposedDataFrame\",\n    function(x, do.NULL=TRUE, prefix=\"row\")\n    {\n        if (!(identical(do.NULL, TRUE) && identical(prefix, \"row\")))\n            stop(wmsg(\"argument 'do.NULL' and 'prefix' are not supported\"))\n        colnames(x@data)\n    }\n)\nsetMethod(\"colnames\", \"TransposedDataFrame\",\n    function(x, do.NULL=TRUE, prefix=\"col\")\n    {\n        if (!(identical(do.NULL, TRUE) && identical(prefix, \"col\")))\n            stop(wmsg(\"argument 'do.NULL' and 'prefix' are not supported\"))\n        rownames(x@data)\n    }\n)\n\n### For a TransposedDataFrame object, the length is the number of rows\n### and the names are the rownames. Note that 'length(x)' and 'names(x)'\n### will ultimately end up calling 'length(x@data)' and 'names(x@data)',\n### repectively.\nsetMethod(\"length\", \"TransposedDataFrame\", function(x) nrow(x))\nsetMethod(\"names\", \"TransposedDataFrame\", function(x) rownames(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setters\n###\n\n### base::`rownames<-`() and base::`colnames<-`() work as long as\n### `dimnames<-`() works.\nsetReplaceMethod(\"dimnames\", \"TransposedDataFrame\",\n    function(x, value)\n    {\n        if (!(is.list(value) && length(value) == 2L))\n            stop(\"dimnames replacement value must be a list of length 2\")\n        dimnames(x@data) <- rev(value)\n        x\n    }\n)\nsetReplaceMethod(\"names\", \"TransposedDataFrame\",\n    function(x, value) `rownames<-`(x, value)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"extractROWS\", \"TransposedDataFrame\",\n    function(x, i) t(extractCOLS(t(x), i))\n)\n\nsetMethod(\"extractCOLS\", \"TransposedDataFrame\",\n    function(x, i) t(extractROWS(t(x), i))\n)\n\n.subset_TransposedDataFrame <- function(x, i, j, ..., drop=TRUE)\n{\n    if (!isTRUEorFALSE(drop))\n        stop(\"'drop' must be TRUE or FALSE\")\n    linear_subsetting <- (nargs() - !missing(drop)) < 3L\n    if (linear_subsetting) {\n        if (!missing(drop))\n            warning(\"'drop' argument ignored by linear subsetting\")\n        if (missing(i))\n            return(x)\n        return(extractROWS(x, i))\n    }\n    tx <- t(x)\n    ## Use 'drop=FALSE' to make sure 'ans' is a DataFrame.\n    if (missing(i) && missing(j)) {\n        ans <- tx[ ,  , ..., drop=FALSE]\n    } else if (missing(i)) {\n        ans <- tx[j,  , ..., drop=FALSE]\n    } else if (missing(j)) {\n        ans <- tx[ , i, ..., drop=FALSE]\n    } else {\n        ans <- tx[j, i, ..., drop=FALSE]\n    }\n    if (drop && ncol(ans) == 1L)\n        return(ans[[1L]])\n    t(ans)\n}\nsetMethod(\"[\", \"TransposedDataFrame\", .subset_TransposedDataFrame)\n\nsetMethod(\"getListElement\", \"TransposedDataFrame\",\n    function(x, i, exact=TRUE) getListElement(x@data, i, exact=exact)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subassignment\n###\n\nsetMethod(\"normalizeSingleBracketReplacementValue\", \"TransposedDataFrame\",\n    function(value, x)\n    {\n        is_empty_list <- is(value, \"list_OR_List\") && length(value) == 0L\n        if (is.null(value) || is_empty_list)\n            return(NULL)\n        as(value, class(x), strict=FALSE)\n    }\n)\n\nsetReplaceMethod(\"[\", \"TransposedDataFrame\",\n    function(x, i, j, ..., value)\n    {\n        value <- normalizeSingleBracketReplacementValue(value, x)\n        if (!is.null(value))\n            value <- t(value)\n        t(callGeneric(t(x), j, i, ..., value=value))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercions\n###\n\nsetAs(\"DataFrame\", \"TransposedDataFrame\", function(from) t(from))\nsetAs(\"TransposedDataFrame\", \"DataFrame\", function(from) t(from))\n\nsetMethod(\"as.matrix\", \"TransposedDataFrame\",\n    function(x, ...) t(as.matrix(x@data, ...))\n)\n\n### S3/S4 combo for as.list.TransposedDataFrame\n.as.list.TransposedDataFrame <-\n    function(x, use.names=TRUE) as.list(x@data, use.names=use.names)\nas.list.TransposedDataFrame <-\n    function(x, ...) .as.list.TransposedDataFrame(x, ...)\nsetMethod(\"as.list\", \"TransposedDataFrame\",\n    as.list.TransposedDataFrame\n)\n\nsetAs(\"ANY\", \"TransposedDataFrame\", function(from) t(as(from, \"DataFrame\")))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"TransposedDataFrame\",\n    function(x)\n    {\n        m <- t(makeNakedCharacterMatrixForDisplay(x@data))\n        x_colnames <- rownames(x@data)\n        if (!is.null(x_colnames))\n            colnames(m) <- x_colnames\n        m\n    }\n)\n\n.show_TransposedDataFrame <- function(x)\n{\n    nhead <- get_showHeadLines()\n    ntail <- get_showTailLines()\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    cat(classNameForDisplay(x), \" with \",\n        x_nrow, \" row\", ifelse(x_nrow == 1L, \"\", \"s\"),\n        \" and \",\n        x_ncol, \" column\", ifelse(x_ncol == 1L, \"\", \"s\"),\n        \"\\n\", sep=\"\")\n    if (x_nrow != 0L && x_ncol != 0L) {\n        x_rownames <- rownames(x)\n        classinfo <- make_class_info_for_DataFrame_display(x@data)\n        if (x_nrow <= nhead + ntail + 1L) {\n            m <- makeNakedCharacterMatrixForDisplay(x)\n            if (!is.null(x_rownames))\n                rownames(m) <- x_rownames\n        } else { \n            m <- rbind(makeNakedCharacterMatrixForDisplay(head(x, nhead)),\n                       rbind(rep.int(\"...\", x_ncol)),\n                       makeNakedCharacterMatrixForDisplay(tail(x, ntail)))\n            rownames(m) <- make_rownames_for_RectangularData_display(\n                                             x_rownames, x_nrow,\n                                             nhead, ntail)\n            classinfo <- make_rownames_for_RectangularData_display(\n                                             classinfo, x_nrow,\n                                             nhead, ntail)\n        }\n        rownames(m) <- paste(format(rownames(m)), classinfo)\n        print(m, quote=FALSE, right=TRUE)\n    }\n    invisible(NULL)\n}\n\nsetMethod(\"show\", \"TransposedDataFrame\",\n    function(object) .show_TransposedDataFrame(object)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Combining\n###\n\n### Defining bindROWS() gives us c() and rbind().\n### Ignore the 'check' argument!\nsetMethod(\"bindROWS\", \"TransposedDataFrame\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        if (!identical(use.names, TRUE))\n            stop(wmsg(\"the bindROWS() method for TransposedDataFrame objects \",\n                      \"only accepts 'use.names=TRUE'\"))\n        if (!isTRUEorFALSE(ignore.mcols))\n            stop(\"'ignore.mcols' must be TRUE or FALSE\")\n        objects <- prepare_objects_to_bind(x, objects)\n        all_objects <- c(list(x), objects)\n        if (ignore.mcols)\n            all_objects <- lapply(all_objects, `mcols<-`, value=NULL)\n        t(do.call(cbind, lapply(all_objects, t)))\n    }\n)\n\n### Defining bindCOLS() gives us cbind().\n### Ignore the 'ignore.mcols' argument!\nsetMethod(\"bindCOLS\", \"TransposedDataFrame\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        objects <- prepare_objects_to_bind(x, objects)\n        t(bindROWS(t(x), objects=lapply(objects, t),\n                   use.names=use.names, check=check))\n    }\n)\n\n",
        "Vector-class.R": "### =========================================================================\n### Vector objects\n### -------------------------------------------------------------------------\n###\n### The Vector virtual class is a general container for storing a finite\n### sequence i.e. an ordered finite collection of elements.\n###\n\nsetClass(\"Vector\",\n    contains=\"Annotated\",\n    representation(\n        \"VIRTUAL\",\n        elementMetadata=\"DataFrame_OR_NULL\"\n    )\n)\n\n### Beware that:\n###   > is(factor(), \"vector_OR_Vector\")\n###   [1] TRUE\n### even though:\n###   > is(factor(), \"vector\")\n###   [1] FALSE\n###   > is(factor(), \"Vector\")\n###   [1] FALSE\n### See R/S4-utils.R for other examples of messed up inheritance with union\n### classes.\n### TODO: Should we explicitely add \"factor\" to this union?\nsetClassUnion(\"vector_OR_Vector\", c(\"vector\", \"Vector\"))  # vector-like objects\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n### For internal use only.\n###\n\n### parallel_slot_names() must return the names of all the slots in Vector\n### derivative 'x' that are **parallel** to the object. Slot \"foo\" in 'x'\n### is considered to be parallel to 'x' if it's guaranteed to contain a\n### value that is either NULL or such that 'NROW(x@foo)' is equal to\n### 'length(x)' and the i-th ROW in 'x@foo' is associated with the i-th\n### vector element in 'x'.\n### For example, the \"start\", \"width\", \"NAMES\", and \"elementMetadata\" slots\n### of an IRanges object 'x' are parallel to 'x'. Note that the \"NAMES\"\n### and \"elementMetadata\" slots can be set to NULL.\nsetGeneric(\"parallel_slot_names\",\n    function(x) standardGeneric(\"parallel_slot_names\")\n)\n\n### Methods for Vector derivatives should be defined in an incremental\n### fashion, that is, they should only explicitly list the new \"parallel\n### slots\" (i.e. the parallel slots that they add to their parent class).\n### See above for what slots should or should not be considered \"parallel\".\n### See Hits-class.R file for an example of a parallel_slot_names() method\n### defined for a Vector derivative.\nsetMethod(\"parallel_slot_names\", \"Vector\", function(x) \"elementMetadata\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallelVectorNames()\n###\n### For internal use only.\n###\n\nsetGeneric(\"parallelVectorNames\",\n           function(x) standardGeneric(\"parallelVectorNames\"))\nsetMethod(\"parallelVectorNames\", \"ANY\",\n          function(x) setdiff(colnames(as.data.frame(new(class(x)))), \"value\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n### The default method (defined in BiocGenerics) does complicated, costly,\n### and dangerous things, and sometimes it actually breaks valid objects\n### (e.g. it breaks valid OverlapEncodings objects). So we overwrite it with\n### a method for Vector objects that does nothing! That way it's simple,\n### cheap, and safe ;-). And that's really all it needs to do at the moment.\n### UPDATE: Starting with S4Vectors 0.23.19, all DataFrame instances need\n### to be replaced with DFrame instances. So the updateObject() method for\n### Vector objects got updated from doing nothing (no-op) to call\n### updateObject() on the elementMetadata component of the object.\n\nsetMethod(\"updateObject\", \"Vector\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## Update from DataFrame to DFrame.\n        object@elementMetadata <- updateObject(object@elementMetadata,\n                                               ..., verbose=verbose)\n        object\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\n### We use the **first** slot returned by parallel_slot_names() to infer\n### the length of 'x' so hopefully this is not a slot that can contain a\n### NULL (like the \"elementMetadata\" of a Vector derivative or the \"NAMES\"\n### slot of an IRanges object).\nsetMethod(\"length\", \"Vector\",\n    function(x) NROW(slot(x, parallel_slot_names(x)[[1L]]))\n)\n\nsetMethod(\"lengths\", \"Vector\",\n     function(x, use.names=TRUE)\n     {\n         if (!isTRUEorFALSE(use.names))\n             stop(\"'use.names' must be TRUE or FALSE\")\n         ans <- elementNROWS(x)  # This is wrong! See ?Vector for the details.\n         if (!use.names)\n             names(ans) <- NULL\n         ans\n     }\n)\n\n### 3 accessors for the same slot: elementMetadata(), mcols(), and values().\n### mcols() is the recommended one, use of elementMetadata() or values() is\n### discouraged.\nsetGeneric(\"elementMetadata\", signature=\"x\",\n    function(x, use.names=TRUE, ...) standardGeneric(\"elementMetadata\")\n)\n\nsetMethod(\"elementMetadata\", \"Vector\",\n    function(x, use.names=TRUE, ...)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        ans <- updateObject(x@elementMetadata, check=FALSE)\n        if (use.names && !is.null(ans))\n            rownames(ans) <- names(x)\n        ans\n    }\n)\n\nsetGeneric(\"mcols\", signature=\"x\",\n    function(x, use.names=TRUE, ...) standardGeneric(\"mcols\")\n)\n\nsetMethod(\"mcols\", \"Vector\",\n    function(x, use.names=TRUE, ...)\n        elementMetadata(x, use.names=use.names, ...)\n)\n\nsetGeneric(\"values\", function(x, ...) standardGeneric(\"values\"))\n\nsetMethod(\"values\", \"Vector\", function(x, ...) elementMetadata(x, ...))\n\nsetMethod(\"anyNA\", \"Vector\", function(x, recursive=FALSE) FALSE)\n\nsetMethod(\"is.na\", \"Vector\", function(x) rep.int(FALSE, length(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.validate_Vector_length <- function(x)\n{\n    x_len <- length(x)\n    if (!isSingleNumber(x_len) || x_len < 0L)\n        return(\"'length(x)' must be a single non-negative number\")\n    if (!is.null(attributes(x_len)))\n        return(\"'length(x)' must be a single integer with no attributes\")\n    NULL\n}\n\n.validate_Vector_parallel_slots <- function(x)\n{\n    x_len <- length(x)\n    x_pslotnames <- parallel_slot_names(x)\n    if (!is.character(x_pslotnames)\n     || anyMissing(x_pslotnames)\n     || anyDuplicated(x_pslotnames)) {\n        msg <- c(\"'parallel_slot_names(x)' must be a character vector \",\n                 \"with no NAs and no duplicates\")\n        return(paste(msg, collapse=\"\"))\n    }\n    if (x_pslotnames[[length(x_pslotnames)]] != \"elementMetadata\") {\n        msg <- c(\"last string in 'parallel_slot_names(x)' \",\n                 \"must be \\\"elementMetadata\\\"\")\n        return(paste(msg, collapse=\"\"))\n    }\n    msg <- NULL\n    for (slotname in head(x_pslotnames, -1L)) {\n        tmp <- slot(x, slotname)\n        if (!(is.null(tmp) || NROW(tmp) == x_len)) {\n            what <- paste0(\"x@\", slotname)\n            msg <- c(msg, paste0(\"'\", what, \"' is not parallel to 'x'\"))\n        }\n    }\n    tmp <- mcols(x, use.names=FALSE)\n    if (!(is.null(tmp) || nrow(tmp) == x_len)) {\n        msg <- c(msg, \"'mcols(x)' is not parallel to 'x'\")\n    }\n    msg\n}\n\n.validate_Vector_names <- function(x)\n{\n    x_names <- names(x)\n    if (is.null(x_names))\n        return(NULL)\n    if (!is.character(x_names) || !is.null(attributes(x_names))) {\n        msg <- c(\"'names(x)' must be NULL or a character vector \",\n                 \"with no attributes\")\n        return(paste(msg, collapse=\"\"))\n    }\n    if (length(x_names) != length(x))\n        return(\"'names(x)' must be NULL or have the length of 'x'\")\n    NULL\n}\n\n.validate_Vector_mcols <- function(x)\n{\n    x_mcols <- mcols(x, use.names=FALSE)\n    if (is.null(x_mcols))\n        return(NULL)\n    if (!is(x_mcols, \"DataFrame\"))\n        return(\"'mcols(x)' must be a DataFrame object or NULL\")\n    ## 'x_mcols' is a DataFrame derivative.\n    x_mcols_rownames <- rownames(x_mcols)\n    if (is.null(x_mcols_rownames))\n        return(NULL)\n    if (!identical(x_mcols_rownames, names(x)))\n    {\n        msg <- c(\"the rownames of DataFrame 'mcols(x)' \",\n                 \"must match the names of 'x'\")\n        return(paste(msg, collapse=\"\"))\n    }\n    NULL\n}\n\n.validate_Vector <- function(x)\n{\n    c(.validate_Vector_length(x),\n      .validate_Vector_parallel_slots(x),\n      .validate_Vector_names(x),\n      .validate_Vector_mcols(x))\n}\n\nsetValidity2(\"Vector\", .validate_Vector)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setters\n###\n\nsetGeneric(\"elementMetadata<-\",\n           function(x, ..., value) standardGeneric(\"elementMetadata<-\"))\n\n### NOT exported but used in the IRanges and GenomicRanges packages.\nnormarg_mcols <- function(mcols, x_class, x_len)\n{\n    ## Note that 'mcols_target_class' could also be obtained with\n    ## 'getClassDef(x_class)@slots[[\"elementMetadata\"]]', in which\n    ## case the class name would be returned with the \"package\" attribute.\n    mcols_target_class <- getSlots(x_class)[[\"elementMetadata\"]]\n    ok <- is(mcols, mcols_target_class)\n    if (is.null(mcols)) {\n        if (ok)\n            return(mcols)  # NULL\n        mcols <- make_zero_col_DFrame(x_len)\n    } else if (is.list(mcols)) {\n        ## Note that this will also handle an 'mcols' that is a data.frame\n        ## or a data.frame derivative (e.g. data.table object).\n        if (ok)\n            return(mcols)\n        mcols <- new_DataFrame(mcols)\n    } else {\n        mcols <- updateObject(mcols, check=FALSE)\n    }\n    ok <- is(mcols, mcols_target_class)\n    if (!ok)\n        mcols <- as(mcols, mcols_target_class)\n\n    ## From now on, 'mcols' is guaranteed to be a DataFrame derivative.\n    if (!is.null(rownames(mcols)))\n        rownames(mcols) <- NULL\n\n    mcols_nrow <- nrow(mcols)\n    if (mcols_nrow == x_len)\n        return(mcols)\n    one <- ncol(mcols) == 1L\n    if (mcols_nrow > x_len && mcols_nrow != 1L)\n        stop(wmsg(\"trying to set \", if (one) \"a \" else \"\",\n                  \"metadata column\", if (one) \"\" else \"s\", \" \",\n                  \"of length \", mcols_nrow, \" on an object of length \", x_len))\n    if (mcols_nrow == 0L)\n        stop(wmsg(\"trying to set \", if (one) \"a \" else \"\", \"zero length \",\n                  \"metadata column\", if (one) \"\" else \"s\", \" \",\n                  \"on a non-zero length object \"))\n    if (x_len %% mcols_nrow != 0L)\n        warning(wmsg(\"You supplied \", if (one) \"a \" else \"\",\n                     \"metadata column\", if (one) \"\" else \"s\", \" \",\n                     \"of length \", mcols_nrow, \" to set on an object \",\n                     \"of length \", x_len, \". However please note that \",\n                     \"the latter is not a multiple of the former.\"))\n    i <- rep(seq_len(mcols_nrow), length.out=x_len)\n    extractROWS(mcols, i)\n}\n\nsetReplaceMethod(\"elementMetadata\", \"Vector\",\n    function(x, ..., value)\n    {\n        value <- normarg_mcols(value, class(x), length(x))\n        BiocGenerics:::replaceSlots(x, elementMetadata=value, check=FALSE)\n    }\n)\n\nsetGeneric(\"mcols<-\", function(x, ..., value) standardGeneric(\"mcols<-\"))\n\nsetReplaceMethod(\"mcols\", \"Vector\",\n    function(x, ..., value) `elementMetadata<-`(x, ..., value=value)\n)\n\nsetGeneric(\"values<-\", function(x, ..., value) standardGeneric(\"values<-\"))\n\nsetReplaceMethod(\"values\", \"Vector\",\n                 function(x, value) {\n                     elementMetadata(x) <- value\n                     x\n                 })\n\nsetGeneric(\"rename\", function(x, ...) standardGeneric(\"rename\"))\n\n.renameVector <- function(x, ...) {\n  newNames <- c(...)\n  if (!is.character(newNames) || any(is.na(newNames))) {\n      stop(\"arguments in '...' must be character and not NA\")\n  }\n  badOldNames <- setdiff(names(newNames), names(x))\n  if (length(badOldNames))\n    stop(\"Some 'from' names in value not found on 'x': \",\n         paste(badOldNames, collapse = \", \"))\n  names(x)[match(names(newNames), names(x))] <- newNames\n  x\n}\n\nsetMethod(\"rename\", \"vector\", .renameVector)\nsetMethod(\"rename\", \"Vector\", .renameVector)\n\nsetGeneric(\"unname\", signature=\"obj\")\n\nsetMethod(\"unname\", \"Vector\", function(obj, force = FALSE) {\n    names(obj) <- NULL\n    obj\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetMethod(\"as.logical\", \"Vector\",\n    function(x) as.vector(x, mode=\"logical\")\n)\nsetMethod(\"as.integer\", \"Vector\",\n    function(x) as.vector(x, mode=\"integer\")\n)\nsetMethod(\"as.numeric\", \"Vector\",\n    function(x) as.vector(x, mode=\"numeric\")\n)\n### Even though as.double() is a generic function (as reported by\n### 'getGeneric(\"as.double\")', it seems impossible to define methods for this\n### generic. Trying to do so like in the code below actually creates an\n### \"as.numeric\" method.\n#setMethod(\"as.double\", \"Vector\",\n#    function(x) as.vector(x, mode=\"double\")\n#)\nsetMethod(\"as.complex\", \"Vector\",\n    function(x) as.vector(x, mode=\"complex\")\n)\nsetMethod(\"as.character\", \"Vector\",\n    function(x) as.vector(x, mode=\"character\")\n)\nsetMethod(\"as.raw\", \"Vector\",\n    function(x) as.vector(x, mode=\"raw\")\n)\n\nsetAs(\"Vector\", \"vector\", function(from) as.vector(from))\nsetAs(\"Vector\", \"logical\", function(from) as.logical(from))\nsetAs(\"Vector\", \"integer\", function(from) as.integer(from))\nsetAs(\"Vector\", \"numeric\", function(from) as.numeric(from))\nsetAs(\"Vector\", \"complex\", function(from) as.complex(from))\nsetAs(\"Vector\", \"character\", function(from) as.character(from))\nsetAs(\"Vector\", \"raw\", function(from) as.raw(from))\n\nsetAs(\"Vector\", \"factor\", function(from) as.factor(from))\n\nsetAs(\"Vector\", \"data.frame\", function(from) as.data.frame(from, optional=TRUE))\n\n### S3/S4 combo for as.data.frame.Vector\nas.data.frame.Vector <- function(x, row.names=NULL, optional=FALSE, ...) {\n    as.data.frame(x, row.names=NULL, optional=optional, ...)\n}\nsetMethod(\"as.data.frame\", \"Vector\",\n          function(x, row.names=NULL, optional=FALSE, ...)\n          {\n              x <- as.vector(x)\n              as.data.frame(x, row.names=row.names, optional=optional, ...)\n          })\n\nas.matrix.Vector <- function(x, ...) {\n    as.matrix(x)\n}\n\nsetMethod(\"as.matrix\", \"Vector\", function(x) {\n              as.matrix(as.vector(x))\n          })\n\nclassNamespace <- function(x) {\n    pkg <- packageSlot(class(x))\n    pvnEnv <- .GlobalEnv\n    if (!is.null(pkg)) {\n        pvnEnv <- getNamespace(pkg)\n    }\n    pvnEnv\n}\n\nmakeFixedColumnEnv <- function(x, parent, tform = identity) {\n  env <- new.env(parent=parent)\n  pvnEnv <- classNamespace(x)\n  lapply(c(\"names\", parallelVectorNames(x)), function(nm) {\n    accessor <- get(nm, pvnEnv, mode=\"function\")\n    makeActiveBinding(nm, function() {\n      val <- tform(accessor(x))\n      rm(list=nm, envir=env)\n      assign(nm, val, env)\n      val\n    }, env)\n  })\n  env\n}\n\nsetGeneric(\"as.env\", function(x, ...) standardGeneric(\"as.env\"))\n\nsetMethod(\"as.env\", \"NULL\", function(x, enclos, tform = identity) {\n  new.env(parent=enclos)\n})\n\naddSelfRef <- function(x, env) {\n  env$.. <- x\n  env\n}\n\nsetMethod(\"as.env\", \"Vector\", function(x, enclos, tform = identity) {\n  parent <- as.env(mcols(x, use.names=FALSE), enclos, tform)\n  addSelfRef(x, makeFixedColumnEnv(x, parent, tform))\n})\n\n### S3/S4 combo for as.list.Vector\nas.list.Vector <- function(x, ...) as.list(as(x, \"List\"), ...)\nsetMethod(\"as.list\", \"Vector\", as.list.Vector)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n### The \"[\" and \"[<-\" methods for Vector objects are just delegating to\n### extractROWS() and replaceROWS() for performing the real work. Most of\n### the times, the author of a Vector subclass only needs to implement\n### an \"extractROWS\" and \"replaceROWS\" method for his/her objects.\n###\n\n### The \"[\" method for Vector objects supports the 'x[i, j]' form to\n### allow the user to conveniently subset the metadata columns thru 'j'.\n### Note that a Vector subclass with a true 2-D semantic (e.g.\n### SummarizedExperiment) needs to overwrite this. This means that code\n### intended to operate on an arbitrary Vector derivative 'x' should not\n### use this feature as there is no guarantee that 'x' supports it. For\n### this reason this feature should preferrably be used interactively only.\nsetMethod(\"[\", \"Vector\",\n    function(x, i, j, ..., drop=TRUE)\n    {\n        ans <- subset_along_ROWS(x, i, , ..., drop=drop)\n        if (!missing(j))\n            mcols(ans) <- mcols(ans, use.names=FALSE)[ , j, drop=FALSE]\n        ans\n    }\n)\n\n### We provide a default extractROWS() method for Vector objects. It calls\n### the extractROWS() generic internally to subset all the \"parallel slots\".\n### It behaves like an endomorphism with respect to 'x'.\n### NOTE TO THE DEVELOPERS OF Vector SUBCLASSES: The default extractROWS()\n### method below will work out-of-the-box and do the right thing on your\n### objects as long as calling parallel_slot_names() on them reports all\n### the \"parallel slots\". So please make sure to register all the parallel\n### slots via a parallel_slot_names() method.\n### If that simple approach does not work for your objects (typically\n### because some slots require special treatment) then you should override\n### the extractROWS() method for Vector objects (you should never need to\n### override the \"[\" method for Vector objects). In addition to taking care\n### of the slots that require special treatment, your specialized extractROWS()\n### method will typically delegate to the default extractROWS() method below\n### via the use of callNextMethod(). See extractROWS() method for Hits objects\n### for an example.\nsetMethod(\"extractROWS\", \"Vector\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        x_pslotnames <- parallel_slot_names(x)\n        ans_pslots <- lapply(setNames(x_pslotnames, x_pslotnames),\n                             function(slotname)\n                                 extractROWS(slot(x, slotname), i))\n        ## Does NOT validate the object before returning it, because, most of\n        ## the times, this is not needed. There are exceptions though. See\n        ## for example the \"extractROWS\" method for Hits objects.\n        do.call(BiocGenerics:::replaceSlots,\n                c(list(x), ans_pslots, list(check=FALSE)))\n    }\n)\n\nsetReplaceMethod(\"[\", \"Vector\",\n    function(x, i, j, ..., value)\n    {\n        if (!missing(j) || length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        nsbs <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE,\n                                                allow.append=TRUE)\n        li <- length(nsbs)\n        if (li == 0L) {\n            ## Surprisingly, in that case, `[<-` on standard vectors does not\n            ## even look at 'value'. So neither do we...\n            return(x)\n        }\n        value <- normalizeSingleBracketReplacementValue(value, x)\n        if (is.null(value)) {\n            return(extractROWS(x, complementNSBS(nsbs)))\n        }\n        value <- recycleSingleBracketReplacementValue(value, x, nsbs)\n        mergeROWS(x, i, value)\n    }\n)\n\nsetMethod(\"mergeROWS\", c(\"Vector\", \"ANY\"),\n    function(x, i, value)\n    {\n        nsbs <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE,\n                                                allow.append=TRUE)\n        if (max(nsbs) <= NROW(x)) {\n            nsbs@upper_bound_is_strict <- TRUE\n            return(replaceROWS(x, nsbs, value))\n        }\n        idx <- as.integer(nsbs)\n        oob <- idx > NROW(x)\n        value_idx <- integer(max(nsbs) - NROW(x))\n        ## handles replacement in the appended region\n        value_idx[idx[oob] - NROW(x)] <- seq_along(value)[oob]\n        if (any(value_idx == 0L)) {\n            stop(\"appending gaps is not supported\")\n        }\n        new_values <- extractROWS(value, value_idx)\n        names(new_values) <- if (is.character(i)) i[oob] else NULL\n        x <- bindROWS(x, list(new_values), check=FALSE)\n        replaceROWS(x, idx[!oob], extractROWS(value, !oob))\n    }\n)\n\n### Work on any Vector object on which bindROWS() and extractROWS() work.\n### Assume that 'value' is compatible with 'x'.\nsetMethod(\"replaceROWS\", c(\"Vector\", \"ANY\"),\n    function(x, i, value)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        stopifnot(length(i) == NROW(value))\n\n        ## --<1>-- Concatenate 'x' and 'value' with bindROWS() -----\n\n        ## We assume that bindROWS() works on objects of class 'class(x)'\n        ## and does the right thing i.e. that it returns an object of the\n        ## same class as 'x' and of NROW 'NROW(x) + NROW(value)'. We skip\n        ## validation.\n        ans <- bindROWS(x, list(value), check=FALSE)\n\n        ## --<2>-- Subset 'ans' with extractROWS() -----\n\n        idx <- replaceROWS(seq_along(x), i, seq_along(value) + NROW(x))\n        ## Because of how we constructed it, 'idx' is guaranteed to be a valid\n        ## subscript to use in 'extractROWS(ans, idx)'. By wrapping it inside a\n        ## NativeNSBS object, extractROWS() won't waste time checking it or\n        ## trying to normalize it.\n        idx <- NativeNSBS(idx, NROW(ans))\n        ## We assume that extractROWS() works on an object of class 'class(x)'.\n        ## For some objects (e.g. Hits), extractROWS() will take care of\n        ## validating the returned object.\n        ans <- extractROWS(ans, idx)\n\n        ## --<3>-- Restore the original names -----\n\n        names(ans) <- names(x)\n        ## Note that we want the elements coming from 'value' to bring their\n        ## metadata columns into 'x' so we do NOT restore the original metadata\n        ## columns. See this thread on bioc-devel:\n        ##  https://stat.ethz.ch/pipermail/bioc-devel/2015-November/008319.html\n        #mcols(ans) <- mcols(x, use.names=FALSE)\n\n        ans\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Convenience wrappers for common subsetting operations\n###\n\n### S3/S4 combo for subset.Vector\nsubset.Vector <- function(x, ...) subset(x, ...)\nsubset_Vector <- function(x, subset, select, drop=FALSE, ...)\n{\n    i <- evalqForSubset(subset, x, ...)\n    x_mcols <- mcols(x, use.names=FALSE)\n    if (!is.null(x_mcols)) {\n        j <- evalqForSelect(select, x_mcols, ...)\n        mcols(x) <- x_mcols[ , j, drop=FALSE]\n    }\n    x[i, drop=drop]\n}\nsetMethod(\"subset\", \"Vector\", subset_Vector)\n\n### S3/S4 combo for window.Vector\nwindow.Vector <- function(x, ...) window(x, ...)\nVector_window <- function(x, start=NA, end=NA, width=NA)\n{\n    i <- RangeNSBS(x, start=start, end=end, width=width)\n    extractROWS(x, i)\n}\nsetMethod(\"window\", \"Vector\", Vector_window)\n\n### S3/S4 combo for head.Vector\nhead.Vector <- function(x, ...) head(x, ...)\nsetMethod(\"head\", \"Vector\", head_along_ROWS)\n\n## S3/S4 combo for tail.Vector\ntail.Vector <- function(x, ...) tail(x, ...)\nsetMethod(\"tail\", \"Vector\", tail_along_ROWS)\n\nsetMethod(\"rep.int\", \"Vector\", rep.int_along_ROWS)\n\n## NOT exported.\nrevROWS <- function(x) extractROWS(x, rev(seq_len(NROW(x))))\n\n### S3/S4 combo for rev.Vector\nrev.Vector <- revROWS\nsetMethod(\"rev\", \"Vector\", revROWS)\n\n## NOT exported.\nrepROWS <- function(x, ...) extractROWS(x, rep(seq_len(NROW(x)), ...))\n\nsetMethod(\"rep\", \"Vector\", repROWS)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Displaying\n###\n\n.Vector_summary <- function(object)\n{\n    object_len <- length(object)\n    object_mcols <- mcols(object, use.names=FALSE)\n    object_nmc <- if (is.null(object_mcols)) 0L else ncol(object_mcols)\n    paste0(classNameForDisplay(object), \" object of length \", object_len,\n           \" with \", object_nmc, \" metadata \",\n           ifelse(object_nmc == 1L, \"column\", \"columns\"))\n}\n### S3/S4 combo for summary.Vector\nsummary.Vector <- function(object, ...)\n    .Vector_summary(object, ...)\nsetMethod(\"summary\", \"Vector\", summary.Vector)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation along the ROWS\n###\n### Note that supporting \"extractROWS\" and \"c\" makes \"replaceROWS\" (and thus\n### \"[<-\") work out-of-the-box!\n###\n\nensureMcols <- function(x) {\n  ans <- mcols(x, use.names=FALSE)\n  if (is.null(ans))\n    ans <- make_zero_col_DFrame(length(x))\n  ans\n}\n\ncombine_mcols <- function(objects)\n{\n    if (length(objects) == 1L)\n        return(mcols(objects[[1L]], use.names=FALSE))\n    all_mcols <- lapply(objects, mcols, use.names=FALSE)\n    is_null <- sapply_isNULL(all_mcols)\n    if (all(is_null))\n        return(NULL)\n    all_mcols[is_null] <- lapply(\n        objects[is_null],\n        function(object) make_zero_col_DFrame(length(object))\n    )\n    do.call(combineRows, all_mcols)\n}\n\n### We provide a default bindROWS() method for Vector objects. It calls the\n### bindROWS() generic internally to concatenate all the \"parallel slots\"\n### from all the input objects. It behaves like an endomorphism with respect\n### to its first input object 'x'.\n### NOTE TO THE DEVELOPERS OF Vector SUBCLASSES: The default bindROWS()\n### method below will work out-of-the-box and do the right thing on your\n### objects as long as calling parallel_slot_names() on them reports all\n### the \"parallel slots\". So please make sure to register all the parallel\n### slots via a parallel_slot_names() method.\n### If that simple approach does not work for your objects (typically\n### because some slots require special treatment) then you should override\n### the bindROWS() method for Vector objects (you should never need to\n### override the c() method for Vector objects). In addition to taking care\n### of the slots that require special treatment, your specialized bindROWS()\n### method will typically delegate to the default bindROWS() method below\n### via the use of callNextMethod(). See bindROWS() methods for Hits and Rle\n### objects for some examples.\nbindROWS_Vector_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(ignore.mcols))\n        stop(\"'ignore.mcols' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(check))\n        stop(\"'check' must be TRUE or FALSE\")\n\n    objects <- prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ## Concatenate all the parallel slots except \"NAMES\" and \"elementMetadata\".\n    x_pslotnames <- parallel_slot_names(x)\n    pslotnames <- setdiff(x_pslotnames, c(\"NAMES\", \"elementMetadata\"))\n    ans_pslots <- lapply(setNames(pslotnames, pslotnames),\n        function(slotname) {\n            x_slot <- slot(x, slotname)\n            if (is.null(x_slot))\n                return(NULL)\n            slot_list <- lapply(objects, slot, slotname)\n            bindROWS2(x_slot, slot_list)\n        }\n    )\n\n    if (\"NAMES\" %in% x_pslotnames) {\n        ans_NAMES <- NULL\n        if (use.names) {\n            names_list <- lapply(all_objects, slot, \"NAMES\")\n            object_has_no_names <- sapply_isNULL(names_list)\n            if (!all(object_has_no_names)) {\n                ## Concatenate the \"NAMES\" slots.\n                names_list[object_has_no_names] <-\n                    lapply(all_objects[object_has_no_names],\n                           function(object) character(length(object)))\n                ans_NAMES <- unlist(names_list, use.names=FALSE)\n            }\n        }\n        ans_pslots <- c(ans_pslots, list(NAMES=ans_NAMES))\n    }\n\n    if (!ignore.mcols) {\n        ## Concatenate the \"elementMetadata\" slots.\n        ans_mcols <- combine_mcols(all_objects)\n        ans_pslots <- c(ans_pslots, list(elementMetadata=ans_mcols))\n    }\n\n    ans <- do.call(BiocGenerics:::replaceSlots,\n                   c(list(x), ans_pslots, list(check=FALSE)))\n\n    if (ignore.mcols)\n        mcols(ans) <- NULL\n\n    if (check)\n        validObject(ans)\n    ans\n}\n\nsetMethod(\"bindROWS\", \"Vector\", bindROWS_Vector_objects)\n\n### Thin wrapper around bindROWS(). Behave like an endomorphism i.e. return\n### an object of the same class as 'x'. In particular 'c(x)' should return 'x'.\n### No Vector subclass should need to override this method. See the\n### \"bindROWS\" method for Vector objects above for more information.\nsetMethod(\"c\", \"Vector\",\n    function(x, ..., ignore.mcols=FALSE, recursive=FALSE)\n    {\n        if (!identical(recursive, FALSE))\n            stop(wmsg(\"\\\"c\\\" method for Vector objects \",\n                      \"does not support the 'recursive' argument\"))\n        bindROWS(x, list(...), ignore.mcols=ignore.mcols)\n    }\n)\n\n### FIXME: This method doesn't work properly on DataFrame derivatives\n### if 'after' is >= 1 and < length(x).\nsetMethod(\"append\", c(\"Vector\", \"Vector\"),\n    function(x, values, after=length(x))\n    {\n        if (!isSingleNumber(after))\n            stop(\"'after' must be a single number\")\n        x_len <- length(x)\n        if (after == 0L)\n            c(values, x)\n        else if (after >= x_len)\n            c(x, values)\n        else\n            c(head(x, n=after), values, tail(x, n=-after))\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Evaluating\n###\n\nsetMethod(\"eval\", c(\"expression\", \"Vector\"),\n          function(expr, envir, enclos = parent.frame())\n          eval(expr, as.env(envir, enclos))\n          )\n\nsetMethod(\"eval\", c(\"language\", \"Vector\"),\n          function(expr, envir, enclos = parent.frame())\n          eval(expr, as.env(envir, enclos))\n          )\n\nsetMethod(\"with\", \"Vector\",\n          function(data, expr, ...)\n          {\n            safeEval(substitute(expr), data, parent.frame(), ...)\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### transform()\n###\n\n### NOT exported.\nsetGeneric(\"column<-\",\n           function(x, name, value) standardGeneric(\"column<-\"),\n           signature=\"x\")\n\nsetReplaceMethod(\"column\", \"Vector\", function(x, name, value) {\n    if (name %in% parallelVectorNames(x)) {\n        setter <- get(paste0(name, \"<-\"), classNamespace(x), mode=\"function\")\n        setter(x, value=value)\n    } else {\n        mcols(x)[[name]] <- value\n        x\n    }\n})\n\ntransformColumns <- function(`_data`, ...) {\n    exprs <- as.list(substitute(list(...))[-1L])\n    if (any(names(exprs) == \"\")) {\n        stop(\"all arguments in '...' must be named\")\n    }\n    ## elements in '...' can originate from different environments\n    env <- setNames(top_prenv_dots(...), names(exprs))\n    for (colName in names(exprs)) { # for loop allows inter-arg dependencies\n        value <- safeEval(exprs[[colName]], `_data`, env[[colName]])\n        column(`_data`, colName) <- value\n    }\n    `_data`\n}\n\n### S3/S4 combo for transform.Vector\ntransform.Vector <- transformColumns\nsetMethod(\"transform\", \"Vector\", transform.Vector)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Utilities\n###\n\nsetGeneric(\"expand.grid\", signature=\"...\")\n\nsetMethod(\"expand.grid\", \"Vector\",\n          function(..., KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE) {\n              args <- list(...)\n              inds <- lapply(args, seq_along)\n              grid <- do.call(expand.grid,\n                              c(inds,\n                                KEEP.OUT.ATTRS=KEEP.OUT.ATTRS,\n                                stringsAsFactors=stringsAsFactors))\n              names(args) <- names(grid)\n              ans <- DataFrame(mapply(`[`, args, grid, SIMPLIFY=FALSE),\n                               check.names=FALSE)\n              metadata(ans)$out.attrs <- attr(grid, \"out.attrs\")\n              ans\n          })\n\n### FIXME: tapply method still in IRanges\nsetMethod(\"by\", \"Vector\",\n          function(data, INDICES, FUN, ..., simplify = TRUE)\n          {\n              if (!is.list(INDICES)) {\n                  INDICES <- setNames(list(INDICES),\n                                      deparse(substitute(INDICES))[1L])\n              }\n              FUNx <- function(i) FUN(extractROWS(data, i), ...)\n              structure(tapply(seq_len(NROW(data)), INDICES, FUNx,\n                               simplify = simplify),\n                        call = match.call(), class = \"by\")\n          })\n\ndiff.Vector <- function(x, ...) diff(x, ...)\n\n",
        "Vector-comparison.R": "### =========================================================================\n### Comparing, ordering, and tabulating vector-like objects\n### -------------------------------------------------------------------------\n###\n\n\n### Functions/operators for comparing, ordering, tabulating:\n###\n###     pcompare\n###     ==\n###     !=\n###     <=\n###     >=\n###     <\n###     >\n###     sameAsPreviousROW\n###     match\n###     selfmatch\n###     duplicated\n###     anyDuplicated\n###     unique\n###     %in%\n###     findMatches\n###     countMatches\n###     order\n###     sort\n###     rank\n###     xtfrm\n###     table\n\n\n### Method signatures for binary comparison operators.\n.OP2_SIGNATURES <- list(\n    c(\"Vector\", \"Vector\"),\n    c(\"Vector\", \"ANY\"),\n    c(\"ANY\", \"Vector\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Element-wise (aka \"parallel\") comparison of 2 Vector objects.\n###\n\nsetGeneric(\"pcompare\", function(x, y) standardGeneric(\"pcompare\"))\n\nsetMethod(\"pcompare\", c(\"numeric\", \"numeric\"), function(x, y) {\n    as.integer(sign(x - y))\n})\n\nsetMethod(\"pcompare\", c(\"ANY\", \"ANY\"), function(x, y) {\n    combined <- bindROWS(x, list(y))\n    original <- c(seq_len(NROW(x)), seq_len(NROW(y)))\n    is.x <- rep(c(TRUE, FALSE), c(NROW(x), NROW(y)))\n\n    o <- order(combined)\n    original <- original[o]\n    is.x <- is.x[o]\n\n    grouping <- cumsum(!sameAsPreviousROW(extractROWS(combined, o)))\n    x.groups <- integer(NROW(x))\n    x.groups[original[is.x]] <- grouping[is.x]\n    y.groups <- integer(NROW(y))\n    y.groups[original[!is.x]] <- grouping[!is.x]\n\n    pcompare(x.groups, y.groups)\n})\n\n### The methods below are implemented on top of pcompare().\n\nsetMethods(\"==\", .OP2_SIGNATURES,\n    function(e1, e2) { pcompare(e1, e2) == 0L }\n)\n\nsetMethods(\"<=\", .OP2_SIGNATURES,\n    function(e1, e2) { pcompare(e1, e2) <= 0L }\n)\n\n### The methods below are implemented on top of == and <=.\n\nsetMethods(\"!=\", .OP2_SIGNATURES, function(e1, e2) { !(e1 == e2) })\n\nsetMethods(\">=\", .OP2_SIGNATURES, function(e1, e2) { e2 <= e1 })\n\nsetMethods(\"<\", .OP2_SIGNATURES, function(e1, e2) { !(e2 <= e1) })\n\nsetMethods(\">\", .OP2_SIGNATURES, function(e1, e2) { !(e1 <= e2) })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Comparisons along the ROWS\n###\n### Provides a basic implementation of what is different between ROWS.\n###\n### The default \"sameAsPreviousROW\" method below is implemented on top\n### of ==.\n###\n\nsetGeneric(\"sameAsPreviousROW\",\n    function(x) standardGeneric(\"sameAsPreviousROW\")\n)\n\nsetMethod(\"sameAsPreviousROW\", \"ANY\", function(x) {\n    if (NROW(x)==0) {\n        logical(0)\n    } else {\n        c(FALSE, tail(x, n=-1L) == head(x, n=-1L))\n    }\n})\n\n.nasafe_compare <- function(z, y) {\n    comp <- z==y\n    na.z <- is.na(z)\n    na.y <- is.na(y)\n    comp[na.z!=na.y] <- FALSE\n    comp[na.z & na.y] <- TRUE\n    comp\n}\n\n.atomic_sameAsPreviousROW <- function(x) {\n    if (NROW(x)==0) {\n        logical(0)\n    } else {\n        z <- head(x, n=-1L) \n        y <- tail(x, n=-1L)\n        c(FALSE, .nasafe_compare(z, y))\n    }\n}\n\nsetMethod(\"sameAsPreviousROW\", \"atomic\", .atomic_sameAsPreviousROW)\n\n# Explicitly define this to avoid dispatching to the numeric method\n# and suffering the unnecessary is.nan() checks.\nsetMethod(\"sameAsPreviousROW\", \"integer\", .atomic_sameAsPreviousROW)\n\n.numeric_sameAsPreviousROW <- function(x) {\n    if (NROW(x)==0) {\n        logical(0)\n    } else {\n        z <- head(x, n=-1L) \n        y <- tail(x, n=-1L)\n        comp <- .nasafe_compare(z, y)\n\n        # No need to test for '&' to set to TRUE here, \n        # as NaN equality is covered by NA equality.\n        nan.z <- is.nan(z)\n        nan.y <- is.nan(y)\n        comp[nan.z!=nan.y] <- FALSE\n\n        c(FALSE, comp)\n    }\n}\n\nsetMethod(\"sameAsPreviousROW\", \"numeric\", .numeric_sameAsPreviousROW)\n\nsetMethod(\"sameAsPreviousROW\", \"complex\", .numeric_sameAsPreviousROW)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n### The default \"match\" method below is implemented on top of\n### selfmatch().\n###\n\nsetMethod(\"match\", c(\"Vector\", \"Vector\"),\n    function(x, table, nomatch = NA_integer_, incomparables = NULL, ...) \n{\n    # table goes first so it gets picked up by 'selfmatch'.\n    combined <- bindROWS(table, list(x))\n\n    # Do NOT use nomatch=nomatch here, we need the NAs as a marker.\n    ans <- selfmatch(combined, nomatch=NA_integer_, incomparables=incomparables)\n    ans <- tail(ans, NROW(x))\n    ans[is.na(ans) | ans > NROW(table)] <- nomatch\n    ans\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selfmatch()\n###\n### The default \"selfmatch\" method below is implemented on top of match().\n###\n\nsetGeneric(\"selfmatch\", function(x, ...) standardGeneric(\"selfmatch\"))\n\n### Default \"selfmatch\" method. Args in ... are propagated to match().\nsetMethod(\"selfmatch\", \"ANY\", function(x, ...) match(x, x, ...))\n\n### Optimized \"selfmatch\" method for factors.\nsetMethod(\"selfmatch\", \"factor\", function(x, ..., incomparables = NULL) {\n    ignore.na <- isTRUE(is.na(incomparables))\n    has.incomparables <- !is.null(incomparables) && !ignore.na\n    if (!missing(...) || has.incomparables || (!ignore.na && anyNA(x)) ||\n          is.unsorted(x))\n        callNextMethod()\n    else as.integer(x)\n})\n\n### Vector-based \"selfmatch\" method, slightly more efficient than match(x, x).\nsetMethod(\"selfmatch\", \"Vector\", function(x, nomatch = NA_integer_, incomparables = NULL, ...) {\n    if (NROW(x)==0L) return(integer(0))\n\n    g <- grouping(x)\n    ends <- attr(g, \"ends\")\n    starts <- c(1L, head(ends, -1L) + 1L)\n    first.of.kind <- g[starts]\n\n    if (!is.null(incomparables)) {\n        # %in% should call match() with incomparables=NULL,\n        # otherwise we get an infinite loop of S4 dispatch!\n        first.x <- extractROWS(x, first.of.kind)\n        first.of.kind[first.x %in% incomparables] <- nomatch\n    }\n\n    ans <- integer(NROW(x))\n    ans[g] <- rep(first.of.kind, ends - starts + 1L)\n    ans\n})\n\n### 'selfmatch_mapping' must be an integer vector like one returned by\n### selfmatch(), that is, values are non-NAs and such that any value 'v' in it\n### must appear for the first time at *position* 'v'.\n### Such a vector can be seen as a many-to-one mapping that maps any position\n### in the vector to a lower position and that has the additional property of\n### being idempotent.\n### More formally, any vector returned by selfmatch() has the 2 following\n### properties:\n###\n###   (1) for any 1 <= i <= length(selfmatch_mapping),\n###           selfmatch_mapping[i] must be >= 1 and <= i\n### and\n###\n###   (2) selfmatch_mapping[selfmatch_mapping] is the same as selfmatch_mapping\n###\n### reverseSelfmatchMapping() creates the \"reverse mapping\" as an ordinary\n### list.\nreverseSelfmatchMapping <- function(selfmatch_mapping)\n{\n    ans <- vector(mode=\"list\", length=length(selfmatch_mapping))\n    sparse_ans <- split(seq_along(selfmatch_mapping), selfmatch_mapping)\n    ans[as.integer(names(sparse_ans))] <- as.list(sparse_ans)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### duplicated() & anyDuplicated() & unique()\n###\n### The \"duplicated\" method below is implemented on top of selfmatch().\n### The \"anyDuplicated\" and \"unique\" methods below are implemented on top\n### of duplicated().\n###\n\n### S3/S4 combo for duplicated.Vector\nduplicated.Vector <- function(x, incomparables=FALSE, ...)\n    duplicated(x, incomparables=incomparables, ...)\n\n.duplicated.Vector <- function(x, incomparables=FALSE, ...)\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"the \\\"duplicated\\\" method for Vector objects \",\n             \"only accepts 'incomparables=FALSE'\")\n    args <- list(...)\n    if (\"fromLast\" %in% names(args)) {\n        fromLast <- args$fromLast\n        if (!isTRUEorFALSE(fromLast))\n            stop(\"'fromLast' must be TRUE or FALSE\")\n        args$fromLast <- NULL\n        if (fromLast)\n            x <- rev(x)\n    } else {\n        fromLast <- FALSE\n    }\n    xx <- do.call(selfmatch, c(list(x), args))\n    ans <- xx != seq_along(xx)\n    if (fromLast)\n        ans <- rev(ans)\n    ans\n}\nsetMethod(\"duplicated\", \"Vector\", .duplicated.Vector)\n\n### S3/S4 combo for anyDuplicated.Vector\nanyDuplicated.Vector <- function(x, incomparables=FALSE, ...)\n    anyDuplicated(x, incomparables=incomparables, ...)\n.anyDuplicated.Vector <- function(x, incomparables=FALSE, ...)\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"the \\\"anyDuplicated\\\" method for Vector objects \",\n             \"only accepts 'incomparables=FALSE'\")\n    any(duplicated(x, incomparables=incomparables, ...))\n}\nsetMethod(\"anyDuplicated\", \"Vector\", .anyDuplicated.Vector)\n\n### S3/S4 combo for unique.Vector\nunique.Vector <- function(x, incomparables=FALSE, ...)\n    unique(x, incomparables=incomparables, ...)\n.unique.Vector <- function(x, incomparables=FALSE, ...)\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"the \\\"unique\\\" method for Vector objects \",\n             \"only accepts 'incomparables=FALSE'\")\n    i <- !duplicated(x, incomparables=incomparables, ...)\n    extractROWS(x, i)\n}\nsetMethod(\"unique\", \"Vector\", .unique.Vector)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### %in%\n###\n### The method below is implemented on top of match().\n###\n\nsetMethods(\"%in%\", .OP2_SIGNATURES,\n    function(x, table) { match(x, table, nomatch=0L) > 0L }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### findMatches() & countMatches()\n###\n### The default \"findMatches\" and \"countMatches\" methods below are\n### implemented on top of match().\n###\n\nsetGeneric(\"findMatches\", signature=c(\"x\", \"table\"),\n    function(x, table, select=c(\"all\", \"first\", \"last\"), ...)\n        standardGeneric(\"findMatches\")\n)\n\n### Equivalent to 'countQueryHits(findMatches(x, table))' but the default\n### \"countMatches\" method below has a more efficient implementation.\nsetGeneric(\"countMatches\", signature=c(\"x\", \"table\"),\n    function(x, table, ...)\n        standardGeneric(\"countMatches\")\n)\n\n### Problem: using transpose=TRUE generates an invalid SortedByQueryHits\n### object (hits are not sorted by query):\n###   > S4Vectors:::.findAllMatchesInSmallTable(1:6, c(7:5, 4:5),\n###                                             transpose=TRUE)\n###   Hits of length 4\n###   queryLength: 5\n###   subjectLength: 6\n###     queryHits subjectHits\n###      <integer>   <integer>\n###    1         4           4\n###    2         3           5\n###    3         5           5\n###    4         2           6\n### and the cost of ordering them would probably defeat the purpose of the\n### \"put the smallest object on the right\" optimization trick.\n.findAllMatchesInSmallTable <- function(x, table, ..., transpose=FALSE)\n{\n    x2 <- match(x, table, ...)\n    table2 <- selfmatch(table, ...)\n    table_low2high <- reverseSelfmatchMapping(table2)\n    hits_per_x <- table_low2high[as.integer(x2)]\n    x_hits <- rep.int(seq_along(hits_per_x), sapply_NROW(hits_per_x))\n    if (length(x_hits) == 0L) {\n        table_hits <- integer(0)\n    } else {\n        table_hits <- unlist(hits_per_x, use.names=FALSE)\n    }\n    if (transpose) {\n        Hits(table_hits, x_hits, length(table), length(x), sort.by.query=TRUE)\n    } else {\n        Hits(x_hits, table_hits, length(x), length(table), sort.by.query=TRUE)\n    }\n}\n\n### Default \"findMatches\" method. Args in ... are propagated to match() and\n### selfmatch().\nsetMethod(\"findMatches\", c(\"ANY\", \"ANY\"),\n    function(x, table, select=c(\"all\", \"first\", \"last\"), ...)\n    {\n        select <- match.arg(select)\n        if (select != \"all\")\n            stop(\"'select' is not supported yet. Note that you can use \",\n                 \"match() if you want to do 'select=\\\"first\\\"'. Otherwise \",\n                 \"you're welcome to request this on the Bioconductor \",\n                 \"mailing list.\")\n        ## \"put the smallest object on the right\" optimization trick\n        #if (length(x) < length(table))\n        #    return(.findAllMatchesInSmallTable(table, x, ..., transpose=TRUE))\n        .findAllMatchesInSmallTable(x, table, ...)\n    }\n)\n\nsetMethod(\"findMatches\", c(\"ANY\", \"missing\"),\n    function(x, table, select=c(\"all\", \"first\", \"last\"), ...)\n    {\n        ans <- callGeneric(x, x, select=select, ...)\n        if (!is(ans, \"Hits\"))  # e.g. if 'select' is \"first\"\n            return(ans)\n        as(ans, \"SortedByQuerySelfHits\")\n    }\n)\n\n### Default \"countMatches\" method. Args in ... are propagated to match() and\n### selfmatch().\n.countMatches.default <- function(x, table, ...)\n{\n    x_len <- length(x)\n    table_len <- length(table)\n    if (x_len <= table_len) {\n        table2 <- match(table, x, ...)  # can contain NAs\n        nbins <- x_len\n        x2 <- selfmatch(x, ...)  # no NAs\n    } else {\n        table2 <- selfmatch(table, ...)  # no NAs\n        nbins <- table_len + 1L\n        x2 <- match(x, table, nomatch=nbins, ...)\n    }\n    tabulate(table2, nbins=nbins)[x2]\n}\n\nsetMethod(\"countMatches\", c(\"ANY\", \"ANY\"), .countMatches.default)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### sort()\n###\n### The method below is implemented on top of order().\n###\n\n### S3/S4 combo for sort.Vector\n.sort_Vector <- function(x, decreasing=FALSE, na.last=NA, by)\n{\n    if (!missing(by)) {\n        i <- orderBy(by, x, decreasing=decreasing, na.last=na.last)\n    } else {\n        i <- order(x, na.last=na.last, decreasing=decreasing)\n    }\n    extractROWS(x, i)\n}\nsort.Vector <- function(x, decreasing=FALSE, ...)\n    .sort_Vector(x, decreasing=decreasing, ...)\nsetMethod(\"sort\", \"Vector\", .sort_Vector)\n\nformulaAsListCall <- function(formula) {\n    attr(terms(formula), \"variables\")\n}\n\nformulaValues <- function(x, formula) {\n    listCall <- formulaAsListCall(formula)\n    vals <- eval(listCall, as.env(x, environment(formula)))\n    names(vals) <- vapply(listCall, function(x) {\n        paste(deparse(x, width.cutoff = 500), collapse = \" \")\n    }, character(1L))[-1L]\n    vals\n}\n\norderBy <- function(formula, x, decreasing=FALSE, na.last=TRUE) {\n  values <- formulaValues(x, formula)\n  do.call(order, c(decreasing=decreasing, na.last=na.last, values))\n}\n\nsetMethod(\"rank\", \"Vector\",\n    function(x, na.last=TRUE,\n             ties.method=c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"),\n             by)\n    {\n        ties.method <- match.arg(ties.method)\n        if (!missing(by))\n            oo <- orderBy(by, x, na.last=na.last)\n        else oo <- order(x, na.last=na.last)\n        ## 'ans' is the reverse permutation of 'oo'.\n        ans <- integer(length(oo))\n        ans[oo] <- seq_along(oo)\n        if (ties.method == \"first\")\n            return(ans)\n        ans <- ans[selfmatch(x)]\n        if (ties.method == \"min\")\n            return(ans)\n        ## Other ties methods.\n        rank(ans, ties.method=ties.method)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### xtfrm()\n###\n### The method below is implemented on top of order().\n###\n\nsetMethod(\"xtfrm\", \"Vector\", function(x) {\n    o <- order(x)\n    y <- extractROWS(x, o)\n    is.unique <- !sameAsPreviousROW(y)\n    out.rank <- cumsum(is.unique)\n    out.rank[o] <- out.rank\n    out.rank\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### table()\n###\n### The method below is implemented on top of selfmatch(), order(), and\n### as.character().\n###\n\n### This is a copy/paste of the list.names() function locally defined inside\n### base::table().\n.list.names <- function(...) {\n    deparse.level <- 1\n    l <- as.list(substitute(list(...)))[-1L]\n    nm <- names(l)\n    fixup <- if (is.null(nm))\n        seq_along(l)\n    else nm == \"\"\n    dep <- vapply(l[fixup], function(x) switch(deparse.level +\n        1, \"\", if (is.symbol(x)) as.character(x) else \"\",\n        deparse(x, nlines = 1)[1L]), \"\")\n    if (is.null(nm))\n        dep\n    else {\n        nm[fixup] <- dep\n        nm\n    }\n}\n\n### Works on any object for which selfmatch(), order(), and as.character()\n### are supported.\n.compute_table <- function(x)\n{\n    xx <- selfmatch(x)\n    t <- tabulate(xx, nbins=length(xx))\n    keep_idx <- which(t != 0L)\n    x2 <- x[keep_idx]\n    t2 <- t[keep_idx]\n    oo <- order(x2)\n    x2 <- x2[oo]\n    t2 <- t2[oo]\n    ans <- array(t2)\n    ## Some \"as.character\" methods propagate the names (e.g. the method for\n    ## GenomicRanges objects). We drop them.\n    dimnames(ans) <- list(unname(as.character(x2)))\n    ans\n}\n\nsetMethod(\"table\", \"Vector\",\n    function(...)\n    {\n        args <- list(...)\n        if (length(args) != 1L)\n            stop(\"\\\"table\\\" method for Vector objects \",\n                 \"can only take one input object\")\n        x <- args[[1L]]\n\n        ## Compute the table as an array.\n        ans <- .compute_table(x)\n\n        ## Some cosmetic adjustments.\n        names(dimnames(ans)) <- .list.names(...)\n        class(ans) <- \"table\"\n        ans\n    }\n)\n\nsetMethod(\"xtabs\", signature(data = \"Vector\"),\n          function(formula = ~., data, subset, na.action, exclude = c(NA, NaN),\n                   drop.unused.levels = FALSE)\n{\n    data <- as.env(data, environment(formula), tform=decode)\n    callGeneric()\n})\n\n",
        "Vector-merge.R": "### =========================================================================\n### Merging vector-like objects\n### -------------------------------------------------------------------------\n###\n\n\n### Compute the n-ary union (if 'all' is TRUE) or n-ary intersection (if 'all'\n### is FALSE) of a list of vector-like objects with no metadata columns.\n### The objects must support c() for the n-ary union (i.e. when 'all' is TRUE),\n### and %in% and [ for the n-ary intersection (i.e. when 'all' is FALSE).\n### They must also support sort() if 'sort' is TRUE, as well as unique().\n.merge_naked_objects <- function(naked_objects,\n                                 all=FALSE, all.x=NA, all.y=NA,\n                                 sort=TRUE)\n{\n    if (!isTRUEorFALSE(all))\n        stop(\"'all' must be TRUE or FALSE\")\n    if (!(is.logical(all.x) && length(all.x) == 1L))\n        stop(\"'all.x' must be a single logical\")\n    if (!(is.logical(all.y) && length(all.y) == 1L))\n        stop(\"'all.y' must be a single logical\")\n    if (!isTRUEorFALSE(sort))\n        stop(\"'sort' must be TRUE or FALSE\")\n\n    if (length(naked_objects) == 1L) {\n        ## Unary union or intersection.\n        ## 'all', 'all.x', and 'all.y' are ignored.\n        ans <- naked_objects[[1L]]\n    } else if (length(naked_objects) == 2L) {\n        ## Binary union or intersection.\n        ## Behavior is controlled by 'all.x' and 'all.y' (after setting each\n        ## of them to 'all' if it's NA).\n        if (is.na(all.x))\n            all.x <- all\n        if (is.na(all.y))\n            all.y <- all\n        x <- naked_objects[[1L]]\n        y <- naked_objects[[2L]]\n        if (all.x && all.y) {\n            ans <- c(x, y)\n        } else if (all.x) {\n            ans <- x\n        } else if (all.y) {\n            ans <- y\n        } else {\n            ans <- x[x %in% y]\n        }\n    } else {\n        ## N-ary union or intersection (N > 2).\n        ## 'all.x' and 'all.y' must be NAs.\n        if (!(is.na(all.x) && is.na(all.y)))\n            stop(wmsg(\"You need to use 'all' instead of the 'all.x' or \",\n                      \"'all.y' argument when merging more than 2 objects.\"))\n        if (all) {\n            ans <- do.call(\"c\", naked_objects)\n        } else {\n            ans <- naked_objects[[1L]]\n            for (i in 2:length(naked_objects))\n                ans <- ans[ans %in% naked_objects[[i]]]\n        }\n    }\n    if (sort)\n        ans <- sort(ans)\n    unique(ans)\n}\n\n### The list can contain NULLs, which are ignored. Non-NULL list elements are\n### assumed to be of same lengths. This is not checked.\n.collapse_list_of_equal_vectors <- function(x, colname)\n{\n    x <- x[!sapply_isNULL(x)]\n    ans <- x[[1L]]\n    if (length(x) >= 2L) {\n        na_idx <- which(is.na(ans))\n        for (i in 2:length(x)) {\n            x_elt <- x[[i]]\n            if (is.null(x_elt))\n                next\n            if (!all(x_elt == ans, na.rm=TRUE))\n                stop(wmsg(\"metadata column \\\"\", colname, \"\\\" contains \",\n                          \"incompatible values across the objects to merge\"))\n            if (length(na_idx) != 0L) {\n                ans[na_idx] <- x_elt[na_idx]\n                na_idx <- which(is.na(ans))\n            }\n        }\n    }\n    ans\n}\n\n.merge_mcols <- function(x, objects)\n{\n    all_mcolnames <- unique(unlist(\n        lapply(objects,\n            function(object) colnames(mcols(object, use.names=FALSE)))\n    ))\n    if (length(all_mcolnames) == 0L)\n        return(NULL)\n\n    revmaps <- lapply(objects, match, x=x)\n\n    merge_mcol <- function(colname) {\n        cols <- mapply(\n            function(object, revmap) {\n                col <- mcols(object, use.names=FALSE)[[colname]]\n                if (is.null(col))\n                    return(NULL)\n                col <- col[revmap]\n            },\n            objects, revmaps,\n            SIMPLIFY=FALSE\n        )\n        .collapse_list_of_equal_vectors(cols, colname)\n    }\n\n    all_mcols <- lapply(setNames(all_mcolnames, all_mcolnames), merge_mcol)\n    DataFrame(all_mcols)\n}\n\n### 'objects' must be a list of vector-like objects. See .merge_naked_objects()\n### above for what operations these objects must support in order for\n### .merge_Vector_objects() to work.\n.merge_Vector_objects <- function(objects,\n                                  all=FALSE, all.x=NA, all.y=NA,\n                                  sort=TRUE)\n{\n    objects <- unname(objects)\n    naked_objects <- lapply(objects,\n        function(object) {\n            mcols(object) <- NULL\n            if (any(duplicated(object)))\n                ## We don't actually apply unique() to the input objects but\n                ## .merge_Vector_objects() behaves like if we did.\n                warning(wmsg(\"Some of the objects to merge contain \",\n                             \"duplicated elements. These elements were \",\n                             \"removed by applying unique() to each object \",\n                             \"before the merging.\"))\n            object\n        }\n    )\n    ans <- .merge_naked_objects(naked_objects,\n                                all=all, all.x=all.x, all.y=all.y,\n                                sort=sort)\n    mcols(ans) <- .merge_mcols(ans, objects)\n    ans\n}\n\n### 3 important differences with base::merge.data.frame():\n###   1) The matching is based on the vector values (vs arbitrary columns for\n###      base::merge.data.frame()).\n###   2) Self merge is a no-op if 'sort=FALSE' (or object already sorted) and\n###      if the object has no duplicates.\n###   3) This an n-ary merge() of vector-like objects (vs binary for\n###      base::merge.data.frame()).\nsetMethod(\"merge\", c(\"Vector\", \"Vector\"),\n    function(x, y, ..., all=FALSE, all.x=NA, all.y=NA, sort=TRUE)\n    {\n        if (missing(x)) {\n            if (missing(y)) {\n                objects <- list(...)\n            } else {\n                objects <- list(y, ...)\n            }\n        } else {\n            if (missing(y)) {\n                objects <- list(x, ...)\n            } else {\n                objects <- list(x, y, ...)\n            }\n        }\n        ## .merge_Vector_objects() won't work if some of the objects to merge\n        ## are list-like objects that pcompare recursively. In that case, we\n        ## fallback on base::merge() but this one is a binary merge only.\n        comp_rec <- vapply(objects,\n            function(object) {\n                is.list(object) ||\n                  is(object, \"List\") && pcompareRecursively(object)\n            },\n            logical(1))\n        if (any(comp_rec)) {\n            if (length(objects) > 2L)\n                stop(wmsg(\"cannot merge more than 2 objects \",\n                          \"when some of them are list-like objects\"))\n            ans <- base::merge(x, y, all=all, sort=sort)\n            return(ans)\n        }\n        .merge_Vector_objects(objects,\n                              all=all, all.x=all.x, all.y=all.y,\n                              sort=sort)\n    }\n)\n\n",
        "Vector-setops.R": "### =========================================================================\n### Set operations\n### -------------------------------------------------------------------------\n###\n### The methods below are endomorphisms with respect to their first argument\n### 'x'. They propagates the names and metadata columns.\n###\n\n### S3/S4 combo for union.Vector\nsetMethod(\"union\", c(\"Vector\", \"Vector\"), function(x, y) unique(c(x, y)))\nunion.Vector <- function(x, y, ...) union(x, y, ...)\n\n### S3/S4 combo for intersect.Vector\nsetMethod(\"intersect\", c(\"Vector\", \"Vector\"),\n          function(x, y) unique(x[x %in% y]))\nintersect.Vector <- function(x, y, ...) intersect(x, y, ...)\n\n### S3/S4 combo for setdiff.Vector\nsetMethod(\"setdiff\", c(\"Vector\", \"Vector\"),\n          function(x, y) unique(x[!(x %in% y)]))\nsetdiff.Vector <- function(x, y, ...) setdiff(x, y, ...)\n\n### S3/S4 combo for setequal.Vector\nsetMethod(\"setequal\", c(\"Vector\", \"Vector\"),\n          function(x, y) all(x %in% y) && all(y %in% x))\nsetequal.Vector <- function(x, y, ...) setequal(x, y, ...)\n",
        "aggregate-methods.R": "### =========================================================================\n### \"aggregate\" methods\n### -------------------------------------------------------------------------\n###\n### This is messy and broken! E.g.\n###\n###   aggregate(DataFrame(state.x77), FUN=mean, start=1:20, width=10)\n###\n### doesn't work as expected. Or:\n###\n###   aggregate(Rle(2:-2, 5:9), FUN=mean, start=1:20, width=17)\n###\n### doesn't give the same result as:\n###\n###   aggregate(rep(2:-2, 5:9), FUN=mean, start=1:20, width=17)\n###\n### See also the FIXME note down below (the one preceding the definition of\n### the method for vector) for more mess.\n###\n### FIXME: Fix the aggregate() mess. Before fixing, it would be good to\n### simplify by getting rid of the 'frequency' and 'delta' arguments.\n### Then the 'start', 'end', and 'width' arguments wouldn't be needed\n### anymore because the user can aggregate by range by passing\n### IRanges(start, end, width) to 'by'. After removing these arguments,\n### the remaining arguments would be as in stats:::aggregate.data.frame.\n### Finally make sure that, when 'by' is not an IntegerRanges, the \"aggregate\"\n### method for vector objects behaves exactly like stats:::aggregate.data.frame\n### (the easiest way would be to delegate to it).\n###\n### A nice extension would be to have 'by' accept an IntegerList object, not\n### just an IntegerRanges (which is a special case of IntegerList), to let the\n### user specify the subsets of 'x'. When 'by' is an IntegerList, aggregate()\n### would be equivalent to:\n###\n###   sapply(seq_along(by),\n###          function(i) FUN(x[by[[i]]], ...), simplify=simplify)\n###\n### This could be how it is implemented, except for the common use case where\n### 'by' is an IntegerRanges (needs special treatment in order to remain as\n### fast as it is at the moment). This could even be extended to 'by' being a\n### List (e.g. CharacterList, RleList, etc...)\n###\n### Other options (non-exclusive) to explore:\n###\n### (a) aggregateByRanges() new generic (should go in IRanges). aggregate()\n###     would simply delegate to it when 'by' is an IntegerRanges object (but\n###     that means that the \"aggregate\" methods should also go in IRanges).\n###\n### (b) lapply/sapply on Views objects (but only works if Views(x, ...)\n###     works and views can only be created on a few specific types of\n###     objects).\n###  \n\n\nsetMethod(\"aggregate\", \"matrix\", stats:::aggregate.default)\nsetMethod(\"aggregate\", \"data.frame\", stats:::aggregate.data.frame)\nsetMethod(\"aggregate\", \"ts\", stats:::aggregate.ts)\n\n### S3/S4 combo for aggregate.Vector\naggregate.Vector <- function(x, by, FUN, start=NULL, end=NULL, width=NULL,\n                             frequency=NULL, delta=NULL, ..., simplify=TRUE)\n{\n    aggregate(x, by, FUN, start, end, width, frequency, delta, ...,\n              simplify=simplify)\n}\n\n.aggregate.Vector <- function(x, by, FUN, start=NULL, end=NULL, width=NULL,\n                              frequency=NULL, delta=NULL, ..., simplify=TRUE)\n{\n    if (missing(FUN)) {\n        return(aggregateWithDots(x, by, ...))\n    } else if (!missing(by)) {\n        if (is.list(by)) {\n            ans <- aggregate(as.data.frame(x), by=by, FUN=FUN, ...,\n                             simplify=simplify)\n            return(DataFrame(ans))\n        } else if (is(by, \"formula\")) {\n            ans <- aggregate(by, as.env(x, environment(by), tform=decode),\n                             FUN=FUN, ...)\n            return(DataFrame(ans))\n        }\n        start <- structure(start(by), names=names(by))\n        end <- end(by)\n    } else {\n        if (!is.null(width)) {\n            if (is.null(start))\n                start <- end - width + 1L\n            else if (is.null(end))\n                end <- start + width - 1L\n        }\n        ## Unlike as.integer(), as( , \"integer\") propagates the names.\n        start <- as(start, \"integer\")\n        end <- as(end, \"integer\")\n    }\n    FUN <- match.fun(FUN)\n    if (length(start) != length(end))\n        stop(\"'start', 'end', and 'width' arguments have unequal length\")\n    n <- length(start)\n    if (!is.null(names(start)))\n        indices <- structure(seq_len(n), names = names(start))\n    else\n        indices <- structure(seq_len(n), names = names(end))\n    if (is.null(frequency) && is.null(delta)) {\n        sapply(indices, function(i)\n               FUN(Vector_window(x, start = start[i], end = end[i]), ...),\n               simplify = simplify)\n    } else {\n        frequency <- rep(frequency, length.out = n)\n        delta <- rep(delta, length.out = n)\n        sapply(indices, function(i)\n               FUN(window(x, start = start[i], end = end[i],\n                   frequency = frequency[i], delta = delta[i]),\n                   ...),\n               simplify = simplify)\n    }\n}\nsetMethod(\"aggregate\", \"Vector\", .aggregate.Vector)\n\n.aggregate.Rle <- function(x, by, FUN, start=NULL, end=NULL, width=NULL,\n                          frequency=NULL, delta=NULL, ..., simplify=TRUE)\n{\n    FUN <- match.fun(FUN)\n    if (!missing(by)) {\n        start <- structure(start(by), names=names(by))\n        end <- end(by)\n    } else {\n        if (!is.null(width)) {\n            if (is.null(start))\n                start <- end - width + 1L\n            else if (is.null(end))\n                end <- start + width - 1L\n        }\n        start <- as(start, \"integer\")\n        end <- as(end, \"integer\")\n    }\n    if (length(start) != length(end))\n        stop(\"'start', 'end', and 'width' arguments have unequal length\")\n    n <- length(start)\n    if (!is.null(names(start)))\n        indices <- structure(seq_len(n), names = names(start))\n    else\n        indices <- structure(seq_len(n), names = names(end))\n    if (is.null(frequency) && is.null(delta)) {\n        width <- end - start + 1L\n        rle_list <- extract_ranges_from_Rle(x, start, width, as.list=TRUE)\n        names(rle_list) <- names(indices)\n        sapply(rle_list, FUN, ..., simplify = simplify)\n    } else {\n        frequency <- rep(frequency, length.out = n)\n        delta <- rep(delta, length.out = n)\n        sapply(indices,\n               function(i)\n               FUN(window(x, start = start[i], end = end[i],\n                          frequency = frequency[i], delta = delta[i]),\n                   ...),\n               simplify = simplify)\n    }\n}\nsetMethod(\"aggregate\", \"Rle\", .aggregate.Rle)\n\n.aggregate.List <- function(x, by, FUN, start=NULL, end=NULL, width=NULL,\n                           frequency=NULL, delta=NULL, ..., simplify=TRUE)\n{\n    if (missing(by)\n     || !requireNamespace(\"IRanges\", quietly=TRUE)\n     || !is(by, \"IntegerRangesList\")) {\n        ans <- callNextMethod()\n        return(ans)\n    }\n    if (length(x) != length(by))\n        stop(\"for IntegerRanges 'by', 'length(x) != length(by)'\")\n    y <- as.list(x)\n    result <- lapply(structure(seq_len(length(x)), names = names(x)),\n                     function(i)\n                         aggregate(y[[i]], by = by[[i]], FUN = FUN,\n                                   frequency = frequency, delta = delta,\n                                   ..., simplify = simplify))\n    as(result, \"List\")\n}\nsetMethod(\"aggregate\", \"List\", .aggregate.List)\n\nModelFrame <- function(formula, x) {\n    if (length(formula) != 2L) \n        stop(\"'formula' must not have a left side\")\n    DataFrame(formulaValues(x, formula))\n}\n\naggregateWithDots <- function(x, by, FUN, ..., drop = TRUE) {\n    stopifnot(isTRUEorFALSE(drop))\n\n    endomorphism <- FALSE\n    if (missing(by)) {\n        if (is(x, \"List\") && !is(x, \"DataFrame\") && !is(x, \"Ranges\")) {\n            by <- IRanges::PartitioningByEnd(x)\n            x <- unlist(x, use.names=FALSE)\n        } else {\n            endomorphism <- TRUE\n            by <- x\n        }\n    }\n\n    if (is(by, \"IntegerList\") && !is(by, \"Ranges\")) {\n        by <- IRanges::ManyToManyGrouping(by, nobj=NROW(x))\n    }\n    \n    if (is(by, \"formula\")) {\n        by <- ModelFrame(by, x)\n    } else if (is.list(by) || is(by, \"DataFrame\")) {\n        by <- IRanges::FactorList(by, compress=FALSE)\n    }\n    \n    by <- as(by, \"Grouping\", strict=FALSE)\n    if (IRanges::nobj(by) != NROW(x)) {\n        stop(\"'by' does not have the same number of objects as 'x'\")\n    }\n\n    if (drop) {\n        by <- by[lengths(by) > 0L]\n    }\n    \n    by <- unname(by)\n    \n    prenvs <- top_prenv_dots(...)\n    exprs <- substitute(list(...))[-1L]\n    envs <- lapply(prenvs, function(p) {\n        as.env(x, p, tform = function(col) IRanges::extractList(col, by))\n    })\n    stats <- DataFrame(mapply(safeEval, exprs, envs, SIMPLIFY=FALSE))\n\n    if (endomorphism && !is(x, \"DataFrame\")) {\n        ans <- x[end(IRanges::PartitioningByEnd(by))]\n        mcols(by) <- NULL\n        mcols(ans) <- DataFrame(grouping = by, stats)\n    } else {\n        ans <- DataFrame(by, stats)\n        colnames(ans)[1L] <- \"grouping\"\n    }\n    ans\n}\n",
        "bindROWS.R": "### =========================================================================\n### Combine objects by ROWS or COLS\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### bindROWS()\n###\n### A low-level generic function for binding objects along their 1st dimension.\n### It is intended to be the workhorse behind:\n### - the rbind() methods for rectangular objects (e.g. RectangularData\n###   derivatives);\n### - the c() methods for vector-like objects that are not data-frame-like\n###   objects (e.g. Vector derivatives that are not DataFrame derivatives);\n### - the unlist() methods for list-like objects (e.g. List derivatives).\n###\n\nsetGeneric(\"bindROWS\", signature=\"x\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n        standardGeneric(\"bindROWS\")\n)\n\n### NOT exported.\n### Low-level utility used by various bindROWS() and bindCOLS() methods.\n### Prepare 'objects' by deleting NULLs from it, dropping its names, and\n### making sure that each of its list element belongs to the same class\n### as 'x' (or to one of its subclasses) by coercing it if necessary.\nprepare_objects_to_bind <- function(x, objects=list())\n{\n    if (!is.list(objects))\n        stop(\"'objects' must be a list\")\n    lapply(unname(delete_NULLs(objects)), coerce2, x)\n}\n\nsetMethod(\"bindROWS\", \"NULL\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        if (!is.list(objects))\n            stop(\"'objects' must be a list\")\n        objects <- delete_NULLs(objects)\n        if (length(objects) == 0L)\n            return(NULL)\n        x <- objects[[1L]]\n        objects <- objects[-1L]\n        callGeneric()\n    }\n)\n\n### Works on atomic vectors, factors, lists, 1D arrays, matrices, and\n### data frames. Arguments 'ignore.mcols' and 'check' are ignored.\n.default_bindROWS <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    if (!is.list(objects))\n        stop(\"'objects' must be a list\")\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n\n    ## We do not call prepare_objects_to_bind() because we do not want\n    ## to force all the objects in 'objects' to be of the type of 'x'. This\n    ## way we are consistent with what c() and unlist() do when combining\n    ## atomic vectors of mixed types.\n    objects <- lapply(unname(objects),\n        function(object)\n            if (is(object, \"Rle\")) decodeRle(object) else object)\n    all_objects <- c(list(x), objects)\n\n    x_ndim <- length(dim(x))\n    if (x_ndim == 0L) {\n        ## Use unlist() if 'x' is an atomic vector, a factor, or a list.\n        ## Otherwise use c().\n        if (is.vector(x) || is.factor(x)) {\n            ans <- unlist(all_objects, recursive=FALSE)\n        } else {\n            ans <- do.call(c, all_objects)\n        }\n        if (!use.names)\n            names(ans) <- NULL\n    } else if (x_ndim == 1L) {\n        ## 'x' is a 1D array.\n        ## base::rbind() is broken on 1D arrays so we need to handle this\n        ## specially.\n        ## Note that all objects in 'objects' are also treated as if they\n        ## were 1D arrays (even if they have >= 2 dimensions). This is\n        ## probably too laxist!\n        ans <- unlist(all_objects, recursive=FALSE)\n        if (use.names)\n            ans_rownames <- names(ans)\n        dim(ans) <- length(ans)  # this drops the names\n        if (use.names)\n            rownames(ans) <- ans_rownames\n    } else if (x_ndim == 2L) {\n        ## 'x' is a matrix or data frame.\n        ans <- do.call(rbind, all_objects)\n        if (!use.names)\n            rownames(ans) <- NULL\n    } else {\n        ## 'x' is an array with more than 2 dimensions.\n        ## Binding multi-dimensional arrays along the rows is exactly what\n        ## the DelayedArray::arbind() generic does so we should probably move\n        ## this generic to S4Vectors (or to BiocGenerics?).\n        stop(wmsg(\"bindROWS() does not support arrays \",\n                  \"with more than 2 dimensions yet\"))\n    }\n    ans\n}\n\n### Even though is(x, \"vector\") and is.vector(x) are FALSE when 'x'\n### is a data frame, calling bindROWS() on 'x' will actually dispatch\n### on the bindROWS,vector method (this can be checked with\n### selectMethod(\"bindROWS\", \"data.frame\")) so we don't need to\n### define a bindROWS,data.frame method.\n#setMethod(\"bindROWS\", \"vector\", .default_bindROWS)\n\n### Even though calling bindROWS() on an array would dispatch on the\n### bindROWS,vector method (is(x, \"vector\") is TRUE) we still need to\n### define the bindROWS,array method. Otherwise, the dispatch mechanism\n### seems to remove the dim attribute from 'x' **before** passing it to\n### the bindROWS,vector method.\n### See https://stat.ethz.ch/pipermail/r-devel/2018-May/076205.html for\n### the bug report.\n#setMethod(\"bindROWS\", \"array\", .default_bindROWS)\n\n### In the end, all the above trouble can be avoided by simply defining\n### this method.\nsetMethod(\"bindROWS\", \"ANY\", .default_bindROWS)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### bindROWS2()\n###\n### A thin wrapper around bindROWS().\n###\n### NOT exported.\n###\n### If all the objects passed to bindROWS() have the same type, the result of\n### the binding will be an object of that type (endomorphism). But when the\n### objects passed to bindROWS() have mixed types, what bindROWS() will return\n### exactly is a little unpredictable.\n### The purpose of bindROWS2() is to improve handling of mixed type objects\n### by pre-processing them before passing them to bindROWS(). See helper\n### function .preprocess_objects_to_bind() below for more information.\n\n### The **set** of harmonized levels does NOT depend on the order of the\n### objects passed thru 'all_objects'. However, the exact order of the\n### harmonized levels DOES depend on the order of the objects. This is a\n### feature! The reason for doing this is that there's no clear/consensual\n### notion of natural or canonical order for the levels (note that sort()\n### is locale/system dependent) and we purposedly stay away from the business\n### of introducing one, at least for now.\n.harmonize_factor_levels <- function(all_objects)\n{\n    is_factor <- vapply(all_objects, is.factor, logical(1L))\n    if (!any(is_factor))\n        return(all_objects)\n    ## Force any non-factor object into a factor object.\n    all_objects[!is_factor] <- lapply(all_objects[!is_factor],\n        function(object) {\n            object <- as.character(object)\n            factor(object, levels=unique(object))\n        })\n    ## Collect and combine all levels.\n    harmonized_levels <- unique(unlist(lapply(all_objects, levels),\n                                       use.names=FALSE))\n    ## Set harmonized levels on all objects.\n    lapply(all_objects, factor, levels=harmonized_levels)\n}\n\n### The pre-processing implemented by this helper function addresses 4 of the\n### 5 following problems that we face when using bindROWS() directly on mixed\n### type objects:\n###  1. When the objects to bind are a mix of ordinary lists and other\n###     list-like objects like IntegerList, the type of the object returned\n###     by bindROWS() depends on the type of the 1st object. To avoid this\n###     undesirable effect, if one object to bind is an ordinary list then\n###     we pass all objects that are not ordinary lists thru as.list().\n###  2. When the objects to bind are a mix of Rle and non-Rle objects,\n###     the type of the object returned by bindROWS() also depends on the\n###     type of the 1st object. More precisely it's an Rle if and only if\n###     objects[[1]] is an Rle. The pre-processing below addresses this by\n###     decoding the Rle objects first.\n###  3. When the objects to bind are a mix of atomic vectors and factors,\n###     bindROWS() would **always** return an atomic vector (whatever\n###     objects[[1]] is, i.e. atomic vector or factor). However we **always**\n###     want a factor. This is an intended deviation with respect to what\n###     rbind() does when concatenating the columns of ordinary data frames\n###     where the 1st data frame passed to rbind() dictates what the\n###     result is going to be (i.e. a column in the result will be atomic\n###     vector or factor depending on what the corresponding column in the\n###     1st data frame is).\n###  4. When at least one of the objects to bind is a List derivative (and\n###     no other object is an ordinary list, in which case we do 1. above),\n###     bindROWS() can either be plain broken (e.g. if objects[[1]] is an\n###     atomic vector and objects[[2]] a List derivative), or do the right\n###     thing (e.g. if objects[[1]] is a List derivative and objects[[2]]\n###     an atomic vector). To address the former we coerce all objects to\n###     List with as(. , \"List\").\n###  5. Note that even after coercing all objects to List in situation 4.\n###     we're still facing the issue that the type of the object returned\n###     by bindROWS2() depends on the type of the 1st object. For example if\n###     objects[[1]] is an integer vector then it will return an IntegerList\n###     object, but if it's a character vector then it will return a\n###     CharacterList object, etc... We just live with this for now!\n.preprocess_objects_to_bind <- function(objects)\n{\n    is_list <- vapply(objects, is.list, logical(1L))\n    if (any(is_list)) {\n        coerce_idx <- which(!is_list)\n        if (length(coerce_idx) != 0L)\n            objects[coerce_idx] <- lapply(objects[coerce_idx], as.list)\n        return(objects)\n    }\n    is_Rle <- vapply(objects, is, logical(1L), \"Rle\")\n    if (all(is_Rle)) {\n        run_values <- lapply(objects, slot, \"values\")\n        run_values <- .harmonize_factor_levels(run_values)\n        objects <- lapply(seq_along(objects),\n            function(i) {\n                BiocGenerics:::replaceSlots(objects[[i]],\n                                            values=run_values[[i]])\n            })\n        return(objects)\n    }\n    if (any(is_Rle))\n        objects[is_Rle] <- lapply(objects[is_Rle], decodeRle)\n    objects <- .harmonize_factor_levels(objects)\n    is_List <- vapply(objects, is, logical(1L), \"List\")\n    if (any(is_List)) {\n        coerce_idx <- which(!is_List)\n        if (length(coerce_idx) != 0L)\n            objects[coerce_idx] <- lapply(objects[coerce_idx], as, \"List\")\n        return(objects)\n    }\n    objects\n}\n\nbindROWS2 <- function(x, objects=list())\n{\n    all_objects <- .preprocess_objects_to_bind(c(list(x), objects))\n    all_NROWs <- vapply(all_objects, NROW, integer(1L))\n    nonempty_idx <- which(all_NROWs != 0L)\n    if (length(nonempty_idx) == 0L)\n        return(all_objects[[1L]])\n    all_objects <- all_objects[nonempty_idx]\n    if (length(all_objects) == 1L)\n        return(all_objects[[1L]])\n    ans <- bindROWS(all_objects[[1L]], all_objects[-1L])\n    stopifnot(NROW(ans) == sum(all_NROWs))  # sanity check\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### bindCOLS()\n###\n### A low-level generic function for binding objects along their 2nd dimension.\n### It is intended to be the workhorse behind:\n### - the cbind() methods for rectangular objects (e.g. RectangularData\n###   derivatives);\n### - the c() method for data-frame-like objects (e.g. DataFrame derivatives).\n###\n\nsetGeneric(\"bindCOLS\", signature=\"x\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n        standardGeneric(\"bindCOLS\")\n)\n\n",
        "character-utils.R": "### =========================================================================\n### Some utility functions to operate on strings\n### -------------------------------------------------------------------------\n\n\n### NOT exported\ncapitalize <- function(x)\n{\n    substring(x, 1L, 1L) <- toupper(substring(x, 1L, 1L))\n    x\n}\n\n### NOT exported\n### Reduce size of each input string by keeping only its head and tail\n### separated by 3 dots. Each returned strings is guaranteed to have a number\n### characters <= width.\nsketchStr <- function(x, width=23) \n{\n    if (!is.character(x))\n        stop(\"'x' must be a character vector\")\n    if (!isSingleNumber(width))\n        stop(\"'width' must be a single integer\")\n    if (!is.integer(width))\n        width <- as.integer(width)\n    if (width < 7L) \n        width <- 7L\n    x_nchar <- nchar(x, type=\"width\")\n    idx <- which(x_nchar > width)\n    if (length(idx) != 0L) {\n        xx <- x[idx]\n        xx_nchar <- x_nchar[idx]\n        w1 <- (width - 2L) %/% 2L\n        w2 <- (width - 3L) %/% 2L\n        x[idx] <- paste0(substr(xx, start=1L, stop=w1),\n                         \"...\",\n                         substr(xx, start=xx_nchar - w2 + 1L, stop=xx_nchar))\n    }\n    x\n}\n\nsetGeneric(\"unstrsplit\", signature=\"x\",\n    function(x, sep=\"\") standardGeneric(\"unstrsplit\")\n)\n\nsetMethod(\"unstrsplit\", \"list\",\n    function(x, sep=\"\") .Call2(\"unstrsplit_list\", x, sep, PACKAGE=\"S4Vectors\")\n)\n\nsetMethod(\"unstrsplit\", \"character\",\n    function(x, sep=\"\") x\n)\n\n### Safe alternative to 'strsplit(x, NULL, fixed=TRUE)[[1L]]'.\nsafeExplode <- function(x)\n{\n    if (!isSingleString(x))\n        stop(\"'x' must be a single string\")\n    .Call2(\"safe_strexplode\", x, PACKAGE=\"S4Vectors\")\n}\n\n### svn.time() returns the time in Subversion format, e.g.:\n###   \"2007-12-07 10:03:15 -0800 (Fri, 07 Dec 2007)\"\n### The -0800 part will be adjusted if daylight saving time is in effect.\n### TODO: Find a better home for this function.\nsvn.time <- function() .Call2(\"svn_time\", PACKAGE=\"S4Vectors\")\n\n",
        "eval-utils.R": "### =========================================================================\n### Helpers for environments and evaluation\n### -------------------------------------------------------------------------\n\nsafeEval <- function(expr, envir, enclos=parent.env(envir), strict=FALSE) {\n  expr <- eval(call(\"bquote\", expr, enclos))\n  if (strict) {\n    enclos <- makeGlobalWarningEnv(expr, envir, enclos)\n  }\n  eval(expr, envir, enclos)\n}\n\nmakeGlobalWarningEnv <- function(expr, envir, enclos) {\n  envir <- as.env(envir, enclos)\n  globals <- setdiff(all.names(expr, functions=FALSE), ls(envir))\n  env <- new.env(parent=enclos)\n  lapply(globals, function(g) {\n    makeActiveBinding(g, function() {\n      val <- get(g, enclos)\n      warning(\"Symbol '\", g, \"' resolved from calling frame; \",\n              \"escape with .(\", g, \") for safety.\")\n      val\n    }, env)\n  })\n  env\n}\n\nevalArg <- function(expr, envir, ..., where=parent.frame()) {\n  enclos <- eval(call(\"top_prenv\", expr, where))\n  expr <- eval(call(\"substitute\", expr), where)\n  safeEval(expr, envir, enclos, ...)\n}\n\nnormSubsetIndex <- function(i) {\n  i <- try(as.logical(i), silent=TRUE)\n  if (inherits(i, \"try-error\"))\n    stop(\"'subset' must be coercible to logical\")\n  i & !is.na(i)\n}\n\nmissingArg <- function(arg, where=parent.frame()) {\n  eval(call(\"missing\", arg), where)\n}\n\nevalqForSubset <- function(expr, envir, ...) {\n  if (missingArg(substitute(expr), parent.frame())) {\n    rep(TRUE, NROW(envir))\n  } else {\n    i <- evalArg(substitute(expr), envir, ..., where=parent.frame())\n    normSubsetIndex(i)\n  }\n}\n\nevalqForSelect <- function(expr, df, ...) {\n  if (missingArg(substitute(expr), parent.frame())) {\n    rep(TRUE, ncol(df))\n  } else {\n    nl <- as.list(seq_len(ncol(df)))\n    names(nl) <- colnames(df)\n    evalArg(substitute(expr), nl, ..., where=parent.frame())\n  }\n}\n\ntop_prenv <- function(x, where=parent.frame()) {\n  sym <- substitute(x)\n  if (!is.name(sym)) {\n    stop(\"'x' did not substitute to a symbol\")\n  }\n  if (!is.environment(where)) {\n    stop(\"'where' must be an environment\")\n  }\n  .Call2(\"top_prenv\", sym, where, PACKAGE=\"S4Vectors\")\n}\n\ntop_prenv_dots <- function(...) {\n  .Call(\"top_prenv_dots\", environment(), PACKAGE=\"S4Vectors\")\n}\n\n",
        "expand-methods.R": "### =========================================================================\n### expand methods\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"expand\", signature=\"x\",\n           function(x, ...) \n               standardGeneric(\"expand\")\n)\n\n## A helper function to do the work\n.expandCols <- function(x, colnames, keepEmptyRows)\n{\n    if (!is(x, \"DataFrame\"))\n        stop(\"'x' must be a DataFrame object\")\n    if (anyNA(colnames) || length(colnames) == 0L)\n        stop(\"'colnames' must contain at least one element, but without NAs\")\n    cols <- x[colnames]\n    if (length(unique(lapply(cols, elementNROWS))) > 1L) {\n        stop(\"columns to expand must all have the same skeleton\")\n    }\n    enr <- elementNROWS(cols[[1L]])\n    if(keepEmptyRows){\n        cols <- lapply(cols, function(col) {\n            col[enr == 0L] <- NA\n            col\n        })\n    }\n    idx <- rep(seq_len(nrow(x)), elementNROWS(cols[[1L]]))\n    ans <- x[idx, setdiff(colnames(x), colnames), drop=FALSE]\n    ans[colnames] <- lapply(cols, unlist, use.names=FALSE)\n    ans[colnames(x)]\n}\n\n## A better helper\n.expand <- function(x, colnames, keepEmptyRows, recursive) {\n    if (recursive) {\n        for(colname in colnames) {\n            x <- .expandCols(x, colname, keepEmptyRows)\n        }\n    } else {\n        x <- .expandCols(x, colnames, keepEmptyRows)\n    }\n  x\n}\n\n### FIXME: should make is.recursive a generic in base R\nisRecursive <- function(x) is.recursive(x) || is(x, \"List\")\n\ndefaultIndices <- function(x) {\n    which(vapply(x, isRecursive, logical(1L)))\n}\n\nsetMethod(\"expand\", \"DataFrame\",\n          function(x, colnames, keepEmptyRows = FALSE, recursive = TRUE) {\n              stopifnot(isTRUEorFALSE(keepEmptyRows), isTRUEorFALSE(recursive))\n              if (missing(colnames)) {\n                  colnames <- defaultIndices(x)\n              }\n              .expand(x, colnames, keepEmptyRows, recursive)\n          }\n          )\n\nsetMethod(\"expand\", \"Vector\",\n          function(x, colnames, keepEmptyRows = FALSE, recursive = TRUE) {\n              stopifnot(isTRUEorFALSE(keepEmptyRows), isTRUEorFALSE(recursive))\n              if (missing(colnames)) {\n                  colnames <- defaultIndices(mcols(x, use.names=FALSE))\n              }\n              df <- mcols(x, use.names=FALSE)\n              df[[\"__index__\"]] <- seq_along(x)\n              ex <- .expand(df, colnames, keepEmptyRows, recursive)\n              mcols(x) <- NULL\n              ans <- x[ex[[\"__index__\"]]]\n              ex[[\"__index__\"]] <- NULL\n              mcols(ans) <- ex\n              ans\n          }\n          )\n\n## NOT exported but used in VariantAnnotation package.\n## Assume that the named columns have the same geometry and expand\n## them simultaneously; this is different from the cartesian product\n## expansion above.\nexpandByColumnSet <- function(x, colnames, keepEmptyRows) {\n  if (length(colnames) == 0L)\n    return(x)\n  if(keepEmptyRows) {\n    emptyRows <- elementNROWS(col) == 0L\n    x[emptyRows, colnames] <- rep(NA, sum(emptyRows))\n  }\n  ans <- x[quick_togroup(x[[colnames[1L]]]),,drop=FALSE]\n  ans[colnames] <- lapply(x[colnames], unlist, use.names = FALSE)\n  ans\n}\n\n",
        "integer-utils.R": "### =========================================================================\n### Some low-level utility functions to operate on integer vectors\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, the functions defined in this file are not\n### exported.\n###\n\n### Exported!\n### TODO: Implment this in C so we won't need to create 'seq_len(of.length)'\n### and we will be able to bail out early.\nisSequence <- function(x, of.length=length(x))\n{\n    if (!is.integer(x))\n        stop(\"'x' must be an integer vector\")\n    if (!isSingleNumber(of.length) || of.length < 0L)\n        stop(\"'length' must be a single non-negative integer\")\n    length(x) == of.length && identical(x, seq_len(of.length))\n}\n\nanyMissingOrOutside <- function(x, lower = -.Machine$integer.max,\n                                   upper = .Machine$integer.max)\n{\n    if (!is.integer(x))\n        stop(\"'x' must be an integer vector\")\n    if (!is.integer(lower))\n        lower <- as.integer(lower)\n    if (!is.integer(upper))\n        upper <- as.integer(upper)\n    .Call2(\"Integer_any_missing_or_outside\",\n           x, lower, upper,\n           PACKAGE=\"S4Vectors\")\n}\n\n### Equivalent to (but much faster than):\n###\n###   diff(c(0L, x))\n###\n### except that NAs are not supported.\ndiffWithInitialZero <- function(x)\n{\n    if (!is.integer(x))\n        stop(\"'x' must be an integer vector\")\n    .Call2(\"Integer_diff_with_0\", x, PACKAGE=\"S4Vectors\")\n}\n\n### Equivalent to (but much faster than):\n###\n###   diff(c(x, last))\n###\n### except that NAs are not supported.\ndiffWithLast <- function(x, last)\n{\n  if (!is.integer(x))\n    stop(\"'x' must be an integer vector\")\n  if (!isSingleInteger(last))\n    stop(\"'last' must be a single, non-NA integer\")\n  .Call2(\"Integer_diff_with_last\", x, last, PACKAGE=\"S4Vectors\")\n}\n\n### x: integer vector.\n### breakpoints: vector of positions on 'x' in increasing order.\n### Equivalent to (but 10x faster than):\n###     sum(relist(x, PartitioningByEnd(breakpoints)))\n### Also equivalent to (but 200x faster than):\n###     f <- rep(factor(seq_along(breakpoints)), diff(c(0L, breakpoints)))\n###     vapply(split(x, f, drop=FALSE), sum, integer(1), USE.NAMES=FALSE)\ngroupsum <- function(x, breakpoints)\n{   \n    if (last_or(breakpoints, 0L) != length(x))\n        stop(\"invalid 'breakpoints' argument\")\n    diffWithInitialZero(cumsum(x)[breakpoints])\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### toListOfIntegerVectors()\n###\n### On a character vector toListOfIntegerVectors(x) is an alternative to:\n###   lapply(strsplit(x, \",\", fixed=TRUE), as.integer)\n### except that:\n###  - strsplit() accepts NAs but we don't (we raise an error);\n###  - as.integer() introduces NAs by coercion (with a warning) but we don't\n###    (we raise an error);\n###  - as.integer() supports \"inaccurate integer conversion in coercion\"\n###    when the value to coerce is > INT_MAX (then it's coerced to INT_MAX)\n###    but we don't (we raise an error);\n###  - as.integer() will coerce non-integer values (e.g. 10.3) to an int\n###    by truncating them but we don't (we raise an error).\n### Also when it fails, toListOfIntegerVectors() prints a detailed parse\n### error message.\n### Finally it's faster and uses much less memory. E.g. it's 8x faster and\n### uses < 1 Mb versus > 60 Mb on the 'biginput' character vector below:\n###   library(rtracklayer)\n###   session <- browserSession()\n###   genome(session) <- \"hg19\"\n###   query <- ucscTableQuery(session, \"UCSC Genes\")\n###   tx <- getTable(query)\n###   ## 165920 strings in 'biginput' as of Jan 31, 2018.\n###   biginput <- c(as.character(tx$exonStarts), as.character(tx$exonEnds))\n\n### Exported!\ntoListOfIntegerVectors <- function(x, sep=\",\")\n{\n    if (!isSingleString(sep) || nchar(sep) != 1L)\n        stop(\"'sep' must be a single-letter string\")\n    ans <- .Call2(\"to_list_of_ints\", x, sep, PACKAGE=\"S4Vectors\")\n    names(ans) <- names(x)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Fast ordering/comparing of integer pairs.\n###\n\n.normargIntegerOrFactor <- function(arg, argname)\n{\n    if (is.factor(arg))\n        arg <- as.integer(arg)\n    else if (is(arg, \"Rle\") &&\n             (is(runValue(arg), \"integer\") || is(runValue(arg), \"factor\")))\n        arg <- as.integer(arg)\n    else if (!is.integer(arg))\n        stop(\"'\", argname, \"' must be an integer vector or factor\")\n    arg\n}\n\n.normargMethod <- function(method=c(\"auto\", \"quick\", \"hash\"), a_len)\n{\n    method <- match.arg(method)\n    if (method == \"auto\") {\n        if (a_len <= 2^29)\n            method <- \"hash\"\n        else\n            method <- \"quick\"\n    }\n    method\n}\n\npcompareIntegerPairs <- function(a1, b1, a2, b2)\n{\n    a1 <- .normargIntegerOrFactor(a1, \"a1\")\n    b1 <- .normargIntegerOrFactor(b1, \"b1\")\n    if (length(a1) != length(b1))\n        stop(\"'a1' and 'b1' must have the same length\")\n    a2 <- .normargIntegerOrFactor(a2, \"a2\")\n    b2 <- .normargIntegerOrFactor(b2, \"b2\")\n    if (length(a2) != length(b2))\n        stop(\"'a2' and 'b2' must have the same length\")\n    .Call2(\"Integer_pcompare2\", a1, b1, a2, b2, PACKAGE=\"S4Vectors\")\n}\n\nsortedIntegerPairs <- function(a, b, decreasing=FALSE, strictly=FALSE)\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    .Call2(\"Integer_sorted2\", a, b, decreasing, strictly, PACKAGE=\"S4Vectors\")\n}\n\n### Exported!\norderIntegerPairs <- function(a, b, decreasing=FALSE)\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    #.Call2(\"Integer_order2\", a, b, decreasing, PACKAGE=\"S4Vectors\")\n    base::order(a, b, decreasing=decreasing)\n}\n\n.matchIntegerPairs_quick <- function(a1, b1, a2, b2, nomatch=NA_integer_)\n{\n    .Call2(\"Integer_match2_quick\",\n           a1, b1, a2, b2, nomatch,\n           PACKAGE=\"S4Vectors\")\n}\n\n.matchIntegerPairs_hash <- function(a1, b1, a2, b2, nomatch=NA_integer_)\n{\n    .Call2(\"Integer_match2_hash\",\n           a1, b1, a2, b2, nomatch,\n           PACKAGE=\"S4Vectors\")\n}\n\n### Exported!\nmatchIntegerPairs <- function(a1, b1, a2, b2, nomatch=NA_integer_,\n                              method=c(\"auto\", \"quick\", \"hash\"))\n{\n    a1 <- .normargIntegerOrFactor(a1, \"a1\")\n    b1 <- .normargIntegerOrFactor(b1, \"b1\")\n    if (length(a1) != length(b1))\n        stop(\"'a1' and 'b1' must have the same length\")\n    a2 <- .normargIntegerOrFactor(a2, \"a2\")\n    b2 <- .normargIntegerOrFactor(b2, \"b2\")\n    if (length(a2) != length(b2))\n        stop(\"'a2' and 'b2' must have the same length\")\n    if (!isSingleNumberOrNA(nomatch))\n        stop(\"'nomatch' must be a single number or NA\")\n    if (!is.integer(nomatch))\n        nomatch <- as.integer(nomatch)\n    method <- .normargMethod(method, length(a2))\n    if (method == \"quick\") {\n        ans <- .matchIntegerPairs_quick(a1, b1, a2, b2, nomatch=nomatch)\n    } else {\n        ans <- .matchIntegerPairs_hash(a1, b1, a2, b2, nomatch=nomatch)\n    }\n    ans\n}\n\n.selfmatchIntegerPairs_quick <- function(a, b)\n{\n    .Call2(\"Integer_selfmatch2_quick\", a, b, PACKAGE=\"S4Vectors\")\n}\n\n### Author: Martin Morgan\n.selfmatchIntegerPairs_hash <- function(a, b)\n{\n    .Call2(\"Integer_selfmatch2_hash\", a, b, PACKAGE=\"S4Vectors\")\n}\n\n### Exported!\nselfmatchIntegerPairs <- function(a, b, method=c(\"auto\", \"quick\", \"hash\"))\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    if (length(a) != length(b))\n        stop(\"'a' and 'b' must have the same length\")\n    method <- .normargMethod(method, length(a))\n    if (method == \"quick\") {\n        ans <- .selfmatchIntegerPairs_quick(a, b)\n    } else {\n        ans <- .selfmatchIntegerPairs_hash(a, b)\n    }\n    ans\n}\n\n### Exported!\n###\n### For 'a' and 'b' integer vectors of equal length with no NAs,\n### 'duplicatedIntegerPairs(a, b)' is equivalent to (but much faster than):\n###\n###   duplicated(cbind(a, b))\n###\n### For efficiency reasons, we don't support (and don't even check) for NAs.\nduplicatedIntegerPairs <- function(a, b,\n                                   fromLast=FALSE,\n                                   method=c(\"auto\", \"quick\", \"hash\"))\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    if (length(a) != length(b))\n        stop(\"'a' and 'b' must have the same length\")\n    if (!isTRUEorFALSE(fromLast))\n        stop(\"'fromLast' must be TRUE or FALSE\")\n    if (length(a) == 0L)\n        return(logical(0L))\n    if (length(a) == 1L)\n        return(FALSE)\n    ## This is a temporary (and inefficient) workaround until \"quick\"\n    ## and \"hash\" methods can natively support fromLast=TRUE.\n    ## TODO: Add support for fromLast=TRUE to \"quick\" and \"hash\" methods.\n    if (fromLast)\n        return(rev(duplicatedIntegerPairs(rev(a), rev(b), method=method)))\n    sm <- selfmatchIntegerPairs(a, b, method=method)\n    sm != seq_len(length(sm))\n}\n\n### For 'a' and 'b' integer vectors of equal length with no NAs,\n### 'runEndsOfIntegerPairs(a, b)' finds the runs of identical rows in\n### 'cbind(a, b)' and returns the indices of the last row in each run.\n### In other words, it's equivalent to (but much faster than):\n###\n###   cumsum(runLength(Rle(paste(a, b, sep=\"|\"))))\n###\n### Note that, if the rows in 'cbind(a, b)' are already sorted, then\n### 'runEndsOfIntegerPairs(a, b)' returns the indices of the unique rows.\n### In other words, 'runEndsOfIntegerPairs()' could be used to efficiently\n### extract the unique pairs of integers from a presorted set of pairs.\n### However, at the moment (April 2011) using 'duplicatedIntegerPairs()'\n### is still faster than using 'runEndsOfIntegerPairs()' for finding the\n### duplicated or unique pairs of integers in a presorted set of pairs.\n### But this only because 'runEndsOfIntegerPairs()' is not as fast as it\n### could/should be (an all-in-C implementation would probably solve this).\n###\n### For efficiency reasons, we don't support (and don't even check) for NAs.\n### TODO: What happens if 'a' and 'b' don't have the same length? Shouldn't\n### we check for that?\nrunEndsOfIntegerPairs <- function(a, b)\n{\n    not_same_as_prev <- diffWithInitialZero(a) != 0L |\n                        diffWithInitialZero(b) != 0L\n    if (length(not_same_as_prev) == 0L)\n        return(integer())\n    which(c(not_same_as_prev[-1L], TRUE))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Fast ordering/comparing of integer quadruplets.\n###\n\nsortedIntegerQuads <- function(a, b, c, d, decreasing=FALSE, strictly=FALSE)\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    c <- .normargIntegerOrFactor(c, \"c\")\n    d <- .normargIntegerOrFactor(d, \"d\")\n    .Call2(\"Integer_sorted4\", a, b, c, d, decreasing, strictly,\n           PACKAGE=\"S4Vectors\")\n}\n\n### Exported!\norderIntegerQuads <- function(a, b, c, d, decreasing=FALSE)\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    c <- .normargIntegerOrFactor(c, \"c\")\n    d <- .normargIntegerOrFactor(d, \"d\")\n    #.Call2(\"Integer_order4\", a, b, c, d, decreasing, PACKAGE=\"S4Vectors\")\n    base::order(a, b, c, d, decreasing=decreasing)\n}\n\n.matchIntegerQuads_quick <- function(a1, b1, c1, d1, a2, b2, c2, d2,\n                                     nomatch=NA_integer_)\n{\n    .Call2(\"Integer_match4_quick\",\n           a1, b1, c1, d1, a2, b2, c2, d2, nomatch,\n           PACKAGE=\"S4Vectors\")\n}\n\n.matchIntegerQuads_hash <- function(a1, b1, c1, d1, a2, b2, c2, d2,\n                                    nomatch=NA_integer_)\n{\n    .Call2(\"Integer_match4_hash\",\n           a1, b1, c1, d1, a2, b2, c2, d2, nomatch,\n           PACKAGE=\"S4Vectors\")\n}\n\n### Exported!\nmatchIntegerQuads <- function(a1, b1, c1, d1, a2, b2, c2, d2,\n                              nomatch=NA_integer_,\n                              method=c(\"auto\", \"quick\", \"hash\"))\n{\n    a1 <- .normargIntegerOrFactor(a1, \"a1\")\n    b1 <- .normargIntegerOrFactor(b1, \"b1\")\n    c1 <- .normargIntegerOrFactor(c1, \"c1\")\n    d1 <- .normargIntegerOrFactor(d1, \"d1\")\n    if (length(a1) != length(b1) ||\n        length(b1) != length(c1) ||\n        length(c1) != length(d1))\n        stop(\"'a1', 'b1', 'c1' and 'd1' must have the same length\")\n    a2 <- .normargIntegerOrFactor(a2, \"a2\")\n    b2 <- .normargIntegerOrFactor(b2, \"b2\")\n    c2 <- .normargIntegerOrFactor(c2, \"c2\")\n    d2 <- .normargIntegerOrFactor(d2, \"d2\")\n    if (length(a2) != length(b2) ||\n        length(b2) != length(c2) ||\n        length(c2) != length(d2))\n        stop(\"'a2', 'b2', 'c2' and 'd2' must have the same length\")\n    if (!isSingleNumberOrNA(nomatch))\n        stop(\"'nomatch' must be a single number or NA\")\n    if (!is.integer(nomatch))\n        nomatch <- as.integer(nomatch)\n    method <- .normargMethod(method, length(a2))\n    if (method == \"quick\") {\n        ans <- .matchIntegerQuads_quick(a1, b1, c1, d1, a2, b2, c2, d2,\n                                        nomatch=nomatch)\n    } else {\n        ans <- .matchIntegerQuads_hash(a1, b1, c1, d1, a2, b2, c2, d2,\n                                       nomatch=nomatch)\n    }\n    ans\n}\n\n.selfmatchIntegerQuads_quick <- function(a, b, c, d)\n{\n    .Call2(\"Integer_selfmatch4_quick\", a, b, c, d, PACKAGE=\"S4Vectors\")\n}\n\n.selfmatchIntegerQuads_hash <- function(a, b, c, d)\n{\n    .Call2(\"Integer_selfmatch4_hash\", a, b, c, d, PACKAGE=\"S4Vectors\")\n}\n\n### Exported!\nselfmatchIntegerQuads <- function(a, b, c, d,\n                                  method=c(\"auto\", \"quick\", \"hash\"))\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    c <- .normargIntegerOrFactor(c, \"c\")\n    d <- .normargIntegerOrFactor(d, \"d\")\n    if (length(a) != length(b) ||\n        length(b) != length(c) ||\n        length(c) != length(d))\n        stop(\"'a', 'b', 'c' and 'd' must have the same length\")\n    method <- .normargMethod(method, length(a))\n    if (method == \"quick\") {\n        ans <- .selfmatchIntegerQuads_quick(a, b, c, d)\n    } else {\n        ans <- .selfmatchIntegerQuads_hash(a, b, c, d)\n    }\n    ans\n}\n\n### Exported!\nduplicatedIntegerQuads <- function(a, b, c, d,\n                                   fromLast=FALSE,\n                                   method=c(\"auto\", \"quick\", \"hash\"))\n{\n    a <- .normargIntegerOrFactor(a, \"a\")\n    b <- .normargIntegerOrFactor(b, \"b\")\n    c <- .normargIntegerOrFactor(c, \"c\")\n    d <- .normargIntegerOrFactor(d, \"d\")\n    if (length(a) != length(b) ||\n        length(b) != length(c) ||\n        length(c) != length(d))\n        stop(\"'a', 'b', 'c' and 'd' must have the same length\")\n    if (!isTRUEorFALSE(fromLast))\n        stop(\"'fromLast' must be TRUE or FALSE\")\n    if (length(a) == 0L)\n        return(logical(0L))\n    if (length(a) == 1L)\n        return(FALSE)\n    ## This is a temporary (and inefficient) workaround until \"quick\"\n    ## and \"hash\" methods can natively support fromLast=TRUE.\n    ## TODO: Add support for fromLast=TRUE to \"quick\" and \"hash\" methods.\n    if (fromLast)\n        return(rev(duplicatedIntegerQuads(rev(a), rev(b), rev(c), rev(d),\n                                          method=method)))\n    sm <- selfmatchIntegerQuads(a, b, c, d, method=method)\n    sm != seq_len(length(sm))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### tabulate2()\n###\n### An enhanced version of base::tabulate() that: (1) handles integer weights\n### (NA and negative weights are OK), and (2) throws an error if 'strict' is\n### TRUE and if 'x' contains NAs or values not in the [1, 'nbins'] interval.\n### Unlike with base::tabulate(), 'nbins' needs to be specified (no default\n### value). Also for now, it only works if 'x' is an integer vector.\n###\n\ntabulate2 <- function(x, nbins, weight=1L, strict=FALSE)\n{\n    if (!is.integer(x))\n        stop(\"'x' must be an integer vector\")\n    if (!isSingleNumber(nbins))\n        stop(\"'nbins' must be a single integer\")\n    if (!is.integer(nbins))\n        nbins <- as.integer(nbins)\n    if (!is.integer(weight))\n        stop(\"'weight' must be an integer vector\")\n    if (!isTRUEorFALSE(strict))\n        stop(\"'strict' must be TRUE or FALSE\")\n    .Call2(\"Integer_tabulate2\", x, nbins, weight, strict, PACKAGE=\"S4Vectors\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Bitwise operations.\n###\n### The bitwise operations in this section don't treat the integer NA (aka\n### NA_integer_) in any particular way: at the C level an NA_integer_ is\n### just a 32-bit pattern like any other int in C.\n###\n\nmakePowersOfTwo <- function(nbit)\n{\n    if (!isSingleInteger(nbit) || nbit < 0L)\n        stop(\"'nbit' must be a single non-negative integer\")\n    if (nbit == 0L)\n        return(integer(0))\n    as.integer(cumprod(c(1L, rep.int(2L, nbit-1L))))\n}\n\n### Returns an integer matrix with 'length(x)' rows and 'length(bitpos)' cols.\nexplodeIntBits <- function(x, bitpos=1:32)\n{\n    if (!is.integer(x))\n        stop(\"'x' must be an integer vector\")\n    if (!is.integer(bitpos))\n        stop(\"'bitpos' must be an integer vector\")\n    ## Old implementation: not very efficient and also broken on NAs and\n    ## negative integers!\n    #if (length(bitpos) == 0L)\n    #    return(matrix(nrow=length(x), ncol=0L))\n    #nbit <- max(bitpos)\n    #if (is.na(nbit) || min(bitpos) <= 0L)\n    #    stop(\"'bitpos' must contain potive values only\")\n    #ans <- matrix(nrow=length(x), ncol=nbit)\n    #for (i in seq_len(ncol(ans))) {\n    #    ans[ , i] <- x %% 2L\n    #    x <- x %/% 2L\n    #}\n    #ans[ , bitpos, drop=FALSE]\n    .Call2(\"Integer_explode_bits\", x, bitpos, PACKAGE=\"S4Vectors\")\n}\n\n### FIXME: Broken if ncol(x) = 32.\nimplodeIntBits <- function(x)\n{\n    if (!is.matrix(x))\n        stop(\"'x' must be a matrix\")\n    tx <- t(x)\n    data <- tx * makePowersOfTwo(nrow(tx))\n    ## In some circumstances (e.g. if 'tx' has 0 col), the \"dim\" attribute\n    ## gets lost during the above multiplication.\n    if (is.null(dim(data)))\n        dim(data) <- dim(tx)\n    as.integer(colSums(data))\n}\n\nintbitsNOT <- function(x)\n{\n    stop(\"not yet implemented\")  # fix implodeIntBits() first!\n    xbits <- explodeIntBits(x)\n    implodeIntBits(!xbits)\n}\n\nintbitsAND <- function(x, y)\n{\n    stop(\"not yet implemented\")  # fix implodeIntBits() first!\n    xbits <- explodeIntBits(x)\n    ybits <- explodeIntBits(y)\n    implodeIntBits(xbits & ybits)\n}\n\nintbitsOR <- function(x, y)\n{\n    stop(\"not yet implemented\")  # fix implodeIntBits() first!\n    xbits <- explodeIntBits(x)\n    ybits <- explodeIntBits(y)\n    implodeIntBits(xbits | ybits)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Others.\n###\n\nsortedMerge <- function(x, y)\n    .Call2(\"Integer_sorted_merge\", x, y, PACKAGE=\"S4Vectors\")\n\nmake_XYZxyz_to_XxYyZz_subscript <- function(N)\n    as.vector(matrix(seq_len(2L * N), nrow=2L, byrow=TRUE))\n\nfindIntervalAndStartFromWidth <- function(x, width)\n    .Call2(\"findIntervalAndStartFromWidth\", x, width, PACKAGE=\"S4Vectors\")\n\n### Reverse an injection from 1:M to 1:N.\n### The injection is represented by an integer vector of length M (eventually\n### with NAs). Fundamental property:\n###\n###   reverseIntegerInjection(reverseIntegerInjection(injection, N), M)\n###\n### is the identity function.\n### Can be used to efficiently reverse the result of a call to 'order()'.\nreverseIntegerInjection <- function(injection, N)\n{\n    M <- length(injection)\n    ans <- rep.int(NA_integer_, N)\n    is_not_na <- !is.na(injection)\n    ans[injection[is_not_na]] <- seq_len(M)[is_not_na]\n    ans\n}\n\n",
        "isSorted.R": "### =========================================================================\n### isConstant(), isSorted(), isStrictlySorted()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isConstant()\n###\n\nsetGeneric(\"isConstant\", function(x) standardGeneric(\"isConstant\"))\n\n### There are many ways to implement the \"isConstant\" method for integer\n### vectors:\n###   isConstant1 <- function(x) {length(x) <= 1L || all(x == x[1L])}\n###   isConstant2 <- function(x) {length(unique(x)) <= 1L}\n###   isConstant3 <- function(x) {length(x) <= 1L || all(duplicated(x)[-1L])}\n###   isConstant4 <- function(x) {length(x) <= 1L ||\n###                               sum(duplicated(x)) == length(x) - 1L}\n###   isConstant5 <- function(x) {length(x) <= 1L || min(x) == max(x)}\n###   isConstant6 <- function(x) {length(x) <= 1L ||\n###                               {rx <- range(x); rx[1L] == rx[2L]}}\n### Which one is faster is hard to guess. It happens to be isConstant5():\n### it's 2.7x faster than isConstant1(), 6x faster than isConstant2(), 11x\n### faster than isConstant3(), 5.2x faster than isConstant4() and 1.6x faster\n### than isConstant6().\n### Results obtained on 'x0 <- rep.int(112L, 999999L)' with R-2.13 Under\n### development (unstable) (2011-01-08 r53945).\n\n### For this method we use a modified version of isConstant5() above that\n### handles NAs.\nsetMethod(\"isConstant\", \"integer\",\n    function(x)\n    {\n        if (length(x) <= 1L)\n            return(TRUE)\n        x_min <- min(x, na.rm=FALSE)\n        if (!is.na(x_min))  # success means 'x' contains no NAs\n            return(x_min == max(x, na.rm=FALSE))\n        ## From here 'x' is guaranteed to have a length >= 2 and to contain\n        ## at least an NA.\n        ## 'min(x, na.rm=TRUE)' issues a warning if 'x' contains only NAs.\n        ## In that case, and in that case only, it returns Inf.\n        x_min <- suppressWarnings(min(x, na.rm=TRUE))\n        if (x_min == Inf)\n            return(NA)\n        ## From here 'x' is guaranteed to contain a mix of NAs and non-NAs.\n        x_max <- max(x, na.rm=TRUE)\n        if (x_min == x_max)\n            return(NA)\n        FALSE\n    }\n)\n\n### Like the method for integer vectors this method also uses a comparison\n### between min(x) and max(x). In addition it needs to handle rounding errors\n### and special values: NA, NaN, Inf and -Inf.\n### Using all.equal() ensures that TRUE is returned on c(11/3, 2/3+4/3+5/3).\nsetMethod(\"isConstant\", \"numeric\",\n    function(x)\n    {\n        if (length(x) <= 1L)\n            return(TRUE)\n        x_min <- min(x, na.rm=FALSE)\n        if (!is.na(x_min)) {  # success means 'x' contains no NAs and no NaNs\n            x_max <- max(x, na.rm=FALSE)\n            if (is.finite(x_min) && is.finite(x_max))\n                return(isTRUE(all.equal(x_min, x_max)))\n            if (x_min == x_max)  # both are Inf or both are -Inf\n                return(NA)\n            return(FALSE)\n        }\n        ## From here 'x' is guaranteed to have a length >= 2 and to contain\n        ## at least an NA or NaN.\n        ## 'min(x, na.rm=TRUE)' issues a warning if 'x' contains only NAs\n        ## and NaNs.\n        x_min <- suppressWarnings(min(x, na.rm=TRUE))\n        if (x_min == Inf) {\n            ## Only possible values in 'x' are NAs, NaNs or Infs.\n            is_in_x <- c(NA, NaN, Inf) %in% x\n            if (is_in_x[2L] && is_in_x[3L])\n                return(FALSE)\n            return(NA)\n        }\n        ## From here 'x' is guaranteed to contain at least one value that is\n        ## not NA or NaN or Inf.\n        x_max <- max(x, na.rm=TRUE)\n        if (x_max == -Inf) {\n            ## Only possible values in 'x' are NAs, NaNs or -Infs.\n            is_in_x <- c(NA, NaN, -Inf) %in% x\n            if (is_in_x[2L] && is_in_x[3L])\n                return(FALSE)\n            return(NA)\n        }\n        if (is.infinite(x_min) || is.infinite(x_max))\n            return(FALSE)\n        if (!isTRUE(all.equal(x_min, x_max)))\n            return(FALSE)\n        if (NaN %in% x)\n            return(FALSE)\n        return(NA)\n    }\n)\n\nsetMethod(\"isConstant\", \"array\", function(x) isConstant(as.vector(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isNotSorted(), isNotStrictlySorted()\n###\n### NOT exported.\n###\n### isNotStrictlySorted() takes for granted that 'x' contains no NAs (behaviour\n### is undefined if this is not the case). This allows isNotStrictlySorted() to\n### be MUCH faster than is.unsorted() in some situations:\n###   > x <- c(99L, 1:1000000)\n###   > system.time(for (i in 1:1000) isNotStrictlySorted(x))\n###    user  system elapsed \n###   0.004   0.000   0.003 \n###   > system.time(for (i in 1:1000) is.unsorted(x, strictly=TRUE))\n###    user  system elapsed \n###   6.925   1.756   8.690 \n### So let's keep it for now! Until someone has enough time and energy to\n### convince the R core team to fix is.unsorted()...\n### Note that is.unsorted() does not only have a performance problem:\n###   a) It also has a semantic problem: is.unsorted(NA) returns NA despite the\n###      man page stating that all objects of length 0 or 1 are sorted (sounds\n###      like a fair statement).\n###   b) The sort()/is.unsorted() APIs and semantics are inconsistent.\n###   c) Why did they choose to have is.unsorted() instead of is.sorted() in the\n###      first place? Having is.unsorted( , strictly=TRUE) being a \"looser test\"\n###      (or a \"weaker condition\") than is.unsorted( , strictly=FALSE) is really\n###      counterintuitive!\n###        > is.unsorted(c(5L, 5:8), strictly=FALSE)\n###        [1] FALSE\n###        > is.unsorted(c(5L, 5:8), strictly=TRUE)\n###        [1] TRUE\n###      Common sense would expect to have less objects that are \"strictly\n###      something\" than objects that are \"just something\".\n###\n### Update (Sep 30, 2021): Even though commit 80981 to R trunk (to become\n### R 4.2.0) now passes the 'na.rm' argument to '.Internal(is.unsorted())',\n### NAs are still not handled in C. So the huge inefficiency in is.unsorted()\n### remains! Anyways, we modified our hack to pass three arguments instead\n### of two to '.Internal(is.unsorted)' if R >= 4.2.0.\n\n..Internal <- .Internal  # a silly trick to keep 'R CMD check' quiet\n.R_fullversion <- paste(R.version$major, R.version$minor, sep=\".\")\nif (compareVersion(.R_fullversion, \"4.2.0\") >= 0L) {\n    isNotSorted <- function(x) ..Internal(is.unsorted(x, FALSE, FALSE))\n    isNotStrictlySorted <- function(x) ..Internal(is.unsorted(x, FALSE, TRUE))\n} else {\n    isNotSorted <- function(x) ..Internal(is.unsorted(x, FALSE))\n    isNotStrictlySorted <- function(x) ..Internal(is.unsorted(x, TRUE))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isSorted()\n###\n\nsetGeneric(\"isSorted\", function(x) standardGeneric(\"isSorted\"))\n\nsetMethod(\"isSorted\", \"ANY\", function(x) !isNotSorted(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isStrictlySorted()\n###\n\nsetGeneric(\"isStrictlySorted\",\n    function(x) standardGeneric(\"isStrictlySorted\")\n)\n\nsetMethod(\"isStrictlySorted\", \"ANY\", function(x) !isNotStrictlySorted(x))\n\n",
        "map_ranges_to_runs.R": "### =========================================================================\n### map_ranges_to_runs()\n### -------------------------------------------------------------------------\n###\n\nnormarg_method <- function(method)\n{\n    if (!(isSingleNumber(method) && method >= 0 && method <= 3))\n        stop(\"'method' must be a single integer between 0 and 3\")\n    if (!is.integer(method))\n        method <- as.integer(method)\n    method\n}\n\n### Used in GenomicRanges.\nmap_ranges_to_runs <- function(run_lens, start, width, method=0L)\n{\n    method <- normarg_method(method)\n    .Call2(\"map_ranges\", run_lens, start, width, method, PACKAGE=\"S4Vectors\")\n}\n\n### Note that\n###\n###     map_positions_to_runs(run_lengths, pos)\n###\n### is equivalent to\n###\n###     findInterval(pos - 1L, cumsum(run_lengths)) + 1L\n###\n### but is more efficient, specially when the number of runs is big and the\n### number of positions to map relatively small with respect to the number of\n### runs (in which case map_positions_to_runs() can be 10x or 20x faster than\n### findInterval()).\nmap_positions_to_runs <- function(run_lens, pos, method=0L)\n{\n    method <- normarg_method(method)\n    .Call2(\"map_positions\", run_lens, pos, method, PACKAGE=\"S4Vectors\")\n}\n\n",
        "normarg-utils.R": "### =========================================================================\n### Utility functions for checking/fixing user-supplied arguments\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### For checking only.\n###\n\nisTRUEorFALSE <- function(x)\n{\n    is.logical(x) && length(x) == 1L && !is.na(x)\n}\n\nisSingleInteger <- function(x)\n{\n    is.integer(x) && length(x) == 1L && !is.na(x)\n}\n\nisSingleNumber <- function(x)\n{\n    is.numeric(x) && length(x) == 1L && !is.na(x)\n}\n\nisSingleString <- function(x)\n{\n    is.character(x) && length(x) == 1L && !is.na(x)\n}\n\n### We want these functions to return TRUE when passed an NA of whatever type.\nisSingleNumberOrNA <- function(x)\n{\n    is.atomic(x) && length(x) == 1L && (is.numeric(x) || is.na(x))\n}\n\nisSingleStringOrNA <- function(x)\n{\n    is.atomic(x) && length(x) == 1L && (is.character(x) || is.na(x))\n}\n\n### NOT exported.\nanyMissing <- function(x) .Call2(\"anyMissing\", x, PACKAGE=\"S4Vectors\")\n\n### NOT exported.\nisNumericOrNAs <- function(x)\n{\n    is.numeric(x) || (is.atomic(x) && is.vector(x) && all(is.na(x)))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Vertical/horiontal recycling of a vector-like/list-like object.\n###\n\n### Vertical recycling (of any vector-like object).\n### NOT exported.\nV_recycle <- function(x, skeleton, x_what=\"x\", skeleton_what=\"skeleton\")\n{\n    x_NROW <- NROW(x)\n    skeleton_len <- length(skeleton)\n    if (x_NROW == skeleton_len)\n        return(x)\n    if (x_NROW > skeleton_len && x_NROW != 1L)\n        stop(wmsg(\n            \"'NROW(\", x_what, \")' is greater than \",\n            \"'length(\", skeleton_what, \")'\"\n        ))\n    if (x_NROW == 0L)\n        stop(wmsg(\n            \"'NROW(\", x_what, \")' is 0 but \",\n            \"'length(\", skeleton_what, \")' is not\"\n        ))\n    if (skeleton_len %% x_NROW != 0L)\n        warning(wmsg(\n            \"'length(\", skeleton_what, \")' is not a multiple of \",\n            \"'NROW(\", x_what, \")'\"\n        ))\n    idx <- rep(seq_len(x_NROW), length.out=skeleton_len)\n    extractROWS(x, idx)\n}\n\n### Horizontal recycling (of a list-like object only).\n### NOT exported.\nH_recycle <- function(x, skeleton, x_what=\"x\", skeleton_what=\"skeleton\",\n                      more_blahblah=NA)\n{\n    stopifnot(is(x, \"list_OR_List\"))\n    stopifnot(is(skeleton, \"list_OR_List\"))\n    x_len <- length(x)\n    skeleton_len <- length(skeleton)\n    stopifnot(x_len == skeleton_len)\n\n    x_what2 <- paste0(\"some list elements in '\", x_what, \"'\")\n    if (!is.na(more_blahblah))\n        x_what2 <- paste0(x_what2, \" (\", more_blahblah, \")\")\n\n    x_eltNROWS <- unname(elementNROWS(x))\n    skeleton_eltNROWS <- unname(elementNROWS(skeleton))\n    idx <- which(x_eltNROWS != skeleton_eltNROWS)\n    if (length(idx) == 0L)\n        return(x)\n\n    longer_idx <- which(x_eltNROWS > skeleton_eltNROWS)\n    shorter_idx <- which(x_eltNROWS < skeleton_eltNROWS)\n    if (length(longer_idx) == 0L && length(shorter_idx) == 0L)\n        return(x)\n    if (length(longer_idx) != 0L) {\n        if (max(x_eltNROWS[longer_idx]) >= 2L)\n            stop(wmsg(\n                x_what2, \" are longer than their corresponding \",\n                \"list element in '\", skeleton_what, \"'\"\n            ))\n    }\n    if (length(shorter_idx) != 0L) {\n        tmp <- x_eltNROWS[shorter_idx]\n        if (min(tmp) == 0L)\n            stop(wmsg(\n                x_what2, \" are of length 0, but their corresponding \",\n                \"list element in '\", skeleton_what, \"' is not\"\n            ))\n        if (max(tmp) >= 2L)\n            stop(wmsg(\n                x_what2, \" are shorter than their corresponding \",\n                \"list element in '\", skeleton_what, \"', but have \",\n                \"a length >= 2. \\\"Horizontal\\\" recycling only supports \",\n                \"list elements of length 1 at the moment.\"\n            ))\n    }\n\n    ## From here 'x[idx]' is guaranteed to contain list elements of length 1.\n\n    ## We use an \"unlist => stretch => relist\" algo to perform the horizontal\n    ## recycling. Because of this, the returned value is not necessary of the\n    ## same class as 'x' (e.g. can be an IntegerList if 'x' is an ordinary\n    ## list of integers and 'skeleton' a List object).\n    unlisted_x <- unlist(x, use.names=FALSE)\n    times <- rep.int(1L, length(unlisted_x))\n    idx2 <- cumsum(x_eltNROWS)[idx]\n    times[idx2] <- skeleton_eltNROWS[idx]\n    unlisted_ans <- rep.int(unlisted_x, times)\n    ans <- relist(unlisted_ans, skeleton)\n    names(ans) <- names(x)\n    ans\n}\n\n### Performs first vertical then horizontal recycling (of a list-like object\n### only).\n### NOT exported.\nVH_recycle <- function(x, skeleton, x_what=\"x\", skeleton_what=\"skeleton\",\n                       more_blahblah=NA)\n{\n    x <- V_recycle(x, skeleton, x_what=x_what, skeleton_what=skeleton_what)\n    H_recycle(x, skeleton, x_what=x_what, skeleton_what=skeleton_what,\n                           more_blahblah=more_blahblah)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### More recycling of a vector-like object.\n###\n### TODO: This section needs to be cleaned. Some of the stuff in it is\n### redundant with and superseded by V_recycle() and/or H_recycle() (defined\n### in the previous section).\n###\n\n### NOT exported.\n### recycleVector() vs rep(x, length.out=length):\n###   - The former seems a little bit faster (1.5x - 2x).\n###   - The former will issue a warning that \"number of items to replace is not\n###     a multiple of replacement length\". The latter will always remain silent.\nrecycleVector <- function(x, length.out)\n{\n    if (length(x) == length.out) {\n        x\n    } else {\n        ans <- vector(storage.mode(x), length.out)\n        ans[] <- x\n        ans\n    }\n}\n\n### Must always drop the names of 'arg'.\nrecycleArg <- function(arg, argname, length.out)\n{\n    if (length.out == 0L) {\n        if (length(arg) > 1L)\n            stop(\"invalid length for '\", argname, \"'\")\n        if (length(arg) == 1L && is.na(arg))\n            stop(\"'\", argname, \"' contains NAs\")\n        return(recycleVector(arg, length.out))  # drops the names\n    }\n    if (length(arg) == 0L)\n        stop(\"'\", argname, \"' has no elements\")\n    if (length(arg) > length.out)\n        stop(\"'\", argname, \"' is longer than 'x'\")\n    if (anyMissing(arg))\n        stop(\"'\", argname, \"' contains NAs\")\n    if (length(arg) < length.out)\n        arg <- recycleVector(arg, length.out)  # drops the names\n    else\n        arg <- unname(arg)\n    arg\n}\n\nrecycleIntegerArg <- function(arg, argname, length.out)\n{\n    if (!is.numeric(arg))\n        stop(\"'\", argname, \"' must be a vector of integers\")\n    if (!is.integer(arg))\n        arg <- as.integer(arg)\n    recycleArg(arg, argname, length.out)\n}\n\nrecycleNumericArg <- function(arg, argname, length.out)\n{\n    if (!is.numeric(arg))\n        stop(\"'\", argname, \"' must be a numeric vector\")\n    recycleArg(arg, argname, length.out)\n}\n\nrecycleLogicalArg <- function(arg, argname, length.out)\n{\n    if (!is.logical(arg))\n        stop(\"'\", argname, \"' must be a logical vector\")\n    recycleArg(arg, argname, length.out)\n}\n\nrecycleCharacterArg <- function(arg, argname, length.out)\n{\n    if (!is.character(arg))\n        stop(\"'\", argname, \"' must be a character vector\")\n    recycleArg(arg, argname, length.out)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normarg_names()\n###\n\n### NOT exported but used in the IRanges and SummarizedExperiment packages.\nnormarg_names <- function(names, x_class, x_len)\n{\n    if (is.null(names))\n        return(NULL)\n    names <- as.character(names)\n    names_len <- length(names)\n    if (names_len > x_len)\n        stop(wmsg(\"attempt to set too many names (\", names_len, \") \",\n                  \"on \", x_class, \" object of length \", x_len))\n    if (names_len < x_len) {\n        ## We pad with NA's to mimic what 'names(x) <- names' does on\n        ## an ordinary vector.\n        names <- c(names, rep.int(NA_character_, x_len - names_len))\n    }\n    names\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Fold a vector-like object.\n###\n\n### We use a signature in the style of IRanges::successiveIRanges() or\n### IRanges::successiveViews().\n### The current implementation should be fast enough if length(x)/circle.length\n### is small (i.e. < 10 or 20). This will actually be the case for the typical\n### usecase which is the calculation of \"circular coverage vectors\", that is,\n### we use fold() on the \"linear coverage vector\" to turn it into a \"circular\n### coverage vector\" of length 'circle.length' where 'circle.length' is the\n### length of the circular sequence.\nfold <- function(x, circle.length, from=1)\n{\n    if (typeof(x) != \"S4\" && !is.numeric(x) && !is.complex(x))\n        stop(\"'x' must be a vector-like object with elements that can be added\")\n    if (!isSingleNumber(circle.length))\n        stop(\"'circle.length' must be a single integer\")\n    if (!is.integer(circle.length))\n        circle.length <- as.integer(circle.length)\n    if (circle.length <= 0L)\n        stop(\"'circle.length' must be positive\")\n    if (!isSingleNumber(from))\n        stop(\"'from' must be a single integer\")\n    if (!is.integer(from))\n        from <- as.integer(from)\n    from <- 1L + (from - 1L) %% circle.length\n    if (typeof(x) == \"S4\") {\n        ans <- as(rep.int(0L, circle.length), class(x))\n        if (length(ans) != circle.length)\n            stop(\"don't know how to handle 'x' of class \", class(x))\n    } else {\n        ans <- vector(typeof(x), length=circle.length)\n    }\n    if (from > length(x)) {\n        ## Nothing to fold\n        jj <- seq_len(length(x)) + circle.length - from + 1L\n        ans[jj] <- x\n        return(ans)\n    }\n    if (from > 1L) {\n        ii <- seq_len(from - 1L)\n        jj <- ii + circle.length - from + 1L\n        ans[jj] <- x[ii]\n    }\n    max_from <- length(x) - circle.length + 1L\n    while (from <= max_from) {\n        ii <- from:(from+circle.length-1L)\n        ans[] <- ans[] + x[ii]\n        from <- from + circle.length\n    }\n    if (from > length(x))\n        return(ans)\n    ii <- from:length(x)\n    jj <- ii - from + 1L\n    ans[jj] <- ans[jj] + x[ii]\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other non exported normarg* functions.\n###\n\n### NOT exported.\nnormargSingleStartOrNA <- function(start)\n{\n    if (!isSingleNumberOrNA(start))\n        stop(\"'start' must be a single integer or NA\")\n    if (!is.integer(start))\n        start <- as.integer(start)\n    start\n}\n\n### NOT exported.\nnormargSingleEndOrNA <- function(end)\n{\n    if (!isSingleNumberOrNA(end))\n        stop(\"'end' must be a single integer or NA\")\n    if (!is.integer(end))\n        end <- as.integer(end)\n    end\n}\n\n### NOT exported.\nnormargUseNames <- function(use.names)\n{\n    if (is.null(use.names))\n        return(TRUE)\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    use.names\n}\n\n### NOT exported.\nnormargRunK <- function(k, n, endrule)\n{\n    if (!is.numeric(k))\n        stop(\"'k' must be a numeric vector\")\n    if (k < 0)\n        stop(\"'k' must be positive\")\n    if ((endrule != \"drop\") && (k %% 2 == 0)) {\n        k <- 1L + 2L * (k %/% 2L)\n        warning(paste(\"'k' must be odd when 'endrule != \\\"drop\\\"'!\",\n                      \"Changing 'k' to \", k))\n    }\n    if (k > n) {\n        k <- 1L + 2L * ((n - 1L) %/% 2L)\n        warning(\"'k' is bigger than 'n'! Changing 'k' to \", k)\n    }\n    as.integer(k)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Miscellaneous.\n###\n\n### NOT exported.\nnumeric2integer <- function(x)\n{\n    if (is.numeric(x) && !is.integer(x)) as.integer(x) else x\n}\n\n### NOT exported.\nextraArgsAsList <- function(.valid.argnames, ...)\n{\n    args <- list(...)\n    argnames <- names(args)\n    if (length(args) != 0L\n        && (is.null(argnames) || any(argnames %in% c(\"\", NA))))\n        stop(\"all extra arguments must be named\")\n    if (!is.null(.valid.argnames) && !all(argnames %in% .valid.argnames))\n        stop(\"valid extra argument names are \",\n             paste(\"'\", .valid.argnames, \"'\", sep=\"\", collapse=\", \"))\n    if (anyDuplicated(argnames))\n        stop(\"argument names must be unique\")\n    args\n}\n\n",
        "raw-utils.R": "### =========================================================================\n### Some low-level utility functions to operate on raw vectors\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, the functions defined in this file are not\n### exported.\n###\n\n\nTOUPPER_LOOKUP <- c(0:96, 65:90, 123:255)\nTOLOWER_LOOKUP <- c(0:64, 97:122, 91:255)\n\nextract_character_from_raw_by_positions <- function(x, pos,\n                                                    collapse=FALSE, lkup=NULL)\n{\n    .Call(\"C_extract_character_from_raw_by_positions\",\n          x, pos, collapse, lkup,\n          PACKAGE=\"S4Vectors\")\n}\n\nextract_character_from_raw_by_ranges <- function(x, start, width,\n                                                 collapse=FALSE, lkup=NULL)\n{\n    .Call(\"C_extract_character_from_raw_by_ranges\",\n          x, start, width, collapse, lkup,\n          PACKAGE=\"S4Vectors\")\n}\n\n",
        "shiftApply-methods.R": "### =========================================================================\n### shiftApply() methods\n### -------------------------------------------------------------------------\n\n\nsetGeneric(\"shiftApply\", signature=c(\"X\", \"Y\"),\n    function(SHIFT, X, Y, FUN, ..., OFFSET=0L, simplify=TRUE, verbose=FALSE)\n        standardGeneric(\"shiftApply\")\n)\n\n.Vector_shiftApply <- function(SHIFT, X, Y, FUN, ..., OFFSET=0L, simplify=TRUE,\n                               verbose=FALSE)\n{\n    FUN <- match.fun(FUN)\n    N <- length(X)\n    if (N != length(Y))\n        stop(\"'X' and 'Y' must be of equal length\")\n\n    if (!is.integer(SHIFT))\n        SHIFT <- as.integer(SHIFT)\n    if (length(SHIFT) == 0 || anyMissingOrOutside(SHIFT, 0L))\n        stop(\"all 'SHIFT' values must be non-negative\")\n\n    if (!is.integer(OFFSET))\n        OFFSET <- as.integer(OFFSET)\n    if (length(OFFSET) == 0 || anyMissingOrOutside(OFFSET, 0L))\n        stop(\"'OFFSET' must be non-negative\")\n\n    ## Perform X setup\n    shiftedStartX <- rep.int(1L + OFFSET, length(SHIFT))\n    shiftedEndX <- N - SHIFT\n\n    ## Perform Y setup\n    shiftedStartY <- 1L + SHIFT\n    shiftedEndY <- rep.int(N - OFFSET, length(SHIFT))\n\n    if (verbose) {\n        maxI <- length(SHIFT)\n        ans <-\n          sapply(seq_len(length(SHIFT)),\n                 function(i) {\n                     cat(\"\\r\", i, \"/\", maxI)\n                     FUN(Vector_window(X, start = shiftedStartX[i], end = shiftedEndX[i]),\n                         Vector_window(Y, start = shiftedStartY[i], end = shiftedEndY[i]),\n                         ...)\n                 }, simplify = simplify)\n        cat(\"\\n\")\n    } else {\n        ans <-\n          sapply(seq_len(length(SHIFT)),\n                 function(i)\n                     FUN(Vector_window(X, start = shiftedStartX[i], end = shiftedEndX[i]),\n                         Vector_window(Y, start = shiftedStartY[i], end = shiftedEndY[i]),\n                         ...),\n                 simplify = simplify)\n    }\n    ans\n}\n\nsetMethod(\"shiftApply\", signature(X=\"Vector\", Y=\"Vector\"),\n          .Vector_shiftApply)\n\nsetMethod(\"shiftApply\", signature(X=\"vector\", Y=\"vector\"),\n          .Vector_shiftApply)\n\n",
        "show-utils.R": "### =========================================================================\n### Some low-level (not exported) utility functions used by various \"show\"\n### methods\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, nothing in this file is exported.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selectSome()\n###\n\n### taken directly from Biobase, then added 'ellipsisPos' argument\nselectSome <- function(obj, maxToShow = 5, ellipsis = \"...\",\n                       ellipsisPos = c(\"middle\", \"end\", \"start\"), quote=FALSE) \n{\n  if(is.character(obj) && quote)\n      obj <- sQuote(obj)\n  ellipsisPos <- match.arg(ellipsisPos)\n  len <- length(obj)\n  if (maxToShow < 3) \n    maxToShow <- 3\n  if (len > maxToShow) {\n    maxToShow <- maxToShow - 1\n    if (ellipsisPos == \"end\") {\n      c(head(obj, maxToShow), ellipsis)\n    } else if (ellipsisPos == \"start\") {\n      c(ellipsis, tail(obj, maxToShow))\n    } else {\n      bot <- ceiling(maxToShow/2)\n      top <- len - (maxToShow - bot - 1)\n      nms <- obj[c(1:bot, top:len)]\n      c(as.character(nms[1:bot]), ellipsis, as.character(nms[-c(1:bot)]))\n    }\n  } else {\n    obj\n  }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### coolcat()\n###\n\n### Exported!\ncoolcat <- function(fmt, vals=character(), exdent=2, ...)\n{\n    vals <- ifelse(nzchar(vals), vals, \"''\")\n    lbls <- paste(selectSome(vals), collapse=\" \")\n    txt <- sprintf(fmt, length(vals), lbls)\n    cat(strwrap(txt, exdent=exdent, ...), sep=\"\\n\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### labeledLine()\n###\n\n.qualifyByName <- function(x, qualifier=\"=\") {\n    nms <- names(x)\n    x <- as.character(x)\n    aliased <- nzchar(nms)\n    x[aliased] <- paste0(nms[aliased], qualifier, x[aliased])\n    x\n}\n\n.padToAlign <- function(x) {\n    whitespace <- paste(rep(\" \", getOption(\"width\")), collapse=\"\")\n    padlen <- max(nchar(x)) - nchar(x)\n    substring(whitespace, 1L, padlen)\n}\n\n.ellipsize <-\n  function(obj, width = getOption(\"width\"), sep = \" \", ellipsis = \"...\",\n           pos = c(\"middle\", \"end\", \"start\"))\n{\n  pos <- match.arg(pos)\n  if (is.null(obj))\n    obj <- \"NULL\"\n  if (is.factor(obj))\n    obj <- as.character(obj)\n  ## get order selectSome() would print\n  if (pos == \"middle\") {\n    if (length(obj) > 2 * width)\n      obj <- c(head(obj, width), tail(obj, width))\n    half <- seq_len(ceiling(length(obj) / 2L))\n    ind <- as.vector(rbind(half, length(obj) - half + 1L))\n  } else if (pos == \"end\") {\n    obj <- head(obj, width)\n    ind <- seq_len(length(obj))\n  } else {\n    obj <- tail(obj, width)\n    ind <- rev(seq_len(length(obj)))\n  }\n  str <- encodeString(obj)\n  nc <- cumsum(nchar(str[ind]) + nchar(sep)) - nchar(sep)\n  last <- findInterval(width, nc)\n  if (length(obj) > last) {\n    ## make sure ellipsis fits\n    while (last &&\n           (nc[last] + nchar(sep)*2^(last>1) + nchar(ellipsis)) > width)\n      last <- last - 1L\n    if (last == 0) { ## have to truncate the first/last element\n      if (pos == \"start\") {\n        str <-\n          paste(ellipsis,\n                substring(tail(str, 1L),\n                          nchar(tail(str, 1L))-(width-nchar(ellipsis))+1L,\n                          nchar(ellipsis)),\n                sep = \"\")\n      } else {\n        str <-\n          paste(substring(str[1L], 1, width - nchar(ellipsis)), ellipsis,\n                sep = \"\")\n      }\n    }\n    else if (last == 1) { ## can only show the first/last\n      if (pos == \"start\")\n        str <- c(ellipsis, tail(str, 1L))\n      else str <- c(str[1L], ellipsis)\n    }\n    else {\n      str <- selectSome(str, last + 1L, ellipsis, pos)\n    }\n  }\n  paste(str, collapse = sep)\n}\n\nlabeledLine <-\n    function(label, els, count = TRUE, labelSep = \":\", sep = \" \",\n             ellipsis = \"...\", ellipsisPos = c(\"middle\", \"end\", \"start\"),\n             vectorized = FALSE, pad = vectorized)\n{\n  if (!is.null(els)) {\n      label[count] <- paste(label, \"(\",\n                            if (vectorized) lengths(els) else length(els),\n                            \")\", sep = \"\")[count]\n      if (!is.null(names(els))) {\n          els <- .qualifyByName(els)\n      }\n  }\n  label <- paste(label, labelSep, \" \", sep = \"\")\n  if (pad) {\n      label <- paste0(label, .padToAlign(label))\n  }\n  width <- getOption(\"width\") - nchar(label)\n  ellipsisPos <- match.arg(ellipsisPos)\n  if (vectorized) {\n      .ellipsize <- Vectorize(.ellipsize)\n  }\n  line <- .ellipsize(els, width, sep, ellipsis, ellipsisPos)\n  paste(label, line, \"\\n\", sep = \"\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### get_showHeadLines(), set_showHeadLines()\n### get_showTailLines(), set_showTailLines()\n###\n\n### Guaranteed to return a non-negative integer.\n.get_showLines <- function(option, default=5L)\n{\n    n <- getOption(option, default=default)\n    if (!isSingleNumber(n) || n > .Machine$integer.max)\n        return(default)\n    if (n <= 0)\n        return(0L)\n    if (!is.integer(n))\n        n <- as.integer(n)\n    n\n}\n\n### Return the previous 'n' value.\n.set_showLines <- function(option, n)\n{\n    if (!isSingleNumber(n))\n        stop(wmsg(\"'n' must be a single number\"))\n    if (n > .Machine$integer.max)\n        stop(wmsg(\"'n' is too big\"))\n    if (n < 0)\n        stop(wmsg(\"'n' cannot be negative\"))\n    prev <- .get_showLines(option)\n    if (!is.integer(n))\n        n <- as.integer(n)\n    do.call(options, setNames(list(n), option))\n    invisible(prev)\n}\n\n### Exported!\nget_showHeadLines <- function() .get_showLines(\"showHeadLines\")\nset_showHeadLines <- function(n=5) .set_showLines(\"showHeadLines\", n)\nget_showTailLines <- function() .get_showLines(\"showTailLines\")\nset_showTailLines <- function(n=5) .set_showLines(\"showTailLines\", n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### printAtomicVectorInAGrid() and toNumSnippet()\n###\n\n### Exported!\nprintAtomicVectorInAGrid <- function(x, prefix=\"\", justify=\"left\")\n{\n    if (!is.character(x))\n        x <- setNames(as.character(x), names(x))\n\n    ## Nothing to print if length(x) is 0.\n    if (length(x) == 0L)\n        return(invisible(x))\n\n    ## Determine the nb of cols in the grid.\n    grid_width <- getOption(\"width\") + 1L - nchar(prefix)\n    cell_width <- max(3L, nchar(x), nchar(names(x)))\n    ncol <- grid_width %/% (cell_width + 1L)\n\n    ## Determine the nb of rows in the grid.    \n    nrow <- length(x) %/% ncol\n    remainder <- length(x) %% ncol\n    if (remainder != 0L) {\n        nrow <- nrow + 1L\n        x <- c(x, character(ncol - remainder))\n    }\n\n    ## Print the grid.\n    print_line <- function(y)\n    {\n        cells <- format(y, justify=justify, width=cell_width)\n        cat(prefix, paste0(cells, collapse=\" \"), \"\\n\", sep=\"\")\n    }\n    print_grid_row <- function(i)\n    {\n        idx <- (i - 1L) * ncol + seq_len(ncol)\n        slice <- x[idx]\n        if (!is.null(names(slice)))\n            print_line(names(slice))\n        print_line(slice)\n    }\n    n1 <- get_showHeadLines()\n    n2 <- get_showTailLines()\n    if (nrow <= n1 + n2) {\n        for (i in seq_len(nrow)) print_grid_row(i)\n    } else {\n        idx1 <- seq_len(n1)\n        idx2 <- nrow - n2 + seq_len(n2)\n        for (i in idx1) print_grid_row(i)\n        print_line(rep.int(\"...\", ncol))\n        for (i in idx2) print_grid_row(i)\n    }\n    invisible(x)\n}\n\n### Works as long as length(), \"[\" and as.numeric() work on 'x'.\n### Not exported.\ntoNumSnippet <- function(x, max.width)\n{\n    if (length(x) <= 2L)\n        return(paste(format(as.numeric(x)), collapse=\" \"))\n    if (max.width < 0L)\n        max.width <- 0L\n    ## Elt width and nb of elt to display if they were all 0.\n    elt_width0 <- 1L\n    nelt_to_display0 <- min(length(x), (max.width+1L) %/% (elt_width0+1L))\n    head_ii0 <- seq_len(nelt_to_display0 %/% 2L)\n    tail_ii0 <- length(x) + head_ii0 - length(head_ii0)\n    ii0 <- c(head_ii0, tail_ii0)\n    ## Effective elt width and nb of elt to display\n    elt_width <- format.info(as.numeric(x[ii0]))[1L]\n    nelt_to_display <- min(length(x), (max.width+1L) %/% (elt_width+1L))\n    if (nelt_to_display == length(x))\n        return(paste(format(as.numeric(x), width=elt_width), collapse=\" \"))\n    head_ii <- seq_len((nelt_to_display+1L) %/% 2L)\n    tail_ii <- length(x) + seq_len(nelt_to_display %/% 2L) - nelt_to_display %/% 2L\n    ans_head <- format(as.numeric(x[head_ii]), width=elt_width)\n    ans_tail <- format(as.numeric(x[tail_ii]), width=elt_width)\n    ans <- paste(paste(ans_head, collapse=\" \"), \"...\", paste(ans_tail, collapse=\" \"))\n    if (nchar(ans) <= max.width || length(ans_head) == 0L)\n        return(ans)\n    ans_head <- ans_head[-length(ans_head)]\n    ans <- paste(paste(ans_head, collapse=\" \"), \"...\", paste(ans_tail, collapse=\" \"))\n    if (nchar(ans) <= max.width || length(ans_tail) == 0L)\n        return(ans)\n    ans_tail <- ans_tail[-length(ans_tail)]\n    paste(paste(ans_head, collapse=\" \"), \"...\", paste(ans_tail, collapse=\" \"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### classNameForDisplay()\n###\n\n### Exported!\nsetGeneric(\"classNameForDisplay\",\n    function(x) standardGeneric(\"classNameForDisplay\")\n)\n\nsetMethod(\"classNameForDisplay\", \"ANY\",\n   function(x)\n   {\n       ## Selecting the 1st element guarantees that we return a single string\n       ## (e.g. on an ordered factor, class(x) returns a character vector of\n       ## length 2).\n       class(x)[1L]\n   }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### showAsCell()\n###\n### All \"showAsCell\" methods must return a character vector.\n###\n\n### Exported!\nsetGeneric(\"showAsCell\", function(object) standardGeneric(\"showAsCell\"))\n\n### Should work on any matrix-like object e.g. ordinary matrix, Matrix,\n### data.frame, DataFrame, data.table, etc...\n### Should also work on any array-like object with more than 2 dimensions\n### that supports \"reshaping\" via the dim() setter. Note that DelayedArray\n### objects don't support this reshaping in general.\nshowAsCell_array <- function(object)\n{\n    if (length(dim(object)) > 2L) {\n        ## Reshape 'object' as a 2D object.\n        dim1 <- dim(object)[-1L]\n        dim(object) <- c(nrow(object), prod(dim1))\n    }\n    object_ncol <- ncol(object)\n    if (object_ncol == 0L)\n        return(rep.int(\"\", nrow(object)))\n    first_cols <- lapply(seq_len(min(object_ncol, 3L)),\n        function(j) showAsCell(object[ , j, drop=TRUE])\n    )\n    ans <- do.call(paste, c(first_cols, list(sep=\":\")))\n    if (object_ncol > 3L)\n        ans <- paste0(ans, \":...\")\n    ans\n}\n\n.default_showAsCell <- function(object)\n{\n    ## Some objects like SplitDataFrameList have a \"dim\" method that\n    ## returns a non-MULL object (a matrix!) even though they don't have\n    ## an array-like semantic.\n    if (length(dim(object)) >= 2L && !is.matrix(dim(object)))\n        return(showAsCell_array(object))\n    object_NROW <- NROW(object)\n    if (object_NROW == 0L)\n        return(character(0L))\n    attempt <- try(as.character(object), silent=TRUE)\n    if (!is(attempt, \"try-error\"))\n        return(showAsCell(attempt))\n    if (object_NROW == 1L)\n        return(paste0(\"<\", classNameForDisplay(object), \">\"))\n    rep.int(\"####\", object_NROW)\n}\n\nsetMethod(\"showAsCell\", \"ANY\", .default_showAsCell)\n\nsetMethod(\"showAsCell\", \"numeric\",\n    function(object)\n    {\n        if (is.integer(object))\n            return(as.character(object))\n        format(object, digits=6L)\n    }\n)\n\nsetMethod(\"showAsCell\", \"character\",\n    function(object)\n    {\n        nc <- nchar(object, type=\"chars\")\n        trim_idx <- which(nc > 22L)\n        if (length(trim_idx) != 0L) {\n            tmp <- substr(object[trim_idx], start=1L, stop=20L)\n            object[trim_idx] <- paste0(tmp, \"..\")\n        }\n        object\n    }\n)\n\nsetMethod(\"showAsCell\", \"AsIs\",\n    function(object) showAsCell(drop_AsIs(object))\n)\n\nshowAsCell_list <- function(object)\n{\n    vapply(object,\n        function(x) {\n            ## 'x' is not necessarily subsettable so if its length is 1 (e.g.\n            ## 'x' is a BamFile object) we avoid the risky subsetting.\n            if (NROW(x) == 1L)\n                return(showAsCell(x))\n            ## 'head(x, 3L)' is still no guaranteed to work.\n            x3 <- try(head(x, 3L), silent=TRUE)\n            if (is(x3, \"try-error\"))\n                return(\"####\")\n            str <- paste(showAsCell(x3), collapse=\",\")\n            if (length(x) > 3L)\n                str <- paste0(str, \",...\")\n            str\n        },\n        character(1L),\n        USE.NAMES=FALSE\n    )\n}\nsetMethod(\"showAsCell\", \"list\", showAsCell_list)\n\nsetMethod(\"showAsCell\", \"data.frame\", showAsCell_array)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### makeNakedCharacterMatrixForDisplay() and\n### makePrettyMatrixForCompactPrinting()\n###\n\n### Exported!\nsetGeneric(\"makeNakedCharacterMatrixForDisplay\",\n    function(x) standardGeneric(\"makeNakedCharacterMatrixForDisplay\")\n)\n\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"ANY\",\n    function(x) as.matrix(x)\n)\n\n### Exported!\n### For use within makeNakedCharacterMatrixForDisplay() methods.\ncbind_mcols_for_display <- function(m, x)\n{\n    x_len <- length(x)\n    stopifnot(identical(nrow(m), x_len))\n    x_mcols <- mcols(x, use.names=FALSE)\n    x_nmc <- if (is.null(x_mcols)) 0L else ncol(x_mcols)\n    if (x_nmc == 0L)\n        return(m)\n    ## cbind() must be called with unnamed arguments to avoid problems\n    ## in the unlikely situation where some of the argument names are\n    ## 'deparse.level'. So we drop the names with unname() and add them\n    ## back on the matrix returned by cbind().\n    tmp <- do.call(cbind, unname(lapply(x_mcols, showAsCell)))\n    colnames(tmp) <- colnames(x_mcols)\n    cbind(m, `|` = rep.int(\"|\", x_len), tmp)\n}\n\n### Exported!\n### 'makeNakedMat.FUN' for backward compatibility with code that predates\n### the makeNakedCharacterMatrixForDisplay() generic above.\nmakePrettyMatrixForCompactPrinting <- function(x, makeNakedMat.FUN=NULL)\n{\n    if (!is.null(makeNakedMat.FUN))\n        makeNakedCharacterMatrixForDisplay <- makeNakedMat.FUN\n    nhead <- get_showHeadLines()\n    ntail <- get_showTailLines()\n    x_NROW <- NROW(x)\n    x_ROWNAMES <- ROWNAMES(x)\n    wrap_in_square_brackets <- function(idx) {\n        if (length(idx) == 0L)\n            return(character(0))\n        paste0(\"[\", idx, \"]\")\n    }\n    if (x_NROW <= nhead + ntail + 1L) {\n        ## Compute 'ans' (the matrix).\n        ans <- makeNakedCharacterMatrixForDisplay(x)\n        ## Compute 'ans_rownames' (the matrix row names).\n        if (is.null(x_ROWNAMES)) {\n            ans_rownames <- wrap_in_square_brackets(seq_len(x_NROW))\n        } else {\n            ans_rownames <- x_ROWNAMES\n        }\n    } else {\n        ## Compute 'ans' (the matrix).\n        ans_top <- makeNakedCharacterMatrixForDisplay(head(x, n=nhead))\n        ans_bottom <- makeNakedCharacterMatrixForDisplay(tail(x, n=ntail))\n        ellipses <- rep.int(\"...\", ncol(ans_top))\n        ellipses[colnames(ans_top) %in% \"|\"] <- \".\"\n        ans <- rbind(ans_top, matrix(ellipses, nrow=1L), ans_bottom)\n        ## Compute 'ans_rownames' (the matrix row names).\n        if (is.null(x_ROWNAMES)) {\n            idx1 <- seq(from=1L, by=1L, length.out=nhead)\n            idx2 <- seq(to=x_NROW, by=1L, length.out=ntail)\n            s1 <- wrap_in_square_brackets(idx1)\n            s2 <- wrap_in_square_brackets(idx2)\n        } else {\n            s1 <- head(x_ROWNAMES, n=nhead)\n            s2 <- tail(x_ROWNAMES, n=ntail)\n        }\n        max_width <- max(nchar(s1, type=\"width\"), nchar(s2, type=\"width\"))\n        if (max_width <= 1L) {\n            ellipsis <- \".\"\n        } else if (max_width == 2L) {\n            ellipsis <- \"..\"\n        } else {\n            ellipsis <- \"...\"\n        }\n        ans_rownames <- c(s1, ellipsis, s2)\n    }\n    rownames(ans) <- format(ans_rownames, justify=\"right\")\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### makeClassinfoRowForCompactPrinting()\n###\n\n### Exported!\nmakeClassinfoRowForCompactPrinting <- function(x, col2class)\n{\n    ans_names <- names(col2class)\n    no_bracket <- ans_names == \"\"\n    ans_names[no_bracket] <- col2class[no_bracket]\n    left_brackets <- right_brackets <- character(length(col2class))\n    left_brackets[!no_bracket] <- \"<\"\n    right_brackets[!no_bracket] <- \">\"\n    ans <- paste0(left_brackets, col2class, right_brackets)\n    names(ans) <- ans_names\n    x_mcols <- mcols(x, use.names=FALSE)\n    x_nmc <- if (is.null(x_mcols)) 0L else ncol(x_mcols)\n    if (x_nmc > 0L) {\n        tmp <- sapply(x_mcols,\n                      function(xx) paste0(\"<\", classNameForDisplay(xx), \">\"))\n        ans <- c(ans, `|`=\"|\", tmp)\n    }\n    matrix(ans, nrow=1L, dimnames=list(\"\", names(ans)))\n}\n\n",
        "splitAsList.R": "### =========================================================================\n### Split a vector-like object as a list-like object\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### relistToClass()\n###\n### 'relistToClass(x)' is the opposite of 'elementType(y)' in the sense that\n### the former returns the class of the result of relisting (or splitting)\n### 'x' while the latter returns the class of the result of unlisting (or\n### unsplitting) 'y'.\n###\n### More formally, if 'x' is an object that is relistable and 'y' a list-like\n### object:\n###    relistToClass(x) == class(relist(x, some_skeleton))\n###    elementType(y) == class(unlist(y))\n###\n### Therefore, for any object 'x' for which relistToClass() is defined\n### and returns a valid class, 'elementType(new(relistToClass(x)))' should\n### return 'class(x)'.\n###\n\nsetGeneric(\"relistToClass\", function(x) standardGeneric(\"relistToClass\"))\n\n.selectListClassName <- function(x) {\n  cn <- listClassName(\"Compressed\", x)\n  if (cn == \"CompressedList\")\n    cn <- listClassName(\"Simple\", x)\n  cn\n}\n\nsetMethod(\"relistToClass\", \"ANY\", function(x) .selectListClassName(class(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### splitAsList()\n###\n\nsetGeneric(\"splitAsList\", signature=c(\"x\", \"f\"),\n    function(x, f, drop=FALSE, ...) standardGeneric(\"splitAsList\")\n)\n\n### The default splitAsList() method is actually implemented in the\n### IRanges package.\nsetMethod(\"splitAsList\", c(\"ANY\", \"ANY\"),\n    function(x, f, drop=FALSE)\n    {\n        if (!requireNamespace(\"IRanges\", quietly=TRUE))\n            stop(wmsg(\"Couldn't load the IRanges package. Please install \",\n                      \"the IRanges package before you try splitting \",\n                      \"a Vector derivative.\"))\n        IRanges:::default_splitAsList(x, f, drop=drop)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### split()\n###\n\n### Delegate to splitAsList().\nsetMethods(\"split\", list(c(\"Vector\", \"ANY\"),\n                         c(\"ANY\", \"Vector\"),\n                         c(\"Vector\", \"Vector\")),\n    function(x, f, drop=FALSE, ...) splitAsList(x, f, drop=drop, ...)\n)\n\nsetMethod(\"split\", c(\"list\", \"Vector\"),\n    function(x, f, drop=FALSE, ...) split(x, as.vector(f), drop=drop, ...)\n)\n\n",
        "stack-methods.R": "### =========================================================================\n### stack() and mstack() methods\n### -------------------------------------------------------------------------\n\n\n### NOT exported but used in package IRanges.\nstack_index <- function(x, index.var = \"name\") {\n  if (length(names(x)) > 0) {\n    spaceLabels <- names(x)\n  } else {\n    spaceLabels <- seq_len(length(x))\n  }\n  ind <- Rle(factor(spaceLabels, levels = unique(spaceLabels)),\n             elementNROWS(x))\n  do.call(DataFrame, structure(list(ind), names = index.var))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### stack()\n###\n\n### FIXME: need a recursive argument, when TRUE we call stack on\n### unlist result, instead of coercing to DataFrame.\nsetMethod(\"stack\", \"List\",\n          function(x, index.var = \"name\", value.var = \"value\", name.var = NULL)\n          {\n            if (!requireNamespace(\"IRanges\", quietly=TRUE))\n              stop(wmsg(\"Couldn't load the IRanges package. Please install \",\n                        \"the IRanges package before you call stack() on \",\n                        \"List derivative.\"))\n            value <- unlist(x, use.names=FALSE)\n            index <- stack_index(x, index.var)\n            unlistsToVector <- is(value, \"Vector\")\n            if (unlistsToVector) {\n              df <- cbind(index, ensureMcols(unname(value)))\n            } else {\n              df <- DataFrame(index, as(unname(value), \"DataFrame\"))\n              colnames(df)[2] <- value.var\n            }\n            if (!is.null(name.var)) {\n              nms <- as.character(unlist(lapply(x, names)))\n              if (length(nms) == 0L) {\n                rngs <- IRange::IRanges(1L, width=elementNROWS(x))\n                nms <- as.integer(rngs)\n              } else {\n                nms <- factor(nms, unique(nms))\n              }\n              df[[name.var]] <- nms\n              df <- df[c(index.var, name.var, value.var)]\n            }\n            x_mcols <- mcols(x, use.names=FALSE)\n            if (!is.null(x_mcols) && nrow(x_mcols) > 0L) {\n                group <- IRanges::togroup(IRanges::PartitioningByEnd(x))\n                df <- cbind(df, x_mcols[group, , drop=FALSE])\n            }\n            if (unlistsToVector) {\n              mcols(value) <- df\n              value\n            } else {\n              df\n            }\n          })\n\nsetMethod(\"stack\", \"matrix\",\n          function(x, row.var = names(dimnames(x))[1L],\n                   col.var = names(dimnames(x))[2L],\n                   value.var = \"value\")\n          {\n              l <- x\n              attributes(l) <- NULL\n              lens <- elementNROWS(l)\n              rn <- rownames(x)\n              if (is.null(rn))\n                  rn <- seq_len(nrow(x))\n              else rn <- factor(rn, unique(rn))\n              cn <- colnames(x)\n              if (is.null(cn))\n                  cn <- seq_len(ncol(x))\n              else cn <- factor(cn, unique(cn))\n              if (is.list(l))\n                  l <- stack(List(l))\n              ans <- DataFrame(row=rep(rn[row(x)], lens),\n                               col=rep(Rle(cn, rep(nrow(x), ncol(x))), lens),\n                               value=l)\n              if (is.null(row.var)) row.var <- \"row\"\n              if (is.null(col.var)) col.var <- \"col\"\n              colnames(ans) <- c(row.var, col.var, value.var)\n              ans\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### mstack()\n###\n\n### Hackery to avoid R CMD check warning for using an internal...\n.islistfactor <- function(x) {\n    eval(as.call(list(quote(.Internal),\n                      substitute(islistfactor(x, FALSE), list(x=x)))))\n}\n\n### NOT exported but used in package IRanges.\n### TODO: Do we really need this? Sounds like what bindROWS() does.\ncompress_listData <- function(objects, elementType = NULL) {\n    if (length(objects) > 0L) {\n        if (.islistfactor(objects)) {\n            ans <- unlist(objects, recursive=FALSE, use.names=FALSE)\n        } else if (length(dim(objects[[1L]])) < 2L) {\n            ans <- do.call(c, unname(objects))\n        } else {\n            ans <- do.call(rbind, unname(objects))\n        }\n    } else {\n        ans <- vector()\n    }\n    ans\n}\n\nsetGeneric(\"mstack\", function(..., .index.var = \"name\")\n           standardGeneric(\"mstack\"), signature = \"...\")\n\nsetMethod(\"mstack\", \"Vector\", function(..., .index.var = \"name\") {\n  if (!isSingleString(.index.var))\n    stop(\"'.index.var' must be a single, non-NA string\")\n  objects <- list(...)\n  combined <- compress_listData(objects)\n  df <- stack_index(objects, .index.var)\n  if (!is.null(mcols(combined, use.names=FALSE)))\n    df <- cbind(df, mcols(combined, use.names=FALSE))\n  mcols(combined) <- df\n  combined\n})\n\nsetMethod(\"mstack\", \"vector\",\n          function(..., .index.var = \"name\")\n          {\n            if (!isSingleString(.index.var))\n              stop(\"'.index.var' must be a single, non-NA string\")\n            objects <- list(...)\n            combined <- compress_listData(objects)\n            df <- DataFrame(stack_index(objects, .index.var), combined)\n            if (ncol(df) == 2L)\n              colnames(df)[2] <- \"value\"\n            df\n          })\n\nsetMethod(\"mstack\", \"DataFrame\",\n    function(..., .index.var=\"name\")\n    {\n        if (!requireNamespace(\"IRanges\", quietly=TRUE))\n            stop(wmsg(\"Couldn't load the IRanges package. Please install \",\n                      \"the IRanges package before you call mstack() on \",\n                      \"DataFrame objects.\"))\n        stack(IRanges::DataFrameList(...), index.var=.index.var)\n    }\n)\n\n",
        "subsetting-utils.R": "### =========================================================================\n### Low-level subsetting utilities\n### -------------------------------------------------------------------------\n###\n\n\n.match_name <- function(i, x_names, exact=TRUE)\n{\n    if (exact) {\n        match(i, x_names, incomparables=c(NA_character_, \"\"))\n    } else {\n        ## When 'i' has length 1, it doesn't matter whether we use\n        ## 'duplicates.ok=FALSE' (the default) or 'duplicates.ok=TRUE' but\n        ## the latter seems to be just a little bit faster.\n        pmatch(i, x_names, duplicates.ok=TRUE)\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Formal representation of a Normalized Single Bracket Subscript, i.e. a\n### subscript that holds positive integer values that can be used for single\n### bracket subsetting ([ or [<-).\n###\n### NSBS and its subclasses are for internal use only.\n###\n\nsetClass(\"NSBS\",\n    representation(\n        \"VIRTUAL\",\n        ## 'subscript' is an object that represents a vector of integer\n        ## values that are >= 1 and <= upper_bound, or NA_integer_ values.\n        ## The precise type of the object depends on the NSBS subclass and\n        ## is specified via the definition of the subclass.\n        subscript=\"ANY\",\n        upper_bound=\"integer\",            # single integer >= 0\n        upper_bound_is_strict=\"logical\",  # TRUE or FALSE\n        has_NAs=\"logical\"\n    ),\n    prototype(\n        upper_bound=0L,\n        upper_bound_is_strict=TRUE,\n        has_NAs=FALSE\n    )\n)\n\n### There are currently 4 NSBS concrete subclasses:\n### - defined in S4Vectors:\n###     1) NativeNSBS: 'subscript' slot is a vector of positive integers\n###     2) RangeNSBS:  'subscript' slot is c(start, end)\n###     3) RleNSBS:    'subscript' slot is an integer-Rle\n### - defined in IRanges:\n###     4) RangesNSBS: 'subscript' slot is an IRanges\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### NSBS API:\n###   - NSBS() constructor function\n###   - as.integer()\n###   - length()\n###   - anyDuplicated()\n###   - isStrictlySorted()\n###   - max()\n###   - complementNSBS() -- internal generic\n\n### Fallback methods.\n### The 5 fallback methods below will work out-of-the-box on any NSBS\n### derivative for which as.integer() works. However, concrete subclasses\n### RangeNSBS, RleNSBS, and RangesNSBS, should override them with more\n### efficient versions that avoid expanding 'x' into an integer vector.\n\nsetMethod(\"length\", \"NSBS\", function(x) length(as.integer(x)))\n\n## S3/S4 combo for anyDuplicated.NSBS\nanyDuplicated.NSBS <- function(x, incomparables=FALSE, ...)\n    anyDuplicated(as.integer(x), incomparables=incomparables, ...)\nsetMethod(\"anyDuplicated\", \"NSBS\", anyDuplicated.NSBS)\n\nsetMethod(\"isStrictlySorted\", \"NSBS\",\n    function(x) isStrictlySorted(as.integer(x))\n)\n\nsetMethod(\"max\", \"NSBS\",\n    function(x, ..., na.rm=FALSE) max(as.integer(x), ..., na.rm=na.rm)\n)\n\n### Not exported.\n### Must set the 'upper_bound_is_strict' and 'has_NAs' slots of the returned\n### NSBS derivative to their default values (TRUE and FALSE, respectively).\nsetGeneric(\"complementNSBS\", function(x) standardGeneric(\"complementNSBS\"))\n\nsetMethod(\"complementNSBS\", \"NSBS\",\n    function(x)\n    {\n        subscript <- which(tabulate(as.integer(x), x@upper_bound) == 0L)\n        NativeNSBS(subscript, x@upper_bound)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### NSBS() constructor\n###\n\nsetGeneric(\"NSBS\", signature=\"i\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n        standardGeneric(\"NSBS\")\n)\n\n### Used in IRanges.\n### We use 'call.=FALSE' to hide the function call because displaying it seems\n### to confuse some users.\n.subscript_error <- function(...) stop(wmsg(...), call.=FALSE)\n\nsetMethod(\"NSBS\", \"NSBS\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        x_NROW <- NROW(x)\n        if (i@upper_bound != x_NROW ||\n            i@upper_bound_is_strict < strict.upper.bound)\n            .subscript_error(\n                \"subscript is a NSBS object that is incompatible \",\n                \"with the current subsetting operation\"\n            )\n        if (!allow.NAs && i@has_NAs)\n            .subscript_error(\"subscript contains NAs\")\n        i\n    }\n)\n\n### Handle any array-like object with at most one effective dimension, and\n### turn it into a vector with as.vector().\nsetMethod(\"NSBS\", \"ANY\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        i_dim <- dim(i)\n        if (length(i_dim) == 0L)\n            .subscript_error(\"invalid subscript\")\n        if (sum(i_dim != 1L) >= 2L)\n            .subscript_error(\"array-like subscript has more \",\n                             \"than one effective dimension\")\n        #warning(wmsg(\"subscript is an array or array-like object, \",\n        #             \"passing it thru as.vector() first\"))\n        i <- as.vector(i)\n        callGeneric()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### NativeNSBS objects\n###\n\nsetClass(\"NativeNSBS\",  # not exported\n    contains=\"NSBS\",\n    representation(\n        subscript=\"integer\"\n    ),\n    prototype(\n        subscript=integer(0)\n    )\n)\n\n### Low-level constructor.\n### Supplied arguments are trusted so we don't check them!\nNativeNSBS <- function(subscript, upper_bound,\n                       upper_bound_is_strict=TRUE, has_NAs=FALSE)\n    new2(\"NativeNSBS\", subscript=subscript,\n                       upper_bound=upper_bound,\n                       upper_bound_is_strict=upper_bound_is_strict,\n                       has_NAs=has_NAs,\n                       check=FALSE)\n\nsetMethod(\"as.integer\", \"NativeNSBS\", function(x) x@subscript)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### RangeNSBS objects\n###\n\nsetClass(\"RangeNSBS\",  # not exported\n    contains=\"NSBS\",\n    representation(\n        subscript=\"integer\"\n    ),\n    prototype(\n        subscript=c(1L, 0L)\n    )\n)\n\n### Low-level constructor.\n### Replacement for IRanges:::solveUserSEWForSingleSeq()\n### TODO: Get rid of IRanges:::solveUserSEWForSingleSeq() and use RangeNSBS()\n### instead.\n\n.normarg_range_start <- function(start, argname=\"start\")\n{\n    if (!isSingleNumberOrNA(start))\n        .subscript_error(\"'\", argname, \"' must be a single number or NA\")\n    if (!is.integer(start))\n        start <- as.integer(start)\n    start\n}\n\nRangeNSBS <- function(x, start=NA, end=NA, width=NA)\n{\n    x_NROW <- NROW(x)\n    start <- .normarg_range_start(start, \"start\")\n    end   <- .normarg_range_start(end, \"end\")\n    width <- .normarg_range_start(width, \"width\")\n    if (is.na(width)) {\n        if (is.na(start))\n            start <- 1L\n        if (is.na(end))\n            end <- x_NROW\n    } else if (is.na(start) != is.na(end)) {\n        if (is.na(start)) {\n            start <- end - width + 1L\n        } else {\n            end <- start + width - 1L\n        }\n    } else {\n        if (is.na(start) && is.na(end)) {\n            start <- 1L\n            end <- x_NROW\n        }\n        if (width != end - start + 1L)\n            stop(\"the supplied 'start', 'end', and 'width' are incompatible\")\n    }\n    if (!(start >= 1L && start - 1L <= x_NROW && end <= x_NROW && end >= 0L))\n        stop(\"the specified range is out-of-bounds\")\n    if (end < start - 1L)\n        stop(\"the specified range has a negative width\")\n    new2(\"RangeNSBS\", subscript=c(start, end),\n                      upper_bound=x_NROW,\n                      check=FALSE)\n}\n\nsetMethod(\"as.integer\", \"RangeNSBS\",\n    function(x)\n    {\n        range <- x@subscript\n        range_start <- range[[1L]]\n        range_end <- range[[2L]]\n        if (range_end < range_start)\n            return(integer(0))\n        seq.int(range_start, range_end)\n    }\n)\n\n### We override the fallback methods defined for NSBS objects with more\n### efficient ones.\n\nsetMethod(\"length\", \"RangeNSBS\",\n    function(x)\n    {\n        range <- x@subscript\n        range_start <- range[[1L]]\n        range_end   <- range[[2L]]\n        range_end - range_start + 1L\n    }\n)\n\nsetMethod(\"anyDuplicated\", \"RangeNSBS\",\n    function(x, incomparables=FALSE, ...) 0L\n)\n\nsetMethod(\"isStrictlySorted\", \"RangeNSBS\", function(x) TRUE)\n\nsetMethod(\"max\", \"RangeNSBS\",\n    function(x, ..., na.rm=FALSE) max(x@subscript[[2L]], ..., na.rm=na.rm)\n)\n\n### Can return a NativeNSBS, RangeNSBS, or RangesNSBS object.\nsetMethod(\"complementNSBS\", \"RangeNSBS\",\n    function(x)\n    {\n        range <- x@subscript\n        range_start <- range[[1L]]\n        range_end   <- range[[2L]]\n        if (range_start <= 1L) {\n            if (range_end >= x@upper_bound)\n                return(NativeNSBS(integer(0), x@upper_bound))\n            ## Complement has 1 range.\n            subscript <- c(range_end + 1L, x@upper_bound)\n        } else {\n            if (range_end < x@upper_bound) {\n                ## Complement has 2 ranges.\n                if (!requireNamespace(\"IRanges\", quietly=TRUE))\n                    stop(wmsg(\"This operation requires the IRanges package. \",\n                              \"Please install it and try again.\"))\n                starts <- c(1L, range_end + 1L)\n                ends   <- c(range_start - 1L, x@upper_bound)\n                subscript <- IRanges::IRanges(starts, ends)\n                ans <- new2(\"RangesNSBS\", subscript=subscript,\n                                          upper_bound=x@upper_bound,\n                                          check=FALSE)\n                return(ans)\n            }\n            ## Complement has 1 range.\n            subscript <- c(1L, range_start - 1L)\n        }\n        new2(\"RangeNSBS\", subscript=subscript,\n                          upper_bound=x@upper_bound,\n                          check=FALSE)\n    }\n)\n\nsetMethod(\"show\", \"RangeNSBS\",\n    function(object)\n    {\n        range <- object@subscript\n        range_start <- range[[1L]]\n        range_end   <- range[[2L]]\n        cat(sprintf(\"%d:%d%s / 1:%d%s\\n\",\n                    range_start, range_end,\n                    if (length(object) == 0L) \" (empty)\" else \"\",\n                    object@upper_bound,\n                    if (object@upper_bound == 0L) \" (empty)\" else \"\"))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### More NSBS() constructor methods\n###\n\nsetMethod(\"NSBS\", \"missing\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        RangeNSBS(x, start=1L, end=NROW(x))\n    }\n)\n\n\nsetMethod(\"NSBS\", \"NULL\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        x_NROW <- NROW(x)\n        i <- integer(0)\n        NativeNSBS(i, x_NROW, strict.upper.bound)\n    }\n)\n\n.NSBS.numeric <- function(i, x, exact=TRUE,\n                          strict.upper.bound=TRUE, allow.NAs=FALSE)\n{\n    x_NROW <- NROW(x)\n    if (is.integer(i)) {\n        if (!is.null(names(i)))\n            names(i) <- NULL\n    } else {\n        i <- as.integer(i)  # this also drops the names\n    }\n    has_NAs <- anyNA(i)\n    if (!allow.NAs && has_NAs)\n        .subscript_error(\"subscript contains NAs\")\n    ## Strangely, this is much faster than using range().\n    i_max <- suppressWarnings(max(i, na.rm=TRUE))\n    i_min <- suppressWarnings(min(i, na.rm=TRUE))\n    if (strict.upper.bound && i_max > x_NROW)\n        .subscript_error(\"subscript contains out-of-bounds indices\")\n    if (i_min < 0L) {\n        ## Translate into positive indices.\n        i <- seq_len(x_NROW)[i]\n    } else {\n        ## Remove 0's from subscript.\n        zero_idx <- which(!is.na(i) & i == 0L)\n        if (length(zero_idx) != 0L)\n            i <- i[-zero_idx]\n    }\n    NativeNSBS(i, x_NROW, strict.upper.bound, has_NAs)\n}\n\nsetMethod(\"NSBS\", \"numeric\", .NSBS.numeric)\n\nsetMethod(\"NSBS\", \"logical\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        x_NROW <- NROW(x)\n        if (anyNA(i))\n            .subscript_error(\"logical subscript contains NAs\")\n        if (!is.null(names(i)))\n            names(i) <- NULL\n        li <- length(i)\n        if (strict.upper.bound && li > x_NROW) {\n            if (any(i[(x_NROW+1L):li]))\n                .subscript_error(\n                    \"subscript is a logical vector with out-of-bounds \",\n                     \"TRUE values\"\n                )\n            i <- i[seq_len(x_NROW)]\n        }\n        if (li < x_NROW)\n            i <- rep(i, length.out=x_NROW)\n        i <- which(i)\n        NativeNSBS(i, x_NROW, strict.upper.bound)\n    }\n)\n\n.NSBS.character_OR_factor <- function(i, x, exact=TRUE,\n                                      strict.upper.bound=TRUE, allow.NAs=FALSE)\n{\n    x_NROW <- NROW(x)\n    x_ROWNAMES <- ROWNAMES(x)\n    ## The only reason we use suppressWarnings() here is to suppress the\n    ## deprecation warning we get at the moment (BioC 3.14) when calling dim()\n    ## on a DataFrameList derivative. Remove when the method is gone (when\n    ## this happens, dim() will return NULL on a DataFrameList derivative).\n    x_dim <- suppressWarnings(dim(x))\n    what <- if (length(x_dim) != 0L) \"rownames\" else \"names\"\n    if (is.null(x_ROWNAMES)) {\n        if (strict.upper.bound)\n            .subscript_error(\"cannot subset by character when \", what,\n                             \" are NULL\")\n        i <- x_NROW + seq_along(i)\n        return(NativeNSBS(i, x_NROW, FALSE))\n    }\n    i <- .match_name(i, x_ROWNAMES, exact=exact)\n    if (!strict.upper.bound) {\n        na_idx <- which(is.na(i))\n        i[na_idx] <- x_NROW + seq_along(na_idx)\n        return(NativeNSBS(i, x_NROW, FALSE))\n    }\n    has_NAs <- anyNA(i)\n    if (!allow.NAs && has_NAs)\n        .subscript_error(\"subscript contains invalid \", what)\n    NativeNSBS(i, x_NROW, strict.upper.bound, has_NAs)\n}\n\nsetMethod(\"NSBS\", \"character\", .NSBS.character_OR_factor)\n\nsetMethod(\"NSBS\", \"factor\", .NSBS.character_OR_factor)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normalizeSingleBracketSubscript()\n###\n### Must return an unnamed integer vector when 'as.NSBS' is FALSE.\n###\n\nnormalizeSingleBracketSubscript <- function(i, x, exact=TRUE,\n                                            allow.append=FALSE,\n                                            allow.NAs=FALSE,\n                                            as.NSBS=FALSE)\n{\n    if (!isTRUEorFALSE(exact))\n        stop(\"'exact' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(allow.append))\n        stop(\"'allow.append' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(as.NSBS))\n        stop(\"'as.NSBS' must be TRUE or FALSE\")\n    if (missing(i)) {\n        i <- NSBS( , x, exact=exact, strict.upper.bound=!allow.append,\n                        allow.NAs=allow.NAs)\n    } else {\n        i <- NSBS(i, x, exact=exact, strict.upper.bound=!allow.append,\n                        allow.NAs=allow.NAs)\n    }\n    if (!as.NSBS)\n        i <- as.integer(i)\n    i\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normalizeSingleBracketReplacementValue()\n###\n\n### Dispatch on the 2nd argument!\nsetGeneric(\"normalizeSingleBracketReplacementValue\", signature=\"x\",\n    function(value, x)\n        standardGeneric(\"normalizeSingleBracketReplacementValue\")\n)\n\n### Default method.\nsetMethod(\"normalizeSingleBracketReplacementValue\", \"ANY\",\n    function(value, x)\n    {\n        if (is(value, class(x)))\n            return(value)\n        value_len <- length(value)\n        value <- try(as(value, class(x)), silent=TRUE)\n        if (inherits(value, \"try-error\"))\n            stop(\"'value' must be a \", class(x), \" object (or coercible \",\n                 \"to a \", class(x), \" object)\")\n        if (length(value) != value_len)\n            stop(\"coercing replacement value to \", class(x), \"\\n\",\n                 \"  changed its length!\\n\",\n                 \"  Please do the explicit coercion \",\n                 \"yourself with something like:\\n\",\n                 \"    x[...] <- as(value, \\\"\", class(x), \"\\\")\\n\",\n                 \"  but first make sure this coercion does what you want.\")\n        value\n    }\n)\n\nsetMethod(\"normalizeSingleBracketReplacementValue\", \"List\",\n          function(value, x)\n          {\n              if (is.null(value))\n                  return(NULL)\n              callNextMethod()\n          }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### recycleSingleBracketReplacementValue()\n###\n\nrecycleSingleBracketReplacementValue <- function(value, x, i) {\n    if (is.null(value))\n        return(NULL)\n    i <- normalizeSingleBracketSubscript(i, x, allow.append=TRUE, as.NSBS=TRUE)\n    li <- length(i)\n    if (li == 0L)\n        return(value)\n    lv <- NROW(value)\n    if (lv == 0L)\n        stop(\"replacement has length zero\")\n    if (li != lv) {\n        if (li %% lv != 0L)\n            warning(\"number of values supplied is not a sub-multiple \",\n                    \"of the number of values to be replaced\")\n        value <- extractROWS(value, rep(seq_len(lv), length.out=li))\n    }\n    value\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extractROWS(), replaceROWS(), mergeROWS(), extractCOLS(), replaceCOLS()\n###\n### 5 internal generics to ease implementation of [ and [<- subsetting for\n### Vector and DataFrame subclasses.\n###\n### A Vector subclass Foo should only need to implement an \"extractROWS\" and\n### \"replaceROWS\" method to make \"[\" and \"[<-\" work out-of-the-box.\n### extractROWS() does NOT need to support a missing 'i' so \"extractROWS\"\n### methods don't need to do 'if (missing(i)) return(x)'.\n### For replaceROWS(), it's OK to assume that 'value' is \"compatible\" with 'x'\n### i.e. that it has gone thru normalizeSingleBracketReplacementValue().\n### See \"extractROWS\" and \"replaceROWS\" methods for Hits objects for an\n### example.\n###\n### mergeROWS() is a composition of replaceROWS() and bindROWS() to\n### support appending in [<-(). Vector subclasses never need to\n### implement mergeROWS(), but a custom method may be useful for\n### e.g. optimization.\n###\n\nsetGeneric(\"extractROWS\", signature=c(\"x\", \"i\"),\n    function(x, i) standardGeneric(\"extractROWS\")\n)\n\nsetGeneric(\"replaceROWS\", signature=c(\"x\", \"i\"),\n    function(x, i, value) standardGeneric(\"replaceROWS\")\n)\n\nsetGeneric(\"mergeROWS\", signature=c(\"x\", \"i\"),\n    function(x, i, value) standardGeneric(\"mergeROWS\")\n)\n\nsetGeneric(\"extractCOLS\", signature=c(\"x\", \"i\"),\n    function(x, i) standardGeneric(\"extractCOLS\")\n)\n\nsetGeneric(\"replaceCOLS\", signature=c(\"x\", \"i\"),\n    function(x, i, value) standardGeneric(\"replaceCOLS\")\n)\n\ndefault_extractROWS <- function(x, i)\n{\n    if (is.null(x) || missing(i))\n        return(x)\n    i <- normalizeSingleBracketSubscript(i, x, allow.NAs=TRUE,\n                                               allow.append=TRUE)\n    x_dim <- dim(x)\n    if (is.null(x_dim))\n        return(x[i])\n    ## Call x[i,,,..,drop=FALSE] with as many \",\" as 'ndim'.\n    ndim <- max(length(x_dim), 1L)\n    args <- rep.int(list(quote(expr=)), ndim)\n    args[[1L]] <- i\n    args <- c(list(x), args, list(drop=FALSE))\n    do.call(`[`, args)\n}\n\ndefault_replaceROWS <- function(x, i, value)\n{\n    mergeROWS(x, i, value)\n}\n\ndefault_mergeROWS <- function(x, i, value)\n{\n  if (is.null(x))\n    return(x)\n  ndim <- max(length(dim(x)), 1L)\n  i <- normalizeSingleBracketSubscript(i, x, allow.append=TRUE)\n  args <- rep.int(list(quote(expr=)), ndim)\n  args[[1]] <- i\n  args <- c(list(x), args, list(value=value))\n  do.call(`[<-`, args)\n}\n\nsetMethod(\"extractROWS\", c(\"ANY\", \"ANY\"), default_extractROWS)\n\n### NOT exported but used in IRanges package (by \"extractROWS\" method with\n### signature vector_OR_factor,RangesNSBS).\nextract_ranges_from_vector_OR_factor <- function(x, start, width)\n{\n    .Call2(\"vector_OR_factor_extract_ranges\", x, start, width,\n                                              PACKAGE=\"S4Vectors\")\n}\n\nsetMethod(\"extractROWS\", c(\"vector_OR_factor\", \"RangeNSBS\"),\n    function(x, i)\n    {\n        start <- i@subscript[[1L]]\n        width <- i@subscript[[2L]] - start + 1L\n        extract_ranges_from_vector_OR_factor(x, start, width)\n    }\n)\n\nsetMethod(\"extractROWS\", c(\"array\", \"RangeNSBS\"), default_extractROWS)\nsetMethod(\"extractROWS\", c(\"data.frame\", \"RangeNSBS\"), default_extractROWS)\n\n### NOT exported but will be used in IRanges package (by \"extractROWS\" method\n### with signature LLint,RangesNSBS).\nextract_ranges_from_LLint <- function(x, start, width)\n{\n    start <- (start - 1L) * BYTES_PER_LLINT + 1L\n    width <- width * BYTES_PER_LLINT\n    x@bytes <- extract_ranges_from_vector_OR_factor(x@bytes, start, width)\n    x\n}\n\nsetMethod(\"extractROWS\", c(\"LLint\", \"RangeNSBS\"),\n    function(x, i)\n    {\n        start <- i@subscript[[1L]]\n        width <- i@subscript[[2L]] - start + 1L\n        extract_ranges_from_LLint(x, start, width)\n    }\n)\n\nsetMethod(\"extractROWS\", c(\"LLint\", \"NSBS\"),\n    function(x, i)\n    {\n        start <- as.integer(i)\n        width <- rep.int(1L, length(start))\n        extract_ranges_from_LLint(x, start, width)\n    }\n)\n\nsetMethod(\"extractROWS\", c(\"LLint\", \"ANY\"),\n    function (x, i)\n    {\n        ## We don't support NAs in the subscript yet.\n        #i <- normalizeSingleBracketSubscript(i, x, allow.NAs=TRUE,\n        #                                           as.NSBS=TRUE)\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        callGeneric()\n    }\n)\n\nsubset_along_ROWS <- function(x, i, j, ..., drop=TRUE)\n{\n    if (!missing(j) || length(list(...)) > 0L)\n        stop(\"invalid subsetting\")\n    if (missing(i))\n        return(x)\n    extractROWS(x, i)\n}\n\nsetMethod(\"[\", \"LLint\", subset_along_ROWS)\n\nsetMethod(\"replaceROWS\", c(\"ANY\", \"ANY\"), default_replaceROWS)\n\nsetMethod(\"mergeROWS\", c(\"ANY\", \"ANY\"), default_mergeROWS)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normalizeDoubleBracketSubscript()\n###\n### The supplied subscript 'i' must represent (1) a single non-NA number,\n### or (2) a single non-NA string, or (3) a single NA (only if 'allow.NA'\n### is TRUE). It must be represented as an ordinary atomic vector or Rle\n### object of length 1. More precisely:\n###  (1) A single non-NA number must be represented as an integer or numeric\n###      vector of length 1, or as an integer- or numeric-Rle object of\n###      length 1. It must be >= 1 and <= length(x), except if 'allow.append'\n###      is TRUE, in which case it must be >= 1 and <= length(x) + 1.\n###      If these conditions are satisfied, the subscript is returned as a\n###      single integer. Otherwise an error is raised.\n###  (2) A single non-NA string must be represented as a character vector or\n###      factor of length 1, or as a character- or factor-Rle object of\n###      length 1. It must match a name on 'x', except if 'allow.nomatch' is\n###      TRUE, in which case it doesn't have to match a name on 'x'.\n###      If these conditions are satisfied, the position of the match or NA\n###      is returned. Otherwise an error is raised.\n###  (3) A single NA must be represented as an atomic vector (of any type)\n###      or Rle object of length 1. It is returned as a single logical NA.\n### Return a single integer that is >= 1 and <= length(x).\n###\n\nnormalizeDoubleBracketSubscript <- function(i, x, exact=TRUE,\n                                            allow.append=FALSE,\n                                            allow.NA=FALSE,\n                                            allow.nomatch=FALSE)\n{\n    if (missing(i))\n        stop(\"subscript is missing\")\n    if (!isTRUEorFALSE(exact))\n        stop(\"'exact' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(allow.append))\n        stop(\"'allow.append' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(allow.NA))\n        stop(\"'allow.NA' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(allow.nomatch))\n        stop(\"'allow.nomatch' must be TRUE or FALSE\")\n    subscript_type <- class(i)\n    if (is(i, \"Rle\")) {\n        i <- decodeRle(i)\n        subscript_type <- paste0(class(i), \"-\", subscript_type)\n    }\n    if (is.factor(i))\n        i <- as.character(i)\n    if (is.vector(i) && length(i) == 1L && is.na(i)) {\n        if (!allow.NA)\n            stop(\"NA is not a valid [[ subscript\")\n        return(NA)\n    }\n    if (!(is.numeric(i) || is.character(i)))\n        stop(\"invalid [[ subscript type: \", subscript_type)\n    if (length(i) < 1L)\n        stop(\"attempt to extract less than one element\")\n    if (length(i) > 1L)\n        stop(\"attempt to extract more than one element\")\n    x_len <- length(x)\n    if (is.numeric(i)) {\n        if (!is.integer(i))\n            i <- as.integer(i)\n        if (i < 1L)\n            stop(\"[[ subscript must be >= 1\")\n        if (allow.append) {\n            if (i > x_len + 1L)\n                stop(\"[[ subscript must be <= length(x) + 1\")\n        } else {\n            if (i > x_len)\n                stop(\"subscript is out of bounds\")\n        }\n        return(i)\n    }\n    ## 'i' is a single non-NA string.\n    x_names <- names(x)\n    if (is.null(x_names)) {\n        if (!allow.nomatch)\n            stop(\"attempt to extract by name when elements have no names\")\n        return(NA)\n    }\n    #if (i == \"\")\n    #    stop(\"invalid subscript \\\"\\\"\")\n    ans <- .match_name(i, x_names, exact=exact)\n    if (is.na(ans)) {\n        if (!allow.nomatch)\n            stop(\"subscript \\\"\", i, \"\\\" matches no name\")\n        return(NA)\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 2 internal generics to ease implementation of [[ and [[<- subsetting for\n### new List subclasses.\n###\n\nsetGeneric(\"getListElement\", signature=\"x\",\n    function(x, i, exact=TRUE) standardGeneric(\"getListElement\")\n)\n\nsetGeneric(\"setListElement\", signature=\"x\",\n    function(x, i, value) standardGeneric(\"setListElement\")\n)\n\n### Note that although is(x, \"list\") is FALSE on a data.frame (a non-sense\n### that some people will find a way to justify), dispatch will call this\n### method if 'x' is a data.frame.\nsetMethod(\"getListElement\", \"list\",\n    function(x, i, exact=TRUE)\n    {\n        i2 <- normalizeDoubleBracketSubscript(i, x, exact=exact,\n                                              allow.NA=TRUE,\n                                              allow.nomatch=TRUE)\n        if (is.na(i2))\n            return(NULL)\n        x[[i2]]\n    }\n)\n\n### Based on `[`. This should automatically take care of removing the\n### corresponding row in 'mcols(x)' if 'x' is a Vector derivative.\n.remove_list_element <- function(x, i)\n{\n    stopifnot(isSingleNumberOrNA(i))\n    if (is.na(i) || i < 1L || i > length(x))\n        return(x)  # no-op\n    ## `[<-.data.frame` does some terrible mangling of the colnames\n    ## if they contain duplicates so we can't use it here.\n    if (is.data.frame(x)) {\n        x[[i]] <- NULL\n        return(x)\n    }\n    x[-i]\n}\n\n.wrap_in_length_one_list_like_object <- function(value, name, x)\n{\n    stopifnot(is(x, \"list_OR_List\"))\n    stopifnot(is.null(name) || isSingleStringOrNA(name))\n    if (is(x, \"List\")) {\n        tmp <- try(as(value, elementType(x), strict=FALSE), silent=TRUE)\n        if (!inherits(tmp, \"try-error\"))\n            value <- tmp\n    }\n    value <- setNames(list(value), name)\n    value <- try(coerce2(value, x), silent=TRUE)\n    if (inherits(value, \"try-error\"))\n        stop(wmsg(\"failed to coerce 'list(value)' to a \", class(x),\n                  \" object of length 1\"))\n    value\n}\n\n### Based on 'c()'. This should automatically take care of adjusting the\n### metadata columns (by rbind'ing a row of NAs to 'mcols(x)') if 'x' is\n### a Vector derivative.\n.append_list_element <- function(x, value, name=NULL)\n{\n    if (is.null(name) && !is.null(names(x)))\n        name <- \"\"\n    value <- .wrap_in_length_one_list_like_object(value, name, x)\n    coerce2(c(x, value), x)\n}\n\n### Based on `[<-`.\n.replace_list_element <- function(x, i, value)\n{\n    value <- .wrap_in_length_one_list_like_object(value, names(x)[[i]], x)\n    ## `[<-` propagates the metadata columns from 'value' to 'x' but here\n    ## we don't want that.\n    if (is(x, \"Vector\"))\n        x_mcols <- mcols(x, use.names=FALSE)\n    x[i] <- value\n    if (is(x, \"Vector\"))\n        mcols(x) <- x_mcols\n    x\n}\n\n### Work on any list-like object for which `[<-`, c(), and `[` work.\n### Also, if 'value' is not NULL, 'list(value)' must be coercible to a\n### length-one list-like object of the same class as 'x'.\nsetListElement_default <- function(x, i, value)\n{\n    i2 <- normalizeDoubleBracketSubscript(i, x,\n                                          allow.append=TRUE,\n                                          allow.nomatch=TRUE)\n    if (is.null(value))\n        return(.remove_list_element(x, i2))\n    if (is.na(i2) || i2 > length(x)) {\n        name <- if (is.na(i2)) as.character(i) else NULL\n        return(.append_list_element(x, value, name))\n    }\n    .replace_list_element(x, i2, value)\n}\n\n### Note that although is(x, \"list\") is FALSE on a data.frame (a non-sense\n### that some people will find a way to justify), dispatch will call this\n### method if 'x' is a data.frame.\nsetMethod(\"setListElement\", \"list\", setListElement_default)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### window(), head(), tail(), rep.int()\n###\n\n### S3/S4 combo for window.LLint\nwindow_along_ROWS <- function(x, start=NA, end=NA, width=NA)\n{\n    i <- RangeNSBS(x, start=start, end=end, width=width)\n    extractROWS(x, i)\n}\nwindow.LLint <- function(x, ...) window_along_ROWS(x, ...)\nsetMethod(\"window\", \"LLint\", window.LLint)\n\n### S3/S4 combo for head.LLint\nhead_along_ROWS <- function(x, n=6L)\n{\n    if (!isSingleNumber(n))\n        stop(\"'n' must be a single integer\")\n    if (!is.integer(n))\n        n <- as.integer(n)\n    x_NROW <- NROW(x)\n    if (n >= 0L) {\n        n <- min(x_NROW, n)\n    } else {\n        n <- max(0L, x_NROW + n)\n    }\n    window(x, start=1L, width=n)\n}\nhead.LLint <- function(x, ...) head_along_ROWS(x, ...)\nsetMethod(\"head\", \"LLint\", head.LLint)\n\n### S3/S4 combo for tail.LLint\ntail_along_ROWS <- function(x, n=6L)\n{\n    if (!isSingleNumber(n))\n        stop(\"'n' must be a single integer\")\n    if (!is.integer(n))\n        n <- as.integer(n)\n    x_NROW <- NROW(x)\n    if (n >= 0L) {\n        n <- min(x_NROW, n)\n    } else {\n        n <- max(0L, x_NROW + n)\n    }\n    window(x, end=x_NROW, width=n)\n}\ntail.LLint <- function(x, ...) tail_along_ROWS(x, ...)\nsetMethod(\"tail\", \"LLint\", tail.LLint)\n\nrep.int_along_ROWS <- function(x, times)\n{\n    if (!(is.numeric(times) || is.LLint(times)))\n        stop(\"'times' must be a numeric or LLint vector\")\n    x_NROW <- NROW(x)\n    times_len <- length(times)\n    if (times_len == 1L) {\n        if (times == 1L)\n            return(x)\n        if (times == 0L)\n            return(extractROWS(x, integer(0)))\n    }\n    if (times_len == x_NROW) {\n        i <- Rle(seq_len(x_NROW), times)\n    } else if (times_len == 1L) {\n        if (is.LLint(times))\n            times <- as.double(times)\n        i <- IRanges::IRanges(rep.int(1L, times), rep.int(x_NROW, times))\n    } else {\n        stop(\"invalid 'times' value\")\n    }\n    extractROWS(x, i)\n}\n\nsetMethod(\"rep.int\", \"LLint\", rep.int_along_ROWS)\n\n",
        "utils.R": "### =========================================================================\n### Miscellaneous low-level utils\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, nothing in this file is exported.\n###\n\n\n### Wrap the message in lines that don't exceed the terminal width (obtained\n### with 'getOption(\"width\")'). Usage:\n###   stop(wmsg(...))\n###   warning(wmsg(...))\n###   message(wmsg(...))\n### Argument 'margin' added in S4Vectors 0.45.1 and used in package igblastr.\nwmsg <- function(..., margin=2)\n{\n    width <- getOption(\"width\") - margin\n    paste0(strwrap(paste0(c(...), collapse=\"\"), width=width),\n           collapse=paste0(\"\\n\", strrep(\" \", margin)))\n}\n\nerrorIfWarning <- function(expr)\n{\n    old_options <- options(warn=2)        \n    on.exit(options(old_options))\n    eval(expr)\n}\n\n.AEbufs_use_malloc <- function(x)\n    .Call(\"AEbufs_use_malloc\", x, PACKAGE=\"S4Vectors\")\n\n.AEbufs_free <- function()\n    .Call(\"AEbufs_free\", PACKAGE=\"S4Vectors\")\n\n### Exported!\n.Call2 <- function(.NAME, ..., PACKAGE)\n{\n    ## Uncomment the 2 lines below to switch from R_alloc- to malloc-based\n    ## Auto-Extending buffers.\n    #.AEbufs_use_malloc(TRUE)\n    #on.exit({.AEbufs_free(); .AEbufs_use_malloc(FALSE)})    \n    .Call(.NAME, ..., PACKAGE=PACKAGE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Functional fun\n###\n\nHas <- function(FUN) {\n  function(x) {\n    !is.null(FUN(x))\n  }\n}\n\n",
        "vector-utils.R": "### =========================================================================\n### Some low-level (not exported) utility functions to operate on ordinary\n### vectors (including lists and data frames)\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, nothing in this file is exported.\n###\n\n\nlast_or <- function(x, or)\n{\n    x_len <- length(x)\n    if (x_len != 0L) x[[x_len]] else or\n}\n\n### TODO: Maybe implement sapply_isNULL in C? Also maybe\n### Implement (in C) fast 'elementIs(objects, class)' that does\n###\n###     sapply(objects, is, class, USE.NAMES=FALSE)\n###\n### and use it here. 'elementIs(objects, \"NULL\")' should work and be\n### equivalent to 'sapply_isNULL(objects)'.\nsapply_isNULL <- function(objects)\n    vapply(objects, is.null, logical(1), USE.NAMES=FALSE)\n\n### TODO: Maybe implement this in C?\ndelete_NULLs <- function(objects)\n{\n    NULL_idx <- which(sapply_isNULL(objects))\n    if (length(NULL_idx) != 0L)\n        objects <- objects[-NULL_idx]\n    objects\n}\n\nsapply_NROW <- function(x)\n{\n    if (!is.list(x))\n        x <- as.list(x)\n    ans <- try(.Call2(\"sapply_NROW\", x, PACKAGE=\"S4Vectors\"), silent=TRUE)\n    if (!inherits(ans, \"try-error\")) {\n        names(ans) <- names(x)\n        return(ans)\n    }\n    ## From here, 'length(x)' is guaranteed to be != 0\n    return(vapply(x, NROW, integer(1)))\n}\n\n### Return the common ancestor class **among** the classes of the list elements\n### in 'x', or \"ANY\". In other words, if all the classes in 'x' extend one of\n### them, then lowestListElementClass() returns it. Otherwise, it returns \"ANY\".\n### As a consequence, lowestListElementClass() is guaranteed to always return a\n### **concrete** class or \"ANY\".\n###\n### For example:\n###\n###   classes in 'x'              lowestListElementClass\n###   -------------------------   ----------------------\n###   all the same                common class\n###   integer,numeric             \"numeric\"\n###   integer,factor              \"integer\"\n###   numeric,factor              \"numeric\"\n###   integer,numeric,character   \"ANY\"\n###   character,factor            \"ANY\"\n###   matrix, data.frame          \"ANY\"\n###   character,list              \"ANY\"\n###\n### If the class to return is an S4 class, make sure to return it with\n### its \"package\" attribute!\n\n.unique_classes <- function(classes)\n{\n    stopifnot(is.list(classes))\n\n    classnames <- vapply(classes,\n        function(cl) cl[[1L]],\n        character(1), USE.NAMES=FALSE)\n\n    pkgs <- vapply(classes,\n        function(cl) {\n            pkg <- attr(cl, \"package\")\n            if (is.null(pkg)) \"\" else pkg\n        }, character(1), USE.NAMES=FALSE)\n\n    is_dup <- duplicatedIntegerPairs(selfmatch(classnames),\n                                     selfmatch(pkgs))\n    classes[!is_dup]\n}\n\nlowestListElementClass <- function(objects)\n{\n    stopifnot(is.list(objects))\n\n    if (length(objects) == 0L)\n        return(\"ANY\")\n\n    all_classes <- lapply(objects,\n        function(object) {\n            cl <- class(object)\n            if (is.null(attr(cl, \"package\"))) cl[[1L]] else cl\n        })\n    unique_classes <- .unique_classes(all_classes)\n    n <- length(unique_classes)\n    if (n == 1L)\n        return(unique_classes[[1L]])\n\n    ## Find common ancestor candidate.\n    ans <- unique_classes[[1L]]\n    for (i in 2:n) {\n        cl <- unique_classes[[i]]\n        if (extends(ans, cl))\n            ans <- cl\n    }\n\n    ## Do all classes extend 'ans'?\n    for (i in seq_len(n)) {\n        cl <- unique_classes[[i]]\n        if (!extends(cl, ans))\n            return(\"ANY\")  # no\n    }\n\n    ans  # yes!\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### map_inner_ROWS_to_list_elements()\n###\n\nmap_inner_ROWS_to_list_elements <- function(NROWS, as.factor=FALSE)\n{\n    stopifnot(is.integer(NROWS), isTRUEorFALSE(as.factor))\n    groups <- seq_along(NROWS)\n    ans <- rep.int(groups, NROWS)\n    if (as.factor)\n        ans <- structure(ans, levels=as.character(groups), class=\"factor\")\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### quick_unlist()\n###\n### Assumes that 'x' is a list of length >= 1 with no names, and that the\n### list elements in 'x' have the same type. This is NOT checked!\n### TODO: quick_unlist() is superseded by bindROWS(). Search code\n### for use of quick_unlist() and replace with use of bindROWS().\n### Then remove quick_unlist() definition below.\n###\n\nquick_unlist <- function(x)\n{\n    x1 <- x[[1L]]\n    if (is.factor(x1)) {\n        ## Fast unlisting of a list of factors that all have the same levels\n        ## in the same order.\n        structure(unlist(x), levels=levels(x1), class=\"factor\")\n    } else {\n        do.call(c, x)  # doesn't work on list of factors\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### quick_unsplit()\n###\n### Assumes that 'x' is a list of length >= 1 with no names, and that the\n### list elements in 'x' have the same type. This is NOT checked!\n###\n\nquick_unsplit <- function(x, f)\n{\n    idx <- split(seq_along(f), f)\n    idx <- unlist(idx, use.names=FALSE)\n    revidx <- integer(length(idx))\n    revidx[idx] <- seq_along(idx)\n    quick_unlist(x)[revidx]\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_data_frame_rows()\n###\n### A fast version of {df <- df[i, , drop=FALSE]; rownames(df) <- NULL}.\n### Can be up to 20x or 30x faster when extracting millions of rows.\n### What kills [.data.frame is the overhead of propagating the original\n### rownames and trying to keep them unique with make.unique(). However, most\n### of the time, nobody cares about the rownames so this effort is pointless\n### and a waste of time.\n###\n\nextract_data_frame_rows <- function(x, i)\n{\n    stopifnot(is.data.frame(x))\n    i <- normalizeSingleBracketSubscript(i, x, exact=FALSE, allow.NAs=TRUE)\n    ans <- lapply(x, \"[\", i)\n    ## Do NOT use data.frame() or as.data.frame() here as it adds a lot of\n    ## overhead and will mess up non-atomic columns.\n    #data.frame(ans, check.names=FALSE, stringsAsFactors=FALSE)\n    attr(ans, \"row.names\") <- seq_along(i)\n    attr(ans, \"class\") <- \"data.frame\"\n    ans\n}\n\n",
        "zzz.R": "###\n\n.onLoad <- function(libname, pkgname)\n{\n    ns <- asNamespace(pkgname)\n\n    objname <- \"NA_LLint_\"\n    NA_LLint_ <- make_NA_LLint_()\n    assign(objname, NA_LLint_, envir=ns)\n    namespaceExport(ns, objname)\n}\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"S4Vectors\", libpath)\n}\n\n.test <- function() BiocGenerics:::testPackage(\"S4Vectors\")\n\n"
    },
    "zlibbioc": {
        "zzz.R": ".onLoad <-\n    function(libname, pkgname)\n{\n    ## make DLL available for Windows; others use static library\n    if (\"windows\" == .Platform$OS.type) {\n        dll <- file.path(libname, pkgname, \"libs\", .Platform$r_arch,\n                         \"zlib1bioc.dll\")\n        dyn.load(dll)\n    }\n}\n\npkgconfig <-\n    function(opt=c(\"PKG_CFLAGS\", \"PKG_LIBS_static\",\n               \"PKG_LIBS_shared\"))\n{\n    opt <- match.arg(opt)\n    pth <- system.file(\"libs\", package=\"zlibbioc\", mustWork=TRUE)\n    if (nzchar(.Platform$r_arch)) {\n        arch <- sprintf(\"/%s\", .Platform$r_arch)\n    } else {\n        arch <- \"\"\n    }\n    uname <-\n        if (\"windows\" == .Platform$OS.type) \"windows\"\n        else if (\"Darwin\" == system(\"uname -s\", intern=TRUE)) \"darwin\"\n        else \"other\"\n\n    PKG_CFLAGS <-\n        switch(uname, darwin=\"\",\n               sprintf('-I\"%s\"',\n                       system.file(\"include\", package=\"zlibbioc\")))\n\n     PKG_LIBS_static <-\n        switch(uname,\n               darwin=\"-lz\",\n               sprintf('\"%s%s/libzbioc.a\"', pth, arch))\n\n     PKG_LIBS_shared <-\n        switch(uname,\n               windows=sprintf('-L\"%s%s\" -lzlib1bioc', pth, arch),\n               darwin=\"-lz\",\n               sprintf('-L\"%s%s\" -Wl,-rpath,\"%s%s\" -lzbioc', pth,\n                       arch, pth, arch))\n\n    cat(list(PKG_CFLAGS=PKG_CFLAGS, PKG_LIBS_static=PKG_LIBS_static,\n             PKG_LIBS_shared=PKG_LIBS_shared)[[opt]])\n}\n.onAttach <- function(libname, pkgname) {\n    msg <- sprintf(\n        \"Package '%s' is deprecated and will be removed from Bioconductor\n         version %s\", pkgname, \"3.22\")\n    .Deprecated(msg=paste(strwrap(msg, exdent=2), collapse=\"\\n\"))\n}\n"
    },
    "IRanges": {
        "AtomicList-class.R": "### =========================================================================\n### AtomicList objects\n### -------------------------------------------------------------------------\n\n\n## A list that holds atomic objects\n\nsetClass(\"AtomicList\", representation(\"VIRTUAL\"),\n        prototype = prototype(elementType = \"logical\"),\n        contains = \"List\")\n\nsetClass(\"LogicalList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"logical\"),\n         contains = \"AtomicList\")\n\nsetClass(\"IntegerList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"integer\"),\n         contains = \"AtomicList\")\n\nsetClass(\"NumericList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"numeric\"),\n         contains = \"AtomicList\")\n\nsetClass(\"ComplexList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"complex\"),\n         contains = \"AtomicList\")\n\nsetClass(\"CharacterList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"character\"),\n         contains = \"AtomicList\")\n\nsetClass(\"RawList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"raw\"),\n         contains = \"AtomicList\")\n\nsetClass(\"RleList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"Rle\"),\n         contains = \"AtomicList\")\n\nsetClass(\"FactorList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"factor\"),\n         contains = \"IntegerList\")\n\nsetClass(\"SimpleAtomicList\",\n         contains =  c(\"AtomicList\", \"SimpleList\"),\n         representation(\"VIRTUAL\"))\n \nsetClass(\"SimpleLogicalList\",\n         prototype = prototype(elementType = \"logical\"),\n         contains = c(\"LogicalList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleIntegerList\",\n         prototype = prototype(elementType = \"integer\"),\n         contains = c(\"IntegerList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleNumericList\",\n         prototype = prototype(elementType = \"numeric\"),\n         contains = c(\"NumericList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleComplexList\",\n         prototype = prototype(elementType = \"complex\"),\n         contains = c(\"ComplexList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleCharacterList\",\n         prototype = prototype(elementType = \"character\"),\n         contains = c(\"CharacterList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleRawList\",\n         prototype = prototype(elementType = \"raw\"),\n         contains = c(\"RawList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleRleList\",\n         prototype = prototype(elementType = \"Rle\"),\n         contains = c(\"RleList\", \"SimpleAtomicList\"))\n\nsetClass(\"SimpleFactorList\",\n         prototype = prototype(elementType = \"factor\"),\n         contains = c(\"FactorList\", \"SimpleAtomicList\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructors\n###\n\n.dotargsAsList <- function(type, ...) {\n  listData <- list(...)\n  if (length(listData) == 1) {\n      arg1 <- listData[[1]]\n      if (is.list(arg1) || is(arg1, \"List\"))\n        listData <- arg1\n      else if (type == \"integer\" && class(arg1) == \"character\")\n        listData <- toListOfIntegerVectors(arg1) # weird special case\n  }\n  listData\n}\n\nAtomicListConstructor <- function(type, compress.default = TRUE) {\n  constructor <- eval(substitute(function(..., compress = compress.default) {\n    if (!isTRUEorFALSE(compress))\n      stop(\"'compress' must be TRUE or FALSE\")\n    listData <- .dotargsAsList(type, ...)\n    CompressedOrSimple <- if (compress) \"Compressed\" else \"Simple\"\n    ans_class <- S4Vectors:::listClassName(CompressedOrSimple, type)\n    if (compress && sum(lengths(listData)) > .Machine$integer.max) {\n        contructor_name <- paste0(toupper(substr(type, start=1L, stop=1L)),\n                                  substr(type, start=2L, stop=nchar(type)),\n                                  \"List\")\n        stop(wmsg(\"input of \", contructor_name, \"() is too big \",\n                  \"for 'compress=TRUE' (the cumulated length of the \",\n                  \"list elements in the resulting \", ans_class, \" object \",\n                  \"would exceed 2^31); please call the constructor \",\n                  \"with 'compress=FALSE' instead\"))\n    }\n    if (is(listData, ans_class))\n      listData\n    else CoercerToList(type, compress)(listData)\n  }, list(type = type)))\n  formals(constructor)$compress <- compress.default\n  constructor\n}\n\nLogicalList <- AtomicListConstructor(\"logical\")\nIntegerList <- AtomicListConstructor(\"integer\")\nNumericList <- AtomicListConstructor(\"numeric\")\nComplexList <- AtomicListConstructor(\"complex\")\nCharacterList <- AtomicListConstructor(\"character\")\nRawList <- AtomicListConstructor(\"raw\")\nRleList <- AtomicListConstructor(\"Rle\")\nFactorList <- AtomicListConstructor(\"factor\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### Equivalent to 'as.vector(as.list(x), mode=mode)' but faster on\n### CompressedAtomicList objects (10x, 75x, or more, depending on 'length(x)').\nsetMethod(\"as.vector\", \"AtomicList\",\n    function(x, mode=\"any\")\n    {\n        valid_modes <- c(\"any\", S4Vectors:::ATOMIC_TYPES, \"double\", \"list\")\n        mode <- match.arg(mode, valid_modes)\n        if (mode %in% c(\"any\", \"list\"))\n            return(as.list(x))\n        x_eltNROWS <- elementNROWS(x)\n        if (any(x_eltNROWS > 1L))\n            stop(\"coercing an AtomicList object to an atomic vector \",\n                 \"is supported only for\\n\",\n                 \"  objects with top-level elements of length <= 1\")\n        ans <- base::rep.int(as.vector(NA, mode=mode), length(x))\n        ans[x_eltNROWS == 1L] <- as.vector(unlist(x, use.names=FALSE),\n                                           mode=mode)\n        ans\n    }\n)\n\nas.matrix.AtomicList <- function(x, col.names=NULL, ...) {\n    p <- PartitioningByEnd(x)\n    vx <- decode(unlist(x, use.names=FALSE))\n    if (is.null(col.names)) {\n        col.names <- names(vx)\n    }\n    if (is.null(col.names) || is.character(col.names)) {\n        col.ind <- unlist_as_integer(IRanges(1, width(p)))\n    } else if (is.list(col.names) || is(col.names, \"List\")) {\n        col.names <- unlist(col.names, use.names=FALSE)\n        if (is.factor(col.names)) {\n            col.ind <- as.integer(col.names)\n            col.names <- levels(col.names)\n        } else {\n            col.ind <- selfmatch(col.names)\n            col.names <- col.names[col.ind == seq_along(col.ind)]\n        }\n    } else {\n        stop(\"'col.names' should be NULL, a character vector or list\")\n    }\n    row.ind <- togroup(p)\n    nc <- if (!is.null(col.names)) length(col.names) else max(width(p))\n    m <- matrix(nrow=length(x), ncol=nc)\n    m[cbind(row.ind, col.ind)] <- vx\n    if (!is.null(col.names))\n        colnames(m) <- col.names\n    m\n}\nsetMethod(\"as.matrix\", \"AtomicList\", function(x, col.names=NULL)\n    as.matrix.AtomicList(x, col.names))\n\nsetMethod(\"drop\", \"AtomicList\", function(x) {\n  x_eltNROWS <- elementNROWS(x)\n  if (any(x_eltNROWS > 1))\n    stop(\"All element lengths must be <= 1\")\n  x_dropped <- rep.int(NA, sum(x_eltNROWS))\n  x_unlisted <- unlist(x, use.names = FALSE)\n  x_dropped[x_eltNROWS > 0L] <- x_unlisted\n  if (is.factor(x_unlisted)) {\n      x_dropped <- structure(as.integer(x_dropped), levels=levels(x_unlisted),\n                             class=\"factor\")\n  }\n  names(x_dropped) <- names(x)\n  x_dropped\n})\n\nCoercerToList <- function(type, compress) {\n  .coerceToList <- if (compress)\n                     coerceToCompressedList\n                   else\n                     S4Vectors:::coerceToSimpleList\n  function(from) {\n    .coerceToList(from, type)\n  }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### General methods\n###\n\n### Could actually be made the \"table\" method for List objects. Will work on\n### any List object 'x' for which 'as.factor(unlist(x))' works.\nsetMethod(\"table\", \"AtomicList\",\n    function(...)\n    {\n        args <- list(...)\n        if (length(args) != 1L)\n            stop(\"\\\"table\\\" method for AtomicList objects \",\n                 \"can only take one input object\")\n        x <- args[[1L]]\n        if (!pcompareRecursively(x)) {\n            ## Not sure why callNextMethod() doesn't work. Is it because of\n            ## dispatch on the ellipsis?\n            #return(callNextMethod())\n            return(selectMethod(\"table\", \"Vector\")(...))\n        }\n        y1 <- togroup(PartitioningByWidth(x))\n        attributes(y1) <- list(levels=as.character(seq_along(x)),\n                               class=\"factor\")\n        y2 <- as.factor(unlist(x, use.names=FALSE))\n        ans <- table(y1, y2)\n        names(dimnames(ans)) <- NULL\n        x_names <- names(x)\n        if (!is.null(x_names))\n            rownames(ans) <- x_names\n        ans\n    }\n)\n\nsetMethod(\"table\", \"SimpleAtomicList\", function(...)\n{\n    args <- list(...)\n    if (length(args) != 1L)\n        stop(\"\\\"table\\\" method for SimpleAtomicList objects \",\n             \"can only take one input object\")\n    x <- args[[1L]]\n    levs <- sort(unique(unlist(lapply(x, function(xi) {\n        if (!is.null(levels(xi))) levels(xi) else unique(xi)\n    }), use.names=FALSE)))\n    as.table(do.call(rbind,\n                     lapply(x, function(xi) {\n                         if (is(xi, \"Rle\"))\n                             runValue(xi) <- factor(runValue(xi), levs)\n                         else xi <- factor(xi, levs)\n                         table(xi)\n                     })))\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Rle methods\n###\n\n### 'use.names' is ignored.\nsetMethod(\"unlist\", \"SimpleRleList\",\n    function (x, recursive=TRUE, use.names=TRUE)\n    {\n        if (!identical(recursive, TRUE))\n            stop(\"\\\"unlist\\\" method for SimpleRleList objects \",\n                 \"does not support the 'recursive' argument\")\n        if (length(x) == 0L)\n            return(Rle())\n        ans_values <- unlist(lapply(x@listData, slot, \"values\"),\n                             use.names=FALSE)\n        ans_lengths <- unlist(lapply(x@listData, slot, \"lengths\"),\n                              use.names=FALSE)\n        Rle(ans_values, ans_lengths)\n    }\n)\n\nsetMethod(\"runLength\", \"RleList\", function(x) {\n  as(lapply(x, runLength), \"IntegerList\")\n})\n\nsetMethod(\"runValue\", \"RleList\", function(x) {\n  as(lapply(x, runValue), \"List\")\n})\n\nsetReplaceMethod(\"runValue\", \"SimpleRleList\",\n                 function(x, value) {\n                   if (!identical(elementNROWS(ranges(x)),\n                                  elementNROWS(value)))\n                     stop(\"elementNROWS() of 'x' and 'value' must match\")\n                   x@listData <- mapply(function(rle, v) {\n                     runValue(rle) <- v\n                     rle\n                   }, x, value, SIMPLIFY=FALSE)\n                   x\n                 })\n\nsetMethod(\"ranges\", \"RleList\", function(x, use.names=TRUE, use.mcols=FALSE) {\n  as(lapply(x, ranges, use.names=use.names, use.mcols=use.mcols), \"List\")\n})\n\ndiceRangesByList <- function(x, list) {\n  listPart <- PartitioningByEnd(list)\n  ## 'x' cannot contain empty ranges so using\n  ## 'hit.empty.query.ranges=TRUE' won't affect the result but\n  ## it makes findOverlaps_IntegerRanges_Partitioning() just a little\n  ## bit faster.\n  hits <- findOverlaps_IntegerRanges_Partitioning(\n              x, listPart,\n              hit.empty.query.ranges=TRUE)\n  ov <- overlapsRanges(x, listPart, hits)\n  ans_unlistData <- shift(ov, 1L - start(listPart)[subjectHits(hits)])\n  ans_partitioning <- PartitioningByEnd(subjectHits(hits), NG=length(list))\n  ans <- relist(ans_unlistData, ans_partitioning)\n  names(ans) <- names(list)\n  ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Factor methods\n###\n\nsetMethod(\"levels\", \"FactorList\", function(x) {\n  CharacterList(lapply(x, levels))\n})\n\nsetMethod(\"unlist\", \"SimpleFactorList\",\n          function(x, recursive = TRUE, use.names = TRUE) {\n            levs <- levels(x)\n            if (length(x) > 1L &&\n                !all(vapply(levs[-1L], identical, logical(1L), levs[[1L]]))) {\n              stop(\"inconsistent level sets\")\n            }\n            structure(callNextMethod(),\n                      levels=as.character(levs[[1L]]),\n                      class=\"factor\")\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\n.showAtomicList <- function(object, minLines, ...)\n{\n    len <- length(object)\n    object_names <- names(object)\n    k <- min(minLines, len)\n    d <- len - minLines\n    for (i in seq_len(k)) {\n        if (is.null(object_names)) {\n            label <- i\n        } else {\n            nm <- object_names[[i]]\n            if (is.na(nm)) {\n                label <- \"NA\"\n            } else {\n                label <- paste0(\"\\\"\", nm, \"\\\"\")\n            }\n        }\n        label <- paste0(\"[[\", label, \"]]\")\n        if (length(object[[i]]) == 0) {\n            cat(label, \" \", sep = \"\")\n            print(object[[i]])\n        } else {\n            cat(S4Vectors:::labeledLine(label, object[[i]], labelSep = \"\",\n                                        count = FALSE))\n        }\n    }\n    if (d > 0)\n        cat(\"...\\n<\", d,\n            ifelse(d == 1,\n                   \" more element>\\n\", \" more elements>\\n\"), sep=\"\")\n}\n\nsetMethod(\"show\", \"AtomicList\",\n          function(object) \n          {\n              cat(classNameForDisplay(object), \" of length \",\n                  length(object), \"\\n\", sep = \"\")\n              .showAtomicList(object, 10) \n          }\n)\n\nsetMethod(\"show\", \"RleList\",\n          function(object) {\n              lo <- length(object)\n              k <- min(5, length(object))\n              diffK <- lo - 5\n              cat(classNameForDisplay(object), \" of length \", lo,\n                  \"\\n\", sep = \"\")\n              show(as.list(head(object, k)))\n              if (diffK > 0)\n                  cat(\"...\\n<\", diffK,\n                      ifelse(diffK == 1,\n                             \" more element>\\n\", \" more elements>\\n\"),\n                      sep=\"\")\n          })\n",
        "AtomicList-utils.R": "### =========================================================================\n### Common operations on AtomicList objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Group generic methods\n###\n\nemptyOpsReturnValue <- function(.Generic, e1, e2, compress) {\n  dummy.vector <- do.call(.Generic,\n                          list(vector(e1@elementType), vector(e2@elementType)))\n  CoercerToList(NULL, compress)(dummy.vector)\n}\n\nrecycleList <- function(x, length.out) {\n  if (length.out %% length(x) > 0L)\n    warning(\"shorter object is not a multiple of longer object length\")\n  rep(x, length.out = length.out)\n}\n\nsetMethod(\"Ops\",\n          signature(e1 = \"AtomicList\", e2 = \"AtomicList\"),\n          function(e1, e2)\n          {\n              if (length(e1) == 0L || length(e2) == 0L) {\n                return(emptyOpsReturnValue(.Generic, e1, e2, compress = FALSE))\n              }\n              n <- max(length(e1), length(e2))\n              e1 <- recycleList(e1, n)\n              e2 <- recycleList(e2, n)\n              as(Map(.Generic, e1, e2), \"List\")\n          })\n\nsetMethod(\"Ops\",\n          signature(e1 = \"AtomicList\", e2 = \"atomic\"),\n          function(e1, e2)\n          {\n              e2 <- as(e2, class(e1))\n              callGeneric(e1, e2)\n          })\n\nsetMethod(\"Ops\",\n          signature(e1 = \"atomic\", e2 = \"AtomicList\"),\n          function(e1, e2)\n          {\n              e1 <- as(e1, class(e2))\n              callGeneric(e1, e2)\n          })\n\n### Only to make unary + and - work (i.e. '+x' and '-x').\nsetMethod(\"Ops\", c(\"AtomicList\", \"missing\"),\n    function(e1, e2) callGeneric(0L, e1)\n)\n\nsetMethod(\"Math\", \"AtomicList\",\n          function(x) as(lapply(x, .Generic), \"List\"))\n\nsetMethod(\"Math2\", \"AtomicList\",\n          function(x, digits)\n          {\n              if (missing(digits))\n                  digits <- ifelse(.Generic == \"round\", 0, 6)\n              as(lapply(x, .Generic, digits = digits), \"List\")\n          })\n\nsetMethod(\"Summary\", \"AtomicList\",\n          function(x, ..., na.rm = FALSE) {\n            sapply(x, .Generic, na.rm = na.rm)\n        })\n\nsetMethod(\"Complex\", \"AtomicList\",\n          function(z) as(lapply(z, .Generic), \"List\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Logical methods\n###\n\nifelseReturnValue <- function(yes, no, len) {\n  proto <- function(x)\n    new(if (is.atomic(x)) class(x) else x@elementType)\n  v <- logical()\n  v[1L] <- proto(yes)[1L]\n  v[1L] <- proto(no)[1L]\n  v\n  compress <- is(yes, \"CompressedList\") || is(no, \"CompressedList\")\n  as(rep(v, length.out = len),\n    if(compress) \"CompressedList\" else \"SimpleList\")\n}\n\nsetGeneric(\"ifelse2\", function(test, yes, no) standardGeneric(\"ifelse2\"))\n\nsetMethods(\"ifelse2\", list(c(\"ANY\", \"ANY\", \"List\"),\n                           c(\"ANY\", \"List\", \"List\"),\n                           c(\"ANY\", \"List\", \"ANY\")),      \n           function(test, yes, no) {\n             ans <- ifelseReturnValue(yes, no, length(test))\n             ok <- !(nas <- is.na(test))\n             if (any(test[ok])) \n               ans[test & ok] <- rep(yes, length.out = length(ans))[test & ok]\n             if (any(!test[ok])) \n               ans[!test & ok] <- rep(no, length.out = length(ans))[!test & ok]\n             ans[nas] <- NA\n             names(ans) <- names(test)\n             ans\n           })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Numerical methods\n###\n\n### which.min() and which.max()\nsetMethods(\"which.min\", list(\"IntegerList\", \"NumericList\", \"RleList\"),\n    function(x) setNames(as.integer(lapply(x, which.min)), names(x))\n)\nsetMethods(\"which.max\", list(\"IntegerList\", \"NumericList\", \"RleList\"),\n    function(x) setNames(as.integer(lapply(x, which.max)), names(x))\n)\n\ntoglobal <- function(i, x) {\n    start(PartitioningByEnd(x)) + i - 1L\n}\n\nfor (i in c(\"IntegerList\", \"NumericList\", \"RleList\")) {\n    setMethod(\"pmax\", i, function(..., na.rm = FALSE)\n                  mendoapply(pmax, ..., MoreArgs = list(na.rm = na.rm)))\n    setMethod(\"pmin\", i, function(..., na.rm = FALSE)\n                  mendoapply(pmin, ..., MoreArgs = list(na.rm = na.rm)))\n    setMethod(\"pmax.int\", i, function(..., na.rm = FALSE)\n                  mendoapply(pmax.int, ..., MoreArgs = list(na.rm = na.rm)))\n    setMethod(\"pmin.int\", i, function(..., na.rm = FALSE)\n                  mendoapply(pmin.int, ..., MoreArgs = list(na.rm = na.rm)))\n}\n\nsetMethod(\"mean\", \"AtomicList\",\n    function(x, ...) sapply(x, mean, ...)\n)\n\nsetMethod(\"var\", c(\"AtomicList\", \"missing\"),\n    function(x, y=NULL, na.rm=FALSE, use)\n    {\n        if (missing(use))\n            use <- ifelse(na.rm, \"na.or.complete\", \"everything\")\n        sapply(x, var, na.rm=na.rm, use=use)\n    }\n)\nsetMethod(\"var\", c(\"AtomicList\", \"AtomicList\"),\n    function(x, y=NULL, na.rm=FALSE, use)\n    {\n        if (missing(use))\n            use <- ifelse(na.rm, \"na.or.complete\", \"everything\")\n        mapply(var, x, y, MoreArgs=list(na.rm=na.rm, use=use))\n    }\n)\n\nsetMethod(\"cov\", c(\"AtomicList\", \"AtomicList\"),\n    function(x, y=NULL,\n             use=\"everything\", method=c(\"pearson\", \"kendall\", \"spearman\"))\n        mapply(cov, x, y, MoreArgs=list(use=use, method=match.arg(method)))\n)\n\nsetMethod(\"cor\", c(\"AtomicList\", \"AtomicList\"),\n    function(x, y=NULL,\n             use=\"everything\", method=c(\"pearson\", \"kendall\", \"spearman\"))\n        mapply(cor, x, y, MoreArgs=list(use=use, method=match.arg(method)))\n)\n\nsetMethod(\"sd\", \"AtomicList\",\n    function(x, na.rm=FALSE) sapply(x, sd, na.rm=na.rm)\n)\n\nsetMethod(\"median\", \"AtomicList\",\n    function(x, na.rm=FALSE) sapply(x, median, na.rm=na.rm)\n)\n\nsetMethod(\"quantile\", \"AtomicList\",\n    function(x, ...) do.call(rbind, lapply(x, quantile, ...))\n)\n\nsetMethod(\"mad\", \"AtomicList\",\n    function(x, center=median(x), constant=1.4826, na.rm=FALSE,\n                low=FALSE, high=FALSE)\n    {\n        if (!missing(center))\n            stop(\"'center' argument is not supported\")\n        sapply(x, mad, constant=constant, na.rm=na.rm, low=low, high=high)\n    }\n)\n\nsetMethod(\"IQR\", \"AtomicList\",\n    function(x, na.rm=FALSE, type=7) sapply(x, IQR, na.rm=na.rm, type=type)\n)\n\ndiff.AtomicList <- function(x, ...) diff(x, ...)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Running window statistic methods\n###\n\nsetMethod(\"runmed\", \"SimpleIntegerList\",\n          function(x, k, endrule = c(\"median\", \"keep\", \"constant\"),\n                   algorithm = NULL, print.level = 0)\n              NumericList(lapply(x, runmed, k = k, endrule = match.arg(endrule),\n                                 algorithm = algorithm,\n                                 print.level = print.level), compress = FALSE))\nsetMethod(\"runmed\", \"NumericList\",\n          function(x, k, endrule = c(\"median\", \"keep\", \"constant\"),\n                   algorithm = NULL, print.level = 0)\n              endoapply(x, runmed, k = k, endrule = match.arg(endrule),\n                        algorithm = algorithm, print.level = print.level))\nsetMethod(\"runmed\", \"RleList\",\n          function(x, k, endrule = c(\"median\", \"keep\", \"constant\"),\n                   algorithm = NULL, print.level = 0)\n              endoapply(x, runmed, k = k, endrule = match.arg(endrule)))\nsetMethod(\"runmean\", \"RleList\",\n          function(x, k, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n              endoapply(x, runmean, k = k, endrule = match.arg(endrule),\n                        na.rm = na.rm))\nsetMethod(\"runsum\", \"RleList\",\n          function(x, k, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n              endoapply(x, runsum, k = k, endrule = match.arg(endrule),\n                        na.rm = na.rm))\nsetMethod(\"runwtsum\", \"RleList\",\n          function(x, k, wt, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n              endoapply(x, runwtsum, k = k, wt = wt,\n                        endrule = match.arg(endrule), na.rm = na.rm))\nsetMethod(\"runq\", \"RleList\",\n          function(x, k, i, endrule = c(\"drop\", \"constant\"), na.rm = FALSE)\n              endoapply(x, runq, k = k, i = i, endrule = match.arg(endrule),\n                        na.rm = na.rm))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Character\n###\n\n### TODO: paste, ...\n\nsetMethod(\"unstrsplit\", \"CharacterList\",\n    function(x, sep=\"\") unstrsplit(as.list(x), sep=sep)\n)\n\nsetMethod(\"unstrsplit\", \"RleList\",\n          function(x, sep=\"\") unstrsplit(CharacterList(x, compress=FALSE),\n                                         sep=sep)\n          )\n\nsetMethods(\"nchar\", c(\"CharacterList\", \"RleList\"),\n           function(x) {\n               relist(nchar(unlist(x, use.names=FALSE)), x)\n           })\n\nsetMethods(\"substring\", c(\"CharacterList\", \"RleList\"),\n           function(text, first, last = 1000000L) {\n               relist(substring(unlist(text, use.names=FALSE), first, last),\n                      text)\n           })\n\nsetMethods(\"substr\", c(\"CharacterList\", \"RleList\"),\n           function(x, start, stop) {\n               relist(substr(unlist(x, use.names=FALSE), start, stop), x)\n           })\n\nsetMethods(\"chartr\", list(c(old = \"ANY\", new = \"ANY\", x = \"CharacterList\"),\n                          c(old = \"ANY\", new = \"ANY\", x = \"RleList\")),\n           function(old, new, x) {\n               relist(chartr(old, new, unlist(x, use.names=FALSE)), x)\n           })\n\nsetMethods(\"toupper\", c(\"CharacterList\", \"RleList\"),\n           function(x) {\n               relist(toupper(unlist(x, use.names=FALSE)), x)\n           })\n\nsetMethods(\"tolower\", c(\"CharacterList\", \"RleList\"),\n           function(x) {\n               relist(tolower(unlist(x, use.names=FALSE)), x)\n           })\n\nsetMethods(\"sub\", list(c(\"ANY\", \"ANY\", \"CharacterList\"),\n                       c(\"ANY\", \"ANY\", \"RleList\")),\n           function(pattern, replacement, x, ignore.case = FALSE,\n                    perl = FALSE, fixed = FALSE, useBytes = FALSE) {\n               relist(sub(pattern, replacement, unlist(x, use.names=FALSE),\n                          ignore.case, perl, fixed, useBytes),\n                      x)\n           })\n\nsetMethods(\"gsub\", list(c(\"ANY\", \"ANY\", \"CharacterList\"),\n                        c(\"ANY\", \"ANY\", \"RleList\")),\n           function(pattern, replacement, x, ignore.case = FALSE,\n                    perl = FALSE, fixed = FALSE, useBytes = FALSE) {\n               relist(gsub(pattern, replacement, unlist(x, use.names=FALSE),\n                           ignore.case, perl, fixed, useBytes),\n                      x)\n           })\n\nsetMethods(\"grepl\", list(c(\"ANY\", \"CharacterList\"),\n                         c(\"ANY\", \"RleList\")),\n           function(pattern, x, ignore.case = FALSE, perl = FALSE,\n                    fixed = FALSE, useBytes = FALSE) {\n               relist(grepl(pattern, unlist(x, use.names=FALSE),\n                            ignore.case, perl, fixed, useBytes),\n                      x)\n           })\n\nsetMethods(\"grep\", list(c(\"ANY\", \"CharacterList\"),\n                        c(\"ANY\", \"RleList\")),\n           function(pattern, x, ignore.case = FALSE, perl = FALSE,\n                    value = FALSE,  fixed = FALSE, useBytes = FALSE,\n                    invert = FALSE) {\n               stopifnot(isTRUEorFALSE(invert), isTRUEorFALSE(value))\n               g <- grepl(pattern, x, ignore.case, perl, fixed, useBytes)\n               if (invert) {\n                   g <- !g\n               }\n               if (value) {\n                   x[g]\n               } else {\n                   which(g)\n               }\n           })\n\nsetMethods(\"startsWith\", list(c(\"CharacterList\", \"ANY\"), c(\"RleList\", \"ANY\")),\n           function(x, prefix) {\n               relist(startsWith(unlist(x, use.names = FALSE), prefix), x)\n           })\n\nsetMethods(\"endsWith\", list(c(\"CharacterList\", \"ANY\"), c(\"RleList\", \"ANY\")),\n           function(x, suffix) {\n               relist(endsWith(unlist(x, use.names = FALSE), suffix), x)\n           })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Set/comparison methods\n###\n\nsubgrouping <- function(x) {\n    g <- grouping(togroup(PartitioningByEnd(x)), unlist(x, use.names=FALSE))\n    as(g, \"ManyToOneGrouping\")\n}\n\n.unique.RleList <- function(x, incomparables=FALSE, ...)\n    unique(runValue(x), incomparables=incomparables, ...)\nsetMethod(\"unique\", \"RleList\", .unique.RleList)\n\n",
        "CompressedAtomicList-class.R": "### =========================================================================\n### CompressedAtomicList objects\n### -------------------------------------------------------------------------\n\n\n## Possible optimizations for compressed lists:\n## - order/sort: unlist, order by split factor first\n## - cumsum: unlist, cumsum and subtract offsets\n\nsetClass(\"CompressedAtomicList\",\n         contains =  c(\"AtomicList\", \"CompressedList\"),\n         representation(\"VIRTUAL\"))\n\nsetClass(\"CompressedLogicalList\",\n         prototype = prototype(elementType = \"logical\",\n                               unlistData = logical()),\n         contains = c(\"LogicalList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedIntegerList\",\n         prototype = prototype(elementType = \"integer\",\n                               unlistData = integer()),\n         contains = c(\"IntegerList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedNumericList\",\n         prototype = prototype(elementType = \"numeric\",\n                               unlistData = numeric()),\n         contains = c(\"NumericList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedComplexList\",\n         prototype = prototype(elementType = \"complex\",\n                               unlistData = complex()),\n         contains = c(\"ComplexList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedCharacterList\",\n         prototype = prototype(elementType = \"character\",\n                               unlistData = character()),\n         contains = c(\"CharacterList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedRawList\",\n         prototype = prototype(elementType = \"raw\",\n                               unlistData = raw()),\n         contains = c(\"RawList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedRleList\",\n         prototype = prototype(elementType = \"Rle\",\n                               unlistData = new(\"Rle\")),\n         contains = c(\"RleList\", \"CompressedAtomicList\"))\n\nsetClass(\"CompressedFactorList\",\n         prototype = prototype(elementType = \"factor\",\n           unlistData = factor()),\n         contains = c(\"FactorList\", \"CompressedAtomicList\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetListCoercions(\"logical\")\nsetListCoercions(\"integer\")\nsetListCoercions(\"numeric\")\nsetListCoercions(\"complex\")\nsetListCoercions(\"character\")\nsetListCoercions(\"raw\")\nsetListCoercions(\"Rle\")\nsetListCoercions(\"factor\")\n\nsetMethod(\"as.list\", \"CompressedAtomicList\",\n          function(x, use.names = TRUE) {\n              if (is(x, \"CompressedRleList\")) {\n                  callNextMethod(x, use.names = use.names)\n              } else {\n                  f <- S4Vectors:::map_inner_ROWS_to_list_elements(\n                                       elementNROWS(x),\n                                       as.factor=TRUE)\n                  ans <- split(x@unlistData, f)\n                  if (use.names) {\n                      names(ans) <- names(x)\n                  } else {\n                      names(ans) <- NULL\n                  }\n                  ans\n              }\n          })\n\nsetAs(\"CompressedAtomicList\", \"list\", function(from) as.list(from))\n\n.from_IPosRanges_to_CompressedIntegerList <- function(from)\n{\n    ans <- relist(unlist_as_integer(from), from)\n    metadata(ans) <- metadata(from)\n    mcols(ans) <- mcols(from, use.names=FALSE)\n    ans\n}\n\n### Propagate the names, metadata, and metadata columns.\nsetAs(\"IPosRanges\", \"CompressedIntegerList\",\n    .from_IPosRanges_to_CompressedIntegerList\n)\nsetAs(\"IPosRanges\", \"IntegerList\",\n    .from_IPosRanges_to_CompressedIntegerList\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### General methods\n###\n\nsetCompressedNumericalListMethod <-\n    function(fun, def, where=topenv(parent.frame()))\n{\n    types <- c(\"Logical\", \"Integer\", \"Numeric\")\n    classNames <- paste0(\"Compressed\", types, \"List\")\n    lapply(classNames, function(className) {\n               C_fun <- paste0(\"C_\", sub(\".\", \"_\", fun, fixed=TRUE),\n                               \"_\", className)\n               body(def) <- eval(call(\"substitute\", body(def)))\n               setMethod(fun, className, def, where=where)\n           })\n}\n\nsetCompressedNumericalListMethod(\"is.unsorted\",\n    function(x, na.rm = FALSE, strictly=FALSE) {\n        stopifnot(isTRUEorFALSE(na.rm))\n        stopifnot(isTRUEorFALSE(strictly))\n        .Call2(C_fun, x, na.rm, strictly, PACKAGE=\"IRanges\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Rle methods\n###\n\nsetMethod(\"runValue\", \"CompressedRleList\",\n    function(x)\n    {\n        rle <- unlist(x, use.names=FALSE)\n        rlePart <- PartitioningByWidth(runLength(rle))\n        listPart <- PartitioningByEnd(x)\n        ## 'rlePart' cannot contain empty ranges so using\n        ## Using 'hit.empty.query.ranges=TRUE' won't affect the result\n        ## (because 'rlePart' cannot contain empty ranges) but it makes\n        ## findOverlaps_IntegerRanges_Partitioning() just a little bit faster.\n        hits <- findOverlaps_IntegerRanges_Partitioning(\n                    rlePart, listPart,\n                    hit.empty.query.ranges=TRUE)\n        ans_partitioning <- PartitioningByEnd(subjectHits(hits), NG=length(x))\n        ans_unlistData <- runValue(rle)[queryHits(hits)]\n        ans <- relist(ans_unlistData, ans_partitioning)\n        names(ans) <- names(x)\n        ans\n    }\n)\n\nsetReplaceMethod(\"runValue\", \"CompressedRleList\",\n                 function(x, value) {\n                   if (!identical(elementNROWS(ranges(x)),\n                                  elementNROWS(value)))\n                     stop(\"elementNROWS() of 'x' and 'value' must match\")\n                   runValue(x@unlistData) <- unlist(value, use.names=FALSE)\n                   x\n                 })\n\nsetMethod(\"runLength\", \"CompressedRleList\", function(x) {\n  width(ranges(x))\n})\n\nsetMethod(\"ranges\", \"CompressedRleList\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n      rle <- unlist(x, use.names=FALSE)\n      rlePart <- PartitioningByWidth(runLength(rle))\n      diceRangesByList(rlePart, x)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Factor methods\n###\n\nsetMethod(\"levels\", \"CompressedFactorList\", function(x) {\n  setNames(rep(CharacterList(levels(x@unlistData)), length(x)), names(x))\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Iteration\n###\n\nsetMethod(\"lapply\", \"CompressedAtomicList\",\n          function(X, FUN, ...)\n          {\n            FUN <- match.fun(FUN)\n            if (is(X, \"CompressedRleList\")) {\n              callNextMethod(X, FUN, ...)\n            } else {\n              lapply(as.list(X), FUN, ...)\n            }\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Group generic methods\n###\n\n.do_CompressedList_binary_op <- function(OP, e1, e2, skeleton) {\n  if (!missing(skeleton)) {\n    n <- length(skeleton)\n  } else {\n    n <- max(length(e1), length(e2))\n  }\n  e1 <- recycleList(e1, n)\n  e2 <- recycleList(e2, n)\n  if (missing(skeleton)) {\n    n1 <- elementNROWS(e1)\n    n2 <- elementNROWS(e2)\n    if (any(n1 != n2)) {\n      en <- ifelse(n1 == 0L | n2 == 0L, 0L, pmax.int(n1, n2))\n    } else {\n      en <- NULL\n    }\n    nms <- names(e1)\n    if (is.null(nms))\n      nms <- names(e2)\n  } else {\n    en <- elementNROWS(skeleton)\n    nms <- names(skeleton)\n  }\n  if (!is.null(en)) {\n    e1 <- recycleListElements(e1, en)\n    e2 <- recycleListElements(e2, en)\n  }\n  partitioning <- PartitioningByEnd(e1)\n  names(partitioning) <- nms\n  relist(OP(unlist(e1, use.names=FALSE), unlist(e2, use.names=FALSE)),\n         partitioning)\n}\n\nsetMethod(\"Ops\",\n          signature(e1 = \"CompressedAtomicList\", e2 = \"CompressedAtomicList\"),\n          function(e1, e2)\n          {\n              if (length(e1) == 0L || length(e2) == 0L) {\n                return(emptyOpsReturnValue(.Generic, e1, e2, compress = TRUE))\n              }\n              .do_CompressedList_binary_op(function(x, y) {\n                .Generic <- .Generic\n                callGeneric(x, y)\n              }, e1, e2)\n          })\n\nsetMethod(\"Ops\",\n          signature(e1 = \"SimpleAtomicList\", e2 = \"CompressedAtomicList\"),\n          function(e1, e2)\n          {\n              if (sum(as.numeric(elementNROWS(e1))) < .Machine$integer.max)\n                  e1 <- as(e1, \"CompressedList\")\n              else\n                  e2 <- as(e2, \"SimpleList\")\n              callGeneric(e1, e2)\n          })\n\nsetMethod(\"Ops\",\n          signature(e1 = \"CompressedAtomicList\", e2 = \"SimpleAtomicList\"),\n          function(e1, e2)\n          {\n              if (sum(as.numeric(elementNROWS(e2))) < .Machine$integer.max)\n                  e2 <- as(e2, \"CompressedList\")\n              else\n                  e1 <- as(e1, \"SimpleList\")\n              callGeneric(e1, e2)\n          })\n\nsetMethod(\"Ops\",\n          signature(e1 = \"CompressedAtomicList\", e2 = \"atomic\"),\n          function(e1, e2)\n          {\n              if (length(e2) > 1) {\n                  e2 <- S4Vectors:::recycleVector(e2, length(e1))\n                  e2 <- rep(e2, elementNROWS(e1))\n              }\n              relist(callGeneric(e1@unlistData, e2), e1)\n          })\n\nsetMethod(\"Ops\",\n          signature(e1 = \"atomic\", e2 = \"CompressedAtomicList\"),\n          function(e1, e2)\n          {\n              if (length(e1) > 1) {\n                  e1 <- S4Vectors:::recycleVector(e1, length(e2))\n                  e1 <- rep(e1, elementNROWS(e2))\n              }\n              relist(callGeneric(e1, e2@unlistData), e2)\n          })\n\nsetMethod(\"Math\", \"CompressedAtomicList\",\n          function(x) {\n              relist(callGeneric(x@unlistData), x)\n          })\n\nsetMethod(\"cumsum\", \"CompressedAtomicList\",\n          function(x) {\n              xunlist <- unlist(x, use.names=FALSE)\n              xcumsum <- cumsum(as.numeric(xunlist))\n              partition <- PartitioningByEnd(x)\n              ans <- xcumsum - rep(xcumsum[start(partition)] -\n                  xunlist[start(partition)], width(partition))\n              relist(ans, x)\n          })\n\nsetMethod(\"cumprod\", \"CompressedAtomicList\",\n          function(x) {\n              as(lapply(x, .Generic), \"CompressedList\")\n          })\n\nsetMethod(\"cummin\", \"CompressedAtomicList\",\n          function(x) {\n              as(lapply(x, .Generic), \"CompressedList\")\n          })\n\nsetMethod(\"cummax\", \"CompressedAtomicList\",\n          function(x) {\n              as(lapply(x, .Generic), \"CompressedList\")\n          })\n\nsetMethod(\"Math2\", \"CompressedAtomicList\",\n          function(x, digits)\n          {\n              if (missing(digits))\n                  digits <- ifelse(.Generic == \"round\", 0, 6)\n              relist(callGeneric(x@unlistData, digits = digits), x)\n          })\n\nsetMethod(\"any\", \"CompressedAtomicList\", function(x, na.rm = FALSE) {\n              stopifnot(isTRUEorFALSE(na.rm))\n              ans <- sum(x, na.rm=TRUE) > 0L\n              if (!na.rm) {\n                  ans[!ans & any(is.na(x), na.rm=TRUE)] <- NA\n              }\n              ans\n          })\n\nsetMethod(\"all\", \"CompressedAtomicList\", function(x, na.rm = FALSE) {\n              stopifnot(isTRUEorFALSE(na.rm))\n              ans <- !any(!x, na.rm=TRUE)\n              if (!na.rm) {\n                  ans[ans & any(is.na(x), na.rm=TRUE)] <- NA\n              }\n              ans\n          })\n\nsetMethod(\"anyNA\", \"CompressedAtomicList\", function(x, recursive=FALSE) {\n    callNextMethod(x, recursive=FALSE) ## recursion will just slow us down\n})\n\nrowsumCompressedList <- function(x, ..., na.rm = FALSE) {\n  x_flat <- unlist(x, use.names = FALSE)\n  ans <- vector(class(x_flat), length(x))\n  non_empty <- elementNROWS(x) > 0\n  if (is.logical(x_flat))\n    x_flat <- as.integer(x_flat)\n  ans[non_empty] <- rowsum(x_flat, togroup(PartitioningByWidth(x)),\n                           reorder = FALSE,\n                           na.rm = na.rm)[,1]\n  setNames(ans, names(x))\n}\n\nsetCompressedListSummaryMethod <- function(fun, where=topenv(parent.frame()))\n{\n    setCompressedNumericalListMethod(fun, function(x, na.rm = FALSE) {\n        stopifnot(isTRUEorFALSE(na.rm))\n        .Call2(C_fun, x, na.rm, PACKAGE=\"IRanges\")\n    }, where)\n}\n\nsetCompressedListSummaryMethod(\"sum\")\nsetCompressedListSummaryMethod(\"prod\")\nsetCompressedListSummaryMethod(\"min\")\nsetCompressedListSummaryMethod(\"max\")\n\nsetMethods(\"range\",\n           list(\"CompressedLogicalList\",\n                \"CompressedIntegerList\",\n                \"CompressedNumericList\",\n                \"CompressedRleList\"),\n           function(x, na.rm=FALSE) {\n               stopifnot(isTRUEorFALSE(na.rm))\n               cbind(min(x, na.rm=na.rm), max(x, na.rm=na.rm))\n           })\n\nsetMethod(\"Summary\", \"CompressedRleList\",\n          function(x, ..., na.rm = FALSE) {\n            toViewFun <- list(max = viewMaxs, min = viewMins, sum = viewSums)\n            if (!is.null(viewFun <- toViewFun[[.Generic]])) {\n              ans <- viewFun(as(x, \"RleViews\"), na.rm = na.rm)\n              names(ans) <- names(x)\n              ans\n            } else if (.Generic %in% c(\"any\", \"all\"))\n                callNextMethod()\n            else sapply(x, .Generic, na.rm = na.rm)\n          })\n\nsetMethod(\"all\", \"CompressedRleList\", function(x, ..., na.rm = FALSE) {\n  args <- list(...)\n  if (length(args) > 0L)\n    stop(\"Only a single argument in '...' is supported for now\")\n  if (!isTRUEorFALSE(na.rm))\n    stop(\"'na.rm' must be TRUE or FALSE\")\n  rv <- runValue(x)\n  if (na.rm)\n    rv <- rv[!is.na(rv)]\n  rv_eltNROWS <- elementNROWS(rv)\n  ans <- rv_eltNROWS == 0L\n  singletons <- rv_eltNROWS == 1L\n  ans[singletons] <- unlist(rv, use.names = FALSE)[singletons[togroup(PartitioningByWidth(rv))]]\n  ans\n})\n\nsetMethod(\"Complex\", \"CompressedAtomicList\",\n          function(z)\n              relist(callGeneric(z@unlistData), z))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### More list-ized methods\n###\n\n.setListMethod <- function(f,\n                           inputClass,\n                           outputBaseClass,\n                           whichArg = 1L,\n                           remainingSignature = character(),\n                           mapply = FALSE,\n                           endoapply = FALSE,\n                           applyToUnlist = FALSE,\n                           where = topenv(parent.frame()))\n{\n    fargs <- formals(args(get(f)))\n    args <- sapply(names(fargs), as.name)\n    names(args) <- sub(\"...\", \"\", names(args), fixed = TRUE)\n    if (applyToUnlist) {\n        call2 <- as.call(c(as.name(\"@\"), args[[whichArg]], \"partitioning\"))\n        args[[whichArg]] <-\n          as.call(c(as.name(\"@\"), args[[whichArg]], \"unlistData\"))\n        call1 <- as.call(c(as.name(f), args))\n        call <-\n          as.call(c(as.name(\"new2\"), paste0(\"Compressed\", outputBaseClass),\n                    unlistData = call1, partitioning = call2, check = FALSE))\n    } else {\n        args <- c(args[[whichArg]], as.name(f), args[-whichArg])\n        if (endoapply) {\n            call <- as.call(c(as.name(\"endoapply\"), args))\n        } else if (missing(outputBaseClass)) {\n            call <- as.call(c(as.name(\"sapply\"), args, list(simplify = TRUE)))\n        } else {\n            if (mapply) {\n                if (length(args) <= 3) {\n                    call <-\n                      as.call(c(as.name(\"mapply\"), args[c(2:1,3L)],\n                                SIMPLIFY = FALSE))\n                } else {\n                    call <-\n                      as.call(c(as.name(\"mapply\"),\n                                args[c(2:1,3L)],\n                                MoreArgs =\n                                as.call(c(as.name(\"list\"), tail(args, -3))),\n                                SIMPLIFY = FALSE))\n                }\n            } else {\n                call <- as.call(c(as.name(\"lapply\"), args))\n            }\n            if (extends(inputClass, \"SimpleList\")) {\n                call <-\n                  as.call(c(as.name(\"new2\"),\n                            paste0(\"Simple\", outputBaseClass),\n                            listData = call, check = FALSE))\n            } else {\n                call <-\n                  as.call(c(as.name(outputBaseClass), call, compress = TRUE))\n            }\n        }\n    }\n    def <- as.function(c(fargs, call))\n    environment(def) <- parent.frame()\n    setMethod(f, c(rep(\"ANY\", whichArg - 1L), inputClass, remainingSignature),\n              def, where)\n}\n\n.setAtomicListMethod <- function(f,\n                                 inputBaseClass = \"AtomicList\",\n                                 outputBaseClass,\n                                 whichArg = 1L,\n                                 remainingSignature = character(),\n                                 mapply = FALSE,\n                                 endoapply = FALSE,\n                                 applyToUnlist = FALSE,\n                                 addRleList = TRUE,\n                                 rleListOutputBaseClass = \"RleList\",\n                                 where = topenv(parent.frame()))\n{\n    if (missing(outputBaseClass)) {\n        for (i in inputBaseClass)\n            .setListMethod(f, i, whichArg = whichArg,\n                           remainingSignature = remainingSignature,\n                           endoapply = endoapply, where = where)\n    } else if (endoapply) {\n        .setListMethod(f, \"AtomicList\", whichArg = whichArg,\n                       remainingSignature = remainingSignature,\n                       endoapply = TRUE, where = where)\n    } else {\n        .setListMethod(f, paste0(\"Simple\", inputBaseClass),\n                       outputBaseClass = outputBaseClass, whichArg = whichArg,\n                       remainingSignature = remainingSignature, mapply = mapply,\n                       where = where)\n        .setListMethod(f, paste0(\"Compressed\", inputBaseClass),\n                       outputBaseClass = outputBaseClass, whichArg = whichArg,\n                       remainingSignature, mapply = mapply,\n                       applyToUnlist = applyToUnlist, where = where)\n        if (addRleList) {\n            .setListMethod(f, \"SimpleRleList\",\n                           outputBaseClass = rleListOutputBaseClass,\n                           whichArg = whichArg,\n                           remainingSignature = remainingSignature,\n                           mapply = mapply, where = where)\n            .setListMethod(f, \"CompressedRleList\",\n                           outputBaseClass = rleListOutputBaseClass,\n                           whichArg = whichArg,\n                           remainingSignature = remainingSignature,\n                           mapply = mapply, applyToUnlist = applyToUnlist,\n                           where = where)\n        }\n    }\n}\n\n \n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Logical methods\n###\n\n.setAtomicListMethod(\"which\", inputBaseClass = \"LogicalList\",\n                     outputBaseClass = \"IntegerList\",\n                     rleListOutputBaseClass = \"IntegerList\")\n\nsetMethod(\"which\", \"CompressedLogicalList\", function(x) {\n  x.flat <- unlist(x, use.names = FALSE)\n  part <- PartitioningByEnd(x)\n  which.global <- which(x.flat)\n  group <- findInterval(which.global, start(part))\n  which.local <- which.global - start(part)[group] + 1L\n  ans <- splitAsList(which.local, factor(group, seq_len(length(x))))\n  names(ans) <- names(x)\n  ans\n})\n\nsetMethods(\"ifelse2\", list(c(\"CompressedLogicalList\", \"ANY\", \"ANY\"),\n                           c(\"CompressedLogicalList\", \"ANY\", \"List\"),\n                           c(\"CompressedLogicalList\", \"List\", \"ANY\"),\n                           c(\"CompressedLogicalList\", \"List\", \"List\")),\n           function(test, yes, no) {\n             .do_CompressedList_binary_op(function(yes, no) {\n               ifelse(unlist(test, use.names=FALSE), yes, no)\n             }, as(yes, \"List\"), as(no, \"List\"), test)\n           })\n\nsetMethods(\"ifelse2\", list(c(\"SimpleLogicalList\", \"ANY\", \"ANY\"),\n                           c(\"SimpleLogicalList\", \"ANY\", \"List\"),\n                           c(\"SimpleLogicalList\", \"List\", \"ANY\"),\n                           c(\"SimpleLogicalList\", \"List\", \"List\")),\n           function(test, yes, no) {\n             as(mapply(ifelse, test, yes, no, SIMPLIFY=FALSE), \"List\")\n           })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Numerical methods\n###\n\nsetCompressedListWhichSummaryMethod <-\n    function(fun, where=topenv(parent.frame()))\n    {\n        def <- function(x, global = FALSE) {\n            stopifnot(isTRUEorFALSE(global))\n            ans <- .Call2(C_fun, x, PACKAGE=\"IRanges\")\n            if (global) {\n                ans <- toglobal(ans, x)\n            }\n            ans\n        }\n        setCompressedNumericalListMethod(fun, def, where)\n    }\nsetCompressedListWhichSummaryMethod(\"which.min\")\nsetCompressedListWhichSummaryMethod(\"which.max\")\n\nsetMethod(\"which.min\", \"CompressedRleList\",\n          function(x) {\n            viewWhichMins(as(x, \"RleViews\")) -\n              c(0L, head(cumsum(elementNROWS(x)), -1))\n          })\nsetMethod(\"which.max\", \"CompressedRleList\",\n          function(x) {\n            viewWhichMaxs(as(x, \"RleViews\")) -\n              c(0L, head(cumsum(elementNROWS(x)), -1))\n          })\n\nfor (i in c(\"IntegerList\", \"NumericList\", \"RleList\")) {\n    .setAtomicListMethod(\"diff\", inputBaseClass = i, endoapply = TRUE)\n}\n\nsetMethods(\"mean\",\n           list(\"CompressedLogicalList\",\n                \"CompressedIntegerList\",\n                \"CompressedNumericList\",\n                \"CompressedRleList\"),\n           function(x, trim = 0, na.rm = FALSE) {\n               stopifnot(isTRUEorFALSE(na.rm))\n               stopifnot(isSingleNumber(trim))\n               if (trim > 0) {\n                   return(callNextMethod())\n               }\n               x_eltNROWS <- if (na.rm) sum(!is.na(x)) else elementNROWS(x)\n               sum(x, na.rm=na.rm) / x_eltNROWS\n           })\n\nsetMethod(\"median\", \"CompressedAtomicList\", function(x, na.rm=FALSE) {\n    stopifnot(isTRUEorFALSE(na.rm))\n    sx <- sort(x)\n    n <- lengths(sx)\n    half <- (n + 1L)%/%2L\n    even <- n%%2L != 1L\n    ind <- IRanges(half, width=1L+even)\n    NAs <- half == 0L\n    ind <- relist(ind[!NAs], PartitioningByWidth(as.integer(!NAs)))\n    ## ind <- as(half, \"IntegerList\")\n    ## ind[even] <- ind[even] + as(0:1, \"IntegerList\")\n    ans <- mean(sx[ind])\n    if (!na.rm) {\n        NAs <- NAs | anyNA(x)\n    }\n    if (any(NAs)) {\n        ans[NAs] <- as(NA, elementType(x))\n    }\n    ans\n})\n\nsetMethod(\"diff\", \"CompressedAtomicList\",\n           function(x, lag = 1L, differences = 1L) {\n               stopifnot(isSingleNumber(lag))\n               stopifnot(isSingleNumber(differences))\n               r <- x\n               for (i in seq_len(differences))\n                   r <- tails(r, -lag) - heads(r, -lag)\n               r\n           })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Running window statistic methods\n###\n\n.setAtomicListMethod(\"smoothEnds\", inputBaseClass = \"IntegerList\",\n                     endoapply = TRUE)\n\n.setAtomicListMethod(\"smoothEnds\", inputBaseClass = \"NumericList\",\n                     endoapply = TRUE)\n\n.setAtomicListMethod(\"smoothEnds\", inputBaseClass = \"RleList\",\n                     endoapply = TRUE)\n\nsetMethod(\"runmed\", \"CompressedIntegerList\",\n          function(x, k, endrule = c(\"median\", \"keep\", \"constant\"),\n                   algorithm = NULL, print.level = 0)\n              NumericList(lapply(x, runmed, k = k, endrule = match.arg(endrule),\n                                 algorithm = algorithm,\n                                 print.level = print.level)))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Character\n###\n\nnchar_CompressedList <- function(x, type=\"chars\", allowNA=FALSE)\n{\n        unlisted_x <- unlist(x, use.names=FALSE)\n        unlisted_ans <- nchar(unlisted_x, type=type, allowNA=allowNA)\n        relist(unlisted_ans, x)\n}\n\n### H.P. (Feb 5, 2018): Does not seem right to output a CompressedList object\n### when the input is SimpleList!\nsetMethod(\"nchar\", \"CompressedCharacterList\", nchar_CompressedList)\nsetMethod(\"nchar\", \"SimpleCharacterList\", nchar_CompressedList)  # not good!\n\nsetMethod(\"nchar\", \"CompressedRleList\", nchar_CompressedList)\nsetMethod(\"nchar\", \"SimpleRleList\", nchar_CompressedList)  # not good!\n\n\nsetMethod(\"paste\", \"CompressedAtomicList\",\n          function(..., sep=\" \", collapse=NULL) {\n              args <- lapply(list(...), as, \"CharacterList\")\n              x_eltNROWS <- do.call(pmax, lapply(args, elementNROWS))\n              args <- lapply(args, recycleListElements, x_eltNROWS)\n              unlisted <- lapply(args, unlist, use.names=FALSE)\n              ans <- relist(do.call(paste, c(unlisted, sep=sep)),\n                            PartitioningByWidth(x_eltNROWS))\n              if (!is.null(collapse)) {\n                  ans <- unstrsplit(ans, collapse)\n              }\n              ans\n          })\n\n## need vectorized start, end\n##.setAtomicListMethod(\"substr\")\n##.setAtomicListMethod(\"substring\")\n.setAtomicListMethod(\"chartr\", inputBaseClass = \"CharacterList\",\n                     outputBaseClass = \"CharacterList\", whichArg = 3L,\n                     applyToUnlist = TRUE)\n\n.setAtomicListMethod(\"tolower\", inputBaseClass = \"CharacterList\",\n                     outputBaseClass = \"CharacterList\",  applyToUnlist = TRUE)\n\n.setAtomicListMethod(\"toupper\", inputBaseClass = \"CharacterList\",\n                     outputBaseClass = \"CharacterList\", applyToUnlist = TRUE)\n\n.setAtomicListMethod(\"sub\", inputBaseClass = \"CharacterList\",\n                     outputBaseClass = \"CharacterList\", whichArg = 3L,\n                     applyToUnlist = TRUE)\n\n.setAtomicListMethod(\"gsub\", inputBaseClass = \"CharacterList\",\n                     outputBaseClass = \"CharacterList\", whichArg = 3L,\n                     applyToUnlist = TRUE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Comparison / sorting\n###\n\nsetMethod(\"selfmatch\", \"CompressedAtomicList\", function(x, global=FALSE) {\n    g <- subgrouping(x)\n    first <- unlist(g)[start(PartitioningByEnd(g))]\n    ux <- unlist(x, use.names=FALSE)\n    ux[unlist(g)] <- rep(first, lengths(g))\n    ans <- relist(ux, x)\n    if (!global) {\n        ans <- ans - start(ans) + 1L\n    }\n    ans\n})\n\n.duplicated.CompressedAtomicList <- function(x, incomparables=FALSE,\n                                             fromLast=FALSE, nmax=NA, ...)\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"\\\"duplicated\\\" method for CompressedList objects \",\n             \"does not support the 'incomparables' argument\")\n    if (length(list(...)) > 0L) {\n        stop(\"arguments in '...' are not supported\")\n    }\n    stopifnot(isTRUEorFALSE(fromLast))\n    g <- subgrouping(x)\n    p <- PartitioningByEnd(g)\n    first <- unlist(g)[if (fromLast) end(p) else start(p)]\n    v <- rep(TRUE, length(unlist(g)))\n    v[first] <- FALSE\n    relist(v, x)\n}\nsetMethod(\"duplicated\", \"CompressedAtomicList\",\n          .duplicated.CompressedAtomicList)\n\nsetMethod(\"rank\", \"CompressedAtomicList\",\n          function (x, na.last = TRUE,\n                    ties.method = c(\"average\", \"first\",\n                                    \"last\", \"random\", \"max\", \"min\"))\n          {\n              stopifnot(isTRUE(na.last))\n              ties.method <- match.arg(ties.method)\n              if (ties.method == \"last\" || ties.method == \"random\")\n                  stop(\"'ties.method' last/random not yet supported\")\n              p <- PartitioningByEnd(x)\n              o <- order(togroup(p), unlist(x, use.names=FALSE))\n              r <- unlist_as_integer(IRanges(1L, width=width(p)))\n              gp <- PartitioningByEnd(end(Rle(unlist(x, use.names=FALSE)[o])))\n              v <- switch(ties.method,\n                          average=(r[start(gp)] + r[end(gp)])/2,\n                          first=r,\n                          ## last=,\n                          ## random=,\n                          max=r[end(gp)],\n                          min=r[start(gp)])\n              if (ties.method != \"first\")\n                  v <- rep(v, width(gp))\n              r[o] <- v\n              relist(r, x)\n          })\n\nsetMethod(\"order\", \"CompressedAtomicList\",\n          function (..., na.last = TRUE, decreasing = FALSE,\n                    method = c(\"auto\", \"shell\", \"radix\"))\n{\n    args <- list(...)\n    if (length(args) != 1L)\n        stop(\"\\\"order\\\" method for CompressedAtomicList objects \",\n             \"can only take one input object\")\n    x <- args[[1L]]\n    p <- PartitioningByEnd(x)\n    ux <- unlist(x, use.names=FALSE)\n    o <- order(togroup(p), ux, na.last=na.last,\n               decreasing=decreasing, method=method)\n    skeleton <- if (is.na(na.last) && anyNA(ux)) {\n        skeleton <- PartitioningByWidth(width(p) - sum(is.na(x)))\n    } else p\n    relist(o, skeleton) - start(p) + 1L\n})\n\n\n",
        "CompressedDataFrameList-class.R": "### =========================================================================\n### CompressedDataFrameList objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"CompressedDataFrameList\",\n    contains=c(\"DataFrameList\", \"CompressedList\"),\n    representation(\"VIRTUAL\", unlistData=\"DataFrame\"),\n    prototype(unlistData=new(\"DFrame\"))\n)\n\nsetClass(\"CompressedDFrameList\",\n    contains=c(\"DFrameList\", \"CompressedDataFrameList\"),\n    representation(unlistData=\"DFrame\")\n)\n\nsetClass(\"CompressedSplitDataFrameList\",\n    contains=c(\"SplitDataFrameList\", \"CompressedDataFrameList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"CompressedSplitDFrameList\",\n    contains=c(\"SplitDFrameList\", \"CompressedDFrameList\",\n               \"CompressedSplitDataFrameList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\n### Deprecated.\n### IMPORTANT NOTE: We won't be able to go thru the Defunct cycle because\n### a lot of code around assumes that ncol() can be called on an arbitrary\n### object!\nsetMethod(\"ncol\", \"CompressedSplitDataFrameList\",\n          function(x)\n          {\n            msg <- c(\"The ncol() method for CompressedSplitDataFrameList \",\n                     \"objects is deprecated. Please use ncols() on these \",\n                     \"objects instead.\")\n            .Deprecated(msg=wmsg(msg))\n            if (length(x) == 0L)\n              0L\n            else\n              structure(rep.int(ncol(x@unlistData), length(x)),\n                        names = names(x))\n          })\n\nsetMethod(\"ncols\", \"CompressedSplitDataFrameList\",\n    function(x, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        ans_names <- if (use.names) names(x) else NULL\n        structure(rep.int(ncol(x@unlistData), length(x)), names=ans_names)\n    }\n)\n\nsetMethod(\"colnames\", \"CompressedSplitDataFrameList\",\n          function(x, do.NULL = TRUE, prefix = \"col\")\n          {\n            if (length(x)) {\n              nms <- colnames(x@unlistData, do.NULL = do.NULL, prefix = prefix)\n              rep(CharacterList(nms), length(x))\n            } else NULL\n          })\n\nsetReplaceMethod(\"rownames\", \"CompressedSplitDataFrameList\",\n                 function(x, value)\n                 {\n                   if (is.null(value)) {\n                     rownames(x@unlistData) <- NULL\n                   } else if (is(value, \"CharacterList\")){\n                     if (length(x) != length(value))\n                       stop(\"replacement value must be the same length as x\")\n                     rownames(x@unlistData) <- unlist(value, use.names=FALSE)\n                   } else {\n                     stop(\"replacement value must either be NULL or a CharacterList\")\n                   }\n                   x\n                 })\n\nsetReplaceMethod(\"colnames\", \"CompressedSplitDataFrameList\",\n                 function(x, value)\n                 {\n                   if (is.null(value)) {\n                     colnames(x@unlistData) <- NULL\n                   } else if (is.character(value)) {\n                     colnames(x@unlistData) <- value\n                   } else if (is(value, \"CharacterList\")){\n                     if (length(x) != length(value))\n                       stop(\"replacement value must be the same length as x\")\n                     if (length(x) > 0)\n                       colnames(x@unlistData) <- unlist(value[[1L]])\n                   } else {\n                     stop(\"replacement value must either be NULL or a CharacterList\")\n                   }\n                   x\n                 })\n\nsetMethod(\"commonColnames\", \"CompressedSplitDataFrameList\",\n          function(x) colnames(unlist(x, use.names=FALSE)))\n\nsetMethod(\"columnMetadata\", \"CompressedSplitDataFrameList\", function(x) {\n  mcols(x@unlistData, use.names=FALSE)\n})\n\nsetReplaceMethod(\"columnMetadata\", \"CompressedSplitDataFrameList\",\n                 function(x, value) {\n                   mcols(x@unlistData) <- value\n                   x\n                 })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting.\n###\n\nsetMethod(\"[\", \"CompressedSplitDataFrameList\",\n          function(x, i, j, ..., drop=TRUE)\n          {\n            if (!missing(j))\n              x@unlistData <- x@unlistData[, j, drop=FALSE]\n            if (!missing(i))\n              x <- callNextMethod(x, i)\n\n            if (((nargs() - !missing(drop)) > 2) &&\n                (ncol(x@unlistData) == 1) && (missing(drop) || drop)) {\n              x <- relist(x@unlistData[[1L]], x)\n            }\n\n            x\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"ANY\", \"CompressedDataFrameList\",\n    function(from) as(from, \"CompressedDFrameList\")\n)\nsetAs(\"ANY\", \"CompressedSplitDataFrameList\",\n    function(from) as(from, \"CompressedSplitDFrameList\")\n)\n\nsetListCoercions(\"DFrame\")\n\nsetAs(\"ANY\", \"CompressedSplitDFrameList\",\n      function(from) {\n        coerceToCompressedList(from, \"DFrame\")\n      })\n\nsetAs(\"ANY\", \"SplitDFrameList\",\n      function(from) as(from, \"CompressedSplitDFrameList\"))\n\nsetAs(\"DataFrame\", \"SplitDFrameList\",\n      function(from) as(from, \"CompressedSplitDFrameList\"))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"classNameForDisplay\", \"CompressedDFrameList\",\n    function(x) sub(\"^Compressed\", \"\", sub(\"DFrame\", \"DataFrame\", class(x)))\n)\n\n",
        "CompressedGrouping-class.R": "### =========================================================================\n### CompressedGrouping objects\n### -------------------------------------------------------------------------\n\nsetClass(\"CompressedGrouping\",\n### TODO: contain VIRTUAL after R 3.4 release\n         contains=c(\"Grouping\", \"CompressedIntegerList\"))\n\nsetClass(\"CompressedManyToOneGrouping\",\n         contains=c(\"ManyToOneGrouping\", \"CompressedGrouping\"))\n\nsetClass(\"CompressedManyToManyGrouping\",\n         contains=c(\"BaseManyToManyGrouping\", \"CompressedGrouping\"))\n\n### -------------------------------------------------------------------------\n### Grouping API implementation\n### ----------------------------\n###\n\nsetMethod(\"grouplengths\", \"CompressedGrouping\",\n          function(x, i=NULL) grouplengths(PartitioningByEnd(x), i))\n\nsetMethod(\"nobj\", \"CompressedManyToOneGrouping\",\n          function(x) nobj(PartitioningByEnd(x)))\n\n",
        "CompressedHitsList-class.R": "### =========================================================================\n### CompressedHitsList objects\n### -------------------------------------------------------------------------\n\n### [H.P. - 2015/12/17] Why do we need this? Where is it used?\n### It's not even exported.\n\nsetClass(\"CompressedHitsList\",\n    prototype = prototype(elementType = \"Hits\",\n                          unlistData = new(\"Hits\")),\n    contains=\"CompressedList\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"from\", \"CompressedHitsList\", function(x) from(x@unlistData))\nsetMethod(\"to\", \"CompressedHitsList\", function(x) to(x@unlistData))\n\nsetMethod(\"nLnode\", \"CompressedHitsList\", function(x) nLnode(x@unlistData))\nsetMethod(\"nRnode\", \"CompressedHitsList\", function(x) nRnode(x@unlistData))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nCompressedHitsList <- function(hits, query)\n{\n  if (!(is(query, \"CompressedIRangesList\")))\n    stop(\"'query' must be a 'CompressedIRangesList' object\")\n  if (!is(hits, \"Hits\"))\n    stop(\"'hits' must be a 'Hits' object\")\n\n  qspace <- space(query)\n  hspace <- as.integer(qspace[queryHits(hits)])\n  partitioning <- PartitioningByEnd(hspace, names=names(query@partitioning), NG=length(names(query@partitioning)))\n  newCompressedList0(\"CompressedHitsList\", unlistData=hits, partitioning=partitioning)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n## return as.matrix as on Hits, with indices adjusted\n\nsetMethod(\"as.matrix\", \"CompressedHitsList\", function(x) {\n  cbind(queryHits=queryHits(x), subjectHits=subjectHits(x))\n})\n\n",
        "CompressedList-class.R": "### =========================================================================\n### CompressedList objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"CompressedList\",\n    contains=\"List\",\n    representation(\n        \"VIRTUAL\",\n        unlistData=\"ANY\",\n        partitioning=\"PartitioningByEnd\"\n    )\n)\n\nsetMethod(\"classNameForDisplay\", \"CompressedList\",\n    function(x) sub(\"^Compressed\", \"\", class(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.CompressedList.partitioning <- function(x)\n{\n    dataLength <- NROW(x@unlistData)\n    if (nobj(x@partitioning) != dataLength)\n        \"improper partitioning\"\n    else NULL\n}\n.valid.CompressedList.unlistData <- function(x)\n{\n    ## FIXME: workaround to support CompressedNormalIRangesList\n    ## elementTypeX <- elementType(x)\n    elementTypeX <- elementType(new(class(x)))\n    if (!extends(class(x@unlistData), elementTypeX))\n        paste(\"the 'unlistData' slot must be of class\", elementTypeX)\n    else NULL\n}\n.valid.CompressedList <- function(x)\n{\n    c(.valid.CompressedList.unlistData(x),\n      .valid.CompressedList.partitioning(x))\n}\nsetValidity2(\"CompressedList\", .valid.CompressedList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### This just implements the generic updateObject strategy that consists\n### in calling updateObject() on each **proper** CompressedList slot i.e.\n### on the slots added by the CompressedList class, or, said otherwise, on\n### the slots that are not inherited.\nsetMethod(\"updateObject\", \"CompressedList\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## The 'unlistData' slot could be an Rle, DataFrame, IRanges or\n        ## GRanges object, or any vector-like object that needs an update.\n        object@unlistData <- updateObject(object@unlistData,\n                                          ..., verbose=verbose)\n\n        ## The 'partitioning' slot is a PartitioningByEnd object which derives\n        ## from IPosRanges so its elementType slot might need to be updated.\n        ## See \"updateObject\" method for IPosRanges objects for more\n        ## information.\n        object@partitioning <- updateObject(object@partitioning,\n                                            ..., verbose=verbose)\n\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters and setters\n###\n\nsetMethod(\"length\", \"CompressedList\", function(x) length(x@partitioning))\n\nsetMethod(\"names\", \"CompressedList\", function(x) names(x@partitioning))\n\nsetMethod(\"elementNROWS\", \"CompressedList\",\n    function(x)\n    {\n        ans <- elementNROWS(x@partitioning)\n        names(ans) <- names(x)\n        ans\n    }\n)\n\nsetReplaceMethod(\"names\", \"CompressedList\",\n    function(x, value)\n    {\n        names(x@partitioning) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n### Use\n###     IRanges:::newCompressedList0(getClass(\"MyClass\"),\n###                                  unlistData, partitioning)\n### when calling this from another package.\n###\n\n.reconcile_mcols <- function(x) {\n  x_mcols <- mcols(x, use.names=FALSE)\n  if (is(x_mcols, \"DataFrame\") &&\n      nrow(x_mcols) == 0L && ncol(x_mcols) == 0L)\n    {\n      x_mcols <- make_zero_col_DFrame(length(x))\n      mcols(x) <- x_mcols\n    }\n  x\n}\n\n### Low-level. NOT exported.\nnewCompressedList0 <- function(Class, unlistData, partitioning)\n{\n    ## Note that 'unlistData_target_class' could also be obtained\n    ## with 'getClassDef(Class)@slots[[\"unlistData\"]]', in which\n    ## case the class name would be returned with the \"package\" attribute.\n    unlistData_target_class <- getSlots(Class)[[\"unlistData\"]]\n\n    ## 'unlistData' must derive from the class expected by the \"unlistData\"\n    ## slot. If it doesn't (e.g. if 'Class' is \"CompressedSplitDFrameList\"\n    ## and 'unlistData' is an ordinary data.frame), then we coerce it. Note\n    ## that this coercion could fail.\n    if (!is(unlistData, unlistData_target_class))\n        unlistData <- as(unlistData, unlistData_target_class)\n    ans <- new2(Class, unlistData=unlistData,\n                       partitioning=partitioning, check=FALSE)\n    .reconcile_mcols(ans)\n}\n\n### Low-level. NOT exported.\n### Stuff to put in elementMetadata slot can be passed either with\n###   new_CompressedList_from_list(..., elementMetadata=somestuff)\n### or with\n###   new_CompressedList_from_list(..., mcols=somestuff)\n### The latter is the new recommended form.\nnew_CompressedList_from_list <- function(Class, x, ..., mcols)\n{\n    if (!extends(Class, \"CompressedList\"))\n        stop(\"class \", Class, \" must extend CompressedList\")\n    if (!is.list(x))\n        stop(\"'x' must be a list\")\n    ans_elementType <- elementType(new(Class))\n    if (!all(sapply(x, function(xi) extends(class(xi), ans_elementType))))\n        stop(\"all elements in 'listData' must be \", ans_elementType, \" objects\")\n    ans_partitioning <- PartitioningByEnd(x)\n    if (length(x) == 0L) {\n        if (missing(mcols))\n            return(new2(Class, partitioning=ans_partitioning, ..., check=FALSE))\n        return(new2(Class, partitioning=ans_partitioning, ...,\n                           elementMetadata=mcols, check=FALSE))\n    }\n    ans_unlistData <- S4Vectors:::compress_listData(x, ans_elementType)\n    if (missing(mcols)) {\n        ans <- new2(Class, unlistData=ans_unlistData,\n                           partitioning=ans_partitioning, ...,\n                           check=FALSE)\n    } else {\n        ans <- new2(Class, unlistData=ans_unlistData,\n                           partitioning=ans_partitioning, ...,\n                           elementMetadata=mcols,\n                           check=FALSE)\n    }\n    .reconcile_mcols(ans)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unlist()\n###\n\n### Overwrite method for List objects with super fast method for CompressedList\n### objects.\nsetMethod(\"unlist\", \"CompressedList\",\n    function(x, recursive=TRUE, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        unlisted_x <- x@unlistData\n        if (use.names)\n            unlisted_x <- S4Vectors:::set_unlisted_names(unlisted_x, x)\n        unlisted_x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\ncoerceToCompressedList <- function(from, element.type = NULL, ...) {\n  if (is(from, S4Vectors:::listClassName(\"Compressed\", element.type)))\n    return(from)\n  if (is.list(from) || (is(from, \"List\") && !is(from, \"DataFrame\"))) {\n    if (is.list(from)) {\n      v <- S4Vectors:::compress_listData(from, element.type)\n    } else {\n      v <- unlist(from, use.names = FALSE)\n    }\n    part <- PartitioningByEnd(from)\n  } else {\n    v <- from\n    part <- PartitioningByEnd(seq_len(NROW(from)))\n  }\n  if (!is.null(element.type)) {\n    v <- S4Vectors:::coercerToClass(element.type)(v, ...)\n  }\n  to <- relist(v, part)\n  names(to) <- names(from)\n  if (is(from, \"List\"))\n    mcols(to) <- mcols(from)\n  to\n}\n\nsetAs(\"ANY\", \"CompressedList\", function(from) coerceToCompressedList(from))\n\nsetListCoercions <- function(type) {\n  CompressedClass <- S4Vectors:::listClassName(\"Compressed\", type)\n  SimpleClass <- S4Vectors:::listClassName(\"Simple\", type)\n  Class <- S4Vectors:::listClassName(\"\", type)\n  hasCompressedList <- CompressedClass != \"CompressedList\"\n  if (hasCompressedList) {\n    setAs(\"ANY\", CompressedClass, CoercerToList(type, compress = TRUE))\n  }\n  setAs(\"ANY\", SimpleClass, CoercerToList(type, compress = FALSE))\n  setAs(\"ANY\", Class, CoercerToList(type, compress = hasCompressedList))\n  setAs(\"SimpleList\", Class, CoercerToList(type, compress = FALSE))\n  setAs(\"list\", Class, CoercerToList(type, compress = FALSE))\n}\n\n### Used by the following coercion methods to perform a \"dumb split\" with\n### propagation of the metadata columns:\n###   - from IntegerRanges to CompressedIRangesList\n###   - from GenomicRanges to CompressedGRangesList\n###   - from XStringSet to XStringSetList\n###   - and maybe more...\n### NOT exported.\nfrom_Vector_to_CompressedList <- function(from)\n{\n    ans_mcols <- mcols(from, use.names=FALSE)\n    mcols(from) <- NULL\n    ans <- splitAsList(from)  # dumb split\n    mcols(ans) <- ans_mcols\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting.\n###\n\nsetMethod(\"extractROWS\", \"CompressedList\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        ans_eltNROWS <- extractROWS(width(x@partitioning), i)\n        ans_breakpoints <- suppressWarnings(cumsum(ans_eltNROWS))\n        nbreakpoints <- length(ans_breakpoints)\n        if (nbreakpoints != 0L && is.na(ans_breakpoints[[nbreakpoints]]))\n            stop(wmsg(\"Subsetting operation on \", class(x), \" object 'x' \",\n                      \"produces a result that is too big to be \",\n                      \"represented as a CompressedList object. \",\n                      \"Please try to coerce 'x' to a SimpleList object \",\n                      \"first (with 'as(x, \\\"SimpleList\\\")').\"))\n        idx_on_unlisted_x <- IRanges(end=extractROWS(end(x@partitioning), i),\n                                     width=ans_eltNROWS)\n        ans_unlistData <- extractROWS(x@unlistData, idx_on_unlisted_x)\n        ans_partitioning <- new2(\"PartitioningByEnd\",\n                                 end=ans_breakpoints,\n                                 NAMES=extractROWS(names(x), i),\n                                 check=FALSE)\n        ans_elementMetadata <- extractROWS(x@elementMetadata, i)\n        initialize(x, unlistData=ans_unlistData,\n                      partitioning=ans_partitioning,\n                      elementMetadata=ans_elementMetadata)\n    }\n)\n\nsetMethod(\"getListElement\", \"CompressedList\",\n    function(x, i, exact=TRUE)\n    {\n        i2 <- normalizeDoubleBracketSubscript(i, x, exact=exact,\n                                              allow.NA=TRUE,\n                                              allow.nomatch=TRUE)\n        if (is.na(i2))\n            return(NULL)\n        unlisted_x <- unlist(x, use.names=FALSE)\n        x_partitioning <- PartitioningByEnd(x)\n        window_start <- start(x_partitioning)[i2]\n        window_end <- end(x_partitioning)[i2]\n        S4Vectors:::Vector_window(unlisted_x,\n                                  start=window_start,\n                                  end=window_end)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.concatenate_CompressedList_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- S4Vectors:::prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ## 1. Take care of the parallel slots\n\n    ## Call method for Vector objects to concatenate all the parallel slots\n    ## (only \"elementMetadata\" in the case of CompressedList) and stick them\n    ## into 'ans'. Note that the resulting 'ans' can be an invalid object\n    ## because its \"elementMetadata\" slot can be longer (i.e. have more rows)\n    ## than 'ans' itself so we use 'check=FALSE' to skip validation.\n    ans <- callNextMethod(x, objects, use.names=use.names,\n                                      ignore.mcols=ignore.mcols,\n                                      check=FALSE)\n\n    ## 2. Take care of the non-parallel slots\n\n    ## Concatenate the \"unlistData\" slots.\n    unlistData_list <- lapply(all_objects, slot, \"unlistData\")\n    ## Skip validation here too (we'll validate the final object).\n    ans_unlistData <- bindROWS(unlistData_list[[1L]],\n                               objects=unlistData_list[-1L],\n                               check=FALSE)\n\n    ## Concatenate the \"partitioning\" slots.\n    ans_breakpoints <- cumsum(unlist(lapply(all_objects, elementNROWS),\n                                     use.names=use.names))\n    ans_partitioning <- PartitioningByEnd(ans_breakpoints)\n\n    ## Update 'ans' and validate it (if the caller has set 'check' to TRUE).\n    BiocGenerics:::replaceSlots(ans, unlistData=ans_unlistData,\n                                     partitioning=ans_partitioning,\n                                     check=check)\n}\n\nsetMethod(\"bindROWS\", \"CompressedList\", .concatenate_CompressedList_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Looping.\n###\n\n### Cannot really avoid the cost of extracting X[[i]] for all valid i but tries\n### to minimize this cost by using 2 tricks:\n###   1. Avoids looping on values of i for which X[[i]] has length 0. Instead\n###      FUN(X[[i]], ...) is computed only once (because it's the same for all\n###      these values of i) and placed at the corresponding positions in the\n###      returned list.\n###   2. Turn off object validation during the main loop. Note that there is no\n###      reason to restrict this trick to CompressedList objects and the same\n###      trick could be used in the \"lapply\" method for List objects.\n### Does NOT propagate the names.\nlapply_CompressedList <- function(X, FUN, ...)\n{\n    FUN <- match.fun(FUN)\n    ans <- vector(mode=\"list\", length=length(X))\n    unlisted_X <- unlist(X, use.names=FALSE)\n    X_partitioning <- PartitioningByEnd(X)\n    X_elt_width <- width(X_partitioning)\n    empty_idx <- which(X_elt_width == 0L)\n    if (length(empty_idx) != 0L) \n        ans[empty_idx] <- list(FUN(extractROWS(unlisted_X, integer(0)), ...))\n    non_empty_idx <- which(X_elt_width != 0L)\n    if (length(non_empty_idx) == 0L)\n        return(ans)\n    X_elt_start <- start(X_partitioning)\n    X_elt_end <- end(X_partitioning)\n    ans[non_empty_idx] <-\n      lapply(non_empty_idx,\n             function(i)\n                 FUN(extractROWS(unlisted_X,\n                                 IRanges(X_elt_start[i], X_elt_end[i])),\n                     ...))\n    ans\n}\n\nsetMethod(\"lapply\", \"CompressedList\",\n    function(X, FUN, ...)\n    {\n        ans <- lapply_CompressedList(X, FUN, ...)\n        names(ans) <- names(X)\n        ans\n    }\n)\n\nsetMethod(\"revElements\", \"CompressedList\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        if (length(i) == 0L)\n            return(x)\n        rev <- logical(length(x))\n        rev <- replaceROWS(rev, i, TRUE)\n        x_partitioning <- PartitioningByEnd(x)\n        from <- ifelse(rev, end(x_partitioning), start(x_partitioning))\n        by <- ifelse(rev, -1L, 1L)\n        ii <- sequence(width(x_partitioning), from, by)\n        x@unlistData <- extractROWS(x@unlistData, ii)\n        x\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Recycling\n###\n\nrepLengthOneElements <- function(x, times) {\n    x@unlistData <- rep(x@unlistData, times)\n    x@partitioning@end <- cumsum(times)\n    x\n}\n\nrecycleListElements <- function(x, newlen) {\n    x_eltNROWS <- elementNROWS(x)\n    if (identical(x_eltNROWS, newlen)) {\n        return(x)\n    }\n    if (all(x_eltNROWS == 1L)) {\n        ans <- repLengthOneElements(x, newlen)\n    } else {\n        if (any(x_eltNROWS == 0L & newlen > 0L)) {\n            if (is(x, \"AtomicList\")) {\n                x[x_eltNROWS == 0L & newlen > 0L] <- list(NA)\n            } else {\n                stop(\"recycling of zero-length elements not supported\")\n            }\n            x_eltNROWS <- elementNROWS(x)\n        }\n        times <- ceiling(newlen / x_eltNROWS)\n        times[x_eltNROWS == 0L] <- 0L\n        ans_ir <- rep(as(PartitioningByEnd(x), \"IRanges\"), times)\n        remainder <- newlen %% x_eltNROWS\n        remainder[x_eltNROWS == 0L] <- 0L\n        if (any(remainder > 0L)) {\n            last <- cumsum(times)\n            width(ans_ir)[last[remainder > 0]] <- remainder[remainder > 0]\n            warning(\"Some element lengths are not multiples of their \",\n                    \"corresponding element length in \", deparse(substitute(x)))\n        }\n        ans <- relist(extractROWS(unlist(x, use.names=FALSE), ans_ir),\n                      PartitioningByWidth(newlen))\n    }\n    ans\n}\n",
        "CompressedList-comparison.R": "### =========================================================================\n### Comparing and ordering CompressedList objects\n### -------------------------------------------------------------------------\n###\n### Overwrite methods defined in S4Vectors/R/List-comparison.R for List\n### objects with optimized methods for CompressedList objects.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Element-wise (aka \"parallel\") comparison of 2 List objects.\n###\n### TODO: Add optimized \"==\" and \"<=\" methods for CompressedList objects.\n###\n\nsetMethod(\"!\", \"CompressedList\",\n    function(x) relist(!unlist(x, use.names=FALSE), x)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n\n### The first match method catches CompressedList,list; 'table' is atomic\nsetMethod(\"match\", c(\"CompressedList\", \"vector\"),\n          function(x, table, nomatch = NA_integer_, incomparables = NULL, ...)\n          {\n            m <- match(x@unlistData, table, nomatch=nomatch,\n                       incomparables=incomparables, ...)\n            relist(m, x)\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### duplicated() & unique()\n###\n\n.duplicated.CompressedList <- function(x, incomparables=FALSE,\n                                       fromLast=FALSE, nmax=NA)\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"\\\"duplicated\\\" method for CompressedList objects \",\n             \"does not support the 'incomparables' argument\")\n    x_unlistData <- x@unlistData\n    sm <- match(x_unlistData, x_unlistData)  # doesn't work on an Rle\n    x_group <- rep.int(seq_along(x), elementNROWS(x))\n    ans_unlistData <- duplicatedIntegerPairs(x_group, sm, fromLast=fromLast)\n    relist(ans_unlistData, x)\n}\nsetMethod(\"duplicated\", \"CompressedList\", .duplicated.CompressedList)\n\n.unique.CompressedList <- function(x, ...)\n{\n    is_dup <- duplicated(x, ...)\n    x_unlistData <- x@unlistData\n    keep_idx <- which(!is_dup@unlistData)\n    ans_unlistData <- x_unlistData[keep_idx]\n    x_group <- rep.int(seq_along(x), elementNROWS(x))\n    ans_group <- x_group[keep_idx]\n    ans_partitioning <- PartitioningByEnd(ans_group, NG=length(x),\n                                          names=names(x))\n    relist(ans_unlistData, ans_partitioning)\n}\nsetMethod(\"unique\", \"CompressedList\", .unique.CompressedList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### %in%\n###\n\n### The \"%in%\" method for Vector objects calls is.na() internally.\nsetMethod(\"is.na\", \"CompressedList\",\n    function(x) relist(is.na(unlist(x, use.names=FALSE)), x)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### order() and related methods.\n###\n### TODO: Add optimized methods for CompressedList objects.\n###\n\n",
        "CompressedRangesList-class.R": "### =========================================================================\n### CompressedRangesList objects\n### -------------------------------------------------------------------------\n###\n\nsetClass(\"CompressedRangesList\",\n    contains=c(\"RangesList\", \"CompressedList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"CompressedPosList\",\n    contains=c(\"PosList\", \"CompressedRangesList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"CompressedIntegerRangesList\",\n    contains=c(\"IntegerRangesList\", \"CompressedRangesList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"CompressedIRangesList\",\n    contains=c(\"IRangesList\", \"CompressedIntegerRangesList\"),\n    representation(unlistData=\"IRanges\")\n)\n\n### CompressedNormalIRangesList cannot hold NormalIRanges as its elements,\n### due to the compression concatenating everything into a single\n### NormalIRanges (which could easily become non-normal). So just have it\n### hold IRanges, instead.\nsetClass(\"CompressedNormalIRangesList\",\n    contains=c(\"NormalIRangesList\", \"CompressedIRangesList\"),\n    prototype=prototype(\n        elementType=\"IRanges\",\n        unlistData=new(\"IRanges\")\n    )\n)\n\nsetClass(\"CompressedIPosList\",\n    contains=c(\"IPosList\", \"CompressedPosList\", \"CompressedIntegerRangesList\"),\n    prototype=prototype(unlistData=new(\"StitchedIPos\"))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for CompressedRangesList objects\n###\n\nsetMethod(\"start\", \"CompressedRangesList\",\n    function(x) relist(start(unlist(x, use.names=FALSE)), x)\n)\n\nsetMethod(\"end\", \"CompressedRangesList\",\n    function(x) relist(end(unlist(x, use.names=FALSE)), x)\n)\n\nsetMethod(\"width\", \"CompressedRangesList\",\n    function(x) relist(width(unlist(x, use.names=FALSE)), x)\n)\n\nsetMethod(\"pos\", \"CompressedPosList\",\n    function(x) relist(pos(unlist(x, use.names=FALSE)), x)\n)\n\nsetMethod(\".replaceSEW\", \"CompressedRangesList\",\n    function(x, FUN, ..., value)\n    {\n        if (extends(class(value), \"IntegerList\")) {\n            if (!identical(lapply(x, names), lapply(value, names)) &&\n                !all(elementNROWS(x) == elementNROWS(value)))\n                stop(\"'value' must have same length and names as current 'ranges'\")\n            value <- unlist(value)\n        } else if (is.numeric(value)) {\n            lelts <- sum(elementNROWS(x))\n            if (lelts != length(value))\n                value <- rep(value, length.out = lelts)\n            if (!is.integer(value))\n                value <- as.integer(value)\n        } else {\n            stop(\"'value' must extend class IntegerList or integer\")\n        }\n        FUN <- match.fun(FUN)\n        slot(x, \"unlistData\", check=FALSE) <-\n                        FUN(x@unlistData, ..., value = value)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for CompressedIRangesList objects\n###\n\nsetMethod(\"isNormal\", \"CompressedIRangesList\",\n    function(x, use.names=FALSE)\n        .Call2(\"C_isNormal_CompressedIRangesList\", x, use.names,\n               PACKAGE=\"IRanges\")\n)\n\nsetMethod(\"summary\", \"CompressedIRangesList\",\n    function(object)\n        .Call2(\"C_summary_CompressedIRangesList\", object,\n               PACKAGE=\"IRanges\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from list-like object to CompressedIRangesList\n###\n\n### From ordinary list to CompressedIRangesList\n\n.from_list_to_CompressedIRangesList <- function(from)\n{\n    from <- as_list_of_IRanges(from)\n    new_CompressedList_from_list(\"CompressedIRangesList\", from)\n}\n\nsetAs(\"list\", \"CompressedIRangesList\", .from_list_to_CompressedIRangesList)\n\n### From List derivative to CompressedIRangesList\n\n.from_List_to_CompressedIRangesList <- function(from)\n{\n    new_CompressedList_from_list(\"CompressedIRangesList\",\n                                 as_list_of_IRanges(from),\n                                 metadata=metadata(from),\n                                 mcols=mcols(from, use.names=FALSE))\n}\n\n### IntegerRanges objects are List objects so this case is already covered\n### by the .from_List_to_CompressedIRangesList() helper above. However, we\n### can implement it much more efficiently.\n.from_IntegerRanges_to_CompressedIRangesList <- function(from)\n{\n    if (!is(from, \"IRanges\"))\n        from <- as(from, \"IRanges\", strict=FALSE)\n    from_Vector_to_CompressedList(from)\n}\n\nsetAs(\"List\", \"CompressedIRangesList\",\n      .from_List_to_CompressedIRangesList)\n\nsetAs(\"IntegerRanges\", \"CompressedIRangesList\",\n      .from_IntegerRanges_to_CompressedIRangesList)\n\nsetAs(\"List\", \"IRangesList\",\n    function(from)\n    {\n        if (is(from, \"CompressedList\") || is(from, \"IntegerRanges\"))\n            as(from, \"CompressedIRangesList\")\n        else\n            as(from, \"SimpleIRangesList\")\n    }\n)\n\n### This case is already covered by the List-to-CompressedIRangesList coercion\n### above. However, we can implement it much more efficiently.\nsetAs(\"CompressedRleList\", \"CompressedIRangesList\",\n      function(from)\n      {\n        if ((length(from) > 0) &&\n            (!is.logical(runValue(from[[1L]])) ||\n             S4Vectors:::anyMissing(runValue(from[[1L]]))))\n          stop(\"cannot coerce a non-logical 'RleList' or a logical 'RleList' \",\n               \"with NAs to a CompressedIRangesList object\")\n        ranges <- as(unlist(from, use.names = FALSE), \"IRanges\")\n        to <- diceRangesByList(ranges, from)\n        metadata(to) <- metadata(from)\n        mcols(to) <- mcols(from, use.names=FALSE)\n        to\n      })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for CompressedNormalIRangesList objects\n###\n\nsetMethod(\"getListElement\", \"CompressedNormalIRangesList\",\n    function(x, i, exact=TRUE) newNormalIRangesFromIRanges(callNextMethod())\n)\n\n.min_CompressedNormalIRangesList <- function(x, use.names)\n{\n    if (!is(x, \"CompressedNormalIRangesList\"))\n        stop(\"'x' must be a CompressedNormalIRangesList object\")\n    use.names <- S4Vectors:::normargUseNames(use.names)\n    .Call2(\"C_min_CompressedNormalIRangesList\", x, use.names,\n\t\t\t\t\t\tPACKAGE=\"IRanges\")\n}\n\nsetMethod(\"min\", \"CompressedNormalIRangesList\",\n          function(x, ..., na.rm) .min_CompressedNormalIRangesList(x, TRUE))\n\n.max_CompressedNormalIRangesList <- function(x, use.names)\n{\n    if (!is(x, \"CompressedNormalIRangesList\"))\n        stop(\"'x' must be a CompressedNormalIRangesList object\")\n    use.names <- S4Vectors:::normargUseNames(use.names)\n    .Call2(\"C_max_CompressedNormalIRangesList\", x, use.names,\n\t\t\t\t\t\tPACKAGE=\"IRanges\")\n}\n\nsetMethod(\"max\", \"CompressedNormalIRangesList\",\n          function(x, ..., na.rm) .max_CompressedNormalIRangesList(x, TRUE))\n\n### Coercion from list to CompressedNormalIRangesList.\n.as.list.CompressedNormalIRangesList <- function(x, use.names=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    ans <- lapply_CompressedList(x, newNormalIRangesFromIRanges)\n    if (use.names)\n        names(ans) <- names(x)\n    ans\n}\nsetMethod(\"as.list\", \"CompressedNormalIRangesList\",\n    .as.list.CompressedNormalIRangesList)\n\n### Coercion from IntegerRangesList to NormalIRangesList.\n\nsetAs(\"NormalIRangesList\", \"CompressedNormalIRangesList\",\n    function(from)\n    {\n        ans <- as(from, \"CompressedIRangesList\", strict=FALSE)\n        class(ans) <- \"CompressedNormalIRangesList\"\n        ans\n    }\n)\n\nsetAs(\"CompressedIRangesList\", \"CompressedNormalIRangesList\",\n    function(from)\n    {\n        if (!all(isNormal(from)))\n            from <- reduce(from, drop.empty.ranges=TRUE)\n        class(from) <- \"CompressedNormalIRangesList\"\n        from\n    }\n)\n\nsetAs(\"IntegerRangesList\", \"CompressedNormalIRangesList\",\n    function(from)\n    {\n        as(as(from, \"CompressedIRangesList\", strict=FALSE),\n           \"CompressedNormalIRangesList\")\n    }\n)\n\nsetAs(\"IntegerRangesList\", \"NormalIRangesList\",\n    function(from)\n    {\n        if (is(from, \"SimpleIntegerRangesList\"))\n            as(from, \"SimpleNormalIRangesList\")\n        else\n            as(from, \"CompressedNormalIRangesList\")\n    }\n)\n\n### Coercion from LogicalList to NormalIRangesList.\n\nsetAs(\"LogicalList\", \"NormalIRangesList\",\n      function(from)\n      {\n        if (is(from, \"CompressedList\"))\n          as(from, \"CompressedNormalIRangesList\")\n        else\n          as(from, \"SimpleNormalIRangesList\")\n      })\n\nsetAs(\"LogicalList\", \"CompressedNormalIRangesList\",\n      function(from)\n      new_CompressedList_from_list(\"CompressedNormalIRangesList\",\n                                   lapply(from, as, \"NormalIRanges\"),\n                                   metadata = metadata(from),\n                                   mcols = mcols(from, use.names=FALSE)))\n\n### Coercion from RleList to NormalIRangesList.\n\nsetAs(\"RleList\", \"NormalIRangesList\",\n        function(from)\n        {\n            if (is(from, \"CompressedList\"))\n                as(from, \"CompressedNormalIRangesList\")\n            else\n                as(from, \"SimpleNormalIRangesList\")\n        })\n\nsetAs(\"RleList\", \"CompressedNormalIRangesList\",\n      function(from)\n      {\n        if ((length(from) > 0) &&\n            (!is.logical(runValue(from[[1L]])) ||\n             S4Vectors:::anyMissing(runValue(from[[1L]]))))\n          stop(\"cannot coerce a non-logical 'RleList' or a logical 'RleList' \",\n               \"with NAs to a CompressedNormalIRangesList object\")\n        new_CompressedList_from_list(\"CompressedNormalIRangesList\",\n                                     lapply(from, as, \"NormalIRanges\"),\n                                     metadata = metadata(from),\n                                     mcols = mcols(from, use.names=FALSE))\n      })\n\n### Coercion from IntegerRanges to IPosList.\n\n.from_IntegerRanges_to_CompressedIPosList <- function(from)\n{\n    from <- as(from, \"IRanges\")\n    ans <- relist(new_StitchedIPos(from), from)\n    mcols(ans) <- mcols(from, use.names=FALSE)\n    metadata(ans) <- metadata(from)\n    ans\n}\n\nsetAs(\"IntegerRanges\", \"CompressedIPosList\",\n    .from_IntegerRanges_to_CompressedIPosList\n)\n\nsetAs(\"IntegerRanges\", \"IPosList\",\n    .from_IntegerRanges_to_CompressedIPosList\n)\n\nsetAs(\"IRanges\", \"IPosList\",\n    .from_IntegerRanges_to_CompressedIPosList\n)\n\n",
        "DataFrameList-class.R": "### =========================================================================\n### DataFrameList objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"DataFrameList\",\n    contains=\"List\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"DataFrame\")\n)\n\nsetClass(\"DFrameList\",\n    contains=\"DataFrameList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"DFrame\")\n)\n\nsetClass(\"SimpleDataFrameList\",\n    contains=c(\"DataFrameList\", \"SimpleList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"SimpleDFrameList\",\n    contains=c(\"DFrameList\", \"SimpleDataFrameList\")\n)\n\nsetClass(\"SplitDataFrameList\",\n    contains=\"DataFrameList\",\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"SplitDFrameList\",\n    contains=c(\"DFrameList\", \"SplitDataFrameList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"SimpleSplitDataFrameList\",\n    contains=c(\"SplitDataFrameList\", \"SimpleDataFrameList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"SimpleSplitDFrameList\",\n    contains=c(\"SplitDFrameList\", \"SimpleDFrameList\",\n               \"SimpleSplitDataFrameList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\n### Deprecated.\n### IMPORTANT NOTE: We won't be able to go thru the Defunct cycle because\n### a lot of code around assumes that nrow() can be called on an arbitrary\n### object!\nsetMethod(\"nrow\", \"DataFrameList\",\n          function(x)\n          {\n            msg <- c(\"The nrow() method for DataFrameList objects is \",\n                     \"deprecated. Please use nrows() on these objects \",\n                     \"instead.\")\n            .Deprecated(msg=wmsg(msg))\n            if (length(x) == 0L)\n              0L\n            else\n              elementNROWS(x)\n          })\n\nsetMethod(\"nrows\", \"DataFrameList\",\n    function(x, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        ans <- elementNROWS(x)\n        if (!use.names)\n            names(ans) <- NULL\n        ans\n    }\n)\n\n### Deprecated.\n### IMPORTANT NOTE: We won't be able to go thru the Defunct cycle because\n### a lot of code around assumes that ncol() can be called on an arbitrary\n### object!\nsetMethod(\"ncol\", \"DataFrameList\",\n          function(x)\n          {\n            msg <- c(\"The ncol() method for DataFrameList objects is \",\n                     \"deprecated. Please use ncols() on these objects \",\n                     \"instead.\")\n            .Deprecated(msg=wmsg(msg))\n            if (length(x) == 0L)\n              0L\n            else\n              unlist(lapply(x, ncol))\n          })\n\nsetMethod(\"ncols\", \"DataFrameList\",\n    function(x, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        vapply(x, ncol, integer(1), USE.NAMES=use.names)\n    }\n)\n\n### Deprecated.\n### IMPORTANT NOTE: We won't be able to go thru the Defunct cycle because\n### a lot of code around assumes that ncol() can be called on an arbitrary\n### object!\nsetMethod(\"ncol\", \"SimpleSplitDataFrameList\",\n          function(x)\n          {\n            msg <- c(\"The ncol() method for SimpleSplitDataFrameList objects \",\n                     \"is deprecated. Please use ncols() on these objects \",\n                     \"instead.\")\n            .Deprecated(msg=wmsg(msg))\n            if (length(x) == 0L)\n              0L\n            else\n              structure(rep.int(ncol(x[[1L]]), length(x)),\n                        names = names(x))\n          })\n\nsetMethod(\"ncols\", \"SimpleSplitDataFrameList\",\n    function(x, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        ans_names <- if (use.names) names(x) else NULL\n        structure(rep.int(ncol(x[[1L]]), length(x)), names=ans_names)\n    }\n)\n\n### Deprecated.\n### IMPORTANT NOTE: We won't be able to go thru the Defunct cycle because\n### a lot of code around assumes that dim() can be called on an arbitrary\n### object e.g. in S4Vectors:::.NSBS.character_OR_factor().\nsetMethod(\"dim\", \"DataFrameList\",\n          function(x)\n          {\n            msg <- c(\"The dim() method for DataFrameList objects is \",\n                     \"deprecated. Please use dims() on these objects \",\n                     \"instead.\")\n            .Deprecated(msg=wmsg(msg))\n            cbind(nrow(x), ncol(x))\n          })\n\nsetMethod(\"dims\", \"DataFrameList\",\n    function(x, use.names=TRUE)\n    {\n        cbind(nrows(x, use.names=use.names), ncols(x, use.names=FALSE))\n    }\n)\n\nsetMethod(\"rownames\", \"DataFrameList\",\n          function(x, do.NULL = TRUE, prefix = \"row\")\n          {\n            CharacterList(lapply(x, rownames, do.NULL = do.NULL, prefix = prefix))\n          })\n\nsetMethod(\"colnames\", \"DataFrameList\",\n          function(x, do.NULL = TRUE, prefix = \"col\")\n          {\n            CharacterList(lapply(x, colnames, do.NULL = do.NULL, prefix = prefix))\n          })\n\nsetMethod(\"colnames\", \"SplitDataFrameList\",\n          function(x, do.NULL = TRUE, prefix = \"col\")\n          {\n            if (length(x)) {\n              nms <- colnames(x[[1]], do.NULL = do.NULL, prefix = prefix)\n              rep(CharacterList(nms), length(x))\n            } else NULL\n          })\n\nsetMethod(\"dimnames\", \"DataFrameList\",\n          function(x)\n          {\n            list(rownames(x), colnames(x))\n          })\n\nsetReplaceMethod(\"rownames\", \"SimpleDataFrameList\",\n                 function(x, value)\n                 {\n                   if (is.null(value) || is(value, \"CharacterList\")) {\n                     if (is.null(value))\n                       value <- list(NULL)\n                     else if (length(x) != length(value))\n                       stop(\"replacement value must be the same length as x\")\n                     x@listData <-\n                       mapply(function(y, rn) {rownames(y) <- rn; y},\n                              x@listData, value, SIMPLIFY=FALSE)\n                   } else {\n                     stop(\"replacement value must be NULL or a CharacterList\")\n                   }\n                   x\n                 })\n\nsetReplaceMethod(\"colnames\", \"SimpleDataFrameList\",\n                 function(x, value)\n                 {\n                   if (is.null(value)) {\n                     x@listData <-\n                       lapply(x@listData, function(y) {colnames(y) <- NULL; y})\n                   } else if (is.character(value)) {\n                     for (i in seq_len(length(x)))\n                       colnames(x@listData[[i]]) <- value\n                   } else if (is(value, \"CharacterList\")){\n                     if (length(x) != length(value))\n                       stop(\"replacement value must be the same length as x\")\n                     for (i in seq_len(length(x)))\n                       colnames(x@listData[[i]]) <- value[[i]]\n                   } else {\n                       stop(\"replacement value must either be NULL or a CharacterList\")\n                   }\n                   x\n                 })\n\nsetReplaceMethod(\"dimnames\", \"DataFrameList\",\n                 function(x, value)\n                 {\n                   if (!is.list(value))\n                     stop(\"replacement value must be a list\")\n                   rownames(x) <- value[[1L]]\n                   colnames(x) <- value[[2L]]\n                   x\n                 })\n\n### NROW(x) and ROWNAMES(x) need to retun length(x) and names(x),\n### respectively, on a DataFrameList object, but the default methods\n### return dim(x)[1L] and rownames(x), which is not what we want.\n### So we need to override them.\nsetMethod(\"NROW\", \"DataFrameList\", function(x) length(x))\nsetMethod(\"ROWNAMES\", \"DataFrameList\", function(x) names(x))\nsetReplaceMethod(\"ROWNAMES\", \"DataFrameList\", function(x, value) {\n    names(x) <- value\n    x\n})\n\nsetGeneric(\"commonColnames\", function(x) standardGeneric(\"commonColnames\"))\n\nsetMethod(\"commonColnames\", \"SimpleSplitDataFrameList\",\n          function(x) {\n            if (length(x)) \n              colnames(x[[1]])\n            else NULL\n          })\n\nsetGeneric(\"commonColnames<-\", function(x, value) standardGeneric(\"commonColnames<-\"))\n\nsetReplaceMethod(\"commonColnames\", \"SplitDataFrameList\", \n                 function(x, value) {\n                   colnames(x) <- value\n                   x\n                 })\n\nsetGeneric(\"columnMetadata\", function(x, ...) standardGeneric(\"columnMetadata\"))\n\nsetMethod(\"columnMetadata\", \"SimpleSplitDataFrameList\", function(x) {\n  if (length(x))\n    mcols(x[[1]], use.names=FALSE)\n  else NULL\n})\n\nsetGeneric(\"columnMetadata<-\",\n           function(x, ..., value) standardGeneric(\"columnMetadata<-\"))\n\nsetReplaceMethod(\"columnMetadata\", \"SimpleSplitDataFrameList\",\n                 function(x, value) {\n                   x@listData <- lapply(x@listData, function(xi) {\n                     mcols(xi) <- value\n                     xi\n                   })\n                   x\n                 })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.SimpleSplitDataFrameList <- function(x) {\n  if (length(x)) {\n    firstNames <- colnames(x[[1L]])\n    l <- as.list(x, use.names = FALSE)\n    if (!all(sapply(l, function(df) identical(firstNames, colnames(df)))))\n      return(\"column counts or names differ across elements\")\n    firstMetaData <- mcols(x[[1L]], use.names=FALSE) # could be NULL\n    if (!all(sapply(l, function(df) {\n      identical(firstMetaData, mcols(df, use.names=FALSE))\n    })))\n      return(\"metadata columns must be identical across elements\")\n  }\n  NULL\n}\n\nsetValidity2(\"SimpleSplitDataFrameList\", .valid.SimpleSplitDataFrameList)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor.\n###\n\nDataFrameList <- function(...)\n{\n  listData <- list(...)\n  if (length(listData) == 1 && is.list(listData[[1L]]) &&\n      !is.data.frame(listData[[1L]]))\n    listData <- listData[[1L]]\n  if (length(listData) > 0 && !is(listData[[1L]], \"DFrame\"))\n    listData <- lapply(listData, as, \"DFrame\")\n  S4Vectors:::new_SimpleList_from_list(\"SimpleDFrameList\", listData)\n}\n\nSplitDataFrameList <- function(..., compress = TRUE, cbindArgs = FALSE)\n{\n  if (!isTRUEorFALSE(compress))\n    stop(\"'compress' must be TRUE or FALSE\")\n  listData <- list(...)\n  if (length(listData) == 1 &&\n      (is.list(listData[[1L]]) || is(listData[[1L]], \"List\")) &&\n      !(is.data.frame(listData[[1L]]) || is(listData[[1L]], \"DFrame\")))\n    listData <- listData[[1L]]\n  if (cbindArgs) {\n    if (is.null(names(listData)))\n      names(listData) <- paste(\"X\", seq_len(length(listData)), sep = \"\")\n    listData <- do.call(Map, c(list(DataFrame), listData))\n  }\n\n  as(listData,\n     if (compress) \"CompressedSplitDFrameList\"\n     else \"SimpleSplitDFrameList\")\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting.\n###\n\nsetMethod(\"[\", \"SimpleSplitDataFrameList\",\n          function(x, i, j, ..., drop=TRUE)\n          {\n            if (!missing(j))\n              x@listData <- lapply(x@listData, function(y) y[,j,drop=FALSE])\n            if (!missing(i))\n              x <- callNextMethod(x, i)\n\n            if (((nargs() - !missing(drop)) > 2) &&\n                (length(x@listData) > 0) && (ncol(x@listData[[1L]]) == 1) &&\n                (missing(drop) || drop)) {\n              x <- as(lapply(x@listData, \"[[\", 1), \"List\")\n            }\n\n            x\n          })\n\nsetMethod(\"normalizeSingleBracketReplacementValue\", \"SplitDataFrameList\",\n    function(value, x)\n    {\n        value <- callNextMethod()  # call default method\n        if (length(x) != 0L && ncols(x)[[1L]] == ncols(value)[[1L]])\n            colnames(value)[[1L]] <- colnames(x)[[1L]]\n        value\n    }\n)\n\nsetReplaceMethod(\"[\", \"SplitDataFrameList\",\n    function(x, i, j,..., value)\n    {\n        if (length(list(...)) > 0L)\n            stop(\"invalid replacement\")\n        value <- normalizeSingleBracketReplacementValue(value, x)\n        if (missing(j)) {\n            if (missing(i))\n                ans <- callNextMethod(x=x, value=value)\n            else\n                ans <- callNextMethod(x=x, i=i, value=value)\n            return(ans)\n        }\n        colind <- setNames(seq_along(commonColnames(x)), commonColnames(x))\n        if (missing(i) && is.character(j)) {\n            colnames(value) <- j\n        }\n        j <- normalizeSingleBracketSubscript(j, colind, allow.append=missing(i))\n        if (missing(i)) {\n            y <- value\n        } else {\n            y <- x[, j, drop=FALSE]\n            if (is.list(i) || (is(i, \"List\") && !is(i, \"IntegerRanges\"))) {\n                y <- S4Vectors:::lsubset_List_by_List(y, i, value)\n            } else {\n                y[i] <- value\n            }\n        }\n        if (length(y) < length(x)) {\n            y <- rep(y, length.out=length(x))\n        }\n        if (is(x, \"CompressedList\")) {\n            x_eltNROWS <- elementNROWS(x)\n            y_eltNROWS <- elementNROWS(y)\n            if (any(x_eltNROWS != y_eltNROWS)) {\n                indices <- IRanges(start(y@partitioning), width=y_eltNROWS)\n                indices <- rep(indices, x_eltNROWS / y_eltNROWS)\n                if (sum(width(indices)) != sum(x_eltNROWS)) {\n                    stop(\"some element lengths of 'x' are not multiples of the \",\n                         \"corresponding element lengths of 'value'\")\n                }\n                y@unlistData <- y@unlistData[indices, , drop=FALSE]\n            }\n            x@unlistData[, j] <- y@unlistData\n        } else if (is(x, \"SimpleList\")) {\n            indices <- structure(seq_len(length(x)), names = names(x))\n            x@listData <- lapply(indices,\n                                 function(k) {\n                                     z <- x@listData[[k]]\n                                     z[j] <- y[[k]]\n                                     z\n                                 })\n        } else {\n            stop(class(x), \" objects not supported\")\n        }\n        x\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"ANY\", \"DataFrameList\",\n    function(from) as(from, \"DFrameList\")\n)\nsetAs(\"ANY\", \"SimpleDataFrameList\",\n    function(from) as(from, \"SimpleDFrameList\")\n)\nsetAs(\"ANY\", \"SplitDataFrameList\",\n    function(from) as(from, \"SplitDFrameList\")\n)\nsetAs(\"ANY\", \"SimpleSplitDataFrameList\",\n    function(from) as(from, \"SimpleSplitDFrameList\")\n)\n\n## Casting DataFrameList -> DFrame implies cast to SplitDataFrameList\nsetAs(\"DataFrameList\", \"DFrame\", function(from) {\n  as(as(from, \"SplitDFrameList\"), \"DFrame\")\n})\n\nsetAs(\"SplitDataFrameList\", \"DFrame\",\n    function(from) {\n      cols <- sapply(commonColnames(from), function(j) from[,j],\n                     simplify=FALSE)\n      DataFrame(cols, check.names=FALSE)\n    }\n)\n\nsetAs(\"list\", \"SplitDFrameList\",\n      function(from) as(from, \"SimpleSplitDFrameList\"))\n\nsetAs(\"SimpleList\", \"SplitDFrameList\",\n      function(from) as(from, \"SimpleSplitDFrameList\"))\n\nsetAs(\"ANY\", \"SimpleSplitDFrameList\",\n      function(from) {\n        new(\"SimpleSplitDFrameList\", as(from, \"SimpleDFrameList\"))\n      })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"classNameForDisplay\", \"SimpleDFrameList\",\n    function(x) sub(\"^Simple\", \"\", sub(\"DFrame\", \"DataFrame\", class(x)))\n)\n\nsetMethod(\"show\", \"SplitDataFrameList\", function(object)\n          {\n            k <- length(object)\n            cumsumN <- cumsum(elementNROWS(object))\n            N <- tail(cumsumN, 1)\n            cat(classNameForDisplay(object), \" of length \", k, \"\\n\",\n                sep = \"\")\n            if (k == 0L) {\n              cat(\"<0 elements>\\n\")\n            } else if ((k == 1L) || (N <= 20L)) {\n              show(as.list(object))\n            } else {\n              sketch <- function(x) c(head(x, 3), \"...\", tail(x, 3))\n              if (k >= 3 && cumsumN[3L] <= 20)\n                showK <- 3\n              else if (k >= 2 && cumsumN[2L] <= 20)\n                showK <- 2\n              else\n                showK <- 1\n              diffK <- k - showK\n              show(as.list(head(object, showK)))\n              if (diffK > 0)\n                cat(\"...\\n<\", k - showK,\n                    ifelse(diffK == 1,\n                           \" more element>\\n\", \" more elements>\\n\"),\n                    sep=\"\")\n            }\n          })\n",
        "DataFrameList-utils.R": "### =========================================================================\n### DataFrameList utilities\n### -------------------------------------------------------------------------\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Combining.\n###\n\nsetMethod(\"cbind\", \"DataFrameList\",\n          function(..., deparse.level=1) mendoapply(cbind, ...))\n\nsetMethod(\"rbind\", \"DataFrameList\",\n          function(..., deparse.level=1) mendoapply(rbind, ...))\n\nsetMethod(\"stack\", \"DataFrameList\",\n          function(x, index.var = \"name\")\n          {\n            DataFrame(S4Vectors:::stack_index(x, index.var),\n                      unlist(x, use.names=FALSE),\n                      row.names = unlist(lapply(x, rownames)))\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Transforming.\n###\n\nsetClass(\"SDFLWrapperForTransform\",\n         representation(delegate = \"SplitDataFrameList\"),\n         contains=\"Vector\")\n\nsetMethod(\"colnames\", \"SDFLWrapperForTransform\", function(x) {\n  commonColnames(x@delegate)\n})\n\nsetMethod(\"[[\", \"SDFLWrapperForTransform\", function (x, i, j, ...) {\n  x@delegate[,i]\n})\n\nsetReplaceMethod(\"[[\", \"SDFLWrapperForTransform\", function(x, i, j, ..., value) {\n  x@delegate[,i] <- value\n  x\n})\n\nsetMethod(S4Vectors:::`column<-`, \"SDFLWrapperForTransform\",\n          function(x, name, value)\n{\n    x[[name]] <- value\n    x\n})\n\nsetMethod(\"as.env\", \"SDFLWrapperForTransform\",\n          function(x, enclos = parent.frame(2)) {\n              env <- S4Vectors:::makeEnvForNames(x, colnames(x), enclos)\n              S4Vectors:::addSelfRef(x@delegate, env)\n          })\n\ntransform.SplitDataFrameList <- function(`_data`, ...) {\n  illConceivedWrapper <- new(\"SDFLWrapperForTransform\", delegate=`_data`)\n  transform.DataFrame(illConceivedWrapper, ...)@delegate\n}\n\nsetMethod(\"transform\", \"SplitDataFrameList\", transform.SplitDataFrameList)\n",
        "Grouping-class.R": "### =========================================================================\n### Grouping objects\n### -------------------------------------------------------------------------\n###\n### We call \"grouping\" an arbitrary mapping from a collection of NO objects\n### to a collection of NG groups, or, more formally, a bipartite graph\n### between integer sets [1, NO] and [1, NG]. Objects mapped to a given group\n### are said to belong to, or to be assigned to, or to be in that group.\n### Additionally, the objects in each group are ordered. So for example the\n### 2 following groupings are considered different:\n###\n###   Grouping 1: NG = 3, NO = 5\n###               group   objects\n###                   1 : 4, 2\n###                   2 :\n###                   3 : 4\n###\n###   Grouping 2: NG = 3, NO = 5\n###               group   objects\n###                   1 : 2, 4\n###                   2 :\n###                   3 : 4\n###\n### There are no restriction on the mapping e.g. any object can be mapped\n### to 0, 1, or more groups, and can be mapped twice to the same group. Also\n### some or all the groups can be empty.\n###\n\n### The Grouping class is a virtual class that formalizes the most general\n### kind of grouping. More specific groupings (e.g. many-to-one mappings)\n### are formalized via specific Grouping subclasses.\nsetClass(\"Grouping\", contains=\"IntegerList\", representation(\"VIRTUAL\"))\n\nsetGeneric(\"nobj\", function(x) standardGeneric(\"nobj\"))\n\nsetGeneric(\"grouplengths\", signature=\"x\",\n    function(x, i=NULL) standardGeneric(\"grouplengths\")\n)\n\n.subset_by_integer <- function(x, i=NULL)\n{\n    if (is.null(i))\n        return(x)\n    if (!is.numeric(i))\n        stop(wmsg(\"subscript must be NULL or an integer vector\"))\n    if (!is.integer(i))\n        i <- as.integer(i)\n    x_len <- length(x)\n    if (S4Vectors:::anyMissingOrOutside(i, -x_len, x_len))\n        stop(wmsg(\"subscript contains NAs or out of bounds indices\"))\n    x[i]\n}\n\nsetMethod(\"grouplengths\", \"Grouping\",\n    function(x, i=NULL)\n    {\n        x_grouplens <- elementNROWS(x)\n        .subset_by_integer(x_grouplens, i)\n    }\n)\n\nsetMethod(\"show\", \"Grouping\",\n    function(object)\n    {\n        NG <- length(object)\n        NO <- nobj(object)\n        cat(class(object), \" with \",\n            NG, ifelse(NG == 1, \" group \", \" groups \"),\n            \"and \", NO, ifelse(NO == 1, \" object\\n\", \" objects\\n\"),\n            sep=\"\")\n        if (NG == 0L)\n            return(invisible(NULL))\n        empty_groups <- which(grouplengths(object) == 0L)\n        cat(\"Nb of empty groups: \", length(empty_groups),\n            \" (\", 100.00 * length(empty_groups) / NG, \"%)\\n\", sep=\"\")\n    }\n)\n\n\n### -------------------------------------------------------------------------\n### ManyToOneGrouping objects\n### -------------------------\n\n### A ManyToOneGrouping object represents a grouping where every object in\n### the collection belongs to exactly one group.\nsetClass(\"ManyToOneGrouping\", contains=\"Grouping\", representation(\"VIRTUAL\"))\n\nsetMethod(\"nobj\", \"ManyToOneGrouping\", function(x) sum(grouplengths(x)))\n\nsetGeneric(\"members\", signature=\"x\",\n    function(x, i) standardGeneric(\"members\")\n)\n\nsetMethod(\"members\", \"ManyToOneGrouping\",\n    function(x, i)\n    {\n        if (!is.numeric(i))\n            stop(wmsg(\"subscript 'i' must be a vector of integers\"))\n        if (!is.integer(i))\n            i <- as.integer(i)\n        sort(unlist(sapply(i, function(ii) x[[ii]])))\n    }\n)\n\nsetGeneric(\"vmembers\", signature=\"x\",\n    function(x, L) standardGeneric(\"vmembers\")\n)\n\nsetMethod(\"vmembers\", \"ManyToOneGrouping\",\n    function(x, L)\n    {\n        if (!is.list(L))\n            stop(wmsg(\"'L' must be a list of integer vectors\"))\n        lapply(L, function(i) members(x, i))\n    }\n)\n\nsetGeneric(\"togroup\", signature=\"x\",\n    function(x, j=NULL) standardGeneric(\"togroup\")\n)\n\n### Works on any ManyToOneGrouping object 'x' for which unlist() and\n### elementNROWS() work.\nsetMethod(\"togroup\", \"ManyToOneGrouping\",\n    function(x, j=NULL)\n    {\n        x_togroup <- unlist(x, use.names=FALSE)\n        x_eltNROWS <- elementNROWS(x)\n        x_togroup[x_togroup] <- rep.int(seq_along(x_eltNROWS), x_eltNROWS)\n        .subset_by_integer(x_togroup, j)\n    }\n)\n\nsetGeneric(\"togrouplength\", signature=\"x\",\n    function(x, j=NULL) standardGeneric(\"togrouplength\")\n)\n\nsetMethod(\"togrouplength\", \"ManyToOneGrouping\",\n    function(x, j=NULL) grouplengths(x, togroup(x, j))\n)\n\n\n### -------------------------------------------------------------------------\n### ManyToManyGrouping objects\n### -------------------------\n\n### A ManyToManyGrouping object represents a grouping where objects\n### can map to any number of groups.\nsetClass(\"ManyToManyGrouping\", contains=\"Grouping\", representation(\"VIRTUAL\"))\n\n### -------------------------------------------------------------------------\n### BiIndexGrouping objects\n### -----------------------\n\n#setClass(\"BiIndexGrouping\",\n#    contains=\"ManyToOneGrouping\",\n#    representation(\n#        group2object=\"list\",\n#        object2group=\"integer\"\n#    )\n#)\n\n#setMethod(\"length\", \"BiIndexGrouping\", function(x) length(x@group2object))\n\n#setMethod(\"nobj\", \"BiIndexGrouping\", function(x) length(x@object2group))\n\n\n\n### -------------------------------------------------------------------------\n### H2LGrouping and Dups objects\n### ----------------------------\n###\n### High-to-Low Index ManyToOneGrouping objects.\n###\n\nsetClass(\"H2LGrouping\",\n    contains=\"ManyToOneGrouping\",\n    representation(\n        high2low=\"integer\",\n        low2high=\"list\"\n    )\n)\n\n### For storing the grouping implicitly defined by the \"duplicated\"\n### relationship between elements of an arbitrary vector.\nsetClass(\"Dups\", contains=\"H2LGrouping\")\n\n### Two additional accessors for H2LGrouping objects.\nsetGeneric(\"high2low\", function(x) standardGeneric(\"high2low\"))\nsetMethod(\"high2low\", \"H2LGrouping\", function(x) x@high2low)\nsetGeneric(\"low2high\", function(x) standardGeneric(\"low2high\"))\nsetMethod(\"low2high\", \"H2LGrouping\", function(x) x@low2high)\n\n### 'length(x)' and 'nobj(x)' are the same.\nsetMethod(\"length\", \"H2LGrouping\", function(x) length(x@low2high))\nsetMethod(\"nobj\", \"H2LGrouping\", function(x) length(x@high2low))\n\nsetMethod(\"getListElement\", \"H2LGrouping\",\n    function(x, i, exact=TRUE)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x, exact=exact)\n        if (is.na(x@high2low[i]))\n            c(i, x@low2high[[i]])\n        else\n            integer()\n    }\n)\n\n### Should be more efficient than the default method for ManyToOneGrouping\n### objects.\nsetMethod(\"grouplengths\", \"H2LGrouping\",\n    function(x, i=NULL)\n    {\n        x_grouplens <- elementNROWS(x@low2high) + 1L\n        x_grouplens[!is.na(x@high2low)] <- 0L\n        .subset_by_integer(x_grouplens, i)\n    }\n)\n\nsetMethod(\"members\", \"H2LGrouping\",\n    function(x, i)\n    {\n        if (!is.numeric(i))\n            stop(wmsg(\"subscript 'i' must be a vector of integers\"))\n        if (!is.integer(i))\n            i <- as.integer(i)\n        ## NAs and \"subscript out of bounds\" are checked at the C level\n        .Call2(\"C_members_H2LGrouping\", x, i, PACKAGE=\"IRanges\")\n    }\n)\n\nsetMethod(\"vmembers\", \"H2LGrouping\",\n    function(x, L)\n    {\n        if (!is.list(L))\n            stop(wmsg(\"'L' must be a list of integer vectors\"))\n        .Call2(\"C_vmembers_H2LGrouping\", x, L, PACKAGE=\"IRanges\")\n    }\n)\n\nsetMethod(\"togroup\", \"H2LGrouping\",\n    function(x, j=NULL)\n    {\n        x_togroup <- x@high2low\n        x_togroup[is.na(x_togroup)] <- which(is.na(x_togroup))\n        .subset_by_integer(x_togroup, j)\n    }\n)\n\n### The default method should be as good (if not better) as this.\n#setMethod(\"togrouplength\", \"H2LGrouping\",\n#    function(x)\n#    {\n#        ans <- rep.int(1L, length(x))\n#        mapped_lows <- setdiff(unique(x@high2low), NA)\n#        for (low in mapped_lows) {\n#            ii <- as.integer(c(low, x@low2high[[low]]))\n#            ans[ii] <- length(ii)\n#        }\n#        ans\n#    }\n#)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### More operations on H2LGrouping objects. These operations are NOT part of\n### the core Grouping API.\n###\n\n### The rank of group G_i is the number of non-empty groups that are before\n### G_i plus one. Or, equivalently, it's the number of non-empty groups with\n### an index <= i.\nsetGeneric(\"grouprank\", signature=\"x\",\n    function(x, i=NULL) standardGeneric(\"grouprank\")\n)\nsetMethod(\"grouprank\", \"H2LGrouping\",\n    function(x, i=NULL)\n    {\n        ans <- cumsum(is.na(high2low(x)))\n        if (!is.null(i))\n            ans <- ans[i]\n        return(ans)\n    }\n)\n\n### togrouprank() returns the mapping from objects to group ranks.\n### An important property of togrouprank() is that:\n###   togrouprank(x, neg_idx)\n### and\n###   seq_along(neg_idx)\n### are identical, where 'neg_idx' is the vector of the indices of\n### the non-empty groups i.e.\n###   neg_idx <- which(grouplengths(x) != 0L)\nsetGeneric(\"togrouprank\", signature=\"x\",\n     function(x, j=NULL) standardGeneric(\"togrouprank\")\n)\nsetMethod(\"togrouprank\", \"H2LGrouping\",\n    function(x, j=NULL)\n    {\n        to_group <- togroup(x)\n        group_rank <- grouprank(x)\n        ans <- group_rank[to_group]\n        if (!is.null(j))\n            ans <- ans[j]\n        return(ans)\n    }\n)\n\nsetReplaceMethod(\"length\", \"H2LGrouping\",\n    function(x, value)\n    {\n        if (!isSingleNumber(value))\n            stop(wmsg(\"length must be a single integer\"))\n        if (!is.integer(value))\n            value <- as.integer(value)\n        if (value < 0L)\n            stop(wmsg(\"length cannot be negative\"))\n        if (value > length(x))\n            stop(wmsg(\"cannot make a \", class(x), \" instance longer\"))\n        length(x@high2low) <- value\n        x@low2high <- S4Vectors:::reverseSelfmatchMapping(x@high2low)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.H2LGrouping <- function(x)\n{\n    if (!is.integer(x@high2low))\n        return(\"the 'high2low' slot must contain an integer vector\")\n    if (!all(x@high2low >= 1L, na.rm=TRUE))\n        return(\"the 'high2low' slot must contain integer values >= 1\")\n    if (!all(x@high2low < seq_along(x@high2low), na.rm=TRUE)) {\n        problem <- c(\"when mapped, elements in the 'high2low' slot must be mapped \",\n                     \"to elements at a lower position\")\n        return(paste(problem, collapse=\"\"))\n    }\n    if (!all(is.na(x@high2low[x@high2low]))) {\n        problem <- c(\"when mapped, elements in the 'high2low' slot must be mapped \",\n                     \"to unmapped elements\")\n        return(paste(problem, collapse=\"\"))\n    }\n    if (!is.list(x@low2high))\n        return(\"the 'low2high' slot must contain a list\")\n    if (length(x@high2low) != length(x@low2high))\n        return(\"the 'high2low' and 'low2high' slots must have the same length\")\n    if (!identical(S4Vectors:::reverseSelfmatchMapping(x@high2low),\n                   x@low2high))\n    {\n        problem <- c(\"the 'low2high' slot must contain the reverse mapping \",\n                     \"of the 'high2low' slot\")\n        return(paste(problem, collapse=\"\"))\n    }\n    NULL\n}\n\nsetValidity(\"H2LGrouping\",\n    function(object)\n    {\n        problems <- .valid.H2LGrouping(object)\n        if (is.null(problems)) TRUE else problems\n    }\n)\n\n### For Dups objects only.\n.duplicated.Dups <- function(x, incomparables=FALSE)\n{\n    if (!identical(incomparables, FALSE))\n        stop(wmsg(\"\\\"duplicated\\\" method for Dups objects \",\n                  \"only accepts 'incomparables=FALSE'\"))\n    !is.na(high2low(x))\n}\nsetMethod(\"duplicated\", \"Dups\", .duplicated.Dups)\n\n### For Dups objects only.\nsetMethod(\"show\", \"Dups\",\n    function(object)\n    {\n        percentage <- 100.00 * sum(duplicated(object)) / length(object)\n        cat(class(object), \" of length \", length(object),\n            \" (\", percentage, \"% of duplicates)\\n\", sep=\"\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructors.\n###\n\n.newH2LGrouping <- function(Class, high2low)\n{\n    if (!is.numeric(high2low))\n        stop(wmsg(\"'high2low' must be a vector of integers\"))\n    if (!is.integer(high2low))\n        high2low <- as.integer(high2low)\n    new2(Class, high2low=high2low,\n         low2high=S4Vectors:::reverseSelfmatchMapping(high2low),\n         check=FALSE)\n}\n\nH2LGrouping <- function(high2low=integer())\n    .newH2LGrouping(\"H2LGrouping\", high2low)\n\nDups <- function(high2low=integer())\n    .newH2LGrouping(\"Dups\", high2low)\n\nsetMethod(\"high2low\", \"ANY\",\n    function(x)\n    {\n        ans <- selfmatch(x)\n        ans[ans == seq_along(x)] <- NA_integer_\n        ans\n    }\n)\n\n\n### -------------------------------------------------------------------------\n### GroupingRanges objects\n### ----------------------\n###\n### A GroupingRanges object represents a \"block-grouping\", that is, a\n### grouping where each group is a block of adjacent elements in the original\n### collection of objects. GroupingRanges objects support the IPosRanges\n### API (e.g. start/end/width) in addition to the Grouping API.\n###\n\nsetClass(\"GroupingRanges\",\n    ## We put IPosRanges before Grouping so GroupingRanges objects inherit\n    ## the \"show\" method for IPosRanges objects instead of the method for\n    ## Grouping objects.\n    contains=c(\"IPosRanges\", \"Grouping\"),\n    representation(\"VIRTUAL\")\n)\n\n### Overwrite default method with optimized method for GroupingRanges objects.\nsetMethod(\"grouplengths\", \"GroupingRanges\",\n    function(x, i=NULL)\n    {\n        x_width <- width(x)\n        .subset_by_integer(x_width, i)\n    }\n)\n\nsetClass(\"GroupingIRanges\", contains=c(\"IRanges\", \"GroupingRanges\"))\n\n\n### -------------------------------------------------------------------------\n### Partitioning objects\n### --------------------\n###\n### A Partitioning object is a GroupingRanges object where the blocks fully\n### cover the original collection of objects and don't overlap. This makes\n### them many-to-one groupings. Furthermore, the blocks must be ordered by\n### ascending position on the original collection of objects.\n### Note that for a Partitioning object 'x', 'togroup(x)' is sorted in\n### increasing order (not necessarily strictly increasing).\n###\n### The Partitioning class is virtual with 2 concrete direct subclasses:\n### PartitioningByEnd and PartitioningByWidth.\n###\n\nsetClass(\"Partitioning\",\n    contains=c(\"GroupingRanges\", \"ManyToOneGrouping\"),\n    representation(\n        \"VIRTUAL\",\n        NAMES=\"character_OR_NULL\"  # R doesn't like @names !!\n    ),\n    prototype(\n        NAMES=NULL\n    )\n)\n\nsetMethod(\"parallel_slot_names\", \"Partitioning\",\n    function(x) c(\"NAMES\", callNextMethod())\n)\n\nsetMethod(\"extractROWS\", \"Partitioning\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x)\n        if (!isStrictlySorted(i))\n            stop(wmsg(\"Partitioning objects only support subsetting by a \",\n                      \"strictly sorted subscript that drops empty partitions\"))\n        x_nobj <- nobj(x)\n        ans <- callNextMethod()\n        if (nobj(ans) != x_nobj)\n            stop(wmsg(\"Partitioning objects only support subsetting by a \",\n                      \"strictly sorted subscript that drops empty partitions\"))\n        ans\n    }\n)\n\nsetMethod(\"bindROWS\", \"Partitioning\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n        stop(wmsg(\"Partitioning objects don't support concatenation\"))\n)\n\n### The default methods below assume that the \"length + start/end/width\" API\n### is already implemented.\n\nsetMethod(\"getListElement\", \"Partitioning\",\n    function(x, i, exact=TRUE)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x, exact=exact)\n        ## The purpose of the code below is to extract 'start(x)[i] - 1'\n        ## (stored in 'ans_shift') and 'width(x)[i]' (stored in 'ans_len')\n        ## in the fastest possible way. Looks like a convoluted way to\n        ## extract those 2 values but it is actually 1000x faster than the\n        ## naive way.\n        ans_shift <- 0L\n        ans_len <- end(x)[i]\n        if (i >= 2L) {\n            ans_shift <- end(x)[i - 1L]\n            ans_len <- ans_len - ans_shift\n        }\n        seq_len(ans_len) + ans_shift\n    }\n)\n\n### Overwrite method for ManyToOneGrouping objects with optimized method for\n### Partitioning objects.\nsetMethod(\"togroup\", \"Partitioning\",\n    function(x, j=NULL)\n    {\n        x_width <- width(x)\n        x_togroup <- rep.int(seq_along(x_width), x_width)\n        .subset_by_integer(x_togroup, j)\n    }\n)\n\nsetMethod(\"names\", \"Partitioning\", function(x) x@NAMES)\n\nsetReplaceMethod(\"names\", \"Partitioning\", set_IRanges_names)\n\nsetMethod(\"NSBS\", \"Partitioning\",\n          function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n          {\n              i <- range(i)\n              callNextMethod()\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### PartitioningByEnd uses a compact internal representation that allows\n### fast mapping from groups to objects. However, it is not efficient for\n### mapping from objects to groups.\n###\n\nsetClass(\"PartitioningByEnd\",\n    contains=\"Partitioning\",\n    representation(\n        end=\"integer\"\n    ),\n    prototype(\n        end=integer()\n    )\n)\n\nsetMethod(\"parallel_slot_names\", \"PartitioningByEnd\",\n    function(x) c(\"end\", callNextMethod())\n)\n\nsetMethod(\"end\", \"PartitioningByEnd\", function(x) x@end)\n\n### Overwrite method for Ranges objects with optimized method for\n### PartitioningByEnd objects.\nsetMethod(\"length\", \"PartitioningByEnd\", function(x) length(end(x)))\n\n### Overwrite method for ManyToOneGrouping objects with optimized method for\n### PartitioningByEnd objects.\nsetMethod(\"nobj\", \"PartitioningByEnd\",\n    function(x) S4Vectors:::last_or(end(x), 0L)\n)\n\nsetMethod(\"start\", \"PartitioningByEnd\",\n    function(x)\n    {\n        x_end <- end(x)\n        if (length(x_end) == 0L)\n            return(integer())\n        c(1L, x_end[-length(x_end)] + 1L)\n    }\n)\n\nsetMethod(\"width\", \"PartitioningByEnd\",\n    function(x) S4Vectors:::diffWithInitialZero(end(x))\n)\n\n.valid.PartitioningByEnd <- function(x)\n{\n    if (!is.integer(end(x)))\n        return(\"the ends must be integers\")\n    if (length(x) == 0L)\n        return(NULL)\n    if (S4Vectors:::anyMissing(end(x)))\n        return(\"the ends cannot be NAs\")\n    if (S4Vectors:::isNotSorted(end(x)))\n        return(\"the ends must be sorted\")\n    if (end(x)[1L] < 0L)\n        return(\"the ends cannot be negative\")\n    if (!is.null(names(end(x))))\n        return(\"the ends should not be named\")\n    NULL\n}\n\nsetValidity2(\"PartitioningByEnd\", .valid.PartitioningByEnd)\n\n.numeric2end <- function(x=integer(0), NG=NULL)\n{\n    if (!is.integer(x))\n        x <- as.integer(x)\n    if (S4Vectors:::anyMissingOrOutside(x, 0L))\n        stop(wmsg(\"when 'x' is an integer vector, \",\n                  \"it cannot contain NAs or negative values\"))\n    if (S4Vectors:::isNotSorted(x))\n        stop(wmsg(\"when 'x' is an integer vector, \",\n                  \"it must be sorted\"))\n    if (is.null(NG))\n        return(x)\n    ## When 'NG' (number of groups) is supplied, then 'x' is considered\n    ## to represent the group assignment of a collection of 'length(x)'\n    ## objects. Therefore the values in 'x' must be >= 1 and <= 'NG'.\n    ## ADDITIONALLY, 'x' must be *sorted* (not strictly) so it can be\n    ## reconstructed from the object returned by PartitioningByEnd()\n    ## by doing togroup() on that object.\n    if (!isSingleNumber(NG))\n        stop(wmsg(\"'NG' must be either NULL or a single integer\"))\n    if (!is.integer(NG))\n        NG <- as.integer(NG)\n    NO <- length(x)  # nb of objects\n    if (NG == 0L) {\n        if (NO != 0L)\n            stop(wmsg(\"when 'NG' is 0, 'x' must be of length 0\"))\n    } else {\n        ## 'x' is expected to be non-decreasing and with values >= 1\n        ## and <= 'NG'.\n        x <- cumsum(tabulate(x, nbins=NG))\n        ## 'x[NG]' is guaranteed to be <= 'NO'.\n        if (x[NG] != NO)\n            stop(wmsg(\"when 'NG' is supplied, values in 'x' must \",\n                      \"be >= 1 and <= 'NG'\"))\n    }\n    x\n}\n\n.prepare_Partitioning_names <- function(names, ans_len, NG, x_names)\n{\n    if (!is.null(names)) {\n        if (!is.character(names) || length(names) != ans_len)\n            stop(wmsg(\"'names' must be either NULL or a character vector \",\n                      \"of length 'NG' (if supplied) or 'length(x)' \",\n                      \"(if 'NG' is not supplied)\"))\n        return(names)\n    }\n    if (is.null(NG))\n        return(x_names)  # should be of length 'ans_len'\n    NULL\n}\n\nPartitioningByEnd <- function(x=integer(0), NG=NULL, names=NULL)\n{\n    if (is(x, \"List\") || is.list(x)) {\n        if (!is.null(NG))\n            warning(wmsg(\"'NG' argument is ignored when 'x' \",\n                         \"is a list-like object\"))\n        if (is(x, \"CompressedList\")) {\n            ## Behaves like a getter for the 'partitioning' slot.\n            ans <- x@partitioning\n            if (!is.null(names))\n                names(ans) <- names\n            return(ans)\n        }\n        if (is(x, \"PartitioningByEnd\")) {\n            if (!is.null(names))\n                names(x) <- names\n            return(x)\n        }\n        x_names <- names(x)\n        if (length(x) == 0L) {\n            ans_end <- integer(0)\n        } else {\n            x_NROWS <- elementNROWS(x)\n            ans_end <- suppressWarnings(cumsum(x_NROWS))\n            if (is.na(ans_end[[length(ans_end)]]))\n                stop(wmsg(class(x)[[1L]], \" object 'x' is too big (the \",\n                          \"cumulated length of its list elements is >= 2^32)\"))\n        }\n    } else {\n        if (!is.numeric(x))\n            stop(wmsg(\"'x' must be either a list-like object or \",\n                      \"a sorted vector of non-NA non-negative integers\"))\n        x_names <- names(x)\n        ans_end <- .numeric2end(x, NG)\n    }\n    ans_names <- .prepare_Partitioning_names(names, length(ans_end),\n                                             NG, x_names)\n    new2(\"PartitioningByEnd\", end=unname(ans_end), NAMES=ans_names,\n                              check=FALSE)\n}\n\nsetAs(\"IntegerRanges\", \"PartitioningByEnd\",\n    function(from)\n    {\n        ans <- PartitioningByEnd(end(from), names=names(from))\n        if (!identical(start(ans), start(from)))\n            stop(wmsg(\"the IntegerRanges object to coerce does not \",\n                      \"represent a partitioning\"))\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### PartitioningByWidth uses a compact internal representation too. Storing\n### the widths instead of the ends would allow the total number of objects\n### (nobj(x)) to be greater than 2^31-1 but note that some methods will break\n### when this happens, e.g. nobj, end, etc...\n###\n\nsetClass(\"PartitioningByWidth\",\n    contains=\"Partitioning\",\n    representation(\n        width=\"integer\"\n    ),\n    prototype(\n        width=integer()\n    )\n)\n\nsetMethod(\"parallel_slot_names\", \"PartitioningByWidth\",\n    function(x) c(\"width\", callNextMethod())\n)\n\nsetMethod(\"width\", \"PartitioningByWidth\", function(x) x@width)\n\n### Overwrite method for Ranges objects with optimized method for\n### PartitioningByWidth objects.\nsetMethod(\"length\", \"PartitioningByWidth\", function(x) length(width(x)))\n\nsetMethod(\"end\", \"PartitioningByWidth\", function(x) cumsum(width(x)))\n\nsetMethod(\"start\", \"PartitioningByWidth\",\n    function(x)\n    {\n        x_width <- width(x)\n        if (length(x_width) == 0L)\n            return(integer())\n        c(1L, cumsum(x_width[-length(x_width)]) + 1L)\n    }\n)\n\n.valid.PartitioningByWidth <- function(x)\n{\n    if (!is.integer(width(x)))\n        return(\"the widths must be integers\")\n    if (length(x) == 0L)\n        return(NULL)\n    if (S4Vectors:::anyMissingOrOutside(width(x), 0L))\n        return(\"the widths cannot be NAs or negative\")\n    if (!is.null(names(width(x))))\n        return(\"the widths should not be named\")\n    NULL\n}\n\nsetValidity2(\"PartitioningByWidth\", .valid.PartitioningByWidth)\n\n.numeric2width <- function(x=integer(0), NG=NULL)\n{\n    if (!is.integer(x))\n        x <- as.integer(x)\n    if (S4Vectors:::anyMissingOrOutside(x, 0L))\n        stop(wmsg(\"when 'x' is an integer vector, \",\n                  \"it cannot contain NAs or negative values\"))\n    if (is.null(NG))\n        return(x)\n    ## When 'NG' (number of groups) is supplied, then 'x' is considered\n    ## to represent the group assignment of a collection of 'length(x)'\n    ## objects. Therefore the values in 'x' must be >= 1 and <= 'NG'.\n    ## ADDITIONALLY, 'x' must be *sorted* (not strictly) so it can be\n    ## reconstructed from the object returned by PartitioningByWidth()\n    ## by doing togroup() on that object.\n    if (S4Vectors:::isNotSorted(x))\n        stop(wmsg(\"when 'x' is an integer vector, it must be sorted\"))\n    if (!isSingleNumber(NG))\n        stop(wmsg(\"'NG' must be either NULL or a single integer\"))\n    if (!is.integer(NG))\n        NG <- as.integer(NG)\n    NO <- length(x)  # nb of objects\n    if (NG == 0L) {\n        if (NO != 0L)\n            stop(wmsg(\"when 'NG' is 0, 'x' must be of length 0\"))\n    } else {\n        ## 'x' is expected to be non-decreasing and with values >= 1\n        ## and <= 'NG'.\n        x <- tabulate(x, nbins=NG)\n        ## 'sum(x)' is guaranteed to be <= 'NO'.\n        if (sum(x) != NO)\n            stop(wmsg(\"when 'NG' is supplied, values in 'x' must \",\n                      \"be >= 1 and <= 'NG'\"))\n    }\n    x\n}\n\nPartitioningByWidth <- function(x=integer(0), NG=NULL, names=NULL)\n{\n    if (is(x, \"List\") || is.list(x)) {\n        if (!is.null(NG))\n            warning(wmsg(\"'NG' argument is ignored when 'x' \",\n                         \"is a list-like object\"))\n        if (is(x, \"PartitioningByWidth\")) {\n            if (!is.null(names))\n                names(x) <- names\n            return(x)\n        }\n        x_names <- names(x)\n        ans_width <- elementNROWS(x)\n    } else {\n        if (!is.numeric(x))\n            stop(wmsg(\"'x' must be either a list-like object or \",\n                      \"a vector of non-NA non-negative integers\"))\n        x_names <- names(x)\n        ans_width <- .numeric2width(x, NG)\n    }\n    ans_names <- .prepare_Partitioning_names(names, length(ans_width),\n                                             NG, x_names)\n    new2(\"PartitioningByWidth\", width=unname(ans_width), NAMES=ans_names,\n                                check=FALSE)\n}\n\nsetAs(\"IntegerRanges\", \"PartitioningByWidth\",\n    function(from)\n    {\n        ans <- PartitioningByWidth(width(from), names(from))\n        if (!identical(start(ans), start(from)))\n            stop(wmsg(\"the IntegerRanges object to coerce does not \",\n                      \"represent a partitioning\"))\n        ans\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### PartitioningMap contains PartitioningByEnd and one additional slot,\n### 'mapOrder', to specify a different order. This object is used by the \n### pack() function in GenomicFiles and is put in @partitioning of a \n### GRangesList of pack()ed ranges. 'mapOrder' records the order of the\n### unpacked() ranges. \n### \n\nsetClass(\"PartitioningMap\",\n    contains=\"PartitioningByEnd\",\n    representation(\n        mapOrder=\"integer\"\n    ),\n    prototype(\n        mapOrder=integer()\n    )\n)\n\nsetGeneric(\"mapOrder\", function(x) standardGeneric(\"mapOrder\"))\nsetMethod(\"mapOrder\", \"PartitioningMap\", function(x) x@mapOrder)\n\n.valid.PartitioningMap <- function(x)\n{\n    if (length(x) == 0L)\n        return(NULL)\n    if (S4Vectors:::anyMissing(mapOrder(x)))\n        return(\"mapOrder cannot contain NA values\")\n    if (any(mapOrder(x) < 0L))\n        return(\"mapOrder values cannot be negative\")\n    if (!is.null(names(mapOrder(x))))\n        return(\"the mapOrder should not be named\")\n\n    if (length(maporder <- mapOrder(x))) {\n        maxorder <- max(maporder)\n        if (max(maporder) > max(end(x)))\n            return(\"max mapOrder value must be == max(end(object))\")\n    }\n    NULL\n}\n\nsetValidity2(\"PartitioningMap\", .valid.PartitioningMap)\n\nPartitioningMap <- function(x=integer(), mapOrder=integer(), ...)\n    new(\"PartitioningMap\", PartitioningByEnd(x=x), mapOrder=mapOrder, ...)\n\nsetAs(\"PartitioningByEnd\", \"PartitioningMap\",\n    function(from)\n        new(\"PartitioningMap\", from, mapOrder=numeric())\n)\n\nsetMethod(\"show\", \"PartitioningMap\", \n    function(object)\n    {\n        cat(class(object), \" of length \", length(object), \"\\n\")\n        cat(\"mapOrder: \", mapOrder(object), \"\\n\")\n        print(PartitioningByEnd(object))\n    }\n) \n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### findOverlaps()\n###\n\n### A simple findOverlaps method that doesn't use NCList but works only\n### on a subject with *adjacent* ranges sorted non-decreasingly.\n### Can be 30% faster or more than the real findOverlaps() (NCList-based)\n### when 'query' is such that 'start(query)' and 'end(query)' are also sorted\n### non-decreasingly (which is the case if for example 'query' is a\n### Partitioning object).\n### TODO: Add a \"findOverlaps\" method for Partitioning,Partitioning in the\n### findOverlaps-methods.R file that calls this.\nfindOverlaps_IntegerRanges_Partitioning <-\n    function(query, subject, hit.empty.query.ranges=FALSE,\n                             hit.empty.subject.ranges=FALSE)\n{\n    if (!is(query, \"IntegerRanges\"))\n        stop(wmsg(\"'query' must be an IntegerRanges object\"))\n    if (!is(subject, \"Partitioning\"))\n        stop(wmsg(\"'subject' must be a Partitioning object\"))\n    if (!isTRUEorFALSE(hit.empty.query.ranges) ||\n        !isTRUEorFALSE(hit.empty.subject.ranges))\n        stop(wmsg(\"'hit.empty.query.ranges' and 'hit.empty.subject.ranges' \",\n                  \"must be TRUE or FALSE\"))\n    q_len <- length(query)\n    q_start <- start(query)\n    q_end <- end(query)\n    s_len <- length(subject)\n    s_end <- end(subject)\n    if (!hit.empty.query.ranges) {\n        q_idx <- which(width(query) != 0L)\n        q_start <- q_start[q_idx]\n        q_end <- q_end[q_idx]\n    }\n    if (!hit.empty.subject.ranges) {\n        s_idx <- which(width(subject) != 0L)\n        s_end <- s_end[s_idx]\n    }\n    vec <- c(0L, s_end) + 0.5\n    q_start2subject <- findInterval(q_start, vec)\n    q_end2subject <- findInterval(q_end, vec)\n    q_hits <- rep.int(seq_along(q_start),\n                      q_end2subject - q_start2subject + 1L)\n    s_hits <- sequence(q_end2subject - q_start2subject + 1L, q_start2subject)\n    ## If 'query' is a Partitioning object, all hits are guaranteed to be\n    ## valid.\n    if (!is(query, \"Partitioning\")) {\n        ## Remove invalid hits.\n        is_valid <- 1L <= s_hits & s_hits <= length(s_end)\n        q_hits <- q_hits[is_valid]\n        s_hits <- s_hits[is_valid]\n    }\n    ## Remap hits to original query/subject.\n    if (!hit.empty.query.ranges)\n        q_hits <- q_idx[q_hits]\n    if (!hit.empty.subject.ranges)\n        s_hits <- s_idx[s_hits]\n\n    ## Make and return Hits object.\n    Hits(q_hits, s_hits, q_len, s_len, sort.by.query=TRUE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Old stuff (deprecated & defunct)\n###\n\nsetMethod(\"togroup\", \"ANY\",\n    function(x, j=NULL)\n    {\n        msg <- wmsg(\n            \"Using togroup() on a \", class(x), \" object is defunct. \",\n            \"Please use togroup(PartitioningByWidth(...)) instead.\"\n        )\n        .Defunct(msg=msg)\n    }\n)\n\n",
        "Hits-class-leftovers.R": "### =========================================================================\n### IMPORTANT NOTE - 4/29/2014\n### Most of the stuff that used to be in the IRanges/R/Hits-class.R file was\n### moved to the S4Vectors package (to R/Hits-class.R).\n### The stuff that could not be moved there was *temporarily* kept here in\n### Hits-class-leftovers.R but will need to find a new home (in S4Vectors\n### or in IRanges).\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### Turn SortedByQueryHits object 'from' into a PartitioningByEnd object that\n### describes the grouping of hits by query.\n.from_SortedByQueryHits_to_PartitioningByEnd <- function(from)\n    PartitioningByEnd(queryHits(from), NG=queryLength(from))\nsetAs(\"SortedByQueryHits\", \"PartitioningByEnd\",\n    .from_SortedByQueryHits_to_PartitioningByEnd\n)\nsetAs(\"SortedByQueryHits\", \"Partitioning\",\n    .from_SortedByQueryHits_to_PartitioningByEnd\n)\nsetAs(\"SortedByQueryHits\", \"IntegerRanges\",\n    .from_SortedByQueryHits_to_PartitioningByEnd\n)\nsetAs(\"SortedByQueryHits\", \"IRanges\",\n    function(from)\n        as(.from_SortedByQueryHits_to_PartitioningByEnd(from), \"IRanges\")\n)\n\n### Turn SortedByQueryHits object 'from' into a CompressedIntegerList object\n### with one list element per element in the original query.\n.from_SortedByQueryHits_to_CompressedIntegerList <- function(from)\n{\n    ans_partitioning <- .from_SortedByQueryHits_to_PartitioningByEnd(from)\n    relist(subjectHits(from), ans_partitioning)\n}\nsetAs(\"SortedByQueryHits\", \"CompressedIntegerList\",\n    .from_SortedByQueryHits_to_CompressedIntegerList\n)\nsetAs(\"SortedByQueryHits\", \"IntegerList\",\n    .from_SortedByQueryHits_to_CompressedIntegerList\n)\nsetAs(\"SortedByQueryHits\", \"List\",\n    .from_SortedByQueryHits_to_CompressedIntegerList\n)\n\n.as.list.SortedByQueryHits <- function(x)\n    as.list(.from_SortedByQueryHits_to_CompressedIntegerList(x))\nsetMethod(\"as.list\", \"SortedByQueryHits\", .as.list.SortedByQueryHits)\n\n.from_Hits_to_CompressedIntegerList <- function(from)\n{\n    as(as(from, \"SortedByQueryHits\"), \"CompressedIntegerList\")\n}\n\nsetAs(\"Hits\", \"List\", .from_Hits_to_CompressedIntegerList)\nsetAs(\"Hits\", \"IntegerList\", .from_Hits_to_CompressedIntegerList)\nsetAs(\"Hits\", \"CompressedIntegerList\", .from_Hits_to_CompressedIntegerList)\n\nsetMethod(\"as.list\", \"Hits\", function(x) as.list(as(x, \"SortedByQueryHits\")))\n\nsetAs(\"Hits\", \"Grouping\",\n      function(from) ManyToManyGrouping(as(from, \"List\"), nobj=nRnode(from)))\n",
        "IPos-class.R": "### =========================================================================\n### IPos objects\n### -------------------------------------------------------------------------\n###\n\n\nsetClass(\"IPos\",\n    contains=c(\"Pos\", \"IPosRanges\"),\n    representation(\n        \"VIRTUAL\",\n        NAMES=\"character_OR_NULL\"  # R doesn't like @names !!\n    )\n)\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"IPos\",\n    function(x) c(\"NAMES\", callNextMethod())\n)\n\nsetClass(\"UnstitchedIPos\",\n    contains=\"IPos\",\n    representation(\n        pos=\"integer\"\n    )\n)\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"UnstitchedIPos\",\n    function(x) c(\"pos\", callNextMethod())\n)\n\nsetClass(\"StitchedIPos\",\n    contains=\"IPos\",\n    representation(\n        pos_runs=\"IRanges\"  # An unnamed IRanges instance that has\n                            # been \"stitched\" (see below).\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.OLD_IPOS_INSTANCE_MSG <- c(\n    \"Starting with BioC 3.10, the class attribute of all \",\n    \"IPos **instances** needs to be set to \\\"StitchedIPos\\\". \",\n    \"Please update this object with 'updateObject(object, verbose=TRUE)' \",\n    \"and re-serialize it.\"\n)\n\n.validate_IPos <- function(x)\n{\n    if (class(x) == \"IPos\")\n        return(paste(.OLD_IPOS_INSTANCE_MSG, collapse=\"\"))\n\n    NULL\n}\n\nsetValidity2(\"IPos\", .validate_IPos)\n\n### TODO: Add validity methods for UnstitchedIPos and StitchedIPos objects.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Very low-level UnstitchedIPos and StitchedIPos constructors\n###\n### For maximum efficiency, these constructors trust all the supplied\n### arguments and do not validate the object.\n###\n\n.unsafe_new_UnstitchedIPos <- function(pos, names=NULL, mcols=NULL,\n                                            metadata=list())\n{\n    new2(\"UnstitchedIPos\", pos=pos,\n                           NAMES=names,\n                           elementMetadata=mcols,\n                           metadata=metadata,\n                           check=FALSE)\n}\n\n### Trusts all supplied arguments and does not validate the object.\n.unsafe_new_StitchedIPos <- function(pos_runs, names=NULL, mcols=NULL,\n                                               metadata=list())\n{\n    new2(\"StitchedIPos\", pos_runs=pos_runs,\n                         NAMES=names,\n                         elementMetadata=mcols,\n                         metadata=metadata,\n                         check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### NOT exported but used in the GenomicRanges package.\nget_IPos_version <- function(object)\n{\n    if (.hasSlot(object, \"NAMES\"))\n        return(\"current\")\n\n    if (class(object) != \"IPos\")\n        return(\">= 2.19.4 and < 2.19.9\")\n\n    return(\"< 2.19.4\")\n}\n\n.updateObject_IPos <- function(object, ..., verbose=FALSE)\n{\n    if (.hasSlot(object, \"NAMES\")) {\n        ## 'object' was made with IRanges >= 2.19.9.\n        if (verbose)\n            message(\"[updateObject] \", class(object), \" object is current.\\n\",\n                    \"[updateObject] Nothing to update.\")\n        return(callNextMethod())\n    }\n\n    if (verbose)\n        message(\"[updateObject] \", class(object), \" object \",\n                \"uses internal representation from\\n\",\n                \"[updateObject] IRanges \", get_IPos_version(object), \". \",\n                \"Updating it ... \", appendLF=FALSE)\n\n    if (class(object) == \"UnstitchedIPos\") {\n        ## 'object' is an UnstitchedIPos instance that was made with\n        ## IRanges >= 2.19.4 and < 2.19.9.\n        object <- .unsafe_new_UnstitchedIPos(object@pos,\n                                             NULL,\n                                             object@elementMetadata,\n                                             object@metadata)\n    } else {\n        ## 'object' is either an IPos instance that was made with\n        ## IRanges < 2.19.4 or a StitchedIPos instance that was made with\n        ## IRanges >= 2.19.4 and < 2.19.9.\n        object <- .unsafe_new_StitchedIPos(object@pos_runs,\n                                           NULL,\n                                           object@elementMetadata,\n                                           object@metadata)\n    }\n\n    if (verbose)\n        message(\"OK\")\n\n    callNextMethod()\n}\n\nsetMethod(\"updateObject\", \"IPos\", .updateObject_IPos)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"pos\", \"UnstitchedIPos\", function(x) x@pos)\n### This really should be the method for StitchedIPos objects but we define a\n### method for IPos objects for backward compatibility with old IPos instances.\nsetMethod(\"pos\", \"IPos\", function(x) unlist_as_integer(x@pos_runs))\n\nsetMethod(\"length\", \"UnstitchedIPos\", function(x) length(x@pos))\n### This really should be the method for StitchedIPos objects but we define a\n### method for IPos objects for backward compatibility with old IPos instances.\nsetMethod(\"length\", \"IPos\", function(x) sum(width(x@pos_runs)))\n\nsetMethod(\"names\", \"IPos\", function(x) x@NAMES)\n\nsetReplaceMethod(\"names\", \"IPos\",\n    function(x, value)\n    {\n        x@NAMES <- S4Vectors:::normarg_names(value, \"IPos\", length(x))\n        x\n    }\n)\n\n### No `pos<-` setter at the moment for IPos objects! Should we have it?\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Collapse runs of \"stitchable integer ranges\"\n###\n### In an IntegerRanges object 'x', 2 ranges x[i] and x[i+1] are \"stitchable\"\n### if start(x[i+1]) == end(x[i])+1. For example, in the following object:\n###   1: .....xxxx.............\n###   2: ...xx.................\n###   3: .........xxx..........\n###   4: ............xxxxxx....\n###   5: ..................x...\n### x[3] and x[4] are stitchable, and x[4] and x[5] are stitchable. So\n### x[3], x[4], and x[5] form a run of \"stitchable ranges\" that will collapse\n### into the following single range after stitching:\n###      .........xxxxxxxxxx...\n### Note that x[1] and x[3] are not stitchable because they are not\n### consecutive vector elements (but they would if we removed x[2]).\n\n### stitch_IntegerRanges() below takes any IntegerRanges derivative and\n### returns an IRanges object (so is NOT an endomorphism). Note that this\n### transformation preserves 'sum(width(x))'.\n### Also note that this is an \"inter range transformation\". However unlike\n### range(), reduce(), gaps(), or disjoin(), its result depends on the order\n### of the elements in the input vector. It's also idempotent like range(),\n### reduce(), and disjoin() (gaps() is not).\n\n### TODO: Define and export stitch() generic and method for IntegerRanges\n### objects (in inter-range-methods.R).\n### Maybe it would also make sense to have an isStitched() generic like we\n### have isDisjoint() to provide a quick and easy way to check the state of\n### the object before applying the transformation to it. In theory each\n### idempotent inter range transformation could have a \"state checker\" so\n### maybe add isReduced() too (range() probably doesn't need one).\n\nstitch_IntegerRanges <- function(x)\n{\n    if (length(x) == 0L)\n        return(IRanges())\n    x_start <- start(x)\n    x_end <- end(x)\n\n    ## Find runs of stitchable elements along 'x'.\n    ## Each run is described by the indices of its first ('run_from') and\n    ## last ('run_to') elements in 'x'.\n    ## The runs form a partitioning of 'x'.\n    new_run_idx <- which(x_start[-1L] != x_end[-length(x)] + 1L)\n    run_from <- c(1L, new_run_idx + 1L)\n    run_to <- c(new_run_idx, length(x))\n\n    IRanges(x_start[run_from], x_end[run_to])\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### 'pos' must be an integer vector with no NAs.\n.make_StitchedIPos_from_pos <- function(pos, names=NULL, mcols=NULL,\n                                             metadata=list())\n{\n    pos_runs <- as(pos, \"IRanges\")\n    .unsafe_new_StitchedIPos(pos_runs, names, mcols, metadata)\n}\n\n.from_UnstitchedIPos_to_StitchedIPos <- function(from)\n{\n    .make_StitchedIPos_from_pos(from@pos, from@NAMES,\n                                          from@elementMetadata,\n                                          from@metadata)\n}\n\n### 'pos_runs' must be an IRanges object.\n.make_UnstitchedIPos_from_pos_runs <- function(pos_runs, names=NULL, mcols=NULL,\n                                                         metadata=list())\n{\n    pos <- unlist_as_integer(pos_runs)\n    .unsafe_new_UnstitchedIPos(pos, names, mcols, metadata)\n}\n\n.from_StitchedIPos_to_UnstitchedIPos <- function(from)\n{\n    .make_UnstitchedIPos_from_pos_runs(from@pos_runs, from@NAMES,\n                                                      from@elementMetadata,\n                                                      from@metadata)\n}\n\n### 'pos' must be an integer vector with no NAs or an IntegerRanges derivative.\n### This is NOT checked!\nnew_UnstitchedIPos <- function(pos=integer(0))\n{\n    if (is(pos, \"UnstitchedIPos\"))\n        return(pos)\n    if (is(pos, \"StitchedIPos\"))\n        return(.from_StitchedIPos_to_UnstitchedIPos(pos))\n    if (is.integer(pos)) {\n        ## Treat 'pos' as a vector of single positions.\n        names <- names(pos)\n        if (!is.null(names))\n            names(pos) <- NULL\n        return(.unsafe_new_UnstitchedIPos(pos, names))\n    }\n    ## 'pos' is an IntegerRanges derivative. Treat its ranges as runs of\n    ## consecutive positions.\n    ans_len <- sum(width(pos))  # no more integer overflow in R >= 3.5\n    if (ans_len > .Machine$integer.max)\n        stop(\"too many positions in 'pos'\")\n    .make_UnstitchedIPos_from_pos_runs(pos)\n}\n\n### 'pos' must be an integer vector with no NAs or an IntegerRanges derivative.\n### This is NOT checked!\nnew_StitchedIPos <- function(pos=integer(0))\n{\n    if (is(pos, \"StitchedIPos\"))\n        return(pos)\n    if (is(pos, \"UnstitchedIPos\"))\n        return(.from_UnstitchedIPos_to_StitchedIPos(pos))\n    if (is.integer(pos)) {\n        ## Treat 'pos' as a vector of single positions.\n        names <- names(pos)\n        if (!is.null(names))\n            names(pos) <- NULL\n        return(.make_StitchedIPos_from_pos(pos, names))\n    }\n    ## 'pos' is an IntegerRanges derivative. Treat its ranges as runs of\n    ## consecutive positions.\n    ans_len <- sum(width(pos))  # no more integer overflow in R >= 3.5\n    if (ans_len > .Machine$integer.max)\n        stop(\"too many positions in 'pos'\")\n    pos_runs <- stitch_IntegerRanges(pos)\n    pos_runs <- pos_runs[width(pos_runs) != 0L]\n    .unsafe_new_StitchedIPos(pos_runs)\n}\n\n### Returns an integer vector with no NAs or an IntegerRanges derivative.\n.normarg_pos <- function(pos)\n{\n    if (is(pos, \"IntegerRanges\"))\n        return(pos)\n    if (is.numeric(pos)) {\n        if (!is.integer(pos))\n            storage.mode(pos) <- \"integer\"  # preserve the names\n        if (anyNA(pos))\n            stop(\"'pos' cannot contain NAs\")\n        return(pos)\n    }\n    ans <- try(as(pos, \"IRanges\"), silent=TRUE)\n    if (inherits(ans, \"try-error\"))\n        stop(\"'pos' must represent positions\")\n    ans\n}\n\n.normarg_stitch <- function(stitch, pos)\n{\n    if (!(is.logical(stitch) && length(stitch) == 1L))\n        stop(\"'stitch' must be TRUE, FALSE, or NA\")\n    if (!is.na(stitch))\n        return(stitch)\n    is(pos, \"IntegerRanges\") && !is(pos, \"UnstitchedIPos\")\n}\n\n### If the input object 'pos' is itself an IPos object, its metadata columns\n### are propagated.\nIPos <- function(pos=integer(0), names=NULL, ..., stitch=NA)\n{\n    mcols <- DataFrame(..., check.names=FALSE)\n\n    pos <- .normarg_pos(pos)\n    stitch <- .normarg_stitch(stitch, pos)\n    if (stitch) {\n        ans <- new_StitchedIPos(pos)\n    } else {\n        ans <- new_UnstitchedIPos(pos)\n    }\n\n    if (!is.null(names))\n        names(ans) <- names\n    if (length(mcols) != 0L)\n        mcols(ans) <- mcols\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"UnstitchedIPos\", \"StitchedIPos\", .from_UnstitchedIPos_to_StitchedIPos)\n\nsetAs(\"StitchedIPos\", \"UnstitchedIPos\", .from_StitchedIPos_to_UnstitchedIPos)\n\n.check_IntegerRanges_for_coercion_to_IPos <- function(from, to)\n{\n    if (!all(width(from) == 1L))\n        stop(wmsg(\"all the ranges in the \", class(from), \" object to \",\n                  \"coerce to \", to, \" must have a width of 1\"))\n}\n.from_IntegerRanges_to_UnstitchedIPos <- function(from)\n{\n    .check_IntegerRanges_for_coercion_to_IPos(from, \"UnstitchedIPos\")\n    ans <- new_UnstitchedIPos(from)\n    names(ans) <- names(from)\n    mcols(ans) <- mcols(from, use.names=FALSE)\n    metadata(ans) <- metadata(from)\n    ans\n}\n.from_IntegerRanges_to_StitchedIPos <- function(from)\n{\n    .check_IntegerRanges_for_coercion_to_IPos(from, \"StitchedIPos\")\n    ans <- new_StitchedIPos(from)\n    names(ans) <- names(from)\n    mcols(ans) <- mcols(from, use.names=FALSE)\n    metadata(ans) <- metadata(from)\n    ans\n}\nsetAs(\"IntegerRanges\", \"UnstitchedIPos\", .from_IntegerRanges_to_UnstitchedIPos)\nsetAs(\"IntegerRanges\", \"StitchedIPos\", .from_IntegerRanges_to_StitchedIPos)\nsetAs(\"IntegerRanges\", \"IPos\", .from_IntegerRanges_to_UnstitchedIPos)\n\nsetAs(\"ANY\", \"UnstitchedIPos\", function(from) IPos(from, stitch=FALSE))\nsetAs(\"ANY\", \"StitchedIPos\", function(from) IPos(from, stitch=TRUE))\nsetAs(\"ANY\", \"IPos\", function(from) IPos(from))\n\n### S3/S4 combo for as.data.frame.IPos\n### The \"as.data.frame\" method for IntegerRanges objects works on an IPos\n### object but returns a data.frame with identical \"start\" and \"end\" columns,\n### and a \"width\" column filled with 1. We overwrite it to return a data.frame\n### with a \"pos\" column instead of the \"start\" and \"end\" columns, and no\n### \"width\" column.\n.as.data.frame.IPos <- function(x, row.names=NULL, optional=FALSE)\n{\n    if (!identical(optional, FALSE))\n        warning(wmsg(\"'optional' argument was ignored\"))\n    ans <- data.frame(pos=pos(x), row.names=row.names, stringsAsFactors=FALSE)\n    x_mcols <- mcols(x, use.names=FALSE)  # can be NULL!\n    if (!is.null(x_mcols))\n        ans <- cbind(ans, as.data.frame(x_mcols, optional=TRUE))\n    ans\n}\nas.data.frame.IPos <- function(x, row.names=NULL, optional=FALSE, ...)\n    .as.data.frame.IPos(x, row.names=NULL, optional=FALSE, ...)\nsetMethod(\"as.data.frame\", \"IPos\", .as.data.frame.IPos)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n### NOT exported but used in the GenomicRanges package.\n### 'pos_runs' must be an IRanges or GRanges object or any range-based\n### object as long as it supports start(), end(), width(), and is subsettable.\n### 'i' must be an IntegerRanges object with no zero-width ranges.\nextract_pos_runs_by_ranges <- function(pos_runs, i)\n{\n    map <- S4Vectors:::map_ranges_to_runs(width(pos_runs),\n                                          start(i), width(i))\n    ## Because 'i' has no zero-width ranges, 'mapped_range_span' cannot\n    ## contain zeroes and so 'mapped_range_Ltrim' and 'mapped_range_Rtrim'\n    ## cannot contain garbbage.\n    mapped_range_offset <- map[[1L]]\n    mapped_range_span <- map[[2L]]\n    mapped_range_Ltrim <- map[[3L]]\n    mapped_range_Rtrim <- map[[4L]]\n    run_idx <- sequence(mapped_range_span, from=mapped_range_offset+1L)\n    pos_runs <- pos_runs[run_idx]\n    if (length(run_idx) != 0L) {\n        Rtrim_idx <- cumsum(mapped_range_span)\n        Ltrim_idx <- c(1L, Rtrim_idx[-length(Rtrim_idx)] + 1L)\n        trimmed_start <- start(pos_runs)[Ltrim_idx] +\n                         mapped_range_Ltrim\n        trimmed_end <- end(pos_runs)[Rtrim_idx] - mapped_range_Rtrim\n        start(pos_runs)[Ltrim_idx] <- trimmed_start\n        end(pos_runs)[Rtrim_idx] <- trimmed_end\n        new_len <- sum(width(pos_runs))  # no more integer overflow in R >= 3.5\n        if (new_len > .Machine$integer.max)\n            stop(\"subscript is too big\")\n    }\n    pos_runs\n}\n\n### This really should be the method for StitchedIPos objects but we define a\n### method for IPos objects for backward compatibility with old IPos instances.\nsetMethod(\"extractROWS\", \"IPos\",\n    function(x, i)\n    {\n        ans <- callNextMethod()\n        if (is(x, \"UnstitchedIPos\"))\n            return(ans)\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        ## TODO: Maybe make this the coercion method from NSBS to\n        ## IntegerRanges.\n        if (is(i, \"RangesNSBS\")) {\n            ir <- i@subscript\n            ir <- ir[width(ir) != 0L]\n        } else {\n            ir <- as(as.integer(i), \"IRanges\")\n        }\n        new_pos_runs <- extract_pos_runs_by_ranges(x@pos_runs, ir)\n        new_pos_runs <- stitch_IntegerRanges(new_pos_runs)\n        BiocGenerics:::replaceSlots(ans, pos_runs=new_pos_runs, check=FALSE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show\n###\n\n.IPos_summary <- function(object)\n{\n    object_class <- classNameForDisplay(object)\n    object_len <- length(object)\n    object_mcols <- mcols(object, use.names=FALSE)\n    object_nmc <- if (is.null(object_mcols)) 0L else ncol(object_mcols)\n    paste0(object_class, \" object with \", object_len, \" \",\n           ifelse(object_len == 1L, \"position\", \"positions\"),\n           \" and \", object_nmc, \" metadata \",\n           ifelse(object_nmc == 1L, \"column\", \"columns\"))\n}\n\n### S3/S4 combo for summary.IPos\nsummary.IPos <- function(object, ...) .IPos_summary(object, ...)\nsetMethod(\"summary\", \"IPos\", summary.IPos)\n\n.from_IPos_to_naked_character_matrix_for_display <- function(x)\n{\n    m <- cbind(pos=showAsCell(pos(x)))\n    cbind_mcols_for_display(m, x)\n}\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"IPos\",\n    .from_IPos_to_naked_character_matrix_for_display\n)\n\nshow_IPos <- function(x, margin=\"\", print.classinfo=FALSE)\n{\n    version <- get_IPos_version(x)\n    if (version != \"current\")\n        stop(c(wmsg(\"This \", class(x), \" object uses internal representation \",\n                    \"from IRanges \", version, \", and so needs to be updated \",\n                    \"before it can be displayed or used. \",\n                    \"Please update it with:\"),\n               \"\\n\\n    object <- updateObject(object, verbose=TRUE)\",\n               \"\\n\\n  and re-serialize it.\"))\n    cat(margin, summary(x), \":\\n\", sep=\"\")\n    ## makePrettyMatrixForCompactPrinting() assumes that head() and tail()\n    ## work on 'xx'.\n    xx <- as(x, \"IPos\")\n    out <- makePrettyMatrixForCompactPrinting(xx)\n    if (print.classinfo) {\n        .COL2CLASS <- c(pos=\"integer\")\n        classinfo <- makeClassinfoRowForCompactPrinting(x, .COL2CLASS)\n        ## A sanity check, but this should never happen!\n        stopifnot(identical(colnames(classinfo), colnames(out)))\n        out <- rbind(classinfo, out)\n    }\n    if (nrow(out) != 0L)\n        rownames(out) <- paste0(margin, \"  \", rownames(out))\n    ## We set 'max' to 'length(out)' to avoid the getOption(\"max.print\")\n    ## limit that would typically be reached when 'showHeadLines' global\n    ## option is set to Inf.\n    print(out, quote=FALSE, right=TRUE, max=length(out))\n}\n\nsetMethod(\"show\", \"IPos\",\n    function(object) show_IPos(object, print.classinfo=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.concatenate_StitchedIPos_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- S4Vectors:::prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ans_len <- sum(lengths(all_objects))  # no more integer overflow\n                                          # in R >= 3.5\n    if (ans_len > .Machine$integer.max)\n        stop(\"too many integer positions to concatenate\")\n\n    ## 1. Take care of the parallel slots\n\n    ## Call method for Vector objects to concatenate all the parallel\n    ## slots (only \"elementMetadata\" in the case of IPos) and stick them\n    ## into 'ans'. Note that the resulting 'ans' can be an invalid object\n    ## because its \"elementMetadata\" slot can be longer (i.e. have more rows)\n    ## than 'ans' itself so we use 'check=FALSE' to skip validation.\n    ans <- callNextMethod(x, objects, use.names=use.names,\n                                      ignore.mcols=ignore.mcols,\n                                      check=FALSE)\n\n    ## 2. Take care of the non-parallel slots\n\n    ## Concatenate the \"pos_runs\" slots.\n    pos_runs_list <- lapply(all_objects, slot, \"pos_runs\")\n    ans_pos_runs <- stitch_IntegerRanges(\n        bindROWS(pos_runs_list[[1L]], pos_runs_list[-1L])\n    )\n\n    BiocGenerics:::replaceSlots(ans, pos_runs=ans_pos_runs,\n                                     check=check)\n}\n\n### This really should be the method for StitchedIPos objects but we define a\n### method for IPos objects for backward compatibility with old IPos instances.\nsetMethod(\"bindROWS\", \"IPos\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        if (is(x, \"UnstitchedIPos\"))\n            return(callNextMethod())\n        x <- updateObject(x, check=FALSE)\n        .concatenate_StitchedIPos_objects(x, objects, use.names, ignore.mcols,\n                                          check)\n    }\n)\n\n",
        "IPosList-class.R": "### =========================================================================\n### IPosList objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"IPosList\",\n    contains=c(\"PosList\", \"IntegerRangesList\"),\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"IPos\")\n)\n\nsetClass(\"SimpleIPosList\",\n    contains=c(\"IPosList\", \"SimplePosList\", \"SimpleIntegerRangesList\")\n)\n\n",
        "IPosRanges-class.R": "### =========================================================================\n### IPosRanges objects\n### -------------------------------------------------------------------------\n###\n### The ranges in an IPosRanges derivative are closed, one-dimensional\n### intervals with integer end points and on the domain of integers.\n###\n### The direct IPosRanges subclasses defined in the IRanges package are:\n### IRanges, IPos, NCList, and GroupingRanges.\n\n\nsetClass(\"IPosRanges\",\n    contains=\"IntegerRanges\",\n    representation(\"VIRTUAL\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n### The checking of the names(x) is taken care of by the validity method for\n### Vector objects.\nsetValidity2(\"IPosRanges\", validate_Ranges)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n### Value of elementType slot has changed from \"integer\" to \"ANY\" for\n### IPosRanges objects in IRanges 2.13.22 (Bioc 3.7). It will soon change\n### again to \"StitchedIPos\".\n###\n\nsetMethod(\"updateObject\", \"IPosRanges\",\n    function(object, ..., verbose=FALSE)\n    {\n        target <- new(class(object))@elementType\n        current <- object@elementType\n        if (identical(target, current)) {\n            if (verbose)\n                message(\"[updateObject] Internal representation of \",\n                        class(object), \" object is current.\\n\",\n                        \"[updateObject] Nothing to update.\")\n        } else {\n            if (verbose)\n                message(\"[updateObject] elementType slot of \", class(object),\n                        \" object should be set to \\\"\", target, \"\\\",\\n\",\n                        \"[updateObject] not to \\\"\", current, \"\\\".\\n\",\n                        \"[updateObject] Updating it ... \", appendLF=FALSE)\n            object@elementType <- target\n            if (verbose)\n                message(\"OK\")\n        }\n\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### Propagate the names.\nsetMethod(\"as.character\", \"IPosRanges\",\n    function(x)\n    {\n        if (length(x) == 0L)\n            return(setNames(character(0), names(x)))\n        x_start <- start(x)\n        x_end <- end(x)\n        ans <- paste0(x_start, \"-\", x_end)\n        idx <- which(x_start == x_end)\n        ans[idx] <- as.character(x_start)[idx]\n        names(ans) <- names(x)\n        ans\n    }\n)\n\n### The as.factor() generic doesn't have the ... argument so this method\n### cannot support the 'ignore.strand' argument.\nsetMethod(\"as.factor\", \"IPosRanges\",\n    function(x)\n        factor(as.character(x), levels=as.character(sort(unique(x))))\n)\n\nsetMethod(\"as.matrix\", \"IPosRanges\",\n    function(x, ...)\n        matrix(data=c(start(x), width(x)), ncol=2,\n               dimnames=list(names(x), NULL))\n)\n\n### S3/S4 combo for as.data.frame.IPosRanges\n.as.data.frame.IPosRanges <- function(x, row.names=NULL, optional=FALSE)\n{\n    if (!identical(optional, FALSE))\n        warning(wmsg(\"'optional' argument was ignored\"))\n    ans <- data.frame(start=start(x),\n                      end=end(x),\n                      width=width(x),\n                      row.names=row.names,\n                      check.names=FALSE,\n                      stringsAsFactors=FALSE)\n    ans$names <- names(x)\n    x_mcols <- mcols(x, use.names=FALSE)  # can be NULL!\n    if (!is.null(x_mcols))\n        ans <- cbind(ans, as.data.frame(x_mcols, optional=TRUE))\n    ans\n}\nas.data.frame.IPosRanges <- function(x, row.names=NULL, optional=FALSE, ...)\n    .as.data.frame.IPosRanges(x, row.names=NULL, optional=FALSE, ...)\nsetMethod(\"as.data.frame\", \"IPosRanges\", .as.data.frame.IPosRanges)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### show()\n###\n\n.IPosRanges_summary <- function(object)\n{\n    object_class <- classNameForDisplay(object)\n    object_len <- length(object)\n    object_mcols <- mcols(object, use.names=FALSE)\n    object_nmc <- if (is.null(object_mcols)) 0L else ncol(object_mcols)\n    paste0(object_class, \" object with \", object_len, \" \",\n           ifelse(object_len == 1L, \"range\", \"ranges\"),\n           \" and \", object_nmc, \" metadata \",\n           ifelse(object_nmc == 1L, \"column\", \"columns\"))\n}\n\n### S3/S4 combo for summary.IPosRanges\nsummary.IPosRanges <- function(object, ...) .IPosRanges_summary(object, ...)\nsetMethod(\"summary\", \"IPosRanges\", summary.IPosRanges)\n\n.from_IPosRanges_to_naked_character_matrix_for_display <- function(x)\n{\n    m <- cbind(start=showAsCell(start(x)),\n               end=showAsCell(end(x)),\n               width=showAsCell(width(x)))\n    cbind_mcols_for_display(m, x)\n}\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"IPosRanges\",\n    .from_IPosRanges_to_naked_character_matrix_for_display\n)\n\nshow_IPosRanges <- function(x, margin=\"\", print.classinfo=FALSE)\n{\n    cat(margin, summary(x), \":\\n\", sep=\"\")\n    ## makePrettyMatrixForCompactPrinting() assumes that 'x' is subsettable\n    ## but not all IPosRanges objects are (and if even when they are,\n    ## subsetting them can be costly). However IRanges objects are assumed\n    ## to be subsettable so if 'x' is not one then we turn it into one (this\n    ## coercion is expected to work on any IPosRanges object).\n    if (!is(x, \"IRanges\"))\n        x <- as(x, \"IRanges\", strict=FALSE)\n    out <- makePrettyMatrixForCompactPrinting(x)\n    if (print.classinfo) {\n        .COL2CLASS <- c(\n            start=\"integer\",\n            end=\"integer\",\n            width=\"integer\"\n        )\n        classinfo <- makeClassinfoRowForCompactPrinting(x, .COL2CLASS)\n        ## A sanity check, but this should never happen!\n        stopifnot(identical(colnames(classinfo), colnames(out)))\n        out <- rbind(classinfo, out)\n    }\n    if (nrow(out) != 0L)\n        rownames(out) <- paste0(margin, \"  \", rownames(out))\n    ## We set 'max' to 'length(out)' to avoid the getOption(\"max.print\")\n    ## limit that would typically be reached when 'showHeadLines' global\n    ## option is set to Inf.\n    print(out, quote=FALSE, right=TRUE, max=length(out))\n}\n\nsetMethod(\"show\", \"IPosRanges\",\n    function(object) show_IPosRanges(object, print.classinfo=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n### Avoid infinite recursion that we would otherwise get:\n###   IRanges(1:4, 8)[[1]]\n###   # Error: C stack usage  7969636 is too close to the limit\nsetMethod(\"getListElement\", \"IPosRanges\",\n    function(x, i, exact=TRUE)\n    {\n        ## A temporary situation\n        stop(wmsg(class(x), \" objects don't support [[, as.list(), \",\n                  \"lapply(), or unlist() at the moment\"))\n    }\n)\n\n",
        "IPosRanges-comparison.R": "### =========================================================================\n### Comparing and ordering the ranges in IPosRanges derivatives\n### -------------------------------------------------------------------------\n###\n\n\nsetMethod(\"pcompareRecursively\", \"IPosRanges\", function(x) FALSE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompare()\n###\n### Ranges are ordered by starting position first and then by width.\n### This way, the space of ranges is totally ordered.\n### This \"pcompare\" method returns one of the 13 predefined codes (>= -6 and\n### <= 6) described in the man page. The signs of those codes reflect this\n### order.\n###\n\nsetMethod(\"pcompare\", c(\"IPosRanges\", \"IPosRanges\"),\n    function(x, y)\n    {\n        .Call2(\"C_pcompare_IPosRanges\",\n               start(x), width(x), start(y), width(y),\n               PACKAGE=\"IRanges\")\n    }\n)\n\nrangeComparisonCodeToLetter <- function(code)\n{\n    if (!is.integer(code))\n        stop(\"'code' must be an integer vector\")\n    code <- code + 7L\n    code[code < 1L | 14L < code] <- 14L\n    levels <- c(letters[1:13], \"X\")\n    structure(code, levels=levels, class=\"factor\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n\nsetMethod(\"match\", c(\"IPosRanges\", \"IPosRanges\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL,\n                       method=c(\"auto\", \"quick\", \"hash\"))\n    {\n        if (!is.null(incomparables))\n            stop(\"\\\"match\\\" method for IPosRanges objects \",\n                 \"only accepts 'incomparables=NULL'\")\n        ## Equivalent to (but faster than):\n        ##     findOverlaps(x, table, type=\"equal\", select=\"first\")\n        ## except when 'x' or 'table' contain empty ranges.\n        matchIntegerPairs(start(x), width(x),\n                          start(table), width(table),\n                          nomatch=nomatch, method=method)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selfmatch()\n###\n\nsetMethod(\"selfmatch\", \"IPosRanges\",\n    function(x, method=c(\"auto\", \"quick\", \"hash\"))\n        selfmatchIntegerPairs(start(x), width(x), method=method)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### order() and related methods.\n###\n### is.unsorted(), order(), sort(), rank() on IPosRanges derivatives are\n### consistent with the order implied by pcompare().\n### is.unsorted() is a quick/cheap way of checking whether an IPosRanges\n### derivative is already sorted, e.g., called prior to a costly sort.\n### sort() and rank() will work out-of-the-box on an IPosRanges derivative\n### thanks to the method for List objects (which delegates to the method for\n### Vector objects).\n###\n\n.IPosRanges_as_integer_pairs <- function(x)\n{\n    a <- start(x)\n    b <- width(x)\n    list(a, b)\n}\n\nsetMethod(\"is.unsorted\", \"IPosRanges\",\n    function(x, na.rm=FALSE, strictly=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(\"\\\"is.unsorted\\\" method for IPosRanges objects \",\n                    \"ignores the 'na.rm' argument\")\n        if (!isTRUEorFALSE(strictly))\n            stop(\"'strictly' must be TRUE of FALSE\")\n        ## It seems that creating the integer pairs below is faster when\n        ## 'x' is already sorted (TODO: Investigate why). Therefore, and\n        ## somewhat counterintuitively, is.unsorted() can be faster when 'x'\n        ## is already sorted (which, in theory, is the worst-case scenario\n        ## because S4Vectors:::sortedIntegerPairs() will then need to take a\n        ## full walk on 'x') than when it is unsorted (in which case\n        ## S4Vectors:::sortedIntegerPairs() might stop walking on 'x' after\n        ## checking its first 2 elements only -- the best-case scenario).\n        pairs <- .IPosRanges_as_integer_pairs(x)\n        !S4Vectors:::sortedIntegerPairs(pairs[[1L]], pairs[[2L]],\n                                        strictly=strictly)\n    }\n)\n\n.order_IPosRanges <- function(x, decreasing=FALSE)\n{\n    if (!isTRUEorFALSE(decreasing))\n        stop(\"'decreasing' must be TRUE or FALSE\")\n    pairs <- .IPosRanges_as_integer_pairs(x)\n    orderIntegerPairs(pairs[[1L]], pairs[[2L]], decreasing=decreasing)\n}\n\n### 'na.last' is pointless (IPosRanges derivatives don't contain NAs) so is\n### ignored.\n### 'method' is also ignored at the moment.\nsetMethod(\"order\", \"IPosRanges\",\n    function(..., na.last=TRUE, decreasing=FALSE,\n                  method=c(\"auto\", \"shell\", \"radix\"))\n    {\n        ## Turn off this warning for now since it triggers spurious warnings\n        ## when calling sort() on an IPosRangesList derivative. The root of\n        ## the problem is inconsistent defaults for 'na.last' between order()\n        ## and sort(), as reported here:\n        ##   https://stat.ethz.ch/pipermail/r-devel/2015-November/072012.html\n        #if (!identical(na.last, TRUE))\n        #    warning(\"\\\"order\\\" method for IPosRanges objects \",\n        #            \"ignores the 'na.last' argument\")\n        if (!isTRUEorFALSE(decreasing))\n            stop(\"'decreasing' must be TRUE or FALSE\")\n        ## All arguments in '...' are guaranteed to be IPosRanges derivatives.\n        args <- list(...)\n        if (length(args) == 1L)\n            return(.order_IPosRanges(args[[1L]], decreasing))\n        order_args <- c(unlist(lapply(args, .IPosRanges_as_integer_pairs),\n                               recursive=FALSE, use.names=FALSE),\n                        list(na.last=na.last, decreasing=decreasing))\n        do.call(order, order_args)\n    }\n)\n\n",
        "IRanges-class.R": "### =========================================================================\n### IRanges objects\n### -------------------------------------------------------------------------\n###\n### The IRanges class is a simple container for storing a vector of integer\n### ranges.\n###\n\nsetClass(\"IRanges\",\n    contains=\"IPosRanges\",\n    representation(\n        start=\"integer\",\n        width=\"integer\",\n        NAMES=\"character_OR_NULL\"  # R doesn't like @names !!\n    )\n)\n\n### A NormalIRanges object is an IRanges object where the ranges are:\n###   (a) not empty (i.e. they have a non-null width);\n###   (b) not overlapping;\n###   (c) ordered from left to right;\n###   (d) not even adjacent (i.e. there must be a non empty gap between 2\n###       consecutive ranges).\n### If 'x' is an IRanges object of length >= 2, then 'x' is normal iff:\n###   start(x)[i] <= end(x)[i] < start(x)[i+1] <= end(x)[i+1]\n### for every 1 <= i < length(x).\n### If length(x) == 1, then 'x' is normal iff width(x)[1] >= 1.\n### If length(x) == 0, then 'x' is normal.\nsetClass(\"NormalIRanges\", contains=\"IRanges\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"IRanges\",\n    function(x) c(\"start\", \"width\", \"NAMES\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"start\", \"IRanges\", function(x, ...) x@start)\n\nsetMethod(\"width\", \"IRanges\", function(x) x@width)\n\nsetMethod(\"names\", \"IRanges\", function(x) x@NAMES)\n\nsetMethod(\"ranges\", \"IntegerRanges\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(use.mcols))\n            stop(\"'use.mcols' must be TRUE or FALSE\")\n        ans_start <- start(x)\n        ans_width <- width(x)\n        ans_names <- if (use.names) names(x) else NULL\n        ans_mcols <- if (use.mcols) mcols(x, use.names=FALSE) else NULL\n        new2(\"IRanges\", start=ans_start,\n                        width=ans_width,\n                        NAMES=ans_names,\n                        elementMetadata=ans_mcols,\n                        check=FALSE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isEmpty() and isNormal()\n###\n\n.isNormal_IRanges <- function(x)\n    .Call2(\"C_isNormal_IRanges\", x, PACKAGE=\"IRanges\")\n\nsetMethod(\"isNormal\", \"IRanges\", .isNormal_IRanges)\n\n### Fast methods for NormalIRanges objects.\nsetMethod(\"isEmpty\", \"NormalIRanges\", function(x) length(x) == 0L)\nsetMethod(\"isNormal\", \"NormalIRanges\", function(x) TRUE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"max\" and \"min\" methods.\n###\n### Note: defined for NormalIRanges objects only.\n### For an ordinary IRanges object 'x', it's not clear what the semantic\n### should be. In particular, should empty ranges be ignored or not? If not\n### then we could end up with 'min(x)' > 'max(x)' (e.g. when 'x' is made of 1\n### empty range) which is not nice. Another (and more pragmatic) reason for\n### not defining these methods for IRanges objects is that I don't need them\n### at the moment.\n###\n\nsetMethod(\"max\", \"NormalIRanges\",\n    function(x, ..., na.rm)\n    {\n        if (isEmpty(x)) {\n            warning(\"empty \", class(x), \" object; returning -Inf\")\n            -Inf\n        } else {\n            end(x)[length(x)]\n        }\n    }\n)\n\nsetMethod(\"min\", \"NormalIRanges\",\n    function(x, ..., na.rm)\n    {\n        if (isEmpty(x)) {\n            warning(\"empty \", class(x), \" object; returning Inf\")\n            Inf\n        } else {\n            start(x)[1L]\n        }\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n### Validity of IRanges objects is taken care of by the validity method for\n### IPosRanges objects.\n###\n\n### NormalIRanges objects\n.valid.NormalIRanges <- function(x)\n{\n    if (!.isNormal_IRanges(x))\n        return(\"object is not normal\")\n    NULL\n}\n\nsetValidity2(\"NormalIRanges\", .valid.NormalIRanges)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"IntegerRanges\", \"IRanges\",\n    function(from) ranges(from, use.mcols=TRUE)\n)\n\n### Helper function (not exported) used by the \"coerce\" methods defined in\n### IRanges-utils.R. Believe it or not but the implicit \"coerce\" methods do\n### NOT check that they return a valid object!\nnewNormalIRangesFromIRanges <- function(x, check=TRUE)\n{\n    if (!is(x, \"IRanges\"))\n        stop(\"'x' must be an IRanges object\")\n    if (!isTRUEorFALSE(check))\n        stop(\"'check' must be TRUE or FALSE\")\n    ## Check only what needs to be checked.\n    if (check) {\n        msg <- .valid.NormalIRanges(x)\n        if (!is.null(msg))\n            stop(wmsg(msg))\n    }\n    class(x) <- \"NormalIRanges\"\n    x\n}\n\n### The returned IRanges instance is guaranteed to be normal.\nsetAs(\"logical\", \"IRanges\",\n    function(from) as(as(from, \"NormalIRanges\"), \"IRanges\")\n)\n\n.from_logical_to_NormalIRanges <- function(from)\n    .Call2(\"C_from_logical_to_NormalIRanges\", from, PACKAGE=\"IRanges\")\n\nsetAs(\"logical\", \"NormalIRanges\", .from_logical_to_NormalIRanges)\n\n### coercion from integer\n.from_integer_to_IRanges <- function(from)\n    .Call2(\"C_from_integer_to_IRanges\", from, PACKAGE=\"IRanges\")\n\nsetAs(\"integer\", \"IRanges\", .from_integer_to_IRanges)\n\nsetAs(\"integer\", \"NormalIRanges\",\n    function(from) newNormalIRangesFromIRanges(as(from, \"IRanges\"))\n)\n\nsetMethod(\"as.integer\", \"NormalIRanges\", function(x) unlist_as_integer(x))\n\nsetAs(\"numeric\", \"IRanges\", function(from) as(as.integer(from), \"IRanges\"))\n\nsetAs(\"numeric\", \"NormalIRanges\", \n    function(from) newNormalIRangesFromIRanges(as(as.integer(from), \"IRanges\")))\n\n### coercion from character\n.from_character_to_IRanges <- function(from)\n{\n    stopifnot(is.character(from))\n    if (anyNA(from))\n        stop(wmsg(\"converting a character vector to an IRanges object \",\n                  \"does not support NAs\"))\n    error_msg <- wmsg(\n        \"The character vector to convert to an IRanges object must \",\n        \"contain strings of the form \\\"start-end\\\" or \\\"start..end\\\", \",\n        \"with end >= start - 1, or just \\\"pos\\\". For example: \\\"2501-2900\\\", \",\n        \"\\\"2501..2900\\\", or \\\"740\\\".\"\n    )\n    ## We want to split on the first occurence of  \"-\" that is preceeded by\n    ## a digit (ignoring and removing the spaces in between if any).\n    from <- sub(\"([[:digit:]])[[:space:]]*-\", \"\\\\1..\", from)\n    split2 <- CharacterList(strsplit(from, \"..\", fixed=TRUE))\n    split2_eltNROWS <- elementNROWS(split2)\n    if (!all(split2_eltNROWS <= 2L))\n        stop(error_msg)\n    ans_start <- suppressWarnings(as.integer(heads(split2, n=1L)))\n    ans_end <- suppressWarnings(as.integer(tails(split2, n=1L)))\n    if (anyNA(ans_start) || anyNA(ans_end))\n        stop(error_msg)\n    IRanges(ans_start, ans_end, names=names(from))\n}\nsetAs(\"character\", \"IRanges\", .from_character_to_IRanges)\n\n.from_factor_to_IRanges <- function(from)\n{\n    from <- setNames(as.character(from), names(from))\n    .from_character_to_IRanges(from)\n}\nsetAs(\"factor\", \"IRanges\", .from_factor_to_IRanges)\n\nsetAs(\"ANY\", \"IPosRanges\", function(from) as(from, \"IRanges\"))\nsetAs(\"ANY\", \"IntegerRanges\", function(from) as(from, \"IRanges\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level setters for IRanges objects.\n###\n### All these low-level setters preserve the length of the object.\n### The choice was made to implement a \"resizing\" semantic:\n###   (1) changing the start preserves the end (so it changes the width)\n###   (2) changing the end preserves the start (so it changes the width)\n###   (3) changing the width preserves the start (so it changes the end)\n###\n\n.set_IRanges_start <- function(x, value, check=TRUE)\n{\n    if (!isTRUEorFALSE(check))\n        stop(\"'check' must be TRUE or FALSE\")\n    ## Fix elementType slot on-the-fly.\n    x <- updateObject(x, check=FALSE)\n    old_start <- start(x)\n    ## Use 'x@start[]' instead of 'x@start' so the right value is recycled.\n    x@start[] <- S4Vectors:::numeric2integer(value)\n    x@width <- width(x) - start(x) + old_start\n    if (check)\n        validObject(x)\n    x\n}\n\nsetReplaceMethod(\"start\", \"IRanges\",\n    function(x, ..., value) .set_IRanges_start(x, value)\n)\n\n.set_IRanges_end <- function(x, value, check=TRUE)\n{\n    if (!isTRUEorFALSE(check))\n        stop(\"'check' must be TRUE or FALSE\")\n    ## Fix elementType slot on-the-fly.\n    x <- updateObject(x, check=FALSE)\n    ## Use 'x@width[]' instead of 'x@width' so the right value is recycled.\n    x@width[] <- width(x) - end(x) + S4Vectors:::numeric2integer(value)\n    if (check)\n        validObject(x)\n    x\n}\n\nsetReplaceMethod(\"end\", \"IRanges\",\n    function(x, ..., value) .set_IRanges_end(x, value)\n)\n\n.set_IRanges_width <- function(x, value, check=TRUE)\n{\n    if (!isTRUEorFALSE(check))\n        stop(\"'check' must be TRUE or FALSE\")\n    ## Fix elementType slot on-the-fly.\n    x <- updateObject(x, check=FALSE)\n    ## Use 'x@width[]' instead of 'x@width' so the right value is recycled.\n    x@width[] <- S4Vectors:::numeric2integer(value)\n    if (check)\n        validObject(x)\n    x\n}\n\nsetReplaceMethod(\"width\", \"IRanges\",\n    function(x, ..., value) .set_IRanges_width(x, value)\n)\n\nset_IRanges_names <- function(x, value)\n{\n    ## Fix elementType slot on-the-fly.\n    x <- updateObject(x, check=FALSE)\n    x@NAMES <- S4Vectors:::normarg_names(value, class(x), length(x))\n    ## No need to validate an IRanges object after setting its names so\n    ## this should be safe.\n    x\n}\n\nsetReplaceMethod(\"names\", \"IRanges\", set_IRanges_names)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"extractROWS\", \"NormalIRanges\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        if (is(x, \"NormalIRanges\")) {\n            if (!isStrictlySorted(i))\n                stop(\"subscript must extract elements at strictly sorted \",\n                     \"positions when\\n  subsetting a \", class(x), \" object\")\n        }\n        callNextMethod()\n    }\n)\n\nsetMethod(\"replaceROWS\", \"IRanges\",\n    function(x, i, value)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        ans_start <- replaceROWS(start(x), i, start(value))\n        ans_width <- replaceROWS(width(x), i, width(value))\n        ans_mcols <- replaceROWS(mcols(x, use.names=FALSE), i,\n                                 mcols(value, use.names=FALSE))\n        BiocGenerics:::replaceSlots(x, start=ans_start,\n                                       width=ans_width,\n                                       mcols=ans_mcols,\n                                       check=FALSE)\n    }\n)\n\nsetMethod(\"replaceROWS\", \"NormalIRanges\",\n    function(x, i, value)\n    {\n        ans <- callNextMethod()\n        validObject(ans)\n        ans\n    }\n)\n\n",
        "IRanges-constructor.R": "### =========================================================================\n### The IRanges constructor\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Tree low-level helpers\n###\n\n.is_numeric_or_NAs <- function(x)\n{\n    is.numeric(x) || is.logical(x) && all(is.na(x))\n}\n\n### Input can contain NAs. Output must be an unnamed integer vector.\n.start_as_unnamed_integer <- function(start, what=\"a start\")\n{\n    if (is.integer(start))\n        ## We still pass 'start' thru 'as.integer()' to drop any troublemaker\n        ## attribute like \"names\", \"dim\", or \"dimnames\".\n        ## See https://github.com/Bioconductor/IRanges/issues/37\n        return(as.integer(start))\n    old_warn <- getOption(\"warn\")\n    options(warn=2L)\n    on.exit(options(warn=old_warn))\n    start <- try(as.integer(start), silent=TRUE)\n    if (inherits(start, \"try-error\"))\n        stop(wmsg(\"each range must have \", what, \" that \",\n                  \"is < 2^31 and > - 2^31\"))\n    start\n}\n\n### Input can contain NAs. Output must be an unnamed integer vector.\n.width_as_unnamed_integer <- function(width, msg=\"a non-negative width\")\n{\n    if (any(width < 0, na.rm=TRUE))\n        stop(wmsg(\"each range must have \", msg))\n    if (is.integer(width))\n        ## We still pass 'width' thru 'as.integer()' to drop any troublemaker\n        ## attribute like \"names\", \"dim\", or \"dimnames\".\n        ## See https://github.com/Bioconductor/IRanges/issues/37\n        return(as.integer(width))\n    old_warn <- getOption(\"warn\")\n    options(warn=2L)\n    on.exit(options(warn=old_warn))\n    width <- try(as.integer(width), silent=TRUE)\n    if (inherits(width, \"try-error\"))\n        stop(wmsg(\"each range must have a width that is < 2^31\"))\n    width\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level IRanges constructors\n###\n\n.new_empty_IRanges <- function() new2(\"IRanges\", check=FALSE)\n\n.new_IRanges_from_start_end <- function(start, end)\n{\n    if (!.is_numeric_or_NAs(start) || !.is_numeric_or_NAs(end))\n        stop(wmsg(\"'start' and 'end' must be numeric vectors\"))\n    if (anyNA(start) || anyNA(end))\n        stop(wmsg(\"'start' or 'end' cannot contain NAs\"))\n    if (length(start) == 0L || length(end) == 0L)\n        return(.new_empty_IRanges())\n    start <- .start_as_unnamed_integer(start)\n    end   <- .start_as_unnamed_integer(end, what=\"an end\")\n    ## We want to perform this operation in \"double\" space rather\n    ## than in \"integer\" space so we use 1.0 instead of 1L.\n    width <- 1.0 + end - start\n    width <- .width_as_unnamed_integer(width,\n                 msg=\"an end that is greater or equal to its start minus one\")\n    start <- S4Vectors:::recycleVector(start, length(width))\n    new2(\"IRanges\", start=start, width=width, check=FALSE)\n}\n\n.new_IRanges_from_start_width <- function(start, width)\n{\n    if (!.is_numeric_or_NAs(start) || !.is_numeric_or_NAs(width))\n        stop(wmsg(\"'start' and 'width' must be numeric vectors\"))\n    if (anyNA(start) || anyNA(width))\n        stop(wmsg(\"'start' or 'width' cannot contain NAs\"))\n    if (length(start) == 0L || length(width) == 0L)\n        return(.new_empty_IRanges())\n    start <- .start_as_unnamed_integer(start)\n    width <- .width_as_unnamed_integer(width)\n    ## We want to perform this operation in \"double\" space rather\n    ## than in \"integer\" space so we use -1.0 instead of -1L.\n    end <- -1.0 + start + width\n    end <- .start_as_unnamed_integer(end, what=\"an end\")\n    start <- S4Vectors:::recycleVector(start, length(end))\n    width <- S4Vectors:::recycleVector(width, length(end))\n    new2(\"IRanges\", start=start, width=width, check=FALSE)\n}\n\n.new_IRanges_from_end_width <- function(end, width)\n{\n    if (!.is_numeric_or_NAs(end) || !.is_numeric_or_NAs(width))\n        stop(wmsg(\"'end' and 'width' must be numeric vectors\"))\n    if (anyNA(end) || anyNA(width))\n        stop(wmsg(\"'end' or 'width' cannot contain NAs\"))\n    if (length(end) == 0L || length(width) == 0L)\n        return(.new_empty_IRanges())\n    end   <- .start_as_unnamed_integer(end, what=\"an end\")\n    width <- .width_as_unnamed_integer(width)\n    ## We want to perform this operation in \"double\" space rather\n    ## than in \"integer\" space so we use 1.0 instead of 1L.\n    start <- 1.0 + end - width\n    start <- .start_as_unnamed_integer(start)\n    start <- suppressWarnings(as.integer(start))\n    width <- S4Vectors:::recycleVector(width, length(start))\n    new2(\"IRanges\", start=start, width=width, check=FALSE)\n}\n\n.solve_start_end_width <- function(start, end, width)\n{\n    if (!.is_numeric_or_NAs(start)\n     || !.is_numeric_or_NAs(end)\n     || !.is_numeric_or_NAs(width))\n        stop(wmsg(\"'start', 'end', and 'width', must be numeric vectors\"))\n    L1 <- length(start)\n    L2 <- length(end)\n    L3 <- length(width)\n    if (min(L1, L2, L3) == 0L)\n        return(.new_empty_IRanges())\n    if (is.logical(start)) {\n        start <- as.integer(start)\n    } else {\n        start <- .start_as_unnamed_integer(start)\n    }\n    if (is.logical(end)) {\n        end <- as.integer(end)\n    } else {\n        end <- .start_as_unnamed_integer(end, what=\"an end\")\n    }\n    if (is.logical(width)) {\n        width <- as.integer(width)\n    } else {\n        width <- .width_as_unnamed_integer(width)\n    }\n    ans_len <- max(L1, L2, L3)\n    start <- S4Vectors:::recycleVector(start, ans_len)\n    end   <- S4Vectors:::recycleVector(end, ans_len)\n    width <- S4Vectors:::recycleVector(width, ans_len)\n    .Call2(\"C_solve_start_end_width\", start, end, width, PACKAGE=\"IRanges\")\n}\n\n.new_IRanges <- function(start=NULL, end=NULL, width=NULL)\n{\n    start_is_null <- is.null(start)\n    end_is_null <- is.null(end)\n    width_is_null <- is.null(width)\n    nb_of_nulls <- sum(start_is_null, end_is_null, width_is_null)\n    if (nb_of_nulls == 3L)\n        return(.new_empty_IRanges())\n    if (nb_of_nulls == 2L)\n        stop(wmsg(\"at least two of the 'start', 'end', and 'width' \",\n                  \"arguments must be supplied\"))\n    if (width_is_null)\n        return(.new_IRanges_from_start_end(start, end))\n    if (end_is_null)\n        return(.new_IRanges_from_start_width(start, width))\n    if (start_is_null)\n        return(.new_IRanges_from_end_width(end, width))\n    .solve_start_end_width(start, end, width)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### High-level IRanges constructor\n###\n\nIRanges <- function(start=NULL, end=NULL, width=NULL, names=NULL, ...)\n{\n    mcols <- DataFrame(..., check.names=FALSE)\n\n    if (!is.null(start) && is.null(end) && is.null(width)) {\n        ans <- as(start, \"IRanges\")\n    } else {\n        ans <- .new_IRanges(start=start, end=end, width=width)\n    }\n\n    if (!is.null(names))\n        names(ans) <- names\n    if (length(mcols) != 0L)\n        mcols(ans) <- mcols\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The SEW interface: start=NA/end=NA/width=NA\n###\n### Some of the functions that support the SEW interface: narrow(),\n### XVector::subseq(), XVector::xvcopy(), Biostrings::BStringSet() (and\n### family), BSgenome::getSeq(), etc...\n###\n\n.normargSEW <- function(x, argname)\n{\n    if (!S4Vectors:::isNumericOrNAs(x))\n        stop(\"'\", argname, \"' must be a vector of integers\")\n    if (!is.integer(x))\n        x <- as.integer(x)\n    x\n}\n\n### Use of 'rep.refwidths=TRUE' is supported only when 'refwidths' is of\n### length 1.\n### If 'rep.refwidths=FALSE' (the default) then 'start', 'end' and 'width'\n### are recycled to 'length(refwidths)' (it's an error if one of them is\n### longer than 'refwidths'). Otherwise, 'refwidths' is replicated L times\n### where L is the length of the longest of 'start', 'end' and 'width'.\n### The returned value is an IRanges object of the same length as 'refwidths'\n### (after replication if 'rep.refwidths=TRUE').\nsolveUserSEW <- function(refwidths, start=NA, end=NA, width=NA,\n                         rep.refwidths=FALSE,\n                         translate.negative.coord=TRUE,\n                         allow.nonnarrowing=FALSE)\n{\n    if (!is.numeric(refwidths))\n        stop(\"'refwidths' must be a vector of integers\")\n    if (!is.integer(refwidths))\n        refwidths <- as.integer(refwidths)\n\n    start <- .normargSEW(start, \"start\")\n    end <- .normargSEW(end, \"end\")\n    width <- .normargSEW(width, \"width\")\n    ## From here, 'refwidths', 'start', 'end' and 'width' are guaranteed to be\n    ## integer vectors. NAs in 'start', 'end' and 'width' are OK but not in\n    ## 'refwidths' so this should be checked at the C level.\n\n    if (!isTRUEorFALSE(rep.refwidths))\n        stop(\"'rep.refwidths' must be TRUE or FALSE\")\n\n    if (!isTRUEorFALSE(translate.negative.coord))\n        stop(\"'translate.negative.coord' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(allow.nonnarrowing))\n        stop(\"'allow.nonnarrowing' must be TRUE or FALSE\")\n\n    Lsew <- c(length(start), length(end), length(width))\n    maxLsew <- max(Lsew)\n    minLsew <- min(Lsew)\n    if (minLsew == 0L && maxLsew > 1L)\n        stop(\"'start', 'end' and 'width' cannot mix zero-length \",\n             \"and longer-than-one vectors\")\n\n    ## Check 'start', 'end', and 'width' *without* recycling them. Recycling\n    ## is done at the C level.\n    if (rep.refwidths) {\n        if (length(refwidths) != 1L)\n            stop(\"'rep.refwidths=TRUE' can be used only when 'refwidths' \",\n                 \"is of length 1\")\n        ## 'ans_len' is the length of the longest of 'start', 'end'\n        ## and 'width'.\n        if (minLsew == 0L) {\n            ans_len <- 0L\n        } else {\n            ans_len <- maxLsew\n        }\n        refwidths <- rep.int(refwidths, ans_len)\n    } else {\n        ans_len <- length(refwidths)\n        if (ans_len == 0L) {\n            if (maxLsew > 1L)\n                stop(\"'start', 'end' or 'width' is longer than 'refwidths'\")\n        } else {\n            if (minLsew == 0L)\n                stop(\"cannot recycle empty 'start', 'end' or 'width'\")\n            if (maxLsew > ans_len)\n                stop(\"'start', 'end' or 'width' is longer than 'refwidths'\")\n        }\n    }\n\n    .Call2(\"C_solve_user_SEW\",\n           refwidths, start, end, width,\n           translate.negative.coord, allow.nonnarrowing,\n           PACKAGE=\"IRanges\")\n}\n\n### Returns an IRanges instance of length 1. Not exported.\nsolveUserSEWForSingleSeq <- function(x_length, start=NA, end=NA, width=NA)\n{\n    solved_SEW <-\n      try(solveUserSEW(x_length, start=start, end=end, width=width),\n          silent = TRUE)\n    if (is(solved_SEW, \"try-error\"))\n        stop(\"Invalid sequence coordinates.\\n\",\n             \"  Please make sure the supplied 'start', 'end' and 'width' arguments\\n\",\n             \"  are defining a region that is within the limits of the sequence.\")\n    solved_SEW\n}\n\n",
        "IRanges-utils.R": "### =========================================================================\n### Utility functions for creating or modifying IRanges objects\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"successiveIRanges\" function.\n###\n### Note that the returned IRanges object is guaranteed to be normal in the\n### following cases:\n###   (a) when length(width) == 0\n###   (b) when length(width) == 1 and width > 0\n###   (c) when length(width) >= 2 and all(width > 0) and all(gapwidth > 0)\n### However, the function doesn't try to turn the result into a NormalIRanges\n### object.\n###\n\nsuccessiveIRanges <- function(width, gapwidth=0, from=1)\n{\n    if (!is.numeric(width))\n        stop(\"'width' must be an integer vector\")\n    if (length(width) == 0L)\n        return(IRanges())\n    if (!is.integer(width))\n        width <- as.integer(width)  # this drops the names\n    else if (!is.null(names(width)))\n        names(width) <- NULL  # unname() used to be broken on 0-length vectors\n    if (S4Vectors:::anyMissingOrOutside(width, 0L))\n        stop(\"'width' cannot contain NAs or negative values\")\n    if (!is.numeric(gapwidth))\n        stop(\"'gapwidth' must be an integer vector\")\n    if (!is.integer(gapwidth))\n        gapwidth <- as.integer(gapwidth)\n    if (S4Vectors:::anyMissing(gapwidth))\n        stop(\"'gapwidth' cannot contain NAs\")\n    if (length(gapwidth) != length(width) - 1L) {\n        if (length(gapwidth) != 1L)\n            stop(\"'gapwidth' must a single integer or an integer vector \",\n                 \"with one less element than the 'width' vector\")\n        gapwidth <- rep.int(gapwidth, length(width) - 1L)\n    }\n    if (!isSingleNumber(from))\n        stop(\"'from' must be a single integer\")\n    if (!is.integer(from))\n        from <- as.integer(from)\n    ans_start <- cumsum(width[-length(width)] + gapwidth)\n    ans_start <- from + c(0L, ans_start)\n    ## 'ans_start' could contain NAs in case of an integer overflow in\n    ## cumsum(), hence the use of 'check=TRUE' here:\n    new2(\"IRanges\", start=ans_start, width=width, check=TRUE)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### slidingIRanges()\n###\n\nslidingIRanges <- function(len, width, shift = 1L) {\n    start <- seq(1L, len-width, by=shift)\n    end <- seq(width, len, by=shift)\n    IRanges(start, end)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### breakInChunks()\n###\n### TODO: Should not be in IRanges-utils.R because it returns a\n### PartitioningByEnd object, not an IRanges object. So move it to another\n### file, e.g. to Partitioning-class.R. breakInChunks() is actually a\n### specialized PartitioningByEnd constructor.\n###\n\n.normarg_totalsize <- function(totalsize)\n{\n    if (!isSingleNumber(totalsize))\n        stop(\"'totalsize' must be a single integer\")\n    if (!is.integer(totalsize))\n        totalsize <- as.integer(totalsize)\n    if (totalsize < 0L)\n        stop(\"'totalsize' cannot be negative\")\n    totalsize\n}\n\n.normarg_nchunk_or_chunksize <- function(nchunk, totalsize, what)\n{\n    if (!isSingleNumber(nchunk))\n        stop(\"'\", what, \"' must be a single integer\")\n    if (!is.integer(nchunk))\n        nchunk <- as.integer(nchunk)\n    if (nchunk < 0L)\n        stop(\"'\", what, \"' cannot be negative\")\n    if (nchunk == 0L && totalsize != 0L)\n        stop(\"'\", what, \"' can be 0 only if 'totalsize' is 0\")\n    nchunk\n}\n\nbreakInChunks <- function(totalsize, nchunk, chunksize)\n{\n    totalsize <- .normarg_totalsize(totalsize)\n    if (!missing(nchunk)) {\n        if (!missing(chunksize))\n            stop(\"only one of 'nchunk' or 'chunksize' can be specified\")\n        ## All chunks will have more or less the same size, with the difference\n        ## between smallest and biggest chunks guaranteed to be <= 1.\n        nchunk <- .normarg_nchunk_or_chunksize(nchunk, totalsize,\n                                               \"nchunk\")\n        if (nchunk == 0L)\n            return(PartitioningByEnd())\n        chunksize <- totalsize / nchunk  # floating point division\n        breakpoints <- as.integer(cumsum(rep.int(chunksize, nchunk)))\n        ## The last value in 'breakpoints' *should* be 'totalsize' but there is\n        ## always some uncertainty about what coercing the result of a floating\n        ## point operation to integer will produce. So we set this value\n        ## manually to 'totalsize' just in case.\n        breakpoints[[nchunk]] <- totalsize\n    } else {\n        if (missing(chunksize))\n            stop(\"one of 'nchunk' or 'chunksize' must be specified\")\n        ## All chunks will have the requested size, except maybe the last one.\n        chunksize <- .normarg_nchunk_or_chunksize(chunksize, totalsize,\n                                                  \"chunksize\")\n        if (totalsize == 0L)\n            return(PartitioningByEnd())\n        quot <- totalsize %/% chunksize  # integer division\n        breakpoints <- cumsum(rep.int(chunksize, quot))\n        if (quot == 0L || breakpoints[[quot]] != totalsize)\n            breakpoints <- c(breakpoints, totalsize)\n    }\n    PartitioningByEnd(breakpoints)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"centeredIRanges\" function.\n###\n\ncenteredIRanges <- function(center, flank)\n{\n    if (!is.numeric(center))\n        stop(\"'center' must be a numeric vector\")\n    if (!is.numeric(flank))\n        stop(\"'flank' must be a numeric vector\")\n    IRanges(start=center-flank, end=center+flank)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"whichAsIRanges\" function.\n###\n### Note that unlike the standard which() function, whichAsIRanges() drops\n### the names of 'x'.\n###\n\nwhichAsIRanges <- function(x)\n{\n    if (!is.logical(x))\n        stop(\"'x' must be a logical vector\")\n    as(x, \"NormalIRanges\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercing an IRanges object to a NormalIRanges object.\n###\n\nasNormalIRanges <- function(x, force=TRUE)\n{\n    if (!is(x, \"IntegerRanges\"))\n        stop(\"'x' must be an IntegerRanges object\")\n    else if (!is(x, \"IRanges\"))\n        x <- as(x, \"IRanges\")\n    if (!isTRUEorFALSE(force))\n        stop(\"'force' must be TRUE or FALSE\")\n    if (force)\n        x <- reduce(x, drop.empty.ranges=TRUE)\n    newNormalIRangesFromIRanges(x, check=!force)\n}\n\n.asNormalIRanges <- function(from) asNormalIRanges(from, force=TRUE)\n\nsetAs(\"IRanges\", \"NormalIRanges\", .asNormalIRanges)\n\n",
        "IRangesList-class.R": "### =========================================================================\n### IRangesList objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### IRangesList\n###\n\nsetClass(\"IRangesList\",\n    contains=\"IntegerRangesList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"IRanges\")\n)\n\nsetClass(\"SimpleIRangesList\",\n    contains=c(\"IRangesList\", \"SimpleIntegerRangesList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### NormalIRangesList\n###\n\nsetClass(\"NormalIRangesList\",\n    contains=\"IRangesList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"NormalIRanges\")\n)\n\nsetClass(\"SimpleNormalIRangesList\",\n     contains=c(\"NormalIRangesList\", \"SimpleIRangesList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.NormalIRangesList <- function(x)\n{\n  if (!all(isNormal(x)))\n    return(\"at least one element of object is not normal\")\n  NULL\n}\n\nsetValidity2(\"NormalIRangesList\", .valid.NormalIRangesList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from list-like object to SimpleIRangesList\n###\n\n### Try to turn an arbitrary list-like object into an ordinary list of\n### IRanges objects.\nas_list_of_IRanges <- function(from)\n{\n    if (is(from, \"IntegerRanges\")) {\n        if (!is(from, \"IRanges\"))\n            from <- as(from, \"IRanges\", strict=FALSE)\n        along_idx <- setNames(seq_along(from), names(from))\n        names(from) <- NULL\n        mcols(from) <- NULL\n        lapply(along_idx, function(i) from[i])\n    } else {\n        lapply(from, as, \"IRanges\", strict=FALSE)\n    }\n}\n\n### From ordinary list to SimpleIRangesList\n\n.from_list_to_SimpleIRangesList <- function(from)\n{\n    from <- as_list_of_IRanges(from)\n    S4Vectors:::new_SimpleList_from_list(\"SimpleIRangesList\", from)\n}\n\nsetAs(\"list\", \"SimpleIRangesList\", .from_list_to_SimpleIRangesList)\nsetAs(\"list\", \"IRangesList\", .from_list_to_SimpleIRangesList)\n\n### From List derivative to SimpleIRangesList\n\n.from_List_to_SimpleIRangesList <- function(from)\n{\n    S4Vectors:::new_SimpleList_from_list(\"SimpleIRangesList\",\n                               as_list_of_IRanges(from),\n                               metadata=metadata(from),\n                               mcols=mcols(from, use.names=FALSE))\n}\n\nsetAs(\"List\", \"SimpleIRangesList\", .from_List_to_SimpleIRangesList)\n\n### Automatic coercion methods from SimpleList, IntegerRangesList, or\n### SimpleIntegerRangesList to SimpleIRangesList silently return a broken\n### object (unfortunately these dummy automatic coercion methods don't bother\n### to validate the object they return). So we overwrite them.\nsetAs(\"SimpleList\", \"SimpleIRangesList\",\n      .from_List_to_SimpleIRangesList)\nsetAs(\"IntegerRangesList\", \"SimpleIRangesList\",\n      .from_List_to_SimpleIRangesList)\nsetAs(\"SimpleIntegerRangesList\", \"SimpleIRangesList\",\n      .from_List_to_SimpleIRangesList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isNormal()\n###\n\nsetMethod(\"isNormal\", \"SimpleIRangesList\",\n    function(x, use.names=FALSE)\n        .Call2(\"C_isNormal_SimpleIRangesList\", x, use.names,\n                                               PACKAGE=\"IRanges\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nIRangesList <- function(..., compress=TRUE)\n{\n    if (!isTRUEorFALSE(compress))\n        stop(\"'compress' must be TRUE or FALSE\")\n    objects <- list(...)\n    if (length(objects) == 2L &&\n        setequal(names(objects), c(\"start\", \"end\")) &&\n        !is(objects[[1L]], \"IntegerRanges\") &&\n        !is(objects[[2L]], \"IntegerRanges\"))\n    {\n        if (!compress)\n            stop(wmsg(\"'compress' must be TRUE when passing the 'start' \",\n                      \"and 'end' arguments\"))\n        ans_start <- IntegerList(objects[[\"start\"]], compress=TRUE)\n        ans_end <- IntegerList(objects[[\"end\"]], compress=TRUE)\n        ans_partitioning <- PartitioningByEnd(ans_start)\n        if (!identical(ans_partitioning, PartitioningByEnd(ans_end)))\n            stop(\"'start' and 'end' are not compatible\")\n        unlisted_start <- unlist(ans_start, use.names=FALSE)\n        unlisted_end <- unlist(ans_end, use.names=FALSE)\n        unlisted_ans <- IRanges(start=unlisted_start, end=unlisted_end)\n        return(relist(unlisted_ans, ans_partitioning))\n    }\n    if (length(objects) == 1L) {\n        tmp <- objects[[1L]]\n        if (is.list(tmp) || (is(tmp, \"List\") && !is(tmp, \"IntegerRanges\")))\n            objects <- tmp\n    }\n    if (compress)\n        as(objects, \"CompressedIRangesList\")\n    else\n        as(objects, \"SimpleIRangesList\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### More coercions\n###\n\nsetMethod(\"unlist\", \"SimpleNormalIRangesList\",\n          function(x, recursive = TRUE, use.names = TRUE)\n          {\n            x <- S4Vectors:::new_SimpleList_from_list(\"SimpleIRangesList\",\n                                                      lapply(x, as, \"IRanges\"))\n            callGeneric()\n          })\n\n### Coercion from IntegerRangesList to NormalIRangesList.\n\n.from_IntegerRangesList_to_SimpleNormalIRangesList <- function(from)\n{\n    S4Vectors:::new_SimpleList_from_list(\"SimpleNormalIRangesList\",\n                               lapply(from, as, \"NormalIRanges\"),\n                               mcols=mcols(from, use.names=FALSE),\n                               metadata=metadata(from))\n}\n\nsetAs(\"IntegerRangesList\", \"SimpleNormalIRangesList\",\n    .from_IntegerRangesList_to_SimpleNormalIRangesList\n)\n\nsetAs(\"SimpleIRangesList\", \"SimpleNormalIRangesList\",\n    .from_IntegerRangesList_to_SimpleNormalIRangesList\n)\n\nsetAs(\"LogicalList\", \"SimpleNormalIRangesList\",\n      function(from)\n      S4Vectors:::new_SimpleList_from_list(\"SimpleNormalIRangesList\",\n                                 lapply(from, as, \"NormalIRanges\"),\n                                 metadata = metadata(from),\n                                 mcols = mcols(from, use.names=FALSE)))\n\n### Coercion from RleList to NormalIRangesList.\n\nsetAs(\"RleList\", \"SimpleNormalIRangesList\",\n      function(from)\n      {\n        if ((length(from) > 0) &&\n            (!is.logical(runValue(from[[1L]])) ||\n             S4Vectors:::anyMissing(runValue(from[[1L]]))))\n          stop(\"cannot coerce a non-logical 'RleList' or a logical 'RleList' \",\n               \"with NAs to a SimpleNormalIRangesList object\")\n        S4Vectors:::new_SimpleList_from_list(\"SimpleNormalIRangesList\",\n                                   lapply(from, as, \"NormalIRanges\"),\n                                   metadata = metadata(from),\n                                   mcols = mcols(from, use.names=FALSE))\n      })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"max\" and \"min\" methods for NormalIRangesList objects.\n###\n\nsetMethod(\"max\", \"SimpleNormalIRangesList\",\n    function(x, ..., na.rm)\n        .Call2(\"C_max_SimpleNormalIRangesList\", x, PACKAGE=\"IRanges\")\n)\n\nsetMethod(\"min\", \"SimpleNormalIRangesList\",\n    function(x, ..., na.rm)\n        .Call2(\"C_min_SimpleNormalIRangesList\", x, PACKAGE=\"IRanges\")\n)\n\n",
        "IntegerRangesList-class.R": "### =========================================================================\n### IntegerRangesList objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\nsetGeneric(\".replaceSEW\", signature=\"x\",  # not exported\n    function(x, FUN, ..., value) standardGeneric(\".replaceSEW\")\n)\n\nsetMethod(\".replaceSEW\", \"IntegerRangesList\",\n    function(x, FUN, ..., value)\n    {\n        if (extends(class(value), \"IntegerList\")) {\n            value <- S4Vectors:::VH_recycle(value, x, \".replaceSEW\", \"x\")\n        } else if (is.numeric(value)) {\n            lelts <- sum(elementNROWS(x))\n            if (lelts != length(value))\n                value <- rep(value, length.out = lelts)\n            if (!is.integer(value))\n                value <- as.integer(value)\n            value <- split(value, factor(space(x), names(x)))\n        } else {\n            stop(\"'value' must extend class IntegerList or integer\")\n        }\n        FUN <- match.fun(FUN)\n        if (is(x, \"CompressedRangesList\")) {\n            unlist_ans <- FUN(unlist(x, use.names=FALSE), ...,\n                              value=unlist(value, use.names=FALSE))\n            return(relist(unlist_ans, x))\n        }\n        for (i in seq_len(length(x)))\n            x[[i]] <- FUN(x[[i]], ..., value = value[[i]])\n        x\n    }\n)\n\nsetReplaceMethod(\"start\", \"IntegerRangesList\",\n    function(x, ..., value) .replaceSEW(x, \"start<-\", ..., value=value)\n)\n\nsetReplaceMethod(\"end\", \"IntegerRangesList\",\n    function(x, ..., value) .replaceSEW(x, \"end<-\", ..., value=value)\n)\n\nsetReplaceMethod(\"width\", \"IntegerRangesList\",\n    function(x, ..., value) .replaceSEW(x, \"width<-\", ..., value=value)\n)\n\nsetMethod(\"space\", \"IntegerRangesList\",\n          function(x)\n          {\n            space <- names(x)\n            if (!is.null(space))\n              space <- factor(rep.int(space, elementNROWS(x)), unique(space))\n            space\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isNormal()\n###\n### Test the list elements of an IntegerRangesList object 'x' individually and\n### return a vector of TRUE's or FALSE's parallel to 'x'. More precisely, is\n### equivalent to 'sapply(x, FUN)', when FUN is 'isNormal'.\n###\n\nsetMethod(\"isNormal\", \"IntegerRangesList\",\n    function(x, use.names=FALSE)\n        vapply(x, isNormal, logical(1), USE.NAMES=use.names)\n)\n\nsetMethod(\"whichFirstNotNormal\", \"IntegerRangesList\",\n    function(x) unlist(lapply(x, whichFirstNotNormal))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\n### NOT exported but used in the Biostrings package.\nshow_IntegerRangesList <- function(x, with.header=TRUE)\n{\n    x_len <- length(x)\n    if (with.header)\n        cat(classNameForDisplay(x), \" object of length \", x_len,\n            if (x_len != 0L) \":\" else \"\", \"\\n\", sep=\"\")\n    cumsumN <- end(PartitioningByEnd(x))\n    N <- tail(cumsumN, 1)\n    if (x_len == 0L) {\n        ## Display nothing.\n    } else if (x_len <= 3L || (x_len <= 5L && N <= 20L)) {\n        ## Display full object.\n        show(as.list(x))\n    } else {\n        ## Display truncated object.\n        if (cumsumN[[3L]] <= 20L) {\n            showK <- 3L\n        } else if (cumsumN[[2L]] <= 20L) {\n            showK <- 2L\n        } else {\n            showK <- 1L\n        }\n        show(as.list(x[seq_len(showK)]))\n        diffK <- x_len - showK\n        cat(\"...\\n\",\n            \"<\", diffK, \" more element\",\n            ifelse(diffK == 1L, \"\", \"s\"), \">\\n\",\n            sep=\"\")\n    }\n}\n\nsetMethod(\"show\", \"IntegerRangesList\",\n    function(object) show_IntegerRangesList(object)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### merge()\n###\n\n### Merges various IntegerRangesList objects into a single IntegerRangesList\n### object. The merging is either by name (if all the IntegerRangesList\n### objects have names), or by position (if any IntegerRangesList object is\n### missing names). When merging by name, and in case of duplicated names\n### within a given IntegerRangesList, the elements corresponding to the\n### duplicated names are ignored.\n### When merging by position, all the IntegerRangesList objects must have the\n### same length.\n### Note that the \"range\" method for IntegerRangesList objects expects \"merge\"\n### to behave like this.  \n.merge_IntegerRangesList <- function(...)\n{\n    args <- unname(list(...))\n    if (length(args) == 0L)\n        stop(\"nothing to merge\")\n    x <- args[[1L]]\n    spaceList <- lapply(args, names)\n    names <- spaces <- unique(do.call(c, spaceList))\n    if (any(S4Vectors:::sapply_isNULL(spaceList))) {\n        ## Merging by position.\n        if (!all(unlist(lapply(args, length)) == length(x)))\n            stop(\"if any IntegerRangesList objects to merge are missing \",\n                 \"names, all must have same length\")\n        names <- NULL\n        spaces <- seq_len(length(x))\n    }\n    ranges <- lapply(spaces,\n                     function(space) {\n                       r <- lapply(args, `[[`, space)\n                       do.call(c, S4Vectors:::delete_NULLs(r))\n                     })\n    names(ranges) <- names\n    if (is(x, \"CompressedList\"))\n      ans <- new_CompressedList_from_list(class(x), ranges)\n    else\n      ans <- S4Vectors:::new_SimpleList_from_list(class(x), ranges)\n    ans\n}\n\nsetMethod(\"merge\", c(\"IntegerRangesList\", \"missing\"),\n    function(x, y, ...) .merge_IntegerRangesList(x, ...)\n)\n\nsetMethod(\"merge\", c(\"missing\", \"IntegerRangesList\"),\n    function(x, y, ...) .merge_IntegerRangesList(y, ...)\n)\n\nsetMethod(\"merge\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n    function(x, y, ...) .merge_IntegerRangesList(x, y, ...)\n)\n\n",
        "MaskCollection-class.R": "### =========================================================================\n### MaskCollection objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"MaskCollection\",\n    contains=\"IntegerRangesList\",\n    representation(\n        nir_list=\"list\",    # a list of NormalIRanges objects\n        width=\"integer\",\n        active=\"logical\",\n        NAMES=\"character\",  # R doesn't like @names !!\n        desc=\"character\"\n    ),\n    prototype(\n        nir_list=list(),\n        width=0L,\n        active=logical(0),\n        NAMES=as.character(NA),\n        desc=as.character(NA)\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"length\" and accessor methods.\n###\n\nsetGeneric(\"nir_list\", function(x) standardGeneric(\"nir_list\"))\n\nsetMethod(\"nir_list\", \"MaskCollection\", function(x) x@nir_list)\n\nsetMethod(\"length\", \"MaskCollection\", function(x) length(nir_list(x)))\n\nsetMethod(\"width\", \"MaskCollection\", function(x) x@width)\n\nsetMethod(\"active\", \"MaskCollection\",\n    function(x)\n    {\n        ans <- x@active\n        names(ans) <- names(x)\n        ans\n    }\n)\n\nsetReplaceMethod(\"active\", \"MaskCollection\",\n    function(x, value)\n    {\n        if (!is.logical(value) || S4Vectors:::anyMissing(value))\n            stop(\"'value' must be a logical vector with no NAs\")\n        x@active[] <- value\n        x\n    }\n)\n\nsetMethod(\"names\", \"MaskCollection\",\n    function(x) if (length(x@NAMES) == 1 && is.na(x@NAMES)) NULL else x@NAMES\n)\n\nsetReplaceMethod(\"names\", \"MaskCollection\",\n    function(x, value)\n    {\n        if (is.null(value)) {\n            x@NAMES <- NA_character_\n            return(x)\n        }\n        value <- as.character(value)\n        ii <- is.na(value)\n        if (any(ii))\n            value[ii] <- \"\"\n        if (length(value) > length(x))\n            stop(\"too many names\")\n        if (length(value) < length(x))\n            value <- c(value, character(length(x) - length(value)))\n        x@NAMES <- value\n        x\n    }\n)\n\nsetGeneric(\"desc\", function(x) standardGeneric(\"desc\"))\n\nsetMethod(\"desc\", \"MaskCollection\",\n    function(x) if (length(x@desc) == 1 && is.na(x@desc)) NULL else x@desc\n)\n\nsetGeneric(\"desc<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"desc<-\")\n)\n\nsetReplaceMethod(\"desc\", \"MaskCollection\",\n    function(x, value)\n    {\n        if (is.null(value)) {\n            x@desc <- as.character(NA)\n            return(x)\n        }\n        if (!is.character(value))\n            stop(\"'value' must be NULL or a character vector\")\n        ii <- is.na(value)\n        if (any(ii))\n            value[ii] <- \"\"\n        if (length(value) > length(x))\n            stop(\"too many names\")\n        if (length(value) < length(x))\n            value <- c(value, character(length(x) - length(value)))\n        x@desc <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.MaskCollection.width <- function(x)\n{\n    if (!isSingleInteger(width(x)) || width(x) < 0)\n        return(\"the width of the collection must be a single non-negative integer\")\n    NULL\n}\n\n.valid.MaskCollection.nir_list <- function(x)\n{\n    if (!is.list(nir_list(x))\n     || !all(sapply(nir_list(x), function(nir) is(nir, \"NormalIRanges\"))))\n        return(\"the 'nir_list' slot must contain a list of NormalIRanges objects\")\n    if (!all(1 <= min(x)) || !all(max(x) <= width(x)))\n        return(\"the min and max of the masks must be >= 1 and <= width of the collection\")\n    NULL\n}\n\n.valid.MaskCollection.active <- function(x)\n{\n    if (!is.logical(active(x)) || S4Vectors:::anyMissing(active(x)))\n        return(\"the 'active' slot must be a logical vector with no NAs\")\n    if (length(active(x)) != length(x))\n        return(\"the length of the 'active' slot differs from the length of the object\")\n    NULL\n}\n\n.valid.MaskCollection.names <- function(x)\n{\n    if (S4Vectors:::anyMissing(names(x)))\n        return(\"the names must be non-NA strings\")\n    NULL\n}\n\n.valid.MaskCollection.desc <- function(x)\n{\n    if (!is.character(x@desc))\n        return(\"the 'desc' slot must contain a character vector\")\n    if (is.null(desc(x)))\n        return(NULL)\n    if (S4Vectors:::anyMissing(desc(x)))\n        return(\"the descriptions must be non-NA strings\")\n    if (length(desc(x)) != length(x))\n        return(\"number of descriptions and number of elements differ\")\n    NULL\n}\n\n.valid.MaskCollection <- function(x)\n{\n    ## The 'width' slot needs to be checked separately and we must return\n    ## if it's invalid. This is because .valid.MaskCollection.nir_list()\n    ## won't work properly if 'x@width' is NA.\n    problems <- .valid.MaskCollection.width(x)\n    if (!is.null(problems))\n        return(problems)\n    c(.valid.MaskCollection.nir_list(x),\n      .valid.MaskCollection.active(x),\n      .valid.MaskCollection.names(x),\n      .valid.MaskCollection.desc(x))\n}\n\nsetValidity2(\"MaskCollection\", .valid.MaskCollection)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The safe and user-friendly \"Mask\" constructor.\n###\n\nMask <- function(mask.width, start=NULL, end=NULL, width=NULL)\n{\n    nir <- asNormalIRanges(IRanges(start=start, end=end, width=width), force=FALSE)\n    new2(\"MaskCollection\", nir_list=list(nir),\n                           width=S4Vectors:::numeric2integer(mask.width),\n                           active=TRUE, check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"max\" and \"min\" methods.\n###\n\nsetMethod(\"max\", \"MaskCollection\",\n    function(x, ..., na.rm)\n    {\n        if (length(x) == 0)\n            return(integer(0))\n        sapply(nir_list(x), max)\n    }\n)\n\nsetMethod(\"min\", \"MaskCollection\",\n    function(x, ..., na.rm)\n    {\n        if (length(x) == 0)\n            return(integer(0))\n        sapply(nir_list(x), min)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"maskedwidth\" and \"maskedratio\" generics and methods.\n###\n\nsetGeneric(\"maskedwidth\", function(x) standardGeneric(\"maskedwidth\"))\nsetMethod(\"maskedwidth\", \"MaskCollection\",\n    function(x)\n    {\n        nir_list <- nir_list(x)\n        if (length(nir_list) == 0)\n            integer(0)\n        else\n            sapply(nir_list, function(nir) sum(width(nir)))\n    }\n)\n\nsetGeneric(\"maskedratio\", function(x) standardGeneric(\"maskedratio\"))\nsetMethod(\"maskedratio\", \"MaskCollection\", function(x) maskedwidth(x) / width(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting.\n###\n\nsetMethod(\"getListElement\", \"MaskCollection\",\n    function(x, i, exact=TRUE)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x, exact=exact)\n        nir_list(x)[[i]]\n    }\n)\n\n### Always behaves like an endomorphism (i.e. ignores the 'drop' argument and\n### behaves like if it was actually set to FALSE).\nsetMethod(\"extractROWS\", \"MaskCollection\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        if (anyDuplicated(i))\n            stop(\"subscript would generate duplicated elements\")\n        slot(x, \"nir_list\", check=FALSE) <- extractROWS(nir_list(x), i)\n        slot(x, \"active\", check=FALSE) <- extractROWS(active(x), i)\n        if (!is.null(names(x)))\n            slot(x, \"NAMES\", check=FALSE) <- extractROWS(names(x), i)\n        if (!is.null(desc(x)))\n            slot(x, \"desc\", check=FALSE) <- extractROWS(desc(x), i)\n        mcols(x) <- extractROWS(mcols(x, use.names=FALSE), i)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"append\" method.\n###\n### TODO: Be more consistent with \"[\" which doesn't allow subscripts with\n### duplicated positive values in order to make it harder for the user to\n### produce a MaskCollection object with duplicated names.\n### The \"append\" method below makes this too easy (with append(x, x)).\n###\n\n.append.names.or.desc <- function(nm1, l1, nm2, l2, after)\n{\n    if (is.null(nm1) && is.null(nm2))\n        return(as.character(NA))\n    if (is.null(nm1))\n        nm1 <- rep.int(\"\", l1)\n    if (is.null(nm2))\n        nm2 <- rep.int(\"\", l2)\n    append(nm1, nm2, after=after)\n}\n\nsetMethod(\"append\", c(\"MaskCollection\", \"MaskCollection\"),\n    function(x, values, after=length(x))\n    {\n        if (width(values) != width(x))\n            stop(\"'x' and 'values' must have the same width\")\n        if (!isSingleNumber(after))\n            stop(\"'after' must be a single number\")\n        if (length(values) == 0)\n            return(x)\n        ans_nir_list <- append(nir_list(x), nir_list(values), after=after)\n        ans_active <- append(active(x), active(values), after=after)\n        l1 <- length(x)\n        l2 <- length(values)\n        ans_NAMES <- .append.names.or.desc(names(x), l1, names(values), l2, after)\n        ans_desc <- .append.names.or.desc(desc(x), l1, desc(values), l2, after)\n        ## This transformation must be atomic.\n        x@nir_list <- ans_nir_list\n        x@active <- ans_active\n        x@NAMES <- ans_NAMES\n        x@desc <- ans_desc\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### collapse()\n###\n\nsetGeneric(\"collapse\", function(x) standardGeneric(\"collapse\"))\n\n### Always return a MaskCollection object of length 1 where the mask is active.\nsetMethod(\"collapse\", \"MaskCollection\",\n    function(x)\n    {\n        keep_it <- active(x)\n        if (!all(keep_it))\n            x <- x[keep_it]\n        if (length(x) == 1)\n            return(x)\n        nir_list <- nir_list(x)\n        if (length(nir_list) == 0) {\n            nir1 <- new(\"NormalIRanges\")\n        } else {\n            start1 <- unlist(lapply(nir_list, start))\n            width1 <- unlist(lapply(nir_list, width))\n            ranges <- new2(\"IRanges\", start=start1, width=width1, check=FALSE)\n            nir1 <- asNormalIRanges(ranges, force=TRUE)\n        }\n        ## This transformation must be atomic.\n        x@nir_list <- list(nir1)\n        x@active <- TRUE\n        x@NAMES <- as.character(NA)\n        x@desc <- as.character(NA)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### From a MaskCollection object to a NormalIRanges object.\nsetAs(\"MaskCollection\", \"NormalIRanges\",\n    function(from) collapse(from)[[1L]]\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\nMaskCollection.show_frame <- function(x)\n{\n    lx <- length(x)\n    cat(\"masks:\")\n    if (lx == 0) {\n        cat(\" NONE\\n\")\n    } else {\n        cat(\"\\n\")\n        ## Explictely specify 'row.names=NULL' otherwise data.frame() will\n        ## try to use the names of the first component that has suitable\n        ## names, which could be 'active(x)' (3rd component) if 'x' has names.\n        frame <- data.frame(maskedwidth=maskedwidth(x),\n                            maskedratio=maskedratio(x),\n                            active=active(x),\n                            row.names=NULL,\n                            check.names=FALSE)\n        frame$names <- names(x)\n        frame$desc <- desc(x)\n        show(frame)\n        if (lx >= 2) {\n            margin <- format(\"\", width=nchar(as.character(lx)))\n            cat(\"all masks together:\\n\")\n            mask0 <- collapse(`active<-`(x, TRUE))\n            frame <- data.frame(maskedwidth=maskedwidth(mask0),\n                                maskedratio=maskedratio(mask0),\n                                check.names=FALSE)\n            row.names(frame) <- margin\n            show(frame)\n            if (sum(active(x)) < lx) {\n                cat(\"all active masks together:\\n\")\n                mask1 <- collapse(x)\n                frame <- data.frame(maskedwidth=maskedwidth(mask1),\n                                    maskedratio=maskedratio(mask1),\n                                    check.names=FALSE)\n                row.names(frame) <- margin\n                show(frame)\n            }\n        }\n    }\n}\n\nsetMethod(\"show\", \"MaskCollection\",\n    function(object)\n    {\n        lo <- length(object)\n        cat(class(object), \" of length \", lo,\n            \" and width \", width(object), \"\\n\", sep=\"\")\n        MaskCollection.show_frame(object)\n    }\n)\n\n",
        "NCList-class.R": "### =========================================================================\n### NCList and NCLists objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### An S4 implementation of Nested Containment List (NCList).\n###\n\n### We deliberately do NOT extend IRanges.\nsetClass(\"NCList\",\n    contains=\"IPosRanges\",\n    representation(\n        nclist=\"integer\",\n        ranges=\"IRanges\"\n    )\n)\n\nsetMethod(\"length\", \"NCList\", function(x) length(x@ranges))\nsetMethod(\"names\", \"NCList\", function(x) names(x@ranges))\nsetMethod(\"start\", \"NCList\", function(x, ...) start(x@ranges))\nsetMethod(\"end\", \"NCList\", function(x, ...) end(x@ranges))\nsetMethod(\"width\", \"NCList\", function(x) width(x@ranges))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .shift_ranges_to_first_circle() and\n### .shift_ranges_in_groups_to_first_circle()\n###\n### TODO: Move to intra-range-methods.R, rename (e.g. shiftToFirstCircle()),\n### make it a generic with methods for IRanges and IRangesList, export, and\n### document.\n###\n\n### Returns a single integer.\n.normarg_circle.length1 <- function(circle.length)\n{\n    msg <- \"'circle.length' must be a single positive integer or NA\"\n    if (!isSingleNumberOrNA(circle.length))\n        stop(msg)\n    if (!is.integer(circle.length))\n        circle.length <- as.integer(circle.length)\n    if (!is.na(circle.length) && circle.length <= 0L)\n        stop(msg)\n    circle.length\n}\n\n### Returns an integer vector of length 'x_len'.\n.normarg_circle.length2 <- function(circle.length, x_len, what)\n{\n    msg <- c(\"'circle.length' must be an integer vector \",\n             \"with positive or NA values\")\n    if (!is.atomic(circle.length))\n        stop(msg)\n    if (!(length(circle.length) == 1L || length(circle.length) == x_len))\n        stop(\"'circle.length' must have length 1 or length of \", what)\n    all_NAs <- all(is.na(circle.length))\n    if (!(all_NAs || is.numeric(circle.length)))\n        stop(msg)\n    if (!is.integer(circle.length))\n        circle.length <- as.integer(circle.length)\n    if (!all_NAs && min(circle.length, na.rm=TRUE) <= 0L)\n        stop(msg)\n    if (length(circle.length) == x_len)\n        return(circle.length)\n    rep.int(circle.length, x_len)\n}\n\n### 'circle.length' assumed to have length 1 or length of 'x'.\n.shift_ranges_to_first_circle <- function(x, circle.length)\n{\n    if (all(is.na(circle.length)))\n        return(x)\n    x_start0 <- start(x) - 1L  # 0-based start\n    x_shift0 <- x_start0 %% circle.length - x_start0\n    x_shift0[is.na(x_shift0)] <- 0L\n    shift(x, x_shift0)\n}\n\n### 'length(circle.length)' assumed to be >= 'length(x_groups)'.\n.shift_ranges_in_groups_to_first_circle <- function(x, x_groups, circle.length)\n{\n    circle.length <- head(circle.length, n=length(x_groups))\n    if (all(is.na(circle.length)))\n        return(x)\n    unlisted_groups <- unlist(x_groups, use.names=FALSE)\n    circle_len <- rep.int(NA_integer_, length(x))\n    circle_len[unlisted_groups + 1L] <-\n        rep.int(circle.length, elementNROWS(x_groups))\n    .shift_ranges_to_first_circle(x, circle_len)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### NCList constructor\n###\n\n### Returns an external pointer to the NCList C struct.\n.NCList_xp <- function(x_start, x_end, x_subset)\n{\n    ans <- .Call2(\"C_new_NCList\", PACKAGE=\"IRanges\")\n    reg.finalizer(ans,\n        function(e) .Call(\"C_free_NCList\", e, PACKAGE=\"IRanges\")\n    )\n    .Call2(\"C_build_NCList\", ans, x_start, x_end, x_subset, PACKAGE=\"IRanges\")\n}\n\n.nclist <- function(x_start, x_end, x_subset=NULL)\n{\n    nclist_xp <- .NCList_xp(x_start, x_end, x_subset)\n    .Call2(\"C_new_NCListAsINTSXP_from_NCList\", nclist_xp, PACKAGE=\"IRanges\")\n}\n\nNCList <- function(x, circle.length=NA_integer_)\n{\n    if (!is(x, \"IntegerRanges\"))\n        stop(\"'x' must be an IntegerRanges object\")\n    if (!is(x, \"IRanges\"))\n        x <- as(x, \"IRanges\")\n    ans_mcols <- mcols(x, use.names=FALSE)\n    mcols(x) <- NULL\n    circle.length <- .normarg_circle.length1(circle.length)\n    x <- .shift_ranges_to_first_circle(x, circle.length)\n    x_nclist <- .nclist(start(x), end(x))\n    new2(\"NCList\", nclist=x_nclist,\n                   ranges=x,\n                   elementMetadata=ans_mcols,\n                   check=FALSE)\n}\n\n### NOT exported.\nprint_NCList <- function(x)\n{\n    if (!is(x, \"NCList\"))\n        stop(\"'x' must be an NCList object\")\n    .Call2(\"C_print_NCListAsINTSXP\", x@nclist, start(x@ranges), end(x@ranges),\n                                     PACKAGE=\"IRanges\")\n    invisible(NULL)\n}\n\nsetAs(\"IntegerRanges\", \"NCList\", function(from) NCList(from))\n\n### Inefficient because it rebuilds a new NCList object from scratch for the\n### selected ranges. Supported for completeness only!\nsetMethod(\"extractROWS\", c(\"NCList\", \"ANY\"),\n    function(x, i)\n    {\n        x_class <- class(x)\n        x <- as(x, \"IRanges\")\n        as(callGeneric(), x_class)\n    }\n)\n\n### Inefficient because it rebuilds a new NCList object from scratch for the\n### concatenated ranges. Supported for completeness only!\nsetMethod(\"bindROWS\", \"NCList\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        x_class <- class(x)\n        x <- as(x, \"IRanges\")\n        as(callGeneric(), x_class)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### findOverlaps_NCList()\n###\n\n### NOT exported.\nfindOverlaps_NCList <- function(query, subject,\n             maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"extend\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\", \"count\"),\n             circle.length=NA_integer_)\n{\n    if (!(is(query, \"IntegerRanges\") && is(subject, \"IntegerRanges\")))\n        stop(\"'query' and 'subject' must be IntegerRanges objects\")\n\n    if (!isSingleNumber(maxgap))\n        stop(\"'maxgap' must be a single integer\")\n    if (!is.integer(maxgap))\n        maxgap <- as.integer(maxgap)\n\n    if (!isSingleNumber(minoverlap))\n        stop(\"'minoverlap' must be a single integer\")\n    if (!is.integer(minoverlap))\n        minoverlap <- as.integer(minoverlap)\n\n    type <- match.arg(type)\n    select <- match.arg(select)\n    circle.length <- .normarg_circle.length1(circle.length)\n\n    if (is(subject, \"NCList\")) {\n        nclist <- subject@nclist\n        nclist_is_q <- FALSE\n        query <- .shift_ranges_to_first_circle(query, circle.length)\n    } else if (is(query, \"NCList\")) {\n        nclist <- query@nclist\n        nclist_is_q <- TRUE\n        subject <- .shift_ranges_to_first_circle(subject, circle.length)\n    } else {\n        ## We'll do \"on-the-fly preprocessing\".\n        nclist <- NULL\n        nclist_is_q <- NA\n        query <- .shift_ranges_to_first_circle(query, circle.length)\n        subject <- .shift_ranges_to_first_circle(subject, circle.length)\n    }\n    .Call2(\"C_find_overlaps_NCList\",\n           start(query), end(query),\n           start(subject), end(subject),\n           nclist, nclist_is_q,\n           maxgap, minoverlap, type, select, circle.length,\n           PACKAGE=\"IRanges\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Representation of a list of NCList objects\n###\n\nsetClass(\"NCLists\",\n    contains=\"IntegerRangesList\",\n    representation(\n        nclists=\"list\",\n        rglist=\"CompressedIRangesList\"\n    ),\n    prototype(\n        elementType=\"NCList\"\n    )\n)\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"NCLists\",\n    function(x) c(\"nclists\", \"rglist\", callNextMethod())\n)\n\n### TODO: Move rglist() generic from GenomicRanges to IRanges\n#setMethod(\"rglist\", \"NCLists\", function(x, ...) x@rglist)\n\nsetMethod(\"ranges\", \"NCLists\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(use.mcols))\n            stop(\"'use.mcols' must be TRUE or FALSE\")\n        ans <- x@rglist\n        if (!use.names)\n            names(ans) <- NULL\n        if (use.mcols)\n            mcols(ans) <- mcols(x, use.names=FALSE)\n        ans\n    }\n)\n\nsetMethod(\"length\", \"NCLists\", function(x) length(x@rglist))\nsetMethod(\"names\", \"NCLists\", function(x) names(x@rglist))\nsetMethod(\"start\", \"NCLists\", function(x, ...) start(x@rglist))\nsetMethod(\"end\", \"NCLists\", function(x, ...) end(x@rglist))\nsetMethod(\"width\", \"NCLists\", function(x) width(x@rglist))\n\nsetMethod(\"elementNROWS\", \"NCLists\", function(x) elementNROWS(x@rglist))\nsetMethod(\"getListElement\", \"NCLists\",\n    function (x, i, exact=TRUE)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x, exact=exact)\n        new2(\"NCList\", nclist=x@nclists[[i]], ranges=x@rglist[[i]],\n                       check=FALSE)\n    }\n)\n\nsetAs(\"NCLists\", \"CompressedIRangesList\",\n    function(from) ranges(from, use.mcols=TRUE)\n)\nsetAs(\"NCLists\", \"IRangesList\",\n    function(from) ranges(from, use.mcols=TRUE)\n)\n\n.extract_groups_from_RangesList <- function(x)\n{\n    x_partitioning <- PartitioningByEnd(x)\n    relist(unlist_as_integer(x_partitioning) - 1L, x_partitioning)\n}\n\n.nclists <- function(x, x_groups)\n{\n    x_start <- start(x)\n    x_end <- end(x)\n    lapply(x_groups, function(group) .nclist(x_start, x_end, x_subset=group))\n}\n\n### NCLists constructor.\nNCLists <- function(x, circle.length=NA_integer_)\n{\n    if (!is(x, \"IntegerRangesList\"))\n        stop(\"'x' must be an IntegerRangesList object\")\n    if (!is(x, \"CompressedIRangesList\"))\n        x <- as(x, \"CompressedIRangesList\")\n    ans_mcols <- mcols(x, use.names=FALSE)\n    mcols(x) <- NULL\n    unlisted_x <- unlist(x, use.names=FALSE)\n    x_groups <- .extract_groups_from_RangesList(x)\n    circle.length <- .normarg_circle.length2(circle.length, length(x_groups),\n                                             \"'x'\")\n    unlisted_x <- .shift_ranges_in_groups_to_first_circle(\n                                   unlisted_x,\n                                   x_groups,\n                                   circle.length)\n    x <- relist(unlisted_x, x)\n    x_nclists <- .nclists(unlisted_x, x_groups)\n    new2(\"NCLists\", nclists=x_nclists,\n                    rglist=x,\n                    elementMetadata=ans_mcols,\n                    check=FALSE)\n}\n\nsetAs(\"IntegerRangesList\", \"NCLists\", function(from) NCLists(from))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### find_overlaps_in_groups_NCList()\n###\n\n### NOT exported. Workhorse behind findOverlaps_NCLists() below and behind\n### GenomicRanges:::findOverlaps_GNCList().\nfind_overlaps_in_groups_NCList <- function(\n             q, q_space, q_groups,\n             s, s_space, s_groups,\n             nclists, nclist_is_q,\n             maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"extend\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\", \"count\"),\n             circle.length)\n{\n    if (!(is(q, \"IntegerRanges\") && is(s, \"IntegerRanges\")))\n        stop(\"'q' and 's' must be IntegerRanges object\")\n    if (!is(q_groups, \"CompressedIntegerList\"))\n        stop(\"'q_groups' must be a CompressedIntegerList object\")\n    if (!is(s_groups, \"CompressedIntegerList\"))\n        stop(\"'s_groups' must be a CompressedIntegerList object\")\n\n    if (!isSingleNumber(maxgap))\n        stop(\"'maxgap' must be a single integer\")\n    if (!is.integer(maxgap))\n        maxgap <- as.integer(maxgap)\n\n    if (!isSingleNumber(minoverlap))\n        stop(\"'minoverlap' must be a single integer\")\n    if (!is.integer(minoverlap))\n        minoverlap <- as.integer(minoverlap)\n\n    type <- match.arg(type)\n    select <- match.arg(select)\n\n    q_circle_len <- circle.length\n    q_circle_len[which(nclist_is_q)] <- NA_integer_\n    q <- .shift_ranges_in_groups_to_first_circle(q, q_groups, q_circle_len)\n    s_circle_len <- circle.length\n    s_circle_len[which(!nclist_is_q)] <- NA_integer_\n    s <- .shift_ranges_in_groups_to_first_circle(s, s_groups, s_circle_len)\n    .Call2(\"C_find_overlaps_in_groups_NCList\",\n           start(q), end(q), q_space, q_groups,\n           start(s), end(s), s_space, s_groups,\n           nclists, nclist_is_q,\n           maxgap, minoverlap, type, select, circle.length,\n           PACKAGE=\"IRanges\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### findOverlaps_NCLists()\n###\n\n.split_and_remap_hits <- function(all_hits, query, subject, select)\n{\n    ## Compute list element lengths and offsets for 'query'.\n    query_partitioning <- PartitioningByEnd(query)\n    query_eltNROWS <- width(query_partitioning)\n    query_offsets <- start(query_partitioning) - 1L\n\n    ## Compute list element lengths and offsets for 'subject'.\n    subject_partitioning <- PartitioningByEnd(subject)\n    subject_eltNROWS <- width(subject_partitioning)\n    subject_offsets <- start(subject_partitioning) - 1L\n\n    if (select != \"all\") {\n        ans <- head(relist(all_hits, query), n=length(subject))\n        if (select != \"count\")\n            ans <- ans - head(subject_offsets, n=length(ans))\n        return(ans)\n    }\n\n    q_hits <- queryHits(all_hits)\n    query_breakpoints <- end(query_partitioning)\n    h_skeleton <- PartitioningByEnd(findInterval(query_breakpoints, q_hits))\n    lapply(seq_len(min(length(query), length(subject))),\n           function(i) {\n               hits <- all_hits[h_skeleton[[i]]]\n               hits@from <- hits@from - query_offsets[[i]]\n               hits@to <- hits@to - subject_offsets[[i]]\n               hits@nLnode <- query_eltNROWS[[i]]\n               hits@nRnode <- subject_eltNROWS[[i]]\n               hits\n           })\n}\n\n### NOT exported.\n### Return an ordinary list of:\n###   (a) SortedByQueryHits objects if 'select' is \"all\". In that case the\n###       list has the length of the shortest of 'query' or 'subject'.\n###   (b) integer vectors if 'select' is not \"all\". In that case the list is\n###       parallel to and has the same shape as 'query'.\nfindOverlaps_NCLists <- function(query, subject,\n             maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"extend\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\", \"count\"),\n             circle.length=NA_integer_)\n{\n    if (!(is(query, \"IntegerRangesList\") && is(subject, \"IntegerRangesList\")))\n        stop(\"'query' and 'subject' must be IntegerRangesList objects\")\n    type <- match.arg(type)\n    select <- match.arg(select)\n    circle.length <- .normarg_circle.length2(circle.length,\n                              max(length(query), length(subject)),\n                              \"longest of 'query' or 'subject'\")\n    if (is(subject, \"NCLists\")) {\n        nclists <- subject@nclists\n        nclist_is_q <- rep.int(FALSE, length(nclists))\n        subject <- subject@rglist\n    } else if (is(query, \"NCLists\")) {\n        nclists <- query@nclists\n        nclist_is_q <- rep.int(TRUE, length(nclists))\n        query <- query@rglist\n    } else {\n        ## We'll do \"on-the-fly preprocessing\".\n        NG <- min(length(query), length(subject))\n        nclists <- vector(mode=\"list\", length=NG)\n        nclist_is_q <- rep.int(NA, length(nclists))\n    }\n\n    if (!is(query, \"CompressedIRangesList\"))\n        query <- as(query, \"CompressedIRangesList\")\n    q <- unlist(query, use.names=FALSE)\n    q_groups <- .extract_groups_from_RangesList(query)\n\n    if (!is(subject, \"CompressedIRangesList\"))\n        subject <- as(subject, \"CompressedIRangesList\")\n    s <- unlist(subject, use.names=FALSE)\n    s_groups <- .extract_groups_from_RangesList(subject)\n\n    all_hits <- find_overlaps_in_groups_NCList(\n                        q, NULL, q_groups,\n                        s, NULL, s_groups,\n                        nclists, nclist_is_q,\n                        maxgap, minoverlap, type, select, circle.length)\n    .split_and_remap_hits(all_hits, query, subject, select)\n}\n\n",
        "RangedSelection-class.R": "### =========================================================================\n### Selection of features and columns by intervals and column names\n### -------------------------------------------------------------------------\n\nsetClass(\"RangedSelection\",\n         representation(ranges = \"IntegerRangesList\", colnames = \"character\"))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\nsetMethod(\"ranges\", \"RangedSelection\",\n    function(x, use.names=TRUE, use.mcols=FALSE) x@ranges\n)\nsetReplaceMethod(\"ranges\", \"RangedSelection\",\n                 function(x, value) {\n                   x@ranges <- value\n                   x\n                 })\n\nsetMethod(\"colnames\", \"RangedSelection\",\n          function(x, do.NULL = TRUE, prefix = \"col\") x@colnames)\nsetReplaceMethod(\"colnames\", \"RangedSelection\",\n                 function(x, value) {\n                   x@colnames <- value\n                   x\n                 })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor.\n###\n\nRangedSelection <- function(ranges = IRangesList(), colnames = character()) {\n  if (!is(ranges, \"IntegerRangesList\"))\n    stop(\"'ranges' must be an IntegerRangesList\")\n  if (!is.character(colnames) || S4Vectors:::anyMissing(colnames))\n    stop(\"'colnames' must be a character vector without missing values\")\n  new(\"RangedSelection\", ranges = ranges, colnames = colnames)\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"IntegerRangesList\", \"RangedSelection\",\n    function(from) RangedSelection(from)\n)\n\n",
        "Ranges-and-RangesList-classes.R": "### =========================================================================\n### Ranges and RangesList objects\n### -------------------------------------------------------------------------\n###\n### The Ranges class is a virtual class that serves as the parent class for\n### any container that represents a vector of ranges. The core Ranges API\n### consists of the start(), end() and width() getters. All 3 getters must\n### return an integer vector parallel to the object and with no NAs. In\n### addition the 3 vectors must satisfy the 2 following properties:\n###\n###   (1) all(width(x) >= 0) is TRUE\n###   (2) all(start(x) + width(x) - 1L == end(x)) is TRUE\n###\n### The direct Ranges subclasses defined in the IRanges and GenomicRanges\n### packages are: Pos, IntegerRanges, and GenomicRanges.\n###\n### The Ranges hierarchy:\n### - showing the top-level classes only;\n### - showing only classes defined in the IRanges package;\n### - all classes showed in the diagram are virtual except IRanges, NCList,\n###   UnstitchedIPos, and StitchedIPos (marked with an asterisk).\n###\n###                               Ranges\n###                              ^      ^\n###                             /        \\\n###                 IntegerRanges         Pos\n###                 ^           ^            ^\n###                 |           |             \\\n###               Views     IPosRanges <----- IPos\n###                ^        ^ ^    ^           ^  ^\n###               /        /  |    |           |   \\\n###              .        /   |    |           |    \\\n###                      /    |    | UnstitchedIPos* \\\n###                     /     |    |          StitchedIPos*\n###              IRanges*     |    |\n###                 ^     NCList*  |\n###                 |             GroupingRanges\n###                 |                   ^\n###                 .                   |\n###                                     .\n###\n\n### General ranges.\nsetClass(\"Ranges\", contains=\"List\", representation(\"VIRTUAL\"))\n\n### Positions (i.e. ranges of with 1).\nsetClass(\"Pos\", contains=\"Ranges\", representation(\"VIRTUAL\"))\n\n### All ranges are on a single space.\n### Direct IntegerRanges subclasses: Views, IPosRanges.\nsetClass(\"IntegerRanges\", contains=\"Ranges\", representation(\"VIRTUAL\"))\n\n\nsetClass(\"RangesList\",\n    contains=\"List\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"Ranges\")\n)\n\nsetClass(\"SimpleRangesList\",\n    contains=c(\"RangesList\", \"SimpleList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"PosList\",\n    contains=\"RangesList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"Pos\")\n)\n\nsetClass(\"SimplePosList\",\n    contains=c(\"PosList\", \"SimpleRangesList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"IntegerRangesList\",\n    contains=\"RangesList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"IntegerRanges\")\n)\n\nsetClass(\"SimpleIntegerRangesList\",\n    contains=c(\"IntegerRangesList\", \"SimpleRangesList\"),\n    representation(\"VIRTUAL\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for Ranges derivatives\n###\n\n### Note that the 3 default methods below implement a circular relationship.\n### So Ranges subclasses must overwrite at least 2 of them!\nsetMethod(\"start\", \"Ranges\", function(x, ...) {1L - width(x) + end(x)})\nsetMethod(\"end\", \"Ranges\", function(x, ...) {width(x) - 1L + start(x)})\nsetMethod(\"width\", \"Ranges\", function(x) {end(x) - start(x) + 1L})\n\nsetMethod(\"length\", \"Ranges\", function(x) length(start(x)))\n\nsetGeneric(\"mid\", function(x, ...) standardGeneric(\"mid\"))\n\nsetMethod(\"mid\", \"Ranges\",\n    function(x) start(x) + as.integer((width(x) - 1) / 2)\n)\n\n### A Ranges object is considered empty iff all its ranges are empty.\nsetMethod(\"isEmpty\", \"Ranges\", function(x) all(width(x) == 0L))\n\nsetMethod(\"showAsCell\", \"Ranges\", function(object) as.character(object))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Ranges extends List\n###\n\nsetMethod(\"elementNROWS\", \"Ranges\",\n    function(x) setNames(width(x), names(x))\n)\n\nunlist_as_integer <- function(x)\n{\n    stopifnot(is(x, \"Ranges\"))\n    if (is(x, \"Pos\"))\n        return(pos(x))\n    sequence(width(x), from=start(x))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for Pos derivatives\n###\n\n### Pos subclasses only need to implement a \"pos\" method.\nsetMethod(\"start\", \"Pos\", function(x) pos(x))\nsetMethod(\"end\", \"Pos\", function(x) pos(x))\nsetMethod(\"width\", \"Pos\", function(x) rep.int(1L, length(x)))\n\nsetMethod(\"as.integer\", \"Pos\", function(x) pos(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for IntegerRanges derivatives\n###\n\n#setGeneric(\"isDisjointAndSorted\",\n#    function(x, ...) standardGeneric(\"isDisjointAndSorted\")\n#)\n\n#setMethod(\"isDisjointAndSorted\", \"IntegerRanges\",\n#    function(x)\n#    {\n#        x_start <- start(x)\n#        x_len <- length(x_start)\n#        if (x_len <= 1L)\n#            return(TRUE)\n#        x_end <- end(x)\n#        all(x_start[-1L] > x_end[-x_len])\n#    }\n#)\n\n### Being \"normal\" is stronger that being \"disjoint and sorted\".\nsetGeneric(\"isNormal\", function(x, ...) standardGeneric(\"isNormal\"))\n\nsetMethod(\"isNormal\", \"IntegerRanges\",\n    function(x)\n    {\n        x_start <- start(x)\n        x_end <- end(x)\n        if (any(x_end < x_start))\n            return(FALSE)\n        x_len <- length(x_start)\n        if (x_len <= 1L)\n            return(TRUE)\n        all(x_start[-1L] > x_end[-x_len] + 1L)\n    }\n)\n\nsetGeneric(\"whichFirstNotNormal\",\n    function(x) standardGeneric(\"whichFirstNotNormal\")\n)\n\nsetMethod(\"whichFirstNotNormal\", \"IntegerRanges\",\n    function(x)\n    {\n        is_ok <- width(x) >= 1L\n        if (length(x) >= 2)\n            is_ok <- is_ok & c(TRUE, start(x)[-1L] - end(x)[-length(x)] >= 2L)\n        which(!is_ok)[1L]\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for RangesList derivatives\n###\n\nsetMethod(\"start\", \"RangesList\",\n    function(x) as(lapply(x, start), \"SimpleIntegerList\")\n)\n\nsetMethod(\"end\", \"RangesList\",\n    function(x) as(lapply(x, end), \"SimpleIntegerList\")\n)\n\nsetMethod(\"width\", \"RangesList\",\n    function(x) as(lapply(x, width), \"SimpleIntegerList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods for PosList derivatives\n###\n\nsetMethod(\"pos\", \"PosList\",\n    function(x) as(lapply(x, pos), \"SimpleIntegerList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\nvalidate_Ranges <- function(x)\n{\n    x_start <- start(x)\n    x_end <- end(x)\n    x_width <- width(x)\n    validity_failures <- .Call2(\"C_validate_Ranges\",\n                                x_start, x_end, x_width,\n                                PACKAGE=\"IRanges\")\n    if (!is.null(validity_failures))\n        return(validity_failures)\n    if (!(is.null(names(x_start)) &&\n          is.null(names(x_end)) &&\n          is.null(names(x_width))))\n        return(wmsg(\"'start(x)', 'end(x)', and 'width(x)' \",\n                    \"cannot have names on them\"))\n    NULL\n}\n\nvalidate_Pos <- function(x)\n{\n    x_width <- width(x)\n    if (!all(x_width == 1L))\n        return(wmsg())\n    x_pos <- pos(x)\n    x_start <- start(x)\n    if (!all(x_pos == x_start))\n        return(wmsg())\n    NULL\n}\n\n",
        "Rle-class-leftovers.R": "### =========================================================================\n### IMPORTANT NOTE - 7/2/2014\n### Most of the stuff that used to be in the IRanges/R/Rle-class.R file was\n### moved to the S4Vectors package (to R/Rle-class.R and R/Rle-utils.R).\n### The stuff that could not be moved there was *temporarily* kept here in\n### Rle-class-leftovers.R but will need to find a new home (in S4Vectors\n### or in IRanges).\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\nsetMethod(\"ranges\", \"Rle\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n        IRanges(start(x), width=width(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"Rle\", \"IRanges\",\n      function(from)\n      {\n          if (!is.logical(runValue(from)) || S4Vectors:::anyMissing(runValue(from)))\n              stop(\"cannot coerce a non-logical 'Rle' or a logical 'Rle' \",\n                   \"with NAs to an IRanges object\")\n          keep <- runValue(from)\n          ## The returned IRanges instance is guaranteed to be normal.\n          ans_start <- start(from)[keep]\n          ans_width <- runLength(from)[keep]\n          new2(\"IRanges\", start=ans_start, width=ans_width, check=FALSE)\n      })\n\nsetAs(\"Rle\", \"NormalIRanges\",\n      function(from) newNormalIRangesFromIRanges(as(from, \"IRanges\"), check=FALSE))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### General methods\n###\n\nsetGeneric(\"findRange\", signature = \"vec\",\n           function(x, vec) standardGeneric(\"findRange\"))\n\nsetMethod(\"findRange\", signature = c(vec = \"Rle\"),\n          function(x, vec) {\n              run <- findRun(x, vec)\n              if (S4Vectors:::anyMissing(run))\n                stop(\"all 'x' values must be in [1, 'length(vec)']\")\n              IRanges(start = start(vec)[run], width = width(vec)[run],\n                      names = names(x))\n          })\n\nsetGeneric(\"orderAsRanges\", signature = c(\"x\"),  # not exported\n           function(x, na.last = TRUE, decreasing = FALSE)\n               standardGeneric(\"orderAsRanges\"))\n\nsetMethod(\"orderAsRanges\", \"Rle\",\n           function(x, na.last = TRUE, decreasing = FALSE)\n           {\n               ord <- base::order(runValue(x), na.last = na.last,\n                                  decreasing = decreasing)\n               new2(\"IRanges\", start = start(x)[ord], width = runLength(x)[ord],\n                    check = FALSE)\n           })\n\nsetGeneric(\"splitRanges\", signature = \"x\",\n           function(x) standardGeneric(\"splitRanges\"))\n\nsetMethod(\"splitRanges\", \"Rle\",\n          function(x) {\n              split(IRanges(start = start(x), width = runLength(x)),\n                    runValue(x))\n          })\n\nsetMethod(\"splitRanges\", \"vector_OR_factor\",\n          function(x) {\n              callGeneric(Rle(x))\n          })\n\n",
        "RleViews-class.R": "### =========================================================================\n### RleViews objects\n### -------------------------------------------------------------------------\n###\n\n\n### The RleViews class is the basic container for storing a set of views\n### (start/end locations) on the same Rle object, called the \"subject\"\n### vector.\nsetClass(\"RleViews\",\n    contains=c(\"Views\", \"RleList\"),\n    representation(\n        subject=\"Rle\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### User-friendly constructor.\n###\n\nsetMethod(\"Views\", \"Rle\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n        new_Views(subject,\n                  start=start, end=end, width=width, names=names,\n                  Class=\"RleViews\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"AtomicList\", \"RleViews\", function(from) {\n  to <- Views(as(unlist(from, use.names = FALSE), \"Rle\"),\n              PartitioningByEnd(from))\n  names(to) <- names(from)\n  to\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\n### The 2 helper functions below convert a given view on an Rle object\n### into a character-string.\n### Both assume that 'start' <= 'end' (so they don't check it) and\n### padd the result with spaces to produce the \"margin effect\"\n### if 'start' or 'end' are out of limits.\n\nRleViews.show_vframe_header <- function(iW, startW, endW, widthW)\n{\n    cat(format(\"\", width=iW+1),\n        format(\"start\", width=startW, justify=\"right\"), \" \",\n        format(\"end\", width=endW, justify=\"right\"), \" \",\n        format(\"width\", width=widthW, justify=\"right\"), \"\\n\",\n        sep=\"\")\n}\n\nRleViews.show_vframe_line <- function(x, i, iW, startW, endW, widthW)\n{\n    lsx <- length(subject(x))\n    start <- start(x)[i]\n    end <- end(x)[i]\n    width <- end - start + 1\n    snippetWidth <- getOption(\"width\") - 10 - iW - startW - endW - widthW\n    if (width > 0 && lsx > 0 && start <= lsx && end >= 1) {\n        snippetStart <- max(min(start,lsx),1)\n        snippetEnd <- max(min(end,lsx,start + snippetWidth),1)\n        snippet <-\n          format(as.vector(extractROWS(subject(x),\n                                       IRanges(snippetStart, snippetEnd))))\n        snippet <- snippet[cumsum(nchar(snippet) + 1L) < snippetWidth]\n        if (length(snippet) < width) {\n            snippet <- c(snippet, \"...\")\n        }\n        snippet <- paste(snippet, collapse = \" \")\n    } else {\n        snippet <- \" \"\n    }\n    cat(format(paste(\"[\", i,\"]\", sep=\"\"), width=iW, justify=\"right\"), \" \",\n        format(start, width=startW, justify=\"right\"), \" \",\n        format(end, width=endW, justify=\"right\"), \" \",\n        format(width, width=widthW, justify=\"right\"), \" \",\n        \"[\", snippet, \"]\\n\",\n        sep=\"\")\n}\n\n### 'half_nrow' must be >= 1\nRleViews.show_vframe <- function(x, half_nrow=9L)\n{\n    cat(\"\\nviews:\")\n    lx <- length(x)\n    if (lx == 0)\n        cat(\" NONE\\n\")\n    else {\n        cat(\"\\n\")\n        iW <- nchar(as.character(lx)) + 2 # 2 for the brackets\n        startMax <- max(start(x))\n        startW <- max(nchar(startMax), nchar(\"start\"))\n        endMax <- max(end(x))\n        endW <- max(nchar(endMax), nchar(\"end\"))\n        widthMax <- max(width(x))\n        widthW <- max(nchar(widthMax), nchar(\"width\"))\n        RleViews.show_vframe_header(iW, startW, endW, widthW)\n        if (lx <= 2*half_nrow+1) {\n            for (i in seq_len(lx))\n                RleViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        } else {\n            for (i in 1:half_nrow)\n                RleViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n            cat(format(\"...\", width=iW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=startW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=endW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=widthW, justify=\"right\"),\n                \" ...\\n\", sep=\"\")\n            for (i in (lx-half_nrow+1L):lx)\n                RleViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        }\n    }\n}\n\nsetMethod(\"show\", \"RleViews\",\n    function(object)\n    {\n        cat(\"Views on a \", length(subject(object)), \"-length Rle subject\\n\", sep=\"\")\n        RleViews.show_vframe(object)\n    }\n)\n",
        "RleViews-utils.R": "### =========================================================================\n### View summarization methods for RleViews objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### viewApply() method for RleViews objects\n###\n\nsetMethod(\"viewApply\", \"RleViews\",\n          function(X, FUN, ..., simplify = TRUE) {\n              X <- trim(X)\n              ans <-\n                aggregate(subject(X), start = structure(start(X), names = names(X)),\n                          end = end(X), FUN = FUN, ..., simplify = simplify)\n              if (!simplify) {\n                  ans <- S4Vectors:::new_SimpleList_from_list(\"SimpleList\",\n                                                  ans,\n                                                  metadata=metadata(X),\n                                                  mcols=mcols(X))\n              }\n              ans\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### viewMins(), viewMaxs(), viewSums(), viewMeans(), viewWhichMins(), and\n### viewWhichMaxs() methods for RleViews objects\n###\n\n### Coerce 'x' to integer if all its values are within the integer range.\n.double_to_integer_if_in_range <- function(x)\n{\n    stopifnot(is.double(x))\n    x_min <- suppressWarnings(min(x, na.rm=TRUE))\n    x_max <- suppressWarnings(max(x, na.rm=TRUE))\n    int_max_plus_one <- .Machine$integer.max + 1\n    if (-int_max_plus_one < x_min && x_max < int_max_plus_one)\n        x <- setNames(as.integer(x), names(x))\n    x\n}\n\n.C_summarize_RleViews <- function(op, x_subject, x_ranges, na.rm)\n{\n    C_ans <- .Call2(\"C_summarize_RleViews\", op, x_subject, x_ranges, na.rm,\n                                            PACKAGE=\"IRanges\")\n    if (op == \"sum\") {\n        run_vals <- runValue(x_subject)\n        if (is.integer(run_vals) || is.logical(run_vals))\n            C_ans <- .double_to_integer_if_in_range(C_ans)\n    }\n    C_ans\n}\n\n.summarize_RleViews <- function(op, x, na.rm=FALSE)\n{\n    stopifnot(isSingleString(op), is(x, \"RleViews\"), isTRUEorFALSE(na.rm))\n    x <- trim(x)\n    x_ranges <- ranges(x)\n    x_subject <- subject(x)\n    run_vals <- runValue(x_subject)\n    if (!is.complex(run_vals))\n        return(.C_summarize_RleViews(op, x_subject, x_ranges, na.rm))\n    if (op %in% c(\"min\", \"max\", \"which.min\", \"which.max\"))\n        stop(wmsg(\"operation not supported when the subject \",\n                  \"is an Rle that contains \\\"complex\\\" values\"))\n    ans_names <- names(x_ranges)\n    x_ranges <- unname(x_ranges)\n    ans_r <- .C_summarize_RleViews(op, Re(x_subject), x_ranges, na.rm)\n    ans_i <- .C_summarize_RleViews(op, Im(x_subject), x_ranges, na.rm)\n    setNames(complex(real=ans_r, imaginary=ans_i), ans_names)\n}\n\nsetMethod(\"viewMins\", \"RleViews\",\n    function(x, na.rm=FALSE) .summarize_RleViews(\"min\", x, na.rm=na.rm)\n)\n\nsetMethod(\"viewMaxs\", \"RleViews\",\n    function(x, na.rm=FALSE) .summarize_RleViews(\"max\", x, na.rm=na.rm)\n)\n\nsetMethod(\"viewSums\", \"RleViews\",\n    function(x, na.rm=FALSE) .summarize_RleViews(\"sum\", x, na.rm=na.rm)\n)\n\nsetMethod(\"viewMeans\", \"RleViews\",\n    function(x, na.rm=FALSE) .summarize_RleViews(\"mean\", x, na.rm=na.rm)\n)\n\n### Even though base::which(), base::which.min(), and base::which.max() always\n### ignore NAs and don't have an 'na.rm' argument to control that, somehow\n### someone felt it could be a good idea to give the viewWhichMins() and\n### viewWhichMaxs() generics an 'na.rm' argument, not sure why. Plus, the\n### old implementations (from IRanges < 2.41.3) of the viewWhichMins() and\n### viewWhichMaxs() methods for RleViews objects (which were based on old .Call\n### entry points C_viewWhichMins_RleViews and C_viewWhichMaxs_RleViews) were\n### apparently trying to support the 'na.rm' argument but that support was\n### broken.\nsetMethod(\"viewWhichMins\", \"RleViews\",\n    function(x, na.rm=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(wmsg(\"the viewWhichMins() method for RleViews objects \",\n                         \"always ignores NAs (the 'na.rm' argument has \",\n                         \"no effect)\"))\n        .summarize_RleViews(\"which.min\", x)\n    }\n)\n\nsetMethod(\"viewWhichMaxs\", \"RleViews\",\n    function(x, na.rm=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(wmsg(\"the viewWhichMaxs() method for RleViews objects \",\n                         \"always ignores NAs (the 'na.rm' argument has \",\n                         \"no effect)\"))\n        .summarize_RleViews(\"which.max\", x)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### viewRangeMins() and viewRangeMaxs() methods for RleViews objects\n###\n\nsetMethod(\"viewRangeMins\", \"RleViews\",\n    function(x, na.rm=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(wmsg(\"the viewRangeMins() method for RleViews objects \",\n                         \"always ignores NAs (the 'na.rm' argument has \",\n                         \"no effect)\"))\n        mins <- viewWhichMins(x)\n        pintersect(findRange(mins, subject(x)), trim(x))\n    }\n)\n\nsetMethod(\"viewRangeMaxs\", \"RleViews\",\n    function(x, na.rm=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(wmsg(\"the viewRangeMaxs() method for RleViews objects \",\n                         \"always ignores NAs (the 'na.rm' argument has \",\n                         \"no effect)\"))\n        maxs <- viewWhichMaxs(x)\n        pintersect(findRange(maxs, subject(x)), trim(x))\n    }\n)\n\n",
        "RleViewsList-class.R": "### =========================================================================\n### RleViewsList objects\n### -------------------------------------------------------------------------\n\nsetClass(\"RleViewsList\", representation(\"VIRTUAL\"),\n         prototype = prototype(elementType = \"RleViews\"),\n         contains = \"ViewsList\")\nsetClass(\"SimpleRleViewsList\",\n         prototype = prototype(elementType = \"RleViews\"),\n         contains = c(\"RleViewsList\", \"SimpleViewsList\"))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor.\n###\n\nsetMethod(\"subject\", \"SimpleRleViewsList\",\n    function(x)\n        S4Vectors:::new_SimpleList_from_list(\"SimpleRleList\",\n                                             lapply(x, slot, \"subject\"))\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor.\n###\n\nsetMethod(\"Views\", \"RleList\",\n          function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n              RleViewsList(rleList = subject, rangesList = start))\n\nRleViewsList <- function(..., rleList, rangesList)\n{\n    views <- list(...)\n    if (!missing(rleList) && !missing(rangesList)) {\n        if (length(views) > 0)\n            stop(wmsg(\"'...' must be empty when 'rleList' and 'rangesList' \",\n                      \"are specified\"))\n        if (!is(rleList, \"RleList\"))\n            stop(wmsg(\"'rleList' must be a RleList object\"))\n        if (!is(rangesList, \"IntegerRangesList\")) {\n            rangesList <- try(IRangesList(rangesList), silent = TRUE)\n            if (inherits(rangesList, \"try-error\"))\n                stop(wmsg(\"'rangesList' must be a IntegerRangesList object\"))\n        }\n        if (length(rleList) != length(rangesList))\n            stop(\"'rleList' and 'rangesList' must have the same length\")\n        rleList_names <- names(rleList)\n        rangesList_names <- names(rangesList)\n        if (!(is.null(rleList_names) ||\n              is.null(rangesList_names) ||\n              identical(rleList_names, rangesList_names))) {\n            if (anyDuplicated(rleList_names,) ||\n                anyDuplicated(rangesList_names))\n                stop(wmsg(\"when both 'rleList' and 'rangesList' have names, \",\n                          \"the names on each object cannot have duplicates\"))\n            if (!setequal(rleList_names, rangesList_names))\n                stop(wmsg(\"when both 'rleList' and 'rangesList' have names, \",\n                          \"the set of names must be the same on each object\"))\n            warning(wmsg(\"'rleList' was reordered so that its names \",\n                         \"match the names on 'rangesList'\"))\n            rleList <- rleList[rangesList_names]\n        }\n        views <- Map(Views, rleList, rangesList)\n    } else if ((length(views) > 0) &&\n            (!missing(rleList) || !missing(rangesList))) {\n        stop(wmsg(\"cannot specify 'rleList' or 'rangesList' \",\n                  \"when specifying '...'\"))\n    } else {\n        if (length(views) == 1 && is.list(views[[1L]]))\n            views <- views[[1L]]\n        if (!all(sapply(views, is, \"RleViews\")))\n            stop(wmsg(\"all elements in '...' must be RleViews objects\"))\n    }\n    S4Vectors:::new_SimpleList_from_list(\"SimpleRleViewsList\", views)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"RleViewsList\", \"SimpleIRangesList\", function(from)\n      IRangesList(lapply(from, as, \"IRanges\"), compress=FALSE))\n\nsetAs(\"RleViewsList\", \"IRangesList\",\n      function(from) as(from, \"SimpleIRangesList\"))\n\n",
        "RleViewsList-utils.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"viewApply\", \"viewMins\", \"viewMaxs\", and \"viewSums\" generics and\n### methods.\n###\n\nsetMethod(\"viewApply\", \"RleViewsList\",\n          function(X, FUN, ..., simplify = TRUE) {\n            ans_listData <- lapply(structure(seq_along(X), names=names(X)),\n              function(i) {\n                ans_elt <- aggregate(\n                             subject(X[[i]]),\n                             start=structure(start(X[[i]]),\n                                             names=names(start(X[[i]]))),\n                             end=end(X[[i]]),\n                             FUN=FUN,\n                             ...,\n                             simplify=simplify)\n                if (!simplify)\n                  ans_elt <- S4Vectors:::new_SimpleList_from_list(\"SimpleList\",\n                                                     ans_elt,\n                                                     metadata=metadata(X[[i]]),\n                                                     mcols=mcols(X[[i]], use.names=FALSE))\n                ans_elt\n              })\n            S4Vectors:::new_SimpleList_from_list(\"SimpleList\", ans_listData,\n                                                 metadata=metadata(X),\n                                                 mcols=mcols(X, use.names=FALSE))})\n\n.summaryRleViewsList <- function(x, FUN, na.rm = FALSE, outputListType = NULL)\n{\n    FUN <- match.fun(FUN)\n    if (length(x) == 0) {\n        outputListType <- \"SimpleList\"\n        listData <- list()\n    } else {\n        if (is.null(outputListType)) {\n            valuesClass <- class(runValue(subject(x[[1L]])))\n            if (valuesClass == \"integer\" || valuesClass == \"logical\")\n                outputListType <- \"SimpleIntegerList\"\n            else if (valuesClass == \"numeric\")\n                outputListType <- \"SimpleNumericList\"\n            else\n                stop(\"cannot compute numeric summary over a non-numeric Rle\")\n        }\n        listData <-\n          lapply(structure(seq_len(length(x)), names = names(x)),\n                 function(i) FUN(x[[i]], na.rm = na.rm))\n    }\n    S4Vectors:::new_SimpleList_from_list(outputListType, listData,\n                                         metadata = metadata(x),\n                                         mcols = mcols(x, use.names=FALSE))\n}\nsetMethod(\"viewMins\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewMins, na.rm = na.rm))\n\nsetMethod(\"viewMaxs\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewMaxs, na.rm = na.rm))\n\nsetMethod(\"viewSums\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewSums, na.rm = na.rm))\n\nsetMethod(\"viewMeans\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewMeans, na.rm = na.rm,\n                               outputListType = \"SimpleNumericList\"))\n\nsetMethod(\"viewWhichMins\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewWhichMins, na.rm = na.rm,\n                               outputListType = \"SimpleIntegerList\"))\n\nsetMethod(\"viewWhichMaxs\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewWhichMaxs, na.rm = na.rm,\n                               outputListType = \"SimpleIntegerList\"))\n\nsetMethod(\"viewRangeMaxs\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewRangeMaxs, na.rm = na.rm,\n                               outputListType = \"SimpleIRangesList\"))\n\nsetMethod(\"viewRangeMins\", \"RleViewsList\",\n          function(x, na.rm = FALSE)\n          .summaryRleViewsList(x, FUN = viewRangeMins, na.rm = na.rm,\n                               outputListType = \"SimpleIRangesList\"))\n",
        "SimpleGrouping-class.R": "### =========================================================================\n### Grouping objects implemented with an IntegerList\n### -------------------------------------------------------------------------\n\nsetClass(\"SimpleGrouping\",\n### TODO: contain VIRTUAL after R 3.4 release\n         contains=c(\"Grouping\", \"SimpleIntegerList\"))\n\nsetClass(\"SimpleManyToOneGrouping\",\n         contains=c(\"ManyToOneGrouping\", \"SimpleGrouping\"))\n\nsetClass(\"BaseManyToManyGrouping\",\n         representation(nobj=\"integer\"),\n### TODO: contain VIRTUAL after R 3.4 release\n         contains=\"ManyToManyGrouping\",\n         validity=function(object) {\n             if (!isSingleNumber(object@nobj))\n                 \"'nobj' must be a single, non-NA number\"\n         })\n\nsetClass(\"SimpleManyToManyGrouping\",\n         contains=c(\"BaseManyToManyGrouping\", \"SimpleGrouping\"))\n\n### -------------------------------------------------------------------------\n### Grouping API implementation\n### ----------------------------\n###\n\nsetMethod(\"nobj\", \"BaseManyToManyGrouping\", function(x) x@nobj)\n\n### -------------------------------------------------------------------------\n### Constructors\n### ----------------------------\n###\n\nManyToOneGrouping <- function(..., compress=TRUE) {\n    CompressedOrSimple <- if (compress) \"Compressed\" else \"Simple\"\n    Class <- paste0(CompressedOrSimple, \"ManyToOneGrouping\")\n    new(Class, IntegerList(..., compress=compress))\n}\n\nManyToManyGrouping <- function(..., nobj, compress=TRUE) {\n    CompressedOrSimple <- if (compress) \"Compressed\" else \"Simple\"\n    Class <- paste0(CompressedOrSimple, \"ManyToManyGrouping\")\n    new(Class, IntegerList(..., compress=compress), nobj=nobj)\n}\n\n### -------------------------------------------------------------------------\n### Coercion\n### ----------------------------\n###\n\nsetOldClass(c(\"grouping\", \"integer\"))\n\n## utils::relist dipatches only on 'skeleton' so this is here instead of in R\nsetMethod(\"relist\", c(\"grouping\", \"missing\"), function(flesh, skeleton) {\n              relist(as.integer(flesh), PartitioningByEnd(attr(flesh, \"ends\")))\n          })\n\nsetMethod(\"split\", c(\"ANY\", \"ManyToOneGrouping\"), function(x, f, drop=FALSE) {\n              stopifnot(isTRUEorFALSE(drop))\n              ans <- extractList(x, f)\n              if (drop) {\n                  ans <- ans[lengths(ans) > 0L]\n              }\n              ans\n          })\n\nsetAs(\"grouping\", \"Grouping\", function(from) {\n          as(from, \"ManyToOneGrouping\")\n      })\n\nsetAs(\"grouping\", \"ManyToOneGrouping\", function(from) {\n          ManyToOneGrouping(relist(from), compress=TRUE)\n      })\n\nsetAs(\"vector\", \"Grouping\", function(from) {\n          if (anyNA(from))\n              as(from, \"ManyToManyGrouping\")\n          else as(from, \"ManyToOneGrouping\")\n      })\n\nsetAs(\"vector\", \"ManyToOneGrouping\", function(from) {\n    to <- as(grouping(from), \"Grouping\")\n    names(to) <- from[unlist(to)[end(PartitioningByEnd(to))]]\n    to\n})\n\nsetAs(\"factor\", \"ManyToOneGrouping\", function(from) {\n    ManyToOneGrouping(splitAsList(seq_along(from), from))\n})\n\nsetAs(\"vector\", \"ManyToManyGrouping\", function(from) {\n         g <- as(from, \"ManyToOneGrouping\")\n         if (anyNA(from))\n             g <- g[-length(g)]\n         ManyToManyGrouping(g, nobj=length(from))\n      })\n\nsetAs(\"ManyToOneGrouping\", \"factor\", function(from) {\n    levels <- if (!is.null(names(from))) {\n        names(from)\n    } else {\n        as.character(seq_along(from))\n    }\n    structure(togroup(from), levels=levels, class=\"factor\")\n})\n\nsetMethod(\"as.factor\", \"ManyToOneGrouping\", function(x) {\n    as(x, \"factor\")\n})\n\nmakeGroupNames <- function(x) {\n    if (is.null(x)) {\n        x <- character(length(x))\n    }\n    ind <- which(x == \"\")\n    x[ind] <- paste(\"Group\", ind, sep = \".\")\n    x\n}\n\nlevelCols <- function(by) {\n    DataFrame(expand.grid(lapply(by, levels)))\n}\n\nsetAs(\"FactorList\", \"Grouping\", function(from) {\n    l <- as.list(from)\n    names(l) <- makeGroupNames(names(from))\n    as(DataFrame(l), \"Grouping\")\n})\n\nsetAs(\"DataFrame\", \"Grouping\", function(from) {\n    factors <- lapply(from, as.factor)\n    l <- splitAsList(seq_len(nrow(from)), factors)\n    mcols(l) <- levelCols(factors)\n    if (anyNA(from, recursive=TRUE)) {\n        ManyToManyGrouping(l, nobj=nrow(from))\n    } else {\n        ManyToOneGrouping(l)\n    }\n})\n",
        "Vector-class-leftovers.R": "### =========================================================================\n### IMPORTANT NOTE - 4/29/2014\n### Most of the stuff that used to be in the IRanges/R/Vector-class.R file\n### was moved to the S4Vectors package (to R/Vector-class.R).\n### The stuff that could not be moved there was *temporarily* kept here in\n### Vector-class-leftovers.R but will need to find a new home (in S4Vectors\n### or in IRanges).\n###\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other subsetting-related operations\n###\n\n### S3/S4 combo for window<-.Vector\n`window<-.Vector` <- function(x, start=NA, end=NA, width=NA, ..., value) {\n    window(x, start, end, width, ...) <- value\n    x\n}\n`.window<-.Vector` <- function(x, start=NA, end=NA, width=NA, ..., value)\n{\n    i <- solveUserSEWForSingleSeq(NROW(x), start, end, width)\n    li <- width(i)\n    if (li == 0L) {\n        ## Surprisingly, in that case, `[<-` on standard vectors does not\n        ## even look at 'value'. So neither do we...\n        return(x)\n    }\n    lv <- NROW(value)\n    if (lv == 0L)\n        stop(\"replacement has length zero\")\n    value <- normalizeSingleBracketReplacementValue(value, x)\n    if (li != lv) {\n        if (li %% lv != 0L)\n            warning(\"number of values supplied is not a sub-multiple \",\n                    \"of the number of values to be replaced\")\n        value <- extractROWS(value, rep(seq_len(lv), length.out=li))\n    }\n    c(window(x, end=start(i)-1L),\n      value,\n      window(x, start=end(i)+1L))\n}\nsetReplaceMethod(\"window\", \"Vector\", `.window<-.Vector`)\n\n### S3/S4 combo for window<-.vector\n`window<-.vector` <- `window<-.Vector`\nsetReplaceMethod(\"window\", \"vector\", `window<-.vector`)\n\n### S3/S4 combo for window<-.factor\n`window<-.factor` <- function(x, start=NA, end=NA, width=NA, ..., value)\n{\n    levels <- levels(x)\n    x <- as.character(x)\n    value <- as.character(value)\n    factor(callGeneric(), levels=levels)\n}\nsetReplaceMethod(\"window\", \"factor\", `window<-.factor`)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Looping methods\n###\n\n#.tapplyDefault <- base::tapply\n#environment(.tapplyDefault) <- topenv()\n.tapplyDefault <-\nfunction(X, INDEX, FUN = NULL, ..., simplify = TRUE) \n{\n    if (!is.null(FUN))\n        FUN <- match.fun(FUN)\n    if (missing(INDEX))\n        stop(\"'INDEX' is missing\")\n    if (!is(INDEX, \"RleList\")) {\n        if (!is.list(INDEX) && !is(INDEX, \"Rle\"))\n            INDEX <- Rle(INDEX)\n        INDEX <- RleList(INDEX)\n    }\n    nI <- length(INDEX)\n    namelist <- vector(\"list\", nI)\n    names(namelist) <- names(INDEX)\n    extent <- integer(nI)\n    nx <- NROW(X)\n    one <- 1L\n    group <- Rle(one, nx)\n    ngroup <- one\n    for (i in seq_len(nI)) {\n        index <- INDEX[[i]]\n        if (!is.factor(runValue(index)))\n            runValue(index) <- factor(runValue(index))\n        offset <- index\n        runValue(offset) <- ngroup * (as.integer(runValue(index)) - one)\n        if (length(index) != nx) \n            stop(\"arguments must have same length\")\n        namelist[[i]] <- levels(index)\n        extent[i] <- nlevels(index)\n        group <- group + offset\n        ngroup <- ngroup * nlevels(index)\n    }\n    if (is.null(FUN))\n        return(as.vector(group))\n    groupRanges <- splitRanges(group)\n    ans <- lapply(groupRanges, function(i) FUN(extractROWS(X, i), ...))\n    index <- as.integer(names(ans))\n    if (simplify && all(unlist(lapply(ans, length), use.names=FALSE) == 1L)) {\n        ansmat <- array(dim = extent, dimnames = namelist)\n        ans <- unlist(ans, recursive = FALSE)\n    }\n    else {\n        ansmat <-\n          array(vector(\"list\", prod(extent)), dim = extent,\n                dimnames = namelist)\n    }\n    if (length(index) > 0) {\n        names(ans) <- NULL\n        ansmat[index] <- ans\n    }\n    ansmat\n}\nsetMethod(\"tapply\", c(\"Vector\", \"ANY\"), .tapplyDefault)\nsetMethod(\"tapply\", c(\"ANY\", \"Vector\"), .tapplyDefault)\nsetMethod(\"tapply\", c(\"Vector\", \"Vector\"), .tapplyDefault)\n\n",
        "Views-class.R": "### =========================================================================\n### Views objects\n### -------------------------------------------------------------------------\n###\n### The Views virtual class is a general container for storing a set of views\n### on an arbitrary Vector object, called the \"subject\".\n###\n\nsetClass(\"Views\",\n    contains=\"IntegerRanges\",\n    representation(\n        \"VIRTUAL\",\n        subject=\"Vector\",\n        ranges=\"IRanges\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"Views\",\n    function(x) c(\"ranges\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\nsetGeneric(\"subject\", function(x) standardGeneric(\"subject\"))\n\nsetMethod(\"subject\", \"Views\", function(x) x@subject)\n\nsetMethod(\"ranges\", \"Views\",\n    function(x, use.names=TRUE, use.mcols=FALSE) x@ranges\n)\n\nsetGeneric(\"ranges<-\", function(x, ..., value) standardGeneric(\"ranges<-\"))\n\nsetReplaceMethod(\"ranges\", \"Views\",\n    function(x, ..., value)\n    {\n        stop(\"ranges setter for Views objects not ready yet\")\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods derived from the IRanges interface.\n###\n\nsetMethod(\"start\", \"Views\", function(x, ...) start(ranges(x)))\nsetMethod(\"width\", \"Views\", function(x) width(ranges(x)))\nsetMethod(\"names\", \"Views\", function(x) names(ranges(x)))\n\nsetReplaceMethod(\"start\", \"Views\",\n    function(x, ..., value)\n    {\n        start(x@ranges, ...) <- value\n        x\n    }\n)\n\nsetReplaceMethod(\"end\", \"Views\",\n    function(x, ..., value)\n    {\n        end(x@ranges, ...) <- value\n        x\n    }\n)\n\nsetReplaceMethod(\"width\", \"Views\",\n    function(x, ..., value)\n    {\n        width(x@ranges, ...) <- value\n        x\n    }\n)\n\nsetReplaceMethod(\"names\", \"Views\",\n    function(x, value)\n    {\n        names(x@ranges) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### The low-level \"Views\" constructor.\n### NOT exported but used in XVector, Biostrings, and triplex packages.\n### TODO: - add a 'check.limits' arg (default to TRUE) for raising an error if\n###         some views are \"out of limits\".\nnew_Views <- function(subject, start=NULL, end=NULL, width=NULL, names=NULL,\n                      Class=NULL)\n{\n    if (is(start, \"IntegerRanges\")) {\n        if (!is.null(end) || !is.null(width))\n            stop(wmsg(\"'end' and 'width' must be NULLs when \",\n                      \"'start' is an IntegerRanges object\"))\n        ans_ranges <- start\n        if (class(ans_ranges) != \"IRanges\")\n            ans_ranges <- as(ans_ranges, \"IRanges\")\n        ## Keep the names that are already in 'ranges' unless the 'names' arg\n        ## was specified.\n        if (!is.null(names))\n            names(ans_ranges) <- names\n        ans_mcols <- mcols(ans_ranges, use.names=FALSE)\n        mcols(ans_ranges) <- NULL\n    } else {\n        ans_ranges <- IRanges(start=start, end=end, width=width, names=names)\n        ans_mcols <- NULL\n    }\n    if (is.null(Class))\n        Class <- paste(class(subject), \"Views\", sep=\"\")\n    new2(Class, subject=subject,\n                ranges=ans_ranges,\n                elementMetadata=ans_mcols,\n                check=FALSE)\n}\n\n### The user-friendly \"Views\" constructor.\n### TODO: Same as for the new_Views() function above.\nsetGeneric(\"Views\", signature=\"subject\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n        standardGeneric(\"Views\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unlist()\n###\n\n### Overwrite method for List objects with optimized method for Views objects.\nsetMethod(\"unlist\", \"Views\",\n    function(x, recursive=TRUE, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        unlisted_x <- subject(x)[ranges(x)]\n        if (use.names)\n            unlisted_x <- S4Vectors:::set_unlisted_names(unlisted_x, x)\n        unlisted_x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### Returns a single view covering the entire sequence.\nsetAs(\"Vector\", \"Views\",\n    function(from) Views(from, start=1L, width=length(from))\n)\n\nsetAs(\"Views\", \"IntegerRanges\", function(from) ranges(from))\nsetAs(\"Views\", \"IRanges\", function(from) ranges(from))\n\n### Unfortunately, even if we've already defined the IRanges->NormalIRanges\n### \"coerce\" method to override the silly implicit one, we still need to\n### define the <class>->NormalIRanges ones for every <class> that contains\n### IRanges. Otherwise, again, 'as(x, \"NormalIRanges\")' would call another\n### silly implicit method when 'x' is a <class> instance.\n### Yes, this is another S4 \"feature\":\n###   https://stat.ethz.ch/pipermail/r-devel/2008-April/049027.html\nsetAs(\"Views\", \"NormalIRanges\",\n    function(from) asNormalIRanges(ranges(from), force=TRUE)\n)\n\nsetMethod(\"as.matrix\", \"Views\", function(x, rev = FALSE, max.width = NA) {\n  x_ranges <- restrict(ranges(x), start = 1L)\n  if (is.na(max.width)) {\n    max.width <- max(width(x_ranges))\n  }\n  rev <- S4Vectors:::recycleVector(rev, length(x))\n  part <- PartitioningByWidth(x_ranges)\n  from <- ifelse(rev, end(part), start(part))\n  by <- ifelse(rev, -1L, 1L)\n  ord <- sequence(width(part), from=from, by=by)\n  v <- extractROWS(subject(x), x_ranges)[ord]\n  v_fill <- rep.int(NA, max.width * length(x))\n  part <- PartitioningByWidth(rep(max.width, length(x)))\n  i <- unlist_as_integer(IRanges(start(part), width = width(x_ranges)))\n  v_fill[i] <- as.vector(v)\n  matrix(v_fill, ncol = max.width, byrow = TRUE,\n         dimnames = list(names(x), NULL))\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Extracting a view.\n###\n\nsetMethod(\"getListElement\", \"Views\",\n    function(x, i, exact=TRUE)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x, exact=exact)\n        start <- start(x)[i]\n        end <- end(x)[i]\n        if (start < 1L || end > length(subject(x)))\n            stop(\"view is out of limits\")\n        extractROWS(subject(x), IRanges(start, end))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.check_that_Views_objects_are_concatenable <- function(x, objects)\n{\n    ok <- vapply(\n        objects,\n        function(object) isTRUE(all.equal(subject(object), subject(x))),\n        logical(1),\n        USE.NAMES=FALSE\n    )\n    if (!all(ok))\n        stop(wmsg(\"the Views objects to concatenate \",\n                  \"must have the same subject\"))\n}\n\n.concatenate_Views_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- S4Vectors:::prepare_objects_to_bind(x, objects)\n    .check_that_Views_objects_are_concatenable(x, objects)\n    callNextMethod()\n}\n\nsetMethod(\"bindROWS\", \"Views\", .concatenate_Views_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"trim\" function.\n###\n\nsetGeneric(\"trim\", signature=\"x\",\n    function(x, use.names=TRUE, ...) standardGeneric(\"trim\")\n)\n\nsetMethod(\"trim\", \"Views\",\n    function(x, use.names=TRUE)\n    {\n        if (length(x) == 0L)\n            return(x)\n        if (min(start(x)) >= 1L && max(end(x)) <= length(subject(x)))\n            return(x)\n        x@ranges <- restrict(ranges(x), start=1L, end=length(subject(x)),\n                             keep.all.ranges=TRUE,\n                             use.names=use.names)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"subviews\" function.\n###\n\n### TODO: - add a 'check.limits' arg (default to TRUE) for raising an error if\n###         some views are \"out of limits\"\nsetGeneric(\"subviews\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA, use.names=TRUE)\n        standardGeneric(\"subviews\")\n)\n\nsetMethod(\"subviews\", \"Views\",\n    function(x, start=NA, end=NA, width=NA, use.names=TRUE)\n        trim(narrow(x, start=start, end=end, width=width, use.names=use.names))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"successiveViews\" function.\n###\n\nsuccessiveViews <- function(subject, width, gapwidth=0, from=1)\n{\n    ranges <- successiveIRanges(width, gapwidth=gapwidth, from=from)\n    Views(subject, ranges)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"slidingViews\" function.\n###\n\nslidingViews <- function(subject, width, shift = 1L)\n{\n    ranges <- slidingIRanges(length(subject), width, shift)\n    Views(subject, ranges)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"viewApply\" function.\n###\n\nsetGeneric(\"viewApply\", signature=\"X\",\n    function(X, FUN, ..., simplify = TRUE) standardGeneric(\"viewApply\")\n)\n\nsetMethod(\"viewApply\", \"Views\",\n    function(X, FUN, ..., simplify = TRUE)\n    {\n        X <- trim(X)\n        Xsubject <- subject(X)\n        Xstart <- start(X)\n        Xwidth <- width(X)\n        ans <-\n          sapply(structure(seq_len(length(X)), names=names(X)),\n              function(i)\n                  FUN(extractROWS(Xsubject,\n                                  IRanges(start=Xstart[i], width=Xwidth[i])),\n                      ...),\n              simplify = simplify)\n        if (!simplify) {\n            ans <- S4Vectors:::new_SimpleList_from_list(\"SimpleList\", ans,\n                                                        metadata = metadata(X),\n                                                        mcols = mcols(X, use.names=FALSE))\n        }\n        ans\n    }\n)\n\nsetGeneric(\"viewMins\", signature=\"x\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewMins\"))\nsetGeneric(\"viewMaxs\", signature=\"x\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewMaxs\"))\nsetGeneric(\"viewSums\", signature=\"x\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewSums\"))\nsetGeneric(\"viewMeans\", signature=\"x\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewMeans\"))\nsetGeneric(\"viewWhichMins\", signature=\"x\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewWhichMins\"))\nsetGeneric(\"viewWhichMaxs\", signature=\"x\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewWhichMaxs\"))\nsetGeneric(\"viewRangeMaxs\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewRangeMaxs\"))\nsetGeneric(\"viewRangeMins\",\n           function(x, na.rm = FALSE) standardGeneric(\"viewRangeMins\"))\n\nsetMethod(\"Summary\", \"Views\", function(x, ..., na.rm = FALSE) {\n  viewSummaryFunMap <- list(min = viewMins, max = viewMaxs, sum = viewSums)\n  viewSummaryFun <- viewSummaryFunMap[[.Generic]]\n  if (!is.null(viewSummaryFun)) {\n    if (length(list(...)))\n      stop(\"Passing multiple arguments to '\", .Generic, \"' is not supported.\")\n    viewSummaryFun(x, na.rm = na.rm)\n  } else {\n    Summary(ranges(x), ..., na.rm = na.rm)\n  }\n})\n\nsetMethod(\"mean\", \"Views\", viewMeans)\nsetMethod(\"which.min\", \"Views\", function(x) viewWhichMins(x))\nsetMethod(\"which.max\", \"Views\", function(x) viewWhichMaxs(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show\n###\n\nsetMethod(\"showAsCell\", \"Views\", function(object) {\n              showAsCell(as(object, relistToClass(subject(object))))\n          })\n",
        "ViewsList-class.R": "### =========================================================================\n### ViewsList objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"ViewsList\",\n    contains=\"IntegerRangesList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"Views\")\n)\n\nsetClass(\"SimpleViewsList\",\n    contains=c(\"ViewsList\", \"SimpleList\"),\n    representation(\"VIRTUAL\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods.\n###\n\nsetMethod(\"ranges\", \"SimpleViewsList\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n        S4Vectors:::new_SimpleList_from_list(\"SimpleIRangesList\",\n            lapply(x, ranges, use.names=use.names, use.mcols=use.mcols))\n)\n\nsetMethod(\"start\", \"SimpleViewsList\", function(x, ...) start(ranges(x)))\nsetMethod(\"end\", \"SimpleViewsList\", function(x, ...) end(ranges(x)))\nsetMethod(\"width\", \"SimpleViewsList\", function(x) width(ranges(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetMethod(\"as.matrix\", \"ViewsList\",\n          function(x, rev = FALSE, use.names = FALSE)\n          {\n            if (!isTRUEorFALSE(use.names))\n              stop(\"use.names must be TRUE or FALSE\")\n            if (!is(rev, \"List\"))\n              rev <- as(rev, \"List\")\n            rev <- S4Vectors:::VH_recycle(rev, x, \"rev\", \"x\")\n            max_width <- max(max(width(restrict(ranges(x), start = 1L))))\n            m <- do.call(rbind, mapply(as.matrix, x, rev,\n                                       IntegerList(max_width),\n                                       SIMPLIFY = FALSE))\n            nms <- names(x)\n            if (!is.null(nms) && use.names) {\n              nms <- rep(nms, elementNROWS(x))\n              rownms <- rownames(m)\n              if (is.null(rownms))\n                rownms <- unlist_as_integer(IRanges(1L, width=elementNROWS(x)))\n              rownames(m) <- paste(nms, rownms, sep = \".\")\n            }\n            m\n          })\n",
        "cbind-Rle-methods.R": "### =========================================================================\n### Binding Rle or RleList objects together\n### -------------------------------------------------------------------------\n\n\n### Return a DataFrame object with 1 row per run. Its first column is\n### \"runLength\" and is followed by 1 column per supplied Rle object.\nsetMethod(\"cbind\", \"Rle\",\n    function(...)\n    {\n        args <- list(...)\n        args_names <- names(args)\n        if (is.null(args_names)) {\n            noname_idx <- seq_along(args)\n        } else {\n            noname_idx <- which(args_names %in% c(\"\", NA_character_))\n        }\n        if (length(noname_idx) != 0L)\n            names(args)[noname_idx] <- paste0(\"V\", noname_idx)\n        ## TODO: Call disjoin() with 'with.revmap=TRUE' and use the revmap\n        ## to avoid the call to findOverlaps() below.\n        ans_runs <- disjoin(do.call(c, unname(lapply(args, ranges))))\n        DataFrame(\n            runLength=width(ans_runs),\n            DataFrame(\n                lapply(args, function(x) {\n                    run_idx <- findOverlaps(ans_runs, ranges(x), type=\"within\",\n                                            select=\"arbitrary\")\n                    runValue(x)[run_idx]\n                })\n            )\n        )\n    }\n)\n\n### The supplied RleList objects are recycled the \"mapply way\" if necessary.\n### Return a CompressedSplitDataFrameList object parallel to the longest\n### supplied RleList object.\nsetMethod(\"cbind\", \"RleList\",\n    function(...)\n    {\n        args <- list(...)\n        DF_list <- do.call(mapply, c(list(cbind), args, list(SIMPLIFY=FALSE)))\n        as(DF_list, \"CompressedSplitDataFrameList\")\n    }\n)\n\n",
        "coverage-methods.R": "### =========================================================================\n### coverage()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .coverage_IRanges() and coverage_CompressedIRangesList()\n###\n### These 2 internal helpers are the workhorses behind most \"coverage\"\n### methods. All the hard work is almost entirely performed at the C level.\n### Only some argument checking/normalization plus the \"folding\" of the\n### result are performed in R.\n###\n\n.fold_and_truncate_coverage <- function(cvg, circle.length, width)\n{\n    cvg <- fold(cvg, circle.length)\n    if (is.na(width))\n        return(cvg)\n    head(cvg, n=width)\n}\n\n### Returns an Rle object.\n.coverage_IRanges <- function(x, shift=0L, width=NULL,\n                                 weight=1L, circle.length=NA,\n                                 method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n{\n    ## Check 'x'.\n    if (!is(x, \"IRanges\"))\n        stop(\"'x' must be an IRanges object\")\n\n    ## 'shift' will be checked at the C level.\n    if (is(shift, \"Rle\"))\n        shift <- S4Vectors:::decodeRle(shift)\n\n    ## Check 'width'.\n    if (is.null(width)) {\n        width <- NA_integer_\n    } else if (!isSingleNumberOrNA(width)) {\n        stop(\"'width' must be NULL or a single integer\")\n    } else if (!is.integer(width)) {\n        width <- as.integer(width)\n    }\n\n    ## 'weight' will be checked at the C level.\n    if (is(weight, \"Rle\"))\n        weight <- S4Vectors:::decodeRle(weight)\n\n    ## Check 'circle.length'.\n    if (!isSingleNumberOrNA(circle.length))\n        stop(\"'circle.length' must be a single integer\")\n    if (!is.integer(circle.length))\n        circle.length <- as.integer(circle.length)\n\n    ## Check 'method'.\n    method <- match.arg(method)\n\n    ## Ready to go...\n    ans <- .Call2(\"C_coverage_IRanges\", x,\n                                        shift, width,\n                                        weight, circle.length,\n                                        method,\n                                        PACKAGE=\"IRanges\")\n\n    if (is.na(circle.length))\n        return(ans)\n    .fold_and_truncate_coverage(ans, circle.length, width)\n}\n\n### Return an ordinary list.\n.normarg_shift_or_weight_list <- function(arg, argname)\n{\n    if (!is.list(arg)) {\n        if (!(is.numeric(arg) ||\n              (is(arg, \"Rle\") && is.numeric(runValue(arg))) ||\n              is(arg, \"List\")))\n            stop(\"'\", argname, \"' must be a numeric vector \",\n                 \"or a list-like object\")\n        arg <- as.list(arg)\n    }\n    if (length(arg) != 0L) {\n        idx <- which(sapply(arg, is, \"Rle\"))\n        if (length(idx) != 0L)\n            arg[idx] <- lapply(arg[idx], S4Vectors:::decodeRle)\n    }\n    arg\n}\n\n.check_arg_names <- function(arg, argname, x_names, x_names.label)\n{\n    arg_names <- names(arg)\n    if (!(is.null(arg_names) || identical(arg_names, x_names)))\n        stop(\"when '\", argname, \"' has names, \",\n             \"they must be identical to \", x_names.label)\n}\n\n## Some packages like easyRNASeq or TEQC pass 'width' as a named list-like\n## object where each list element is a single number, an NA, or a NULL, when\n## calling coverage() on an IntegerRangesList object. They do so because, for\n## whatever reason, we've been supporting this for a while. However, it never\n## really made sense to support a named list-like object for 'width'.\n## TODO: Deprecate support for this. Preferred 'width' form: NULL or an\n## integer vector. An that's it.\n.unlist_width <- function(width, x_names, x_names.label)\n{\n    if (!identical(names(width), x_names))\n        stop(\"when 'width' is a list-like object, it must be named \",\n             \"and its names must be identical to \", x_names.label)\n    width_eltNROWS <- elementNROWS(width)\n    if (!all(width_eltNROWS <= 1L))\n        stop(\"when 'width' is a list-like object, each list element \",\n             \"should contain at most 1 element or be NULL\")\n    width[width_eltNROWS == 0L] <- NA_integer_\n    setNames(unlist(width, use.names=FALSE), x_names)\n}\n\n### NOT exported but used in the GenomicRanges package.\n### Return a SimpleRleList object of the length of 'x'.\ncoverage_CompressedIRangesList <-\n        function(x, shift=0L, width=NULL,\n                    weight=1L, circle.length=NA,\n                    method=c(\"auto\", \"sort\", \"hash\", \"naive\"),\n                    x_names.label=\"'x' names\")\n{\n    ## Check 'x'.\n    if (!is(x, \"CompressedIRangesList\"))\n        stop(\"'x' must be a CompressedIRangesList object\")\n    x_names <- names(x)\n\n    ## Check and normalize 'shift'.\n    shift <- .normarg_shift_or_weight_list(shift, \"shift\")\n    .check_arg_names(shift, \"shift\", x_names, x_names.label)\n\n    ## Check and normalize 'width'.\n    if (is.null(width)) {\n        width <- NA_integer_\n    } else {\n        if (is.numeric(width)) {\n            .check_arg_names(width, \"width\", x_names, x_names.label)\n        } else if (is.list(width) || is(width, \"List\")) {\n            width <- .unlist_width(width, x_names, x_names.label)\n        } else {\n            ## We purposedly omit to mention that 'width' can also be a named\n            ## list-like object because this will be deprecated soon (this is\n            ## why it's not documented in man/coverage-methods.Rd either).\n            stop(\"'width' must be NULL or an integer vector\")\n        }\n        if (!is.integer(width))\n            width <- setNames(as.integer(width), names(width))\n    }\n\n    ## Check and normalize 'weight'.\n    weight <- .normarg_shift_or_weight_list(weight, \"weight\")\n    .check_arg_names(weight, \"weight\", x_names, x_names.label)\n\n    ## Check and normalize 'circle.length'.\n    if (identical(circle.length, NA)) {\n        circle.length <- NA_integer_\n    } else if (!is.numeric(circle.length)) {\n        stop(\"'circle.length' must be an integer vector\")\n    } else if (!is.integer(circle.length)) {\n        circle.length <- setNames(as.integer(circle.length),\n                                  names(circle.length))\n    }\n    .check_arg_names(circle.length, \"circle.length\", x_names, x_names.label)\n\n    ## Check and normalize 'method'.\n    method <- match.arg(method)\n\n    ## Ready to go...\n    ans_listData <- .Call2(\"C_coverage_CompressedIRangesList\", x,\n                           shift, width,\n                           weight, circle.length,\n                           method,\n                           PACKAGE=\"IRanges\")\n\n    ## \"Fold\" the coverage vectors in 'ans_listData' associated with a\n    ## circular sequence.\n    ## Note that the C code should have raised an error or warning already if\n    ## the length of 'circle.length' or 'width' didn't allow proprer recycling\n    ## to the length of 'x'. So using silent 'rep( , length.out=length(x))' is\n    ## safe.\n    circle.length <- rep(circle.length, length.out=length(x))\n    fold_idx <- which(!is.na(circle.length))\n    if (length(fold_idx) != 0L) {\n        width <- rep(width, length.out=length(x))\n        ## Because we \"fold\" the coverage vectors in an lapply() loop, it will\n        ## be inefficient if 'x' has a lot of list elements associated with a\n        ## circular sequence.\n        ans_listData[fold_idx] <- lapply(fold_idx,\n            function(i)\n                .fold_and_truncate_coverage(ans_listData[[i]],\n                                            circle.length[i],\n                                            width[i]))\n    }\n\n    names(ans_listData) <- names(x)\n    S4Vectors:::new_SimpleList_from_list(\"SimpleRleList\", ans_listData,\n                                         metadata=metadata(x),\n                                         mcols=mcols(x, use.names=FALSE))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### coverage() generic and methods.\n###\n\nsetGeneric(\"coverage\", signature=\"x\",\n    function(x, shift=0L, width=NULL, weight=1L, ...)\n        standardGeneric(\"coverage\")\n)\n\n### NOT exported but used in the GenomicRanges package.\nreplace_with_mcol_if_single_string <- function(arg, x)\n{\n    if (!isSingleString(arg))\n        return(arg)\n    x_mcols <- mcols(x, use.names=FALSE)\n    j <- which(colnames(x_mcols) == arg)\n    if (length(j) == 0L)\n        stop(wmsg(\"'mcols(x)' has no \\\"\", arg, \"\\\" column\"))\n    if (length(j) > 1L)\n        stop(wmsg(\"'mcols(x)' has more than one \\\"\", arg, \"\\\" column\"))\n    x_mcols[[j]]\n}\n\nsetMethod(\"coverage\", \"IntegerRanges\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        shift <- replace_with_mcol_if_single_string(shift, x)\n        weight <- replace_with_mcol_if_single_string(weight, x)\n        .coverage_IRanges(as(x, \"IRanges\"),\n                          shift=shift, width=width, weight=weight,\n                          method=method)\n    }\n)\n\n### Overwrite above method with optimized method for StitchedIPos objects.\nsetMethod(\"coverage\", \"StitchedIPos\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        CAN_ONLY_ETC <- c(\" can only be a single number when \",\n                          \"calling coverage() on a StitchedIPos object\")\n        if (!isSingleNumber(shift))\n            stop(wmsg(\"'shift'\", CAN_ONLY_ETC))\n        if (!isSingleNumber(weight))\n            stop(wmsg(\"'weight'\", CAN_ONLY_ETC))\n        x <- x@pos_runs\n        callGeneric()\n    }\n)\n\nsetMethod(\"coverage\", \"Views\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        if (is.null(width))\n            width <- length(subject(x))\n        coverage(as(x, \"IRanges\"),\n                 shift=shift,\n                 width=width,\n                 weight=weight,\n                 method=method)\n    }\n)\n\nsetMethod(\"coverage\", \"IntegerRangesList\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        x_mcols <- mcols(x, use.names=FALSE)\n        x_mcolnames <- colnames(x_mcols)\n        if (isSingleString(shift)) {\n            if (!(shift %in% x_mcolnames))\n                stop(\"the string supplied for 'shift' (\\\"\", shift, \"\\\")\",\n                     \"is not a valid metadata column name of 'x'\")\n            shift <- x_mcols[[shift]]\n        }\n        if (isSingleString(width)) {\n            if (!(width %in% x_mcolnames))\n                stop(\"the string supplied for 'width' (\\\"\", width, \"\\\")\",\n                     \"is not a valid metadata column name of 'x'\")\n            width <- x_mcols[[width]]\n        }\n        if (isSingleString(weight)) {\n            if (!(weight %in% x_mcolnames))\n                stop(\"the string supplied for 'weight' (\\\"\", weight, \"\\\")\",\n                     \"is not a valid metadata column name of 'x'\")\n            weight <- x_mcols[[weight]]\n        }\n        coverage_CompressedIRangesList(as(x, \"CompressedIRangesList\"),\n                                       shift=shift, width=width,\n                                       weight=weight,\n                                       method=method)\n    }\n)\n\n",
        "cvg-methods.R": "### =========================================================================\n### cvg()\n### -------------------------------------------------------------------------\n###\n### A better coverage().\n###\n### It all started when I came across this:\n### https://stackoverflow.com/questions/17138760/counting-overlaps-of-integer-ranges\n###\n\nsetGeneric(\"cvg\", signature=\"x\",\n    function(x, from=NA, to=NA, weight=1L, varname=\"cvg\", collapse=FALSE, ...)\n        standardGeneric(\"cvg\")\n)\n\n### TODO: Methods for IntegerRanges and IntegerRangesList objects (defined in\n### this file) need to support the 'circle.length' argument.\n### TODO: Implement method for GenomicRanges objects (in GenomicRanges package).\n### Should it support the 'ignore.strand' argument?\n### TODO: The end user should be able to switch between collapsed and expanded\n### representation by calling collapse() and expand() on the returned object.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Restriction window helpers\n###\n### Use these helpers in the \"restrict\" and \"gaps\" methods.\n###\n### Should we turn these helpers into methods of a generic function?\n### Like effectiveRestrictionWindow()? or effectiveFromTo()?\n### Also maybe export and document them so the user can actually use them\n### to see what effective restriction windows are being used and also see\n### the invalid windows causing an error (by calling\n### effectiveRestrictionWindow() with check=FALSE).\n###\n\n### Return an integer vector of length 2.\neffective_restriction_window_for_IntegerRanges <-\n    function(x, from=NA, to=NA, check=TRUE)\n{\n    stopifnot(is(x, \"IntegerRanges\"),\n              isSingleNumberOrNA(from),\n              isSingleNumberOrNA(to))\n    if (!is.integer(from))\n        from <- as.integer(from)\n    if (!is.integer(to))\n        to <- as.integer(to)\n    if (is.na(from) || is.na(to)) {\n        if (length(x) == 0L)\n            return(c(from=from, to=to))\n        x_range <- range(x)\n        if (is.na(from))\n            from <- start(x_range)\n        if (is.na(to))\n            to <- end(x_range)\n    }\n    if (check) {\n        width <- to - from + 1L\n        if (width < 0L)\n            stop(wmsg(\"invalid from-to: \", from, \"-\", to))\n    }\n    c(from=from, to=to)\n}\n\n### Return an N x 2 integer matrix where N is length(x).\neffective_restriction_windows_for_IntegerRangesList <-\n    function(x, from=NA, to=NA, check=TRUE)\n{\n    stopifnot(is(x, \"IntegerRangesList\"),\n              is.numeric(from) || is.logical(from) && all(is.na(from)),\n              is.numeric(to) || is.logical(to) && all(is.na(to)))\n    if (!is.integer(from))\n        from <- as.integer(from)\n    if (!is.integer(to))\n        to <- as.integer(to)\n    from <- S4Vectors:::V_recycle(from, x, \"from\", \"x\")\n    to <- S4Vectors:::V_recycle(to, x, \"to\", \"x\")\n    x_range <- range(x)\n    na_idx <- which(is.na(from))\n    from[na_idx] <- as.integer(start(x_range))[na_idx]\n    na_idx <- which(is.na(to))\n    to[na_idx] <- as.integer(end(x_range))[na_idx]\n    if (check) {\n        width <- to - from + 1L\n        if (any(width < 0L, na.rm=TRUE))\n            stop(wmsg(\"some of the restriction windows defined by the \",\n                      \"supplied 'from' and 'to' have a negative width\"))\n    }\n    cbind(from=from, to=to)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"cvg\" methods\n###\n\n### Takes an IntegerRanges derivative 'x' and returns its coverage as the\n### metadata column of an IPos object by default. If 'collapse' is TRUE',\n### the coverage is returned in an IRanges object instead.\n### The 'from' and 'to' arguments control the window of integer positions\n### for which to compute and return coverage.\n### Each of these arguments must be a single integer or NA. When set to NA\n### (the default), 'from' is replaced internally with 'min(start(x))',\n### and 'to' with 'max(end(x))'.\n### All the integer positions in the from-to window are represented in the\n### returned object. More precisely, the returned IPos or IRanges 'ans' is\n### disjoint, strictly sorted, and with no gaps between the ranges, and its\n### ranges span the from-to window (i.e. 'reduce(ans)' will return the single\n### range from-to). In particular, when 'ans' is an IPos object, 'pos(ans)'\n### returns the from:to sequence.\ncvg_IntegerRanges <- function(x, from=NA, to=NA, weight=1L,\n                                 varname=\"cvg\", collapse=FALSE)\n{\n    stopifnot(isSingleString(varname), isTRUEorFALSE(collapse))\n    from_to <- effective_restriction_window_for_IntegerRanges(x, from, to)\n    shift <- 1L - from_to[[1L]]\n    width <- from_to[[2L]] + shift\n    if (length(x) == 0L) {\n        if (is.na(width) || width == 0L) {\n            ans <- IRanges()\n        } else {\n            ans <- IRanges(from_to[[1L]], width=width)\n        }\n        ## 'weight' determines the type of Rle.\n        cvg0 <- Rle(weight * 0L, sum(width(ans)))\n    } else {\n        ## Compute coverage as an Rle object.\n        cvg0 <- coverage(x, shift=shift, width=width, weight=weight)\n        ans_width <- runLength(cvg0)\n        ans_end <- cumsum(ans_width) - shift\n        ans <- IRanges(end=ans_end, width=ans_width)\n    }\n    if (collapse) {\n        var <- runValue(cvg0)\n    } else {\n        ans <- new_StitchedIPos(ans)\n        var <- cvg0\n    }\n    mcols(ans) <- S4Vectors:::new_DataFrame(setNames(list(var), varname))\n    ans\n}\n\n### Takes an IntegerRangesList derivative 'x' and returns its coverage as the\n### inner metadata column of an IPosList object by default. If 'collapse' is\n### TRUE, the coverage is returned in an IRangesList object instead.\n### The 'from' and 'to' arguments control the windows of integer positions\n### for which to compute and return coverage.\n### Each of these arguments must be an integer vector parallel to 'x',\n### possibly with NAs. If shorter than 'x', they'll be recycled to the length\n### of 'x'.\n### The object to return is computed with a fast implementation of\n###\n###     mapply(cvg_IntegerRanges, x, from, to, weight,\n###            MoreArgs=list(varname=varname, collapse=collapse))\n###\n### and then returned as an IPosList or IRangesList, obeying 'collapse'.\ncvg_IntegerRangesList <- function(x, from=NA, to=NA, weight=1L,\n                                     varname=\"cvg\", collapse=FALSE)\n{\n    stopifnot(isSingleString(varname), isTRUEorFALSE(collapse))\n    from_to <- effective_restriction_windows_for_IntegerRangesList(x, from, to)\n    shift <- 1L - unname(from_to[ , 1L])\n    width <- unname(from_to[ , 2L]) + shift\n    ## Compute coverage as a SimpleRleList object.\n    cvg0 <- coverage(x, shift=shift, width=width, weight=weight)\n    ans_width <- as(runLength(cvg0), \"CompressedIntegerList\")\n    ans_end <- as(cumsum(ans_width), class(ans_width)) - shift\n    unlisted_ans <- IRanges(end=unlist(ans_end, use.names=FALSE),\n                            width=unlist(ans_width, use.names=FALSE))\n    if (collapse) {\n        var <- unlist(runValue(cvg0), use.names=FALSE)\n    } else {\n        unlisted_ans <- new_StitchedIPos(unlisted_ans)\n        if (length(cvg0) == 0L) {\n            ## 'weight' determines the type of Rle.\n            var <- Rle(weight * 0L, 0L)\n        } else {\n            var <- unlist(cvg0, use.names=FALSE)\n        }\n    }\n    mcols(unlisted_ans) <- S4Vectors:::new_DataFrame(\n                               setNames(list(var), varname))\n    if (collapse) {\n        ans <- relist(unlisted_ans, ans_width)\n    } else {\n        ans <- relist(unlisted_ans, cvg0)\n    }\n    ans\n}\n\nsetMethod(\"cvg\", \"IntegerRanges\", cvg_IntegerRanges)\nsetMethod(\"cvg\", \"IntegerRangesList\", cvg_IntegerRangesList)\n\n",
        "extractList.R": "### =========================================================================\n### Group elements of a vector-like object into a list-like object\n### -------------------------------------------------------------------------\n###\n### What should go in this file?\n###\n### - All \"relist\" methods defined in IRanges should go here.\n### - extractList() generic and default method.\n###\n### TODO: Maybe put the default methods for the reverse transformations here\n### (unlist, unsplit, and unsplit<-).\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### relist()\n###\n\nsetMethod(\"relist\", c(\"ANY\", \"PartitioningByEnd\"),\n    function(flesh, skeleton)\n    {\n        ans_class <- relistToClass(flesh)\n        skeleton_len <- length(skeleton)\n        if (skeleton_len == 0L) {\n            flesh_len2 <- 0L\n        } else {\n            flesh_len2 <- end(skeleton)[skeleton_len]\n        }\n        if (NROW(flesh) != flesh_len2)\n            stop(\"shape of 'skeleton' is not compatible with 'NROW(flesh)'\")\n        if (extends(ans_class, \"CompressedList\"))\n            return(newCompressedList0(ans_class, flesh, skeleton))\n        if (!extends(ans_class, \"SimpleList\"))\n            stop(\"don't know how to split or relist a \", class(flesh),\n                 \" object as a \", ans_class, \" object\")\n        listData <- lapply(skeleton, function(i) extractROWS(flesh, i))\n\n        ## TODO: Once \"window\" methods have been revisited/tested and\n        ## 'window(flesh, start=start, end=end)' is guaranteed to do the\n        ## right thing for any 'flesh' object (in particular it subsets a\n        ## data.frame-like object along the rows), then replace the line above\n        ## by the code below (which should be more efficient):\n\n        #skeleton_start <- start(skeleton)\n        #skeleton_end <- end(skeleton)\n        #FUN <- function(start, end) window(flesh, start=start, end=end)\n        #names(skeleton_start) <- names(skeleton)\n        #listData <- mapply(FUN, skeleton_start, skeleton_end)\n\n        ## or, if we don't trust mapply():\n\n        #skeleton_start <- start(skeleton)\n        #skeleton_end <- end(skeleton)\n        #X <- seq_len(skeleton_len)\n        #names(X) <- names(skeleton)\n        #listData <- lapply(X, function(i) window(flesh,\n        #                                         start=skeleton_start[i],\n        #                                         end=skeleton_end[i]))\n\n        S4Vectors:::new_SimpleList_from_list(ans_class, listData)\n    }\n)\n\nsetMethod(\"relist\", c(\"ANY\", \"List\"),\n    function(flesh, skeleton)\n    {\n        relist(flesh, PartitioningByEnd(skeleton))\n    }\n)\n\nsetMethod(\"relist\", c(\"Vector\", \"list\"),\n    function(flesh, skeleton)\n    {\n        relist(flesh, PartitioningByEnd(skeleton))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### default_splitAsList()\n###\n\n### Equivalent to 'setNames(splitAsList(unname(x), seq_along(x)), names(x))'\n### but slightly faster (e.g. twice faster on 'IRanges(1, 1:500000)').\n.dumb_splitAsList <- function(x)\n{\n    f <- PartitioningByEnd(seq_along(x), names=names(x))\n    relist(unname(x), f)\n}\n\n### 'f' is assumed to be an integer vector with no NAs.\n.splitAsList_by_integer <- function(x, f, drop)\n{\n    if (length(f) > NROW(x))\n        stop(\"'f' cannot be longer than 'NROW(x)' when it's an integer vector\")\n    if (!identical(drop, FALSE))\n        warning(\"'drop' is ignored when 'f' is an integer vector\")\n    f_is_not_sorted <- S4Vectors:::isNotSorted(f)\n    if (f_is_not_sorted) {\n        idx <- base::order(f)\n        f <- f[idx]\n        x <- extractROWS(x, idx)\n    }\n    tmp <- Rle(f)\n    f <- cumsum(runLength(tmp))\n    names(f) <- as.character(runValue(tmp))\n    f <- PartitioningByEnd(f)\n    relist(x, f)\n}\n\n### 'f' is assumed to be a factor with no NAs.\n.splitAsList_by_factor <- function(x, f, drop)\n{\n    x_NROW <- NROW(x)\n    f_len <- length(f)\n    f_levels <- levels(f)\n    f <- as.integer(f)\n    if (f_len > x_NROW)\n        f <- head(f, n=x_NROW)\n    f_is_not_sorted <- S4Vectors:::isNotSorted(f)\n    if (f_is_not_sorted) {\n        idx <- base::order(f)\n        x <- extractROWS(x, idx)\n    }\n    f <- tabulate(f, nbins=length(f_levels))\n    names(f) <- f_levels\n    if (drop)\n        f <- f[f != 0L]\n    f <- cumsum(f)\n    f <- PartitioningByEnd(f)\n    relist(x, f)\n}\n\n### 'f' is assumed to be an integer-Rle object with no NAs.\n.splitAsList_by_integer_Rle <- function(x, f, drop)\n{\n    if (length(f) > NROW(x))\n        stop(\"'f' cannot be longer than data when it's an integer-Rle\")\n    if (!identical(drop, FALSE))\n        warning(\"'drop' is ignored when 'f' is an integer-Rle\")\n    f_vals <- runValue(f)\n    f_lens <- runLength(f)\n    f_is_not_sorted <- S4Vectors:::isNotSorted(f_vals)\n    if (f_is_not_sorted) {\n        idx <- base::order(f_vals)\n        xranges <- successiveIRanges(f_lens)[idx]\n        f_vals <- f_vals[idx]\n        f_lens <- f_lens[idx]\n        x <- extractROWS(x, xranges)\n    }\n    tmp <- Rle(f_vals, f_lens)\n    f <- cumsum(runLength(tmp))\n    names(f) <- as.character(runValue(tmp))\n    f <- PartitioningByEnd(f)\n    relist(x, f)\n}\n\n### 'f' is assumed to be an Rle object with no NAs.\n.splitAsList_by_Rle <- function(x, f, drop)\n{\n    x_NROW <- NROW(x)\n    f_len <- length(f)\n    f_vals <- runValue(f)\n    if (!is.factor(f_vals)) {\n        f_vals <- as.factor(f_vals)\n        if (f_len > x_NROW) {\n            runValue(f) <- f_vals\n            f <- head(f, n=x_NROW)\n            f_vals <- runValue(f)\n        }\n    } else if (f_len > x_NROW) {\n        f <- head(f, n=x_NROW)\n        f_vals <- runValue(f)\n    }\n    f_lens <- runLength(f)\n    f_levels <- levels(f_vals)\n    f_vals <- as.integer(f_vals)\n    f_is_not_sorted <- S4Vectors:::isNotSorted(f_vals)\n    if (f_is_not_sorted) {\n        idx <- base::order(f_vals)\n        xranges <- successiveIRanges(f_lens)[idx]\n        x <- extractROWS(x, xranges)\n        f <- S4Vectors:::tabulate2(f_vals, nbins=length(f_levels),\n                                   weight=f_lens)\n        if (drop) {\n            f_levels <- f_levels[f != 0L]\n            f <- f[f != 0L]\n        }\n    } else if (length(f_vals) == length(f_levels) || drop) {\n        if (drop) f_levels <- as.character(runValue(f))\n        f <- f_lens\n    } else {\n        f <- integer(length(f_levels))\n        f[f_vals] <- f_lens\n    }\n    names(f) <- f_levels\n    f <- cumsum(f)\n    f <- PartitioningByEnd(f)\n    relist(x, f)\n}\n\n.to_factor <- function(x) {\n    if (is(x, \"Rle\")) {\n        runValue(x) <- as.factor(runValue(x))\n        x\n    } else as.factor(x)\n}\n\n### Took this out of the still-in-incubation LazyList package\n.interaction2 <- function(factors) {\n  nI <- length(factors)\n  nx <- length(factors[[1L]])\n  factors <- lapply(factors, .to_factor)\n  useRle <- any(vapply(factors, is, logical(1), \"Rle\"))\n  if (useRle) {\n    group <- as(factors[[1L]], \"Rle\")\n    runValue(group) <- as.integer(runValue(group))\n  } else {\n    group <- as.integer(factors[[1L]])\n  }\n  ngroup <- nlevels(factors[[1L]])\n  for (i in tail(seq_len(nI), -1L)) {\n    index <- factors[[i]]\n    if (useRle) {\n      offset <- as(index, \"Rle\")\n      runValue(offset) <- ngroup * (as.integer(runValue(offset)) - 1L)\n    } else {\n      offset <- ngroup * (as.integer(index) - 1L)\n    }\n    group <- group + offset\n    ngroup <- ngroup * nlevels(index)\n  }\n  if (useRle) {\n      runValue(group) <- structure(runValue(group),\n                                   levels=as.character(seq_len(ngroup)),\n                                   class=\"factor\")\n      group\n  } else {\n      structure(group, levels=as.character(seq_len(ngroup)), class=\"factor\")\n  }\n}\n\n.normarg_f <- function(f, x) {\n  if (is(f, \"formula\")) {\n    if (length(f) == 3L)\n      stop(\"formula 'f' should not have a left hand side\")\n    f <- S4Vectors:::formulaValues(x, f)\n  }\n  if (is.list(f) || is(f, \"List\")) {\n      if (length(f) == 1L) {\n          f <- .to_factor(f[[1L]])\n      } else {\n          f <- .interaction2(f)\n      }\n  }\n  f_len <- length(f)\n  if (f_len < NROW(x)) {\n    if (f_len == 0L)\n      stop(\"split factor has length 0 but 'NROW(x)' is > 0\")\n    if (NROW(x) %% f_len != 0L)\n      warning(\"'NROW(x)' is not a multiple of split factor length\")\n    f <- rep(f, length.out=NROW(x))\n  }\n  f\n}\n\n## about 3X faster than as.factor on a ~450k tx ids\n## caveats: no NAs, and radix sort of levels does not support all encodings\n## todo: Would be faster if sort() returned grouping info,\n##       but then we might coalesce this with the order/split.\n## todo: if we could pass na.rm=TRUE to grouping(), NAs would be handled\n.as_factor <- function(x) {\n    if (is.factor(x))\n        return(x)\n    if (is.null(x))\n        return(factor())\n    g <- grouping(x)\n    p <- PartitioningByEnd(relist(g))\n    levs <- as.character(x[g[end(p)]])\n    if (is.character(x)) {\n        o <- order(levs, method=\"radix\")\n        map <- integer(length(levs)) # or rep(NA_integer_, length(levs)) for NAs\n        map[o] <- seq_along(o)\n        ref <- map[togroup(p)]\n        levs <- levs[o]\n    } else {\n        ref <- togroup(p)\n    }\n    f <- integer(length(x))\n    f[g] <- ref\n    structure(f, levels=levs, class=\"factor\")\n}\n\n### Called by the splitAsList,ANY,ANY method defined in the S4Vectors package.\ndefault_splitAsList <- function(x, f, drop=FALSE)\n{\n    if (!isTRUEorFALSE(drop))\n        stop(\"'drop' must be TRUE or FALSE\")\n\n    if (missing(f))\n        return(.dumb_splitAsList(x))\n\n    f <- .normarg_f(f, x)\n    if (anyNA(f)) {\n        keep_idx <- which(!is.na(f))\n        x <- extractROWS(x, keep_idx)\n        f <- f[keep_idx]\n    }\n\n    if (is.integer(f))\n        return(.splitAsList_by_integer(x, f, drop))\n    if (!is(f, \"Rle\")) {\n        f <- .as_factor(f)\n        return(.splitAsList_by_factor(x, f, drop))\n    }\n    ## From now on, 'f' is guaranteed to be an Rle.\n    f_vals <- runValue(f)\n    if (!((is.vector(f_vals) && is.atomic(f_vals)) || is.factor(f_vals)))\n        stop(\"'f' must be an atomic vector or a factor (possibly in Rle form)\")\n    if (is.integer(f_vals))\n        return(.splitAsList_by_integer_Rle(x, f, drop))\n    return(.splitAsList_by_Rle(x, f, drop))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extractList()\n###\n### Would extractGroups be a better name for this?\n### Or extractGroupedROWS? (analog to extractROWS, except that the ROWS are\n### grouped).\n###\n\n### 'x' must be a vector-like object and 'i' a list-like object.\n### Must return a list-like object parallel to 'i' and with same \"shape\" as\n### 'i' (i.e. same elementNROWS). If 'i' has names, they should be\n### propagated to the returned value. The list elements of the returned value\n### must have the class of 'x'.\nsetGeneric(\"extractList\", function(x, i) standardGeneric(\"extractList\"))\n\n### Default method.\nsetMethod(\"extractList\", c(\"ANY\", \"ANY\"),\n    function(x, i)\n    {\n        if (is(i, \"IntegerRanges\"))\n            return(relist(extractROWS(x, i), i))\n        if (is.list(i)) {\n            unlisted_i <- unlist(i, recursive=FALSE, use.names=FALSE)\n        } else {\n            i <- as(i, \"List\", strict=FALSE)\n            ## The various \"unlist\" methods for List derivatives don't know\n            ## how to operate recursively and don't support the 'recursive'\n            ## arg.\n            unlisted_i <- unlist(i, use.names=FALSE)\n        }\n        relist(extractROWS(x, unlisted_i), i)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### resplit() and regroup()\n###\n### Similar to regroupBySupergroup() but there is no assumption that\n### the new grouping is a super-grouping of the current grouping. For\n### resplit(), the grouping is expressed as a factor, although it is\n### effectively a synonym of regroup(), since the latter coerces the\n### input to a Grouping.\n###\n\nresplit <- function(x, f) {\n    regroup(x, f)\n}\n\nregroup <- function(x, g) {\n    g <- as(g, \"Grouping\")\n    gends <- end(PartitioningByEnd(g))\n    xg <- x[unlist(g, use.names=FALSE)]\n    p <- PartitioningByEnd(end(PartitioningByEnd(xg))[gends])\n    names(p) <- names(g)\n    relist(unlist(xg, use.names=FALSE, recursive=FALSE), p)\n}\n\n",
        "extractListFragments.R": "### =========================================================================\n### extractListFragments()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### regroupBySupergroup()\n###\n### A very efficient way to concatenate groups of successive list elements\n### in 'x'.\n### 'x' must be a list-like object (typically a CompressedList object).\n### 'supergroups' must be an object that defines a partitioning of\n### 'seq_along(x)' (i.e. it could be used to do\n### 'relist(seq_along(x), supergroups)'). It will be immediately replaced with\n### 'PartitioningByEnd(supergroups)' so it should be an object that is\n### accepted by the PartitioningByEnd() constructor (note that this constructor\n### is a no-op if 'supergroups' is already a PartitioningByEnd object).\n### Return a list-like object of the same elementType() as 'x' and parallel\n### to 'supergroups'. The names on 'supergroups' are propagated but not the\n### metadata columns.\n###\n### Some properties:\n### - Behaves as an endomorphism on a CompressedList or PartitioningByEnd\n###   object.\n### - This\n###       regroupBySupergroup(x, length(x))[[1L]]\n###   is equivalent to\n###       unlist(x, use.names=FALSE)\n###\n### Other possible names for regroupBySupergroup: regroup,\n### mergeGroupsInSupergroups, combineGroupsOfListElements,\n### unlistGroupsOfListElements, unlistBySupergroup.\n###\n### TODO: Maybe export and document this?\n\nregroupBySupergroup <- function(x, supergroups)\n{\n    supergroups <- PartitioningByEnd(supergroups)\n    x_breakpoints <- end(PartitioningByEnd(x))\n    ans_breakpoints <- x_breakpoints[end(supergroups)]\n    nleading0s <- length(supergroups) - length(ans_breakpoints)\n    if (nleading0s != 0L)\n        ans_breakpoints <- c(rep.int(0L, nleading0s), ans_breakpoints)\n    ans_partitioning <- PartitioningByEnd(ans_breakpoints,\n                                          names=names(supergroups))\n    if (is(x, \"PartitioningByEnd\"))\n        return(ans_partitioning)\n    relist(unlist(x, use.names=FALSE), ans_partitioning)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extractListFragments()\n###\n\nINCOMPATIBLE_ARANGES_MSG <- c(\n    \"'aranges' is incompatible with the cumulated \",\n    \"length of all the list elements in 'x'\"\n)\n\n### If 'hits.only' is FALSE (the default), return a Partitioning object of\n### the same class as 'x' (endomorphism). Otherwise, return a list of 2\n### integer vectors of the same length.\n.extractPartitioningFragments_by_Partitioning <- function(x, aranges,\n                              hits.only=FALSE,\n                              msg.if.incompatible=INCOMPATIBLE_ARANGES_MSG)\n{\n    if (!is(x, \"Partitioning\"))\n        stop(wmsg(\"'x' must be a Partitioning object\"))\n    if (!is(aranges, \"Partitioning\"))\n        stop(wmsg(\"'aranges' must be a Partitioning object\"))\n    if (!isTRUEorFALSE(hits.only))\n        stop(wmsg(\"'hits.only' must be TRUE or FALSE\"))\n    if (!is.character(msg.if.incompatible))\n        stop(wmsg(\"'msg.if.incompatible' must be a character vector\"))\n    x_end <- end(x)\n    aranges_end <- end(aranges)\n    if (S4Vectors:::last_or(x_end, 0L) !=\n        S4Vectors:::last_or(aranges_end, 0L))\n        stop(wmsg(msg.if.incompatible))\n    C_ans <- .Call2(\"C_find_partition_overlaps\",\n                    x_end, aranges_end, !hits.only, PACKAGE=\"IRanges\")\n    if (hits.only)\n        return(C_ans)\n    revmap <- C_ans[[1L]]\n    revmap2 <- C_ans[[2L]]\n    ans_names <- names(x)[revmap]\n    ans <- new2(\"PartitioningByEnd\", end=C_ans[[3L]], NAMES=ans_names,\n                                     check=FALSE)\n    ans <- as(ans, class(x))\n    mcols(ans) <- DataFrame(revmap=revmap, revmap2=revmap2)\n    ans\n}\n\n.extractListFragments_by_Partitioning <- function(x, aranges,\n                      use.mcols=FALSE,\n                      msg.if.incompatible=INCOMPATIBLE_ARANGES_MSG)\n{\n    if (is(x, \"Partitioning\")) {\n        ans <- .extractPartitioningFragments_by_Partitioning(x, aranges,\n                                   msg.if.incompatible=msg.if.incompatible)\n        if (use.mcols) {\n            revmap <- mcols(ans, use.names=FALSE)[ , \"revmap\"]\n            mcols(ans) <- mcols(x, use.names=FALSE)[revmap, , drop=FALSE]\n        }\n        return(ans)\n    }\n    if (!is(x, \"List\")) {\n        if (!is.list(x))\n            stop(wmsg(\"'x' must be a list-like object\"))\n        if (!use.mcols)\n            stop(wmsg(\"'use.mcols' must be set to TRUE \",\n                      \"when 'x' is an ordinary list\"))\n    }\n    ## Will work out-of-the box on any List derivative 'x' that supports [\n    ## and windows() e.g. all the AtomicList derivatives, IRanges, GRanges,\n    ## DNAStringSet, DNAStringSetList, GAlignments, GAlignmentsList objects\n    ## and more...\n    x_partitioning <- PartitioningByEnd(x)\n    hits <- .extractPartitioningFragments_by_Partitioning(\n                                   x_partitioning, aranges,\n                                   hits.only=TRUE,\n                                   msg.if.incompatible=msg.if.incompatible)\n    revmap <- hits[[1L]]\n    revmap2 <- hits[[2L]]\n    ans <- x[revmap]\n    if (!use.mcols)\n        mcols(ans) <- DataFrame(revmap=revmap, revmap2=revmap2)\n    Ltrim <- pmax(start(aranges)[revmap2] -\n                  start(x_partitioning)[revmap], 0L)\n    Rtrim <- pmax(end(x_partitioning)[revmap] -\n                  end(aranges)[revmap2], 0L)\n    windows(ans, start=1L+Ltrim, end=-1L-Rtrim)\n}\n\n### Return a PartitioningByEnd object of length 2 * length(aranges) + 1.\n.make_PartitioningByEnd_from_aranges <- function(aranges, x,\n                                                 msg.if.incompatible)\n{\n    if (!is(aranges, \"IntegerRanges\"))\n        stop(wmsg(\"'aranges' must be an IntegerRanges derivative \",\n                  \"(e.g. an IRanges object\"))\n\n    ## Check that 'aranges' is disjoint and sorted.\n    ## This is the case if and only if 'start_end' is sorted. If 'aranges'\n    ## is a NormalIRanges or Partitioning object, then it's disjoint and sorted\n    ## so we can skip this check.\n    start_end <- as.vector(\n        rbind(start(aranges) - 1L, end(aranges), deparse.level=0)\n    )\n    if (!is(aranges, \"NormalIRanges\") &&\n        !is(aranges, \"Partitioning\") &&\n        S4Vectors:::isNotSorted(start_end))\n        stop(wmsg(\"'aranges' must be disjoint and sorted\"))\n\n    ## Check that 'aranges' is compatible with 'x'.\n    x_cumlen <- nobj(PartitioningByEnd(x))\n    start_end_len <- length(start_end)  # = 2 * length(aranges)\n    if (start_end_len >= 2L &&\n        (start_end[[1L]] < 0L || start_end[[start_end_len]] > x_cumlen))\n        stop(wmsg(msg.if.incompatible))\n\n    ans_end <- c(start_end, x_cumlen)\n    new2(\"PartitioningByEnd\", end=ans_end, check=FALSE)\n}\n\n### Act as an endomorphism.\n### 'x' must be a list-like object.\n### 'aranges' must be an IntegerRanges object that is disjoint, sorted,\n### and compatible with the cumulated length of all the list elements in 'x'.\nextractListFragments <- function(x, aranges,\n                            use.mcols=FALSE,\n                            msg.if.incompatible=INCOMPATIBLE_ARANGES_MSG)\n{\n    if (!isTRUEorFALSE(use.mcols))\n        stop(wmsg(\"'use.mcols' must be TRUE or FALSE\"))\n    if (is(aranges, \"Partitioning\")) {\n        ans <- .extractListFragments_by_Partitioning(x, aranges,\n                                     use.mcols=use.mcols,\n                                     msg.if.incompatible=msg.if.incompatible)\n        return(ans)\n    }\n    aranges <- .make_PartitioningByEnd_from_aranges(aranges, x,\n                                               INCOMPATIBLE_ARANGES_MSG)\n    ans <- .extractListFragments_by_Partitioning(x, aranges,\n                                 msg.if.incompatible=msg.if.incompatible)\n    revmap2 <- mcols(ans, use.names=FALSE)[ , \"revmap2\"]\n    ans <- ans[revmap2 %% 2L == 0L]\n    if (use.mcols) {\n        revmap <- mcols(ans, use.names=FALSE)[ , \"revmap\"]\n        mcols(ans) <- mcols(x, use.names=FALSE)[revmap, , drop=FALSE]\n    } else {\n        mcols(ans)[ , \"revmap2\"] <- mcols(ans, use.names=FALSE)[ , \"revmap2\"] %/% 2L\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### equisplit()\n###\n### A simple wrapper to extractListFragments()\n###\n\n### Will work out-of-the box on any object 'x' that supports\n### extractListFragments() **and relist()** e.g. IRanges, GRanges,\n### DNAStringSet, GAlignments objects and more... Won't work on AtomicList\n### derivatives or DNAStringSetList or GAlignmentsList objects because they\n### don't support relist().\nequisplit <- function(x, nchunk, chunksize, use.mcols=FALSE)\n{\n    if (!isTRUEorFALSE(use.mcols))\n        stop(wmsg(\"'use.mcols' must be TRUE or FALSE\"))\n    x_cumlen <- nobj(PartitioningByEnd(x))\n    aranges <- breakInChunks(x_cumlen, nchunk=nchunk, chunksize=chunksize)\n    unlisted_ans <- extractListFragments(x, aranges)\n    unlisted_ans_mcols <- mcols(unlisted_ans, use.names=FALSE)\n    revmap <- unlisted_ans_mcols[ , \"revmap\"]\n    revmap2 <- unlisted_ans_mcols[ , \"revmap2\"]\n    if (use.mcols) {\n        mcols(unlisted_ans) <- mcols(x, use.names=FALSE)[revmap, , drop=FALSE]\n    } else {\n        mcols(unlisted_ans) <- DataFrame(revmap=revmap)\n    }\n    ans_partitioning <- PartitioningByEnd(revmap2, NG=length(aranges))\n    relist(unlisted_ans, ans_partitioning)\n}\n\n",
        "findOverlaps-methods.R": "### =========================================================================\n### findOverlaps (and related) methods\n### -------------------------------------------------------------------------\n###\n\n\n## internal generic\nsetGeneric(\"process_self_hits\",  signature=\"x\", # not exported\n    function(x, select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n                drop.self=FALSE, drop.redundant=FALSE)\n        standardGeneric(\"process_self_hits\"))\n\nsetMethod(\"process_self_hits\", \"SortedByQueryHits\",\n    function(x, select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n                drop.self=FALSE, drop.redundant=FALSE)\n    {\n        x <- as(x, \"SortedByQuerySelfHits\")\n        select <- match.arg(select)\n        if (!isTRUEorFALSE(drop.self))\n            stop(\"'drop.self' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(drop.redundant))\n            stop(\"'drop.redundant' must be TRUE or FALSE\")\n        if (drop.self) {\n            self_idx <- which(isSelfHit(x))\n            if (length(self_idx) != 0L)\n                x <- x[-self_idx]\n        }\n        if (drop.redundant) {\n            redundant_idx <- which(isRedundantHit(x))\n            if (length(redundant_idx) != 0L)\n                x <- x[-redundant_idx]\n        }\n        selectHits(x, select=select)\n    }\n)\n\nsetMethod(\"process_self_hits\", \"SortedByQueryHitsList\",\n    function(x, select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n                drop.self=FALSE, drop.redundant=FALSE)\n    {\n        x <- as(x, \"SortedByQuerySelfHitsList\")\n        select <- match.arg(select)\n        ans <- lapply(x, process_self_hits,\n                         select, drop.self,  drop.redundant)\n        if (select != \"all\")\n            return(IntegerList(ans))\n        S4Vectors:::new_SimpleList_from_list(\"HitsList\",\n                        ans,\n                        subjectOffsets = x@subjectOffsets)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### findOverlaps()\n###\n### Find objects in the query that overlap those in the subject.\n###\n\nsetGeneric(\"findOverlaps\", signature=c(\"query\", \"subject\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n             ...)\n        standardGeneric(\"findOverlaps\")\n)\n\nfindOverlaps_IntegerRanges <- function(query, subject,\n             maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"))\n{\n    if (is.integer(query))\n        query <- IRanges(query, width=1L)\n    type <- match.arg(type)\n    select <- match.arg(select)\n    findOverlaps_NCList(query, subject,\n                        maxgap=maxgap, minoverlap=minoverlap,\n                        type=type, select=select)\n}\n\nsetMethod(\"findOverlaps\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    findOverlaps_IntegerRanges\n)\n\nsetMethod(\"findOverlaps\", c(\"integer\", \"IntegerRanges\"),\n    findOverlaps_IntegerRanges\n)\n\nsetMethod(\"findOverlaps\", c(\"Vector\", \"missing\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n             ...,\n             drop.self=FALSE, drop.redundant=FALSE)\n    {\n        select <- match.arg(select)\n        result <- findOverlaps(query, query,\n                               maxgap=maxgap, minoverlap=minoverlap,\n                               type=match.arg(type), select=\"all\",\n                               ...)\n        process_self_hits(result, select, drop.self, drop.redundant)\n    }\n)\n\n# might consider making this the following:\n# setMethod(\"findOverlaps\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n#           function(query, subject, maxgap = -1L, minoverlap = 0L,\n#                    type = c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n#                    select = c(\"all\", \"first\", \"last\", \"arbitrary\"),\n#                    drop = FALSE)\n#           {\n#             findOverlaps(query, NCLists(query),\n#               maxgap = maxgap, minoverlap = minoverlap,\n#               type = match.arg(type), select = match.arg(select), drop = drop)\n#           }\n#   )\n\nsetMethod(\"findOverlaps\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n          function(query, subject, maxgap = -1L, minoverlap = 0L,\n                   type = c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n                   select = c(\"all\", \"first\", \"last\", \"arbitrary\"),\n                   drop = FALSE)\n          {\n            type <- match.arg(type)\n            select <- match.arg(select)\n\n            query <- as.list(query)\n            subject <- as.list(subject)\n            origSubject <- subject\n            if (!is.null(names(subject)) && !is.null(names(query))) {\n              subject <- subject[names(query)]\n              names(subject) <- names(query) # get rid of NA's in names\n            } else {\n              subject <- subject[seq_along(query)]\n            }\n            ## NULL's are introduced where they do not match\n            ## We replace those with empty IRanges\n            subject[S4Vectors:::sapply_isNULL(subject)] <- list(IRanges())\n\n            ans <- lapply(seq_len(length(subject)), function(i) {\n              findOverlaps(query[[i]], subject[[i]],\n                           maxgap = maxgap, minoverlap = minoverlap,\n                           type = type, select = select)\n            })\n            names(ans) <- names(subject)\n            if (select == \"all\") {\n              ans <- HitsList(ans, origSubject)\n            } else if (drop) {\n              off <- head(c(0L, cumsum(sapply(origSubject, length))), -1)\n              names(off) <- names(origSubject)\n              if (is.null(names(ans)))\n                off <- off[seq_along(ans)]\n              else\n                off <- off[names(ans)]\n              ans <-\n                unlist(ans, use.names=FALSE) +\n                  rep.int(unname(off), sapply(ans, length))\n            } else {\n              ans <- IntegerList(ans)\n            }\n            ans\n          })\n\nsetMethod(\"findOverlaps\", c(\"Pairs\", \"missing\"),\n          function (query, subject, maxgap = -1L, minoverlap = 0L,\n                    type = c(\"any\",  \"start\", \"end\", \"within\", \"equal\"),\n                    select = c(\"all\", \"first\", \"last\", \"arbitrary\"), ...) {\n              findOverlaps(zipup(query), maxgap=maxgap,\n                           minoverlap=minoverlap, type=type, select=select, ...)\n          })\n\nsetMethod(\"findOverlaps\", c(\"Pairs\", \"ANY\"),\n          function (query, subject, maxgap = -1L, minoverlap = 0L,\n                    type = c(\"any\",  \"start\", \"end\", \"within\", \"equal\"),\n                    select = c(\"all\", \"first\", \"last\", \"arbitrary\"), ...) {\n              findOverlaps(zipup(query), subject, maxgap=maxgap,\n                           minoverlap=minoverlap, type=type, select=select, ...)\n          })\n\nsetMethod(\"findOverlaps\", c(\"ANY\", \"Pairs\"),\n          function (query, subject, maxgap = -1L, minoverlap = 0L,\n                    type = c(\"any\",  \"start\", \"end\", \"within\", \"equal\"),\n                    select = c(\"all\", \"first\", \"last\", \"arbitrary\"), ...) {\n              findOverlaps(query, zipup(subject), maxgap=maxgap,\n                           minoverlap=minoverlap, type=type, select=select, ...)\n          })\n\nsetMethod(\"findOverlaps\", c(\"Pairs\", \"Pairs\"),\n          function (query, subject, maxgap = -1L, minoverlap = 0L,\n                    type = c(\"any\",  \"start\", \"end\", \"within\", \"equal\"),\n                    select = c(\"all\", \"first\", \"last\", \"arbitrary\"), ...) {\n              findOverlaps(zipup(query), zipup(subject),\n                           maxgap=maxgap, minoverlap=minoverlap, type=type,\n                           select=select, ...)\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### countOverlaps()\n###\n\nsetGeneric(\"countOverlaps\", signature=c(\"query\", \"subject\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             ...)\n        standardGeneric(\"countOverlaps\")\n)\n\n.default_countOverlaps <-\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             ...)\n{\n    if (is.integer(query))\n        query <- IRanges(query, width=1L)\n    type <- match.arg(type)\n    if (missing(subject)) {\n        hits <- findOverlaps(query,\n                             maxgap=maxgap, minoverlap=minoverlap,\n                             type=type,\n                             ...)\n    } else {\n        hits <- findOverlaps(query, subject,\n                             maxgap=maxgap, minoverlap=minoverlap,\n                             type=type,\n                             ...)\n    }\n    ans <- countQueryHits(hits)\n    names(ans) <- names(query)\n    ans\n}\n\nsetMethod(\"countOverlaps\", c(\"Vector\", \"Vector\"), .default_countOverlaps)\nsetMethod(\"countOverlaps\", c(\"integer\", \"Vector\"), .default_countOverlaps)\nsetMethod(\"countOverlaps\", c(\"Vector\", \"missing\"), .default_countOverlaps)\n\ncountOverlaps_IntegerRanges <- function(query, subject,\n              maxgap=-1L, minoverlap=0L,\n              type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"))\n{\n    type <- match.arg(type)\n    ans <- findOverlaps_NCList(query, subject,\n                               maxgap=maxgap, minoverlap=minoverlap,\n                               type=type, select=\"count\")\n    names(ans) <- names(query)\n    ans\n}\n\nsetMethod(\"countOverlaps\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    countOverlaps_IntegerRanges\n)\n\nsetMethod(\"countOverlaps\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n          function(query, subject, maxgap=-1L, minoverlap=0L,\n                   type = c(\"any\", \"start\", \"end\", \"within\", \"equal\"))\n          {\n              IntegerList(mapply(countOverlaps, query, subject,\n                              MoreArgs = list(maxgap = maxgap,\n                                      minoverlap = minoverlap,\n                                      type = match.arg(type)),\n                              SIMPLIFY = FALSE))\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### overlapsAny()\n###\n\n### Same args and signature as countOverlaps().\nsetGeneric(\"overlapsAny\", signature=c(\"query\", \"subject\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             ...)\n        standardGeneric(\"overlapsAny\")\n)\n\n### NOT exported but used in the bsseq package.\ndefault_overlapsAny <-\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             ...)\n{\n    if (is.integer(query))\n        query <- IRanges(query, width=1L)\n    type <- match.arg(type)\n    if (missing(subject)) {\n        ahit <- findOverlaps(query,\n                             maxgap=maxgap, minoverlap=minoverlap,\n                             type=type, select=\"arbitrary\",\n                             ...)\n    } else {\n        ahit <- findOverlaps(query, subject,\n                             maxgap=maxgap, minoverlap=minoverlap,\n                             type=type, select=\"arbitrary\",\n                             ...)\n    }\n    !is.na(ahit)\n}\n\nsetMethod(\"overlapsAny\", c(\"Vector\", \"Vector\"), default_overlapsAny)\nsetMethod(\"overlapsAny\", c(\"integer\", \"Vector\"), default_overlapsAny)\nsetMethod(\"overlapsAny\", c(\"Vector\", \"missing\"), default_overlapsAny)\n\nsetMethod(\"overlapsAny\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             ...)\n    {\n        query <- as.list(query)\n        subject <- as.list(subject)\n        type <- match.arg(type)\n        if (!is.null(names(query)) && !is.null(names(subject))) {\n            subject <- subject[names(query)]\n            names(subject) <- names(query) # get rid of NA's in names\n        } else {\n            subject <- subject[seq_along(query)]\n        }\n        ## NULL's are introduced where they do not match\n        ## We replace those with empty IRanges\n        subject[S4Vectors:::sapply_isNULL(subject)] <- list(IRanges())\n        LogicalList(lapply(structure(seq_len(length(query)),\n                                     names = names(query)),\n                           function(i)\n                             overlapsAny(query[[i]], subject[[i]],\n                                         maxgap=maxgap, minoverlap=minoverlap,\n                                         type=type,\n                                         ...)))\n    }\n)\n\n### Convenience wrappers for the 3 most common use cases.\n`%over%` <- function(query, subject) overlapsAny(query, subject)\n`%within%` <- function(query, subject) overlapsAny(query, subject,\n                                                   type=\"within\")\n`%outside%` <- function(query, subject) !overlapsAny(query, subject)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### subsetByOverlaps()\n###\n\n### First 2 arguments are 'x' and 'ranges' like for the\n### transcriptsByOverlaps(), exonsByOverlaps(), and cdsByOverlaps() functions\n### from the GenomicFeatures package and the snpsByOverlaps() function from\n### the BSgenome package.\nsetGeneric(\"subsetByOverlaps\", signature=c(\"x\", \"ranges\"),\n    function(x, ranges, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             invert=FALSE, ...)\n        standardGeneric(\"subsetByOverlaps\")\n)\n\n### NOT exported but used in the bsseq package.\ndefault_subsetByOverlaps <-\n    function(x, ranges, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             invert=FALSE, ...)\n{\n    ov_any <- overlapsAny(x, ranges,\n                          maxgap=maxgap, minoverlap=minoverlap,\n                          type=match.arg(type),\n                          ...)\n    if (invert)\n        ov_any <- !ov_any\n    x[ov_any]\n}\n\nsetMethod(\"subsetByOverlaps\", c(\"Vector\", \"Vector\"), default_subsetByOverlaps)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### overlapsRanges()\n###\n### Extracts the actual regions of intersection between the overlapping ranges.\n###\n\nsetGeneric(\"overlapsRanges\", signature=c(\"query\", \"subject\"),\n    function(query, subject, hits=NULL, ...) standardGeneric(\"overlapsRanges\")\n)\n\nsetMethod(\"overlapsRanges\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(query, subject, hits=NULL, ...)\n    {\n        if (is.null(hits)) {\n            hits <- findOverlaps(query, subject, ...)\n        } else {\n            if (!is(hits, \"Hits\"))\n                stop(\"'hits' must be a Hits object\")\n            if (length(list(...)) != 0L)\n                stop(wmsg(\"Extra arguments are only accepted when the 'hits' \",\n                          \"argument is not supplied, in which case they are \",\n                          \"passed to the internal call to findOverlaps(). \",\n                          \"See ?overlapsRanges for more information.\"))\n            if (queryLength(hits) != length(query) ||\n                subjectLength(hits) != length(subject))\n                stop(\"'hits' is not compatible with 'query' and 'subject'\")\n        }\n        ### Could be replaced by 1-liner:\n        ###   pintersect(query[queryHits(hits)], subject[subjectHits(hits)])\n        ### but will fail if 'query' or 'subject' is a kind of IntegerRanges\n        ### object that cannot be subsetted (e.g. Partitioning object).\n        m <- as.matrix(hits)\n        qstart <- start(query)[m[,1L]]\n        qend <- end(query)[m[,1L]]\n        sstart <- start(subject)[m[,2L]]\n        send <- end(subject)[m[,2L]]\n        IRanges(pmax.int(qstart, sstart), pmin.int(send, qend))\n    }\n)\n\nsetMethod(\"overlapsRanges\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n    function(query, subject, hits=NULL, ...)\n    {\n        if (is.null(hits)) {\n            hits <- findOverlaps(query, subject, ...)\n        } else {\n            if (!is(hits, \"HitsList\"))\n                stop(\"'hits' must be a HitsList object\")\n            if (length(list(...)) != 0L)\n                stop(wmsg(\"Extra arguments are only accepted when the 'hits' \",\n                          \"argument is not supplied, in which case they are \",\n                          \"passed to the internal call to findOverlaps(). \",\n                          \"See ?overlapsRanges for more information.\"))\n            if (length(hits) != length(query) ||\n                length(hits) != length(subject))\n                stop(\"'query', 'subject', and 'hits' must have the same length\")\n        }\n        queries <- as.list(query, use.names = FALSE)\n        subjects <- as.list(subject, use.names = FALSE)\n        els <- as.list(hits, use.names = FALSE)\n        ans <- lapply(seq_len(length(hits)),\n            function(i) overlapsRanges(queries[[i]], subjects[[i]], els[[i]]))\n        ans <- as(ans, \"SimpleIRangesList\")\n        names(ans) <- names(hits)\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### poverlaps()\n###\n\nsetGeneric(\"poverlaps\", signature=c(\"query\", \"subject\"),\n           function(query, subject, maxgap=0L, minoverlap=1L,\n                    type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n                    ...)\n               standardGeneric(\"poverlaps\")\n           )\n\nsetMethod(\"poverlaps\", c(\"IntegerRanges\", \"IntegerRanges\"),\n          function(query, subject, maxgap=0L, minoverlap=1L,\n                   type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"))\n          {\n              stopifnot(isSingleNumber(maxgap))\n              stopifnot(isSingleNumber(minoverlap))\n              type <- match.arg(type)\n              if (type == \"any\") {\n                  query <- query + maxgap\n              } else if (type == \"within\") {\n                  if (maxgap > 0L) {\n                      warning(\"'maxgap' is ignored when type=='within'\")\n                  }\n                  return(start(query) >= start(subject) &\n                             end(query) <= end(subject) &\n                                 width(query) >= minoverlap)\n              }\n              amount <- pmin(end(query), end(subject)) -\n                  pmax(start(query), start(subject)) + 1L\n              overlaps <- amount >= minoverlap\n              samePos <- function(x, y) {\n                  x <= (y + maxgap) & x >= (y - maxgap)\n              }\n              keep <- switch(type,\n                             any = TRUE,\n                             start = samePos(start(query), start(subject)),\n                             end = samePos(end(query), end(subject)),\n                             equal = samePos(start(query), start(subject)) &\n                                 samePos(end(query), end(subject)))\n             overlaps & keep\n          }\n          )\n\nsetMethod(\"poverlaps\", c(\"integer\", \"IntegerRanges\"),\n          function(query, subject, maxgap=0L, minoverlap=1L,\n                   type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"))\n          {\n              poverlaps(IRanges(query, width=1L), subject,\n                        maxgap=maxgap, minoverlap=minoverlap,\n                        type=match.arg(type))\n          })\n\nsetMethod(\"poverlaps\", c(\"IntegerRanges\", \"integer\"),\n          function(query, subject, maxgap=0L, minoverlap=1L,\n                   type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"))\n          {\n              poverlaps(query, IRanges(subject, width=1L),\n                        maxgap=maxgap, minoverlap=minoverlap,\n                        type=match.arg(type))\n          })\n\n### Convenience operators for poverlaps()\n`%pover%` <- function(query, subject) poverlaps(query, subject)\n`%pwithin%` <- function(query, subject) poverlaps(query, subject, type=\"within\")\n`%poutside%` <- function(query, subject) !poverlaps(query, subject)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Merge two sets of ranges by overlap into a DataFrame\n###\n\nmergeByOverlaps <- function(query, subject, ...) {\n  hits <- findOverlaps(query, subject, ...)\n  query_df <- as(extractROWS(query, queryHits(hits)), \"DataFrame\")\n  colnames(query_df)[1L] <- deparse(substitute(query))\n  subject_df <- as(extractROWS(subject, subjectHits(hits)), \"DataFrame\")\n  colnames(subject_df)[1L] <- deparse(substitute(subject))\n  cbind(query_df, subject_df)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Convenience for dereferencing overlap hits to a Pairs\n###\n\nfindOverlapPairs <- function(query, subject, ...) {\n    if (missing(subject)) {\n        hits <- findOverlaps(query, ...)\n        subject <- query\n    } else {\n        hits <- findOverlaps(query, subject, ...)\n    }\n    Pairs(query, subject, hits=hits)\n}\n",
        "inter-range-methods.R": "### =========================================================================\n### Inter-range methods\n### -------------------------------------------------------------------------\n###\n\n\n### TODO: We need a ranges() setter for Views objects that provides this\n### functionality. Once we have it, use it instead of this.\n.set_Views_ranges <- function(x, new_ranges)\n{\n    new_mcols <- mcols(new_ranges, use.names=FALSE)\n    mcols(new_ranges) <- NULL\n    BiocGenerics:::replaceSlots(x, ranges=new_ranges,\n                                   elementMetadata=new_mcols,\n                                   check=FALSE)\n}\n\n### NOT exported but used in the GenomicRanges package\nglobal2local_revmap <- function(unlisted_revmap, y, x)\n{\n    offsets <- rep.int(start(PartitioningByEnd(x)) - 1L, elementNROWS(y))\n    unlisted_revmap - offsets\n}\n\n### NOT exported but used in the GenomicFeatures package\nlocal2global_revmap <- function(unlisted_revmap, y, x)\n{\n    offsets <- rep.int(start(PartitioningByEnd(x)) - 1L, elementNROWS(y))\n    unlisted_revmap + offsets\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### range()\n###\n\n### Always return an IRanges (or NormalIRanges) *instance* whatever\n### IntegerRanges derivative the input is, so does NOT act like an\n### endomorphism in general. \nsetMethod(\"range\", \"IntegerRanges\",\n    function(x, ..., with.revmap=FALSE, na.rm=FALSE)\n    {\n        if (!isTRUEorFALSE(with.revmap))\n            stop(\"'with.revmap' must be TRUE or FALSE\")\n        if (!identical(na.rm, FALSE))\n            warning(\"\\\"range\\\" method for IntegerRanges objects \",\n                    \"ignores the 'na.rm' argument\")\n        args <- unname(list(x, ...))\n        ## TODO: Replace line below with\n        ##     args <- lapply(args, ranges)\n        ## when ranges() works on IntegerRanges objects.\n        args <- lapply(args,\n                       function(arg) IRanges(start(arg), width=width(arg)))\n        ir <- do.call(c, args)\n\n        ans <- .Call2(\"C_range_IRanges\", ir, PACKAGE=\"IRanges\")\n        if (is(x, \"NormalIRanges\"))\n            ans <- as(ans, \"NormalIRanges\")\n        if (with.revmap){\n            mcols(ans) <- DataFrame(revmap=IntegerList(seq_along(ir)))\n        }\n        ans\n    }\n)\n\n### Overwrite above method with optimized method for StitchedIPos objects.\n### Like the above method, return an IRanges instance.\nsetMethod(\"range\", \"StitchedIPos\",\n    function(x, ..., with.revmap=FALSE, ignore.strand=FALSE, na.rm=FALSE)\n    {\n        x <- x@pos_runs\n        callGeneric()\n    }\n)\n\nsetMethod(\"range\", \"IntegerRangesList\",\n    function(x, ..., with.revmap=FALSE, na.rm=FALSE)\n    {\n        if (length(list(x, ...)) >= 2L)\n            x <- merge(x, ...)\n        endoapply(x, range, with.revmap=with.revmap)\n    }\n)\n\n### Equivalent to, but much faster than, 'endoapply(x, range)'.\n.range_CompressedIRangesList <- function(x, with.revmap=FALSE)\n{\n    ## 'x_start' and 'x_end' are CompressedIntegerList objects with the\n    ## same shape as 'x'.\n    x_start <- start(x)\n    x_end <- end(x)\n    ## TEMPORARY HACK!\n    if (!requireNamespace(\"XVector\", quietly=TRUE))\n        stop(\"the XVector package is required by the \\\"range\\\" method \",\n             \"for CompressedIRangesList objects\")\n    ## 'sv' and 'ev' are XIntegerViews objects (see XVector package).\n    sv <- Views(x_start@unlistData, x_start@partitioning)\n    ev <- Views(x_end@unlistData, x_end@partitioning)\n    is_not_empty_view <- width(sv) != 0L  # same as 'width(ev) != 0L'\n    unlisted_ans <- IRanges(viewMins(sv)[is_not_empty_view],\n                            viewMaxs(ev)[is_not_empty_view])\n    ans_partitioning <- PartitioningByEnd(cumsum(is_not_empty_view))\n    if (with.revmap) {\n        x_partitioning <- unname(PartitioningByEnd(x))\n        global_revmap <- relist(seq_along(unlist(x, use.names=FALSE)),\n                                x_partitioning[width(x_partitioning) != 0L])\n        local_revmap <- global2local_revmap(global_revmap, ans_partitioning, x)\n        mcols(unlisted_ans)$revmap <- local_revmap\n    }\n    ans <- relist(unlisted_ans, ans_partitioning)\n    names(ans) <- names(x)\n    ans\n}\n\nsetMethod(\"range\", \"CompressedIRangesList\",\n    function(x, ..., with.revmap=FALSE, na.rm=FALSE)\n    {\n        if (!isTRUEorFALSE(with.revmap))\n            stop(\"'with.revmap' must be TRUE or FALSE\")\n        if (length(list(x, ...)) >= 2L)\n            x <- merge(x, ...)\n        .range_CompressedIRangesList(x, with.revmap=with.revmap)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### reduce()\n###\n\nsetGeneric(\"reduce\", signature=\"x\",\n    function(x, drop.empty.ranges=FALSE, ...) standardGeneric(\"reduce\")\n)\n\n### Always return an IRanges (or NormalIRanges) *instance* whatever\n### IntegerRanges derivative the input is, so does NOT act like an\n### endomorphism in general. \nsetMethod(\"reduce\", \"IntegerRanges\",\n    function(x, drop.empty.ranges=FALSE, min.gapwidth=1L,\n                with.revmap=FALSE,\n                with.inframe.attrib=FALSE)\n    {\n        if (!isTRUEorFALSE(drop.empty.ranges))\n            stop(\"'drop.empty.ranges' must be TRUE or FALSE\")\n        if (!isSingleNumber(min.gapwidth))\n            stop(\"'min.gapwidth' must be a single integer\")\n        if (!is.integer(min.gapwidth))\n            min.gapwidth <- as.integer(min.gapwidth)\n        if (min.gapwidth < 0L)\n            stop(\"'min.gapwidth' must be non-negative\")\n        if (!isTRUEorFALSE(with.revmap))\n            stop(\"'with.revmap' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(with.inframe.attrib))\n            stop(\"'with.inframe.attrib' must be TRUE or FALSE\")\n        C_ans <- .Call2(\"C_reduce_IntegerRanges\",\n                        start(x), width(x),\n                        drop.empty.ranges, min.gapwidth,\n                        with.revmap,\n                        with.inframe.attrib,\n                        PACKAGE=\"IRanges\")\n        ans <- new2(\"IRanges\", start=C_ans$start,\n                               width=C_ans$width,\n                               check=FALSE)\n        if (is(x, \"NormalIRanges\"))\n            ans <- as(ans, \"NormalIRanges\")\n        if (with.revmap) {\n            mcols(ans) <- DataFrame(revmap=IntegerList(C_ans$revmap))\n        }\n        if (with.inframe.attrib) {\n            inframe <- new2(\"IRanges\", start=C_ans$inframe.start,\n                                       width=width(x),\n                                       check=FALSE)\n            attr(ans, \"inframe\") <- inframe\n        }\n        ans\n    }\n)\n\nsetMethod(\"reduce\", \"Views\",\n    function(x, drop.empty.ranges=FALSE, min.gapwidth=1L,\n                with.revmap=FALSE,\n                with.inframe.attrib=FALSE)\n    {\n        new_ranges <- callGeneric(x@ranges,\n                                  drop.empty.ranges=drop.empty.ranges,\n                                  min.gapwidth=min.gapwidth,\n                                  with.revmap=with.revmap,\n                                  with.inframe.attrib=with.inframe.attrib)\n        .set_Views_ranges(x, new_ranges)\n    }\n)\n\nsetMethod(\"reduce\", \"IntegerRangesList\",\n    function(x, drop.empty.ranges=FALSE, min.gapwidth=1L,\n                with.revmap=FALSE,\n                with.inframe.attrib=FALSE)\n    {\n        endoapply(x, reduce, drop.empty.ranges = drop.empty.ranges,\n                             min.gapwidth = min.gapwidth,\n                             with.revmap=with.revmap,\n                             with.inframe.attrib = with.inframe.attrib)\n    }\n)\n\n### 'with.inframe.attrib' is ignored for now.\n### TODO: Support 'with.inframe.attrib=TRUE'.\n.reduce_CompressedIRangesList <- function(x, drop.empty.ranges=FALSE,\n                                             min.gapwidth=1L,\n                                             with.revmap=FALSE,\n                                             with.inframe.attrib=FALSE)\n{\n    if (!isTRUEorFALSE(drop.empty.ranges))\n        stop(\"'drop.empty.ranges' must be TRUE or FALSE\")\n    if (!isSingleNumber(min.gapwidth))\n        stop(\"'min.gapwidth' must be a single integer\")\n    if (!is.integer(min.gapwidth))\n        min.gapwidth <- as.integer(min.gapwidth)\n    if (min.gapwidth < 0L)\n        stop(\"'min.gapwidth' must be non-negative\")\n    if (!isTRUEorFALSE(with.revmap))\n        stop(\"'with.revmap' must be TRUE or FALSE\")\n    if (!identical(with.inframe.attrib, FALSE))\n        stop(\"'with.inframe.attrib' argument not yet supported \",\n             \"when reducing a CompressedIRangesList object\")\n    C_ans <- .Call2(\"C_reduce_CompressedIRangesList\",\n                    x, drop.empty.ranges, min.gapwidth, with.revmap,\n                    PACKAGE=\"IRanges\")\n    unlisted_ans <- new2(\"IRanges\", start=C_ans$start,\n                                    width=C_ans$width,\n                                    check=FALSE)\n    if (with.revmap)\n        mcols(unlisted_ans) <- DataFrame(revmap=IntegerList(C_ans$revmap))\n    ans_partitioning <- PartitioningByEnd(C_ans$breakpoints)\n    names(ans_partitioning) <- names(x)\n    relist(unlisted_ans, ans_partitioning)\n}\n\nsetMethod(\"reduce\", \"CompressedIRangesList\", .reduce_CompressedIRangesList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### gaps()\n###\n\nsetGeneric(\"gaps\", signature=\"x\",\n    function(x, start=NA, end=NA, ...) standardGeneric(\"gaps\")\n)\n\n### Always return an IRanges (or NormalIRanges) *instance* whatever\n### IntegerRanges derivative the input is, so does NOT act like an\n### endomorphism in general. \nsetMethod(\"gaps\", \"IntegerRanges\",\n    function(x, start=NA, end=NA)\n    {\n        start <- S4Vectors:::normargSingleStartOrNA(start)\n        end <- S4Vectors:::normargSingleEndOrNA(end)\n        C_ans <- .Call2(\"C_gaps_IntegerRanges\",\n                        start(x), width(x), start, end,\n                        PACKAGE=\"IRanges\")\n        ans <- new2(\"IRanges\", start=C_ans$start,\n                               width=C_ans$width,\n                               check=FALSE)\n        if (is(x, \"NormalIRanges\"))\n            ans <- as(ans, \"NormalIRanges\")\n        ans\n    }\n)\n\nsetMethod(\"gaps\", \"Views\",\n    function(x, start=NA, end=NA)\n    {\n        if (!isSingleNumberOrNA(start))\n            stop(\"'start' must be a single integer\")\n        if (!is.integer(start))\n            start <- as.integer(start)\n        if (!isSingleNumberOrNA(end))\n            stop(\"'end' must be a single integer\")\n        if (!is.integer(end))\n            end <- as.integer(end)\n        if (is.na(start))\n            start <- 1L\n        if (is.na(end))\n            end <- length(subject(x))\n        new_ranges <- gaps(x@ranges, start=start, end=end)\n        .set_Views_ranges(x, new_ranges)\n    }\n)\n\n.gaps_RangesList <- function(x, start=NA, end=NA)\n{\n    x_len <- length(x)\n    if (!S4Vectors:::isNumericOrNAs(start))\n        stop(\"'start' must be an integer vector or NA\")\n    if (!is.integer(start))\n        start <- as.integer(start)\n    if (!S4Vectors:::isNumericOrNAs(end))\n        stop(\"'end' must be an integer vector or NA\")\n    if (!is.integer(end))\n        end <- as.integer(end)\n    start <- IntegerList(as.list(S4Vectors:::recycleVector(start, x_len)))\n    end <- IntegerList(as.list(S4Vectors:::recycleVector(end, x_len)))\n    mendoapply(gaps, x, start = start, end = end)\n}\n\nsetMethod(\"gaps\", \"IntegerRangesList\", .gaps_RangesList)\n\n.gaps_CompressedIRangesList <- function(x, start=NA, end=NA)\n{\n    ## Normalize 'start'.\n    if (!S4Vectors:::isNumericOrNAs(start))\n        stop(\"'start' must be an integer vector or NA\")\n    if (!is.integer(start))\n        start <- as.integer(start)\n    if (length(start) != 1L)\n        start <- S4Vectors:::V_recycle(start, x,\n                                       x_what=\"start\", skeleton_what=\"x\")\n    ## Normalize 'end'.\n    if (!S4Vectors:::isNumericOrNAs(end))\n        stop(\"'end' must be an integer vector or NA\")\n    if (!is.integer(end))\n        end <- as.integer(end)\n    if (length(end) != 1L)\n        end <- S4Vectors:::V_recycle(end, x,\n                                     x_what=\"end\", skeleton_what=\"x\")\n\n    chunksize <- 10000000L\n    if (length(x) <= chunksize) {\n        ## Process all at once.\n        ans <- .Call2(\"C_gaps_CompressedIRangesList\",\n                      x, start, end,\n                      PACKAGE=\"IRanges\")\n        return(ans)\n    }\n\n    ## Process by chunk.\n    verbose <- getOption(\"verbose\", default=FALSE)\n    chunks <- as(breakInChunks(length(x), chunksize=chunksize), \"IRanges\")\n    ans_chunks <- lapply(seq_along(chunks),\n        function(i) {\n            if (verbose)\n                cat(\"Processing chunk #\", i, \"/\", length(chunks), \" ... \",\n                    sep=\"\")\n            chunk <- chunks[i]\n            x_chunk <- extractROWS(x, chunk)\n            start_chunk <- if (length(start) == 1L) start\n                           else extractROWS(start, chunk)\n            end_chunk <- if (length(end) == 1L) end\n                         else extractROWS(end, chunk)\n            ans_chunk <- .gaps_CompressedIRangesList(x_chunk,\n                                                     start=start_chunk,\n                                                     end=end_chunk)\n            if (verbose)\n                cat(\"OK\\n\")\n            ans_chunk\n        })\n    do.call(c, ans_chunks)\n}\n\nsetMethod(\"gaps\", \"CompressedIRangesList\", .gaps_CompressedIRangesList)\n\n### 'start' and 'end' are ignored.\nsetMethod(\"gaps\", \"MaskCollection\",\n    function(x, start=NA, end=NA)\n    {\n        start <- 1L\n        end <- width(x)\n        x@nir_list <- lapply(nir_list(x),\n            function(nir) gaps(nir, start=start, end=end)\n        )\n        x@NAMES <- as.character(NA)\n        x@desc <- as.character(NA)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### disjoin()\n###\n\nsetGeneric(\"disjoin\", function(x, ...) standardGeneric(\"disjoin\"))\n\n### Always return an IRanges *instance* whatever IntegerRanges derivative\n### the input is, so does NOT act like an endomorphism in general.\n### FIXME: Does not properly handle zero-width ranges at the moment e.g.\n### disjoin(IRanges(c(1, 11, 13), width=c(2, 5, 0)) returns\n### IRanges(c(1, 11, 13), width=c(2, 2, 3)) when it should return\n### IRanges(c(1, 11, 13, 13), width=c(2, 2, 0, 3)).\nsetMethod(\"disjoin\", \"IntegerRanges\",\n    function(x, with.revmap=FALSE)\n    {\n        if (!isTRUEorFALSE(with.revmap))\n            stop(\"'with.revmap' must be TRUE or FALSE\")\n        ## starts: original starts and end+1 when inside another interval\n        ## ends: original ends and start-1 when inside another interval\n        starts <- unique(start(x))\n        ends <- unique(end(x))\n        adj_start <- head(sort(unique(c(starts, ends + 1L))), -1L)\n        adj_end <- tail(sort(unique(c(ends, starts - 1L))), -1L)\n        adj_width <- adj_end - adj_start + 1L\n        adj <- new2(\"IRanges\", start=adj_start,\n                               width=adj_width,\n                               check=FALSE)\n        adj <- subsetByOverlaps(adj, x, minoverlap=1L)\n        if (with.revmap)\n             mcols(adj)$revmap <- as(sort(findOverlaps(adj, x)),\"List\")\n        adj\n    }\n)\n\n### Basically a no-op but returns a NormalIRanges *instance* for consistency\n### with how the other inter-range transformations (range(), reduce(), gaps())\n### behave on a NormalIRanges object.\nsetMethod(\"disjoin\", \"NormalIRanges\", function(x) as(x, \"NormalIRanges\"))\n\nsetMethod(\"disjoin\", \"IntegerRangesList\",\n    function(x, with.revmap=FALSE)\n        endoapply(x, disjoin, with.revmap=with.revmap)\n)\n\nsetMethod(\"disjoin\", \"CompressedIRangesList\",\n          function(x, with.revmap=FALSE, ...)\n          {\n              if (!isTRUEorFALSE(with.revmap))\n                  stop(\"'with.revmap' must be TRUE or FALSE\")        \n              .wunlist <- function(x)\n                  ## unlist CompressedIntegerList, with integer(0) as 0\n              {\n                  w <- integer(length(x))\n                  w[elementNROWS(x) != 0L] <- unlist(x, use.names=FALSE)\n                  w\n              }\n       \n              rng <- range(x)\n              if (sum(.wunlist(width(rng) + 1)) > .Machine$integer.max)\n                  return(endoapply(x, disjoin, with.revmap=with.revmap, ...))\n\n              ## localize coordinates\n              off0 <- head(.wunlist(width(rng) + 1L), -1L)\n              offset <- c(1L, cumsum(off0)) - .wunlist(start(rng))\n              local <- unlist(shift(x, offset), use.names=FALSE)\n\n              ## disjoin\n              d <- disjoin(local, with.revmap=with.revmap, ...)\n              vec <- unlist(start(shift(rng, offset)), use.names=FALSE)\n              lvls <- factor(seq_along(x))\n              lvls0 <- lvls[elementNROWS(rng) != 0]\n              f <- lvls0[findInterval(start(d), vec)]\n              ans <- split(d, f)\n\n              ## globalize coordinates\n              ans <- shift(ans, -offset)\n\n              ## localize 'revmap'\n              if (with.revmap) {\n                  unlisted_ans <- unlist(ans, use.names=FALSE)\n                  global_revmap <- mcols(unlisted_ans, use.names=FALSE)$revmap\n                  local_revmap <- global2local_revmap(global_revmap, ans, x)\n                  mcols(unlisted_ans)$revmap <- local_revmap\n                  ans <- relist(unlisted_ans, ans)\n              }\n\n              names(ans) <- names(x)\n              ans\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isDisjoint()\n###\n\nsetGeneric(\"isDisjoint\", function(x, ...) standardGeneric(\"isDisjoint\"))\n\nsetMethod(\"isDisjoint\", \"IntegerRanges\",\n    function(x)\n    {\n        x_len <- length(x)\n        if (x_len < 2L)\n            return(TRUE)\n        x_start <- start(x)\n        x_end <- end(x)\n        oo <- order(x)\n        start2 <- x_start[oo]\n        end2 <- x_end[oo]\n        all(start2[-1L] > end2[-x_len])\n    }\n)\n\n### Overwrite above method with optimized method for StitchedIPos objects.\nsetMethod(\"isDisjoint\", \"StitchedIPos\", function(x) callGeneric(x@pos_runs))\n\nsetMethod(\"isDisjoint\", \"NormalIRanges\", function(x) TRUE)\n\nsetMethod(\"isDisjoint\", \"IntegerRangesList\",\n    function(x) vapply(x, isDisjoint, logical(1))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### disjointBins()\n###\n\n## make intervals disjoint by segregating them into separate IntegerRanges\nsetGeneric(\"disjointBins\", function(x, ...) standardGeneric(\"disjointBins\"))\n\nsetMethod(\"disjointBins\", \"IntegerRanges\",\n    function(x)\n    {\n        x_names <- names(x)\n        x_ord <- NULL\n        if (S4Vectors:::isNotSorted(start(x))) { # minimize work for sorted ranges (common)\n            x_ord <- order(x)\n            x <- x[x_ord]\n        }\n        bins <- .Call2(\"C_disjointBins_IntegerRanges\", start(x), width(x),\n                       PACKAGE=\"IRanges\")\n        if (!is.null(x_ord)) {\n            rev_ord <- integer(length(x_ord))\n            rev_ord[x_ord] <- seq_along(rev_ord)\n            bins <- bins[rev_ord]\n        }\n        names(bins) <- x_names\n        bins\n    }\n)\n\n### Overwrite above method with trivial method for NormalIRanges objects.\nsetMethod(\"disjointBins\", \"NormalIRanges\",\n    function(x) setNames(rep.int(1L, length(x)), names(x))\n)\n\nsetMethod(\"disjointBins\", \"IntegerRangesList\",\n    function(x) as(lapply(x, disjointBins), \"IntegerList\")\n)\n\n",
        "intra-range-methods.R": "### =========================================================================\n### Intra-range methods\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### update_ranges()\n###\n\n### For internal use by the intra-range methods.\n### Update the ranges of a Ranges derivative. Return an object of the same\n### class as and parallel to 'x'.\nsetGeneric(\"update_ranges\", signature=\"x\",\n    function(x, start=NULL, end=NULL, width=NULL, use.names=TRUE)\n        standardGeneric(\"update_ranges\")\n)\n\n### Shallow check: only check type and length, not the content.\n.check_start_or_end_or_width <- function(start, x_len)\n{\n    if (is.null(start))\n        return()\n    stopifnot(is.integer(start))\n    stopifnot(length(start) == x_len)\n}\n\n### Does not validate the modified object.\nsetMethod(\"update_ranges\", \"IRanges\",\n    function(x, start=NULL, end=NULL, width=NULL, use.names=TRUE)\n    {\n        use.names <- S4Vectors:::normargUseNames(use.names)\n        narg <- sum(!is.null(start), !is.null(end), !is.null(width))\n        if (narg == 0L) {\n            if (!(use.names || is.null(x@NAMES)))\n                x@NAMES <- NULL\n            return(x)\n        }\n        stopifnot(narg <= 2L)\n        x_len <- length(x)\n        .check_start_or_end_or_width(start, x_len)\n        .check_start_or_end_or_width(end, x_len)\n        .check_start_or_end_or_width(width, x_len)\n        if (narg == 2L) {\n            if (!is.null(end)) {\n                if (is.null(start)) {\n                    ## 'end' and 'width' supplied\n                    start <- end - width + 1L\n                } else {\n                    ## 'start' and 'end' supplied\n                    width <- end - start + 1L\n                }\n            }\n            args <- list(start=start, width=width)\n        } else {\n            stopifnot(is.null(width))\n            if (is.null(start)) {\n                ## only 'end' supplied\n                width <- end - x@start + 1L\n                args <- list(width=width)\n            } else {\n                ## only 'start' supplied\n                width <- x@width - (start - x@start)\n                args <- list(start=start, width=width)\n            }\n        }\n        if (use.names) {\n            more_args <- list(check=FALSE)\n        } else {\n            more_args <- list(NAMES=NULL, check=FALSE)\n        }\n        args <- c(list(x), args, more_args)\n        do.call(BiocGenerics:::replaceSlots, args)\n    }\n)\n\nsetMethod(\"update_ranges\", \"Views\",\n    function(x, start=NULL, end=NULL, width=NULL, use.names=TRUE)\n    {\n        x@ranges <- update_ranges(x@ranges, start=start,\n                                            end=end,\n                                            width=width,\n                                            use.names=use.names)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### shift()\n###\n\nsetGeneric(\"shift\", signature=\"x\",\n    function(x, shift=0L, use.names=TRUE) standardGeneric(\"shift\")\n)\n\n### Returns an NA-free unnamed integer vector of length 1 or length 'x_len'.\n### If the user-supplied 'shift' vector is constant then the returned vector\n### is guaranteed to be of length <= 1.\n.normarg_shift <- function(shift, x_len)\n{\n    if (!is.numeric(shift))\n        stop(\"'shift' must be a numeric vector\")\n    if (!is.integer(shift)) {\n        shift <- as.integer(shift)\n    } else if (!is.null(names(shift))) {\n        names(shift) <- NULL\n    }\n    shift_len <- length(shift)\n    if (shift_len == 0L) {\n        if (x_len != 0L)\n            stop(wmsg(\"'length(shift)' is 0 but 'length(x)' is not\"))\n        return(shift)\n    }\n    if (shift_len == 1L) {\n        if (is.na(shift))\n            stop(wmsg(\"'shift' cannot be NA\"))\n        return(shift)\n    }\n    if (shift_len > x_len)\n        stop(wmsg(\"'length(shift)' is greater than 'length(x)'\"))\n    if (x_len %% length(shift) != 0L)\n        warning(wmsg(\"'length(x)' is not a multiple of 'length(shift)'\"))\n    if (anyNA(shift))\n        stop(wmsg(\"'shift' cannot contain NAs\"))\n    if (isConstant(shift))\n        return(shift[[1L]])\n    suppressWarnings(S4Vectors:::recycleVector(shift, x_len))\n}\n\nsetMethod(\"shift\", \"Ranges\",\n    function(x, shift=0L, use.names=TRUE)\n    {\n        shift <- .normarg_shift(shift, length(x))\n        if (is(x, \"NormalIRanges\") && length(shift) >= 2L)\n            stop(\"'shift' must be a single number when shifting \",\n                 \"a NormalIRanges object\")\n        new_start <- start(x) + shift\n        x <- update_ranges(x, start=new_start,\n                              width=width(x),\n                              use.names=use.names)\n        validObject(x)\n        x\n    }\n)\n\n### Overwrite above method with optimized method for IPos objects.\n### An IPos object cannot hold names so the 'use.names' arg has no effect.\n### NOTE: We only support shifting by a single value at the moment!\nsetMethod(\"shift\", \"IPos\",\n    function(x, shift=0L, use.names=TRUE)\n    {\n        shift <- .normarg_shift(shift, length(x))\n        if (is(x, \"UnstitchedIPos\")) {\n            new_pos <- pos(x) + shift\n            ans <- BiocGenerics:::replaceSlots(x, pos=new_pos, check=FALSE)\n            return(ans)\n        }\n        if (length(shift) >= 2L)\n            stop(\"'shift' must be a single number when shifting \",\n                 \"a StitchedIPos object\")\n        new_pos_runs <- callGeneric(x@pos_runs, shift=shift)\n        BiocGenerics:::replaceSlots(x, pos_runs=new_pos_runs, check=FALSE)\n    }\n)\n\nsetMethod(\"shift\", \"RangesList\",\n    function(x, shift=0L, use.names=TRUE)\n    {\n        if (!is(shift, \"List\"))\n            shift <- as(shift, \"List\")\n        shift <- S4Vectors:::VH_recycle(shift, x, \"shift\", \"x\")\n\n        if (is(x, \"CompressedRangesList\")) {\n            unlisted_shift <- unlist(shift, use.names=FALSE)\n            new_unlistData <- shift(x@unlistData, shift=unlisted_shift,\n                                                  use.names=use.names)\n            ans <- BiocGenerics:::replaceSlots(x, unlistData=new_unlistData,\n                                                  check=FALSE)\n            return(ans)\n        }\n        mendoapply(shift, x, shift,\n                          MoreArgs=list(use.names=use.names))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### narrow()\n###\n\n### The default \"narrow\" method calls windows() so we only need to implement\n### a \"windows\" method for IntegerRanges objects to make narrow() work on\n### these objects.\nsetMethod(\"windows\", \"Ranges\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        ir <- make_IRanges_from_windows_args(x, start, end, width)\n        if (length(x) == 0L)\n            return(x)\n        ans_start <- start(x) + start(ir) - 1L\n        ans_width <- width(ir)\n        update_ranges(x, start=ans_start, width=ans_width)\n    }\n)\n\nsetMethod(\"narrow\", \"MaskCollection\",\n    function(x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        solved_SEW <- solveUserSEWForSingleSeq(width(x), start, end, width)\n        solved_start <- start(solved_SEW)\n        solved_end <- end(solved_SEW)\n        solved_width <- width(solved_SEW)\n        x@nir_list <- lapply(nir_list(x),\n            function(nir) shift(restrict(nir, start=solved_start, end=solved_end),\n                                1L - solved_start)\n        )\n        x@width <- solved_width\n        if (!S4Vectors:::normargUseNames(use.names))\n            names(x) <- NULL\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### resize()\n###\n\nsetGeneric(\"resize\", signature=\"x\",\n    function(x, width, fix=\"start\", use.names=TRUE, ...)\n        standardGeneric(\"resize\")\n)\n\nsetMethod(\"resize\", \"Ranges\",\n    function(x, width, fix=\"start\", use.names=TRUE)\n    {\n        if (is(x, \"NormalIRanges\"))\n            stop(\"resizing a NormalIRanges object is not supported\")\n        lx <- length(x)\n        if (!is.numeric(width) || S4Vectors:::anyMissing(width))\n            stop(\"'width' must be a numeric vector without NA's\")\n        if (!is.integer(width))\n            width <- as.integer(width)\n        if (S4Vectors:::anyMissingOrOutside(width, 0L))\n            stop(\"'width' values must be non-negative\")\n        if (!(is.character(fix) ||\n              (is(fix, \"Rle\") && is.character(runValue(fix)))) ||\n            (length(fix) == 0L && length(x) > 0L) ||\n            (length(setdiff(unique(fix),\n                            c(\"start\", \"end\", \"center\"))) > 0)) {\n            stop(\"'fix' must be a character vector or character Rle \",\n                 \"with values in \\\"start\\\", \\\"end\\\", and \\\"center\\\"\")\n        }\n        if (!is(fix, \"Rle\"))\n            fix <- Rle(fix)\n        if (length(fix) != lx)\n            fix <- rep(fix, length.out = lx)\n        ans_width <- S4Vectors:::recycleVector(width, lx)\n        ans_start <- start(x)\n        if (!identical(runValue(fix), \"start\")) {\n            fixEnd <- as(fix == \"end\", \"IRanges\")\n            if (length(fixEnd) > 0) {\n                value <- extractROWS(ans_start, fixEnd) +\n                         (extractROWS(width(x), fixEnd) -\n                          extractROWS(ans_width, fixEnd))\n                ans_start <- replaceROWS(ans_start, fixEnd, value)\n            }\n            fixCenter <- as(fix == \"center\", \"IRanges\")\n            if (length(fixCenter) > 0) {\n                value <- extractROWS(ans_start, fixCenter) +\n                         (extractROWS(width(x), fixCenter) -\n                          extractROWS(ans_width, fixCenter)) %/% 2L\n                ans_start <- replaceROWS(ans_start, fixCenter, value)\n            }\n        }\n        update_ranges(x, start=ans_start, width=ans_width, use.names=use.names)\n    }\n)\n\nsetMethod(\"resize\", \"RangesList\",\n    function(x, width, fix=\"start\", use.names=TRUE, ...)\n    {\n        if (!is(width, \"List\"))\n            width <- as(width, \"List\")\n        width <- S4Vectors:::VH_recycle(width, x, \"width\", \"x\")\n        if (!is(fix, \"List\"))\n            fix <- as(fix, \"List\")\n        fix <- S4Vectors:::VH_recycle(fix, x, \"fix\", \"x\")\n\n        if (is(x, \"CompressedRangesList\")) {\n            unlisted_width <- unlist(width, use.names=FALSE)\n            unlisted_fix <- unlist(fix, use.names=FALSE)\n            new_unlistData <- resize(x@unlistData, width=unlisted_width,\n                                                   fix=unlisted_fix,\n                                                   use.names=use.names,\n                                                   ...)\n            ans <- BiocGenerics:::replaceSlots(x, unlistData=new_unlistData,\n                                                  check=FALSE)\n            return(ans)\n        }\n        mendoapply(resize, x, width, fix,\n                           MoreArgs=list(use.names=use.names, ...))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### flank()\n###\n\nsetGeneric(\"flank\", signature=\"x\",\n    function(x, width, start=TRUE, both=FALSE, use.names=TRUE, ...)\n        standardGeneric(\"flank\")\n)\n\nsetMethod(\"flank\", \"Ranges\",\n    function(x, width, start=TRUE, both=FALSE, use.names=TRUE)\n    {\n        if (is(x, \"NormalIRanges\"))\n            stop(\"flanking a NormalIRanges object is not supported\")\n        width <- recycleIntegerArg(width, \"width\", length(x))\n        if (!is.logical(start) || S4Vectors:::anyMissing(start))\n            stop(\"'start' must be logical without NA's\")\n        start <- S4Vectors:::recycleVector(unname(start), length(x))\n        if (!isTRUEorFALSE(both))\n            stop(\"'both' must be TRUE or FALSE\")\n        ans_start <- integer(length(x))\n        if (both) {\n            idx1 <- which(start)\n            idx2 <- which(!start)\n            width <- abs(width)\n            ans_width <- 2L * width\n            ans_start[idx1] <- start(x)[idx1] - width[idx1]\n            ans_start[idx2] <- end(x)[idx2] - width[idx2] + 1L\n        } else {\n            idx1a <- which(start & width >= 0L)\n            idx1b <- which(start & width < 0L)\n            idx2a <- which(!start & width >= 0L)\n            idx2b <- which(!start & width < 0L)\n            ans_width <- abs(width)\n            ans_start[idx1a] <- start(x)[idx1a] - width[idx1a]\n            ans_start[idx1b] <- start(x)[idx1b]\n            ans_start[idx2a] <- end(x)[idx2a] + 1L\n            ans_start[idx2b] <- end(x)[idx2b] + width[idx2b] + 1L\n        }\n        update_ranges(x, start=ans_start, width=ans_width, use.names=use.names)\n    }\n)\n\nsetMethod(\"flank\", \"RangesList\",\n    function(x, width, start=TRUE, both=FALSE, use.names=TRUE, ...)\n    {\n        if (!is(width, \"List\"))\n            width <- as(width, \"List\")\n        width <- S4Vectors:::VH_recycle(width, x, \"width\", \"x\")\n        if (!is(start, \"List\"))\n            start <- as(start, \"List\")\n        start <- S4Vectors:::VH_recycle(start, x, \"start\", \"x\")\n\n        if (is(x, \"CompressedRangesList\")) {\n            unlisted_width <- unlist(width, use.names=FALSE)\n            unlisted_start <- unlist(start, use.names=FALSE)\n            new_unlistData <- flank(x@unlistData, width=unlisted_width,\n                                                  start=unlisted_start,\n                                                  both=both,\n                                                  use.names=use.names,\n                                                  ...)\n            ans <- BiocGenerics:::replaceSlots(x, unlistData=new_unlistData,\n                                                  check=FALSE)\n            return(ans)\n        }\n        mendoapply(flank, x, width, start,\n                          MoreArgs=list(both=both, use.names=use.names, ...))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### promoters() and terminators()\n###\n\nsetGeneric(\"promoters\", signature=\"x\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE, ...)\n        standardGeneric(\"promoters\")\n)\n\nsetGeneric(\"terminators\", signature=\"x\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE, ...)\n        standardGeneric(\"terminators\")\n)\n\n### Computes the promoter regions if 'site' is set to \"TSS\" (Transcription\n### Start Site), or the terminator regions if it's set to \"TES\" (Transcription\n### End Site).\n.IntegerRanges_promoters <- function(x, upstream, downstream, use.names=TRUE,\n                                     site=c(\"TSS\", \"TES\"))\n{\n    site <- match.arg(site)\n    if (is(x, \"NormalIRanges\"))\n        stop(wmsg(\"promoters() or terminators() is not supported \",\n                  \"on a NormalIRanges object\"))\n    x_len <- length(x)\n    upstream <- recycleIntegerArg(upstream, \"upstream\", x_len)\n    downstream <- recycleIntegerArg(downstream, \"downstream\", x_len)\n    if (x_len == 0L)\n        return(update_ranges(x, use.names=use.names))\n    if (min(upstream) < 0L || min(downstream) < 0L)\n        stop(\"'upstream' and 'downstream' must be integers >= 0\")\n    x_site <- if (site == \"TSS\") start(x) else end(x)\n    new_start <- x_site - upstream\n    new_end <- x_site + downstream - 1L\n    update_ranges(x, start=new_start, end=new_end, use.names=use.names)\n}\n\nsetMethod(\"promoters\", \"IntegerRanges\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE)\n        .IntegerRanges_promoters(x, upstream, downstream, use.names=use.names,\n                                 site=\"TSS\")\n)\n\nsetMethod(\"terminators\", \"IntegerRanges\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE)\n        .IntegerRanges_promoters(x, upstream, downstream, use.names=use.names,\n                                 site=\"TES\")\n)\n\n.RangesList_promoters <- function(x, FUN, upstream, downstream, use.names=TRUE)\n{\n    if (!is(upstream, \"List\"))\n        upstream <- as(upstream, \"List\")\n    upstream <- S4Vectors:::VH_recycle(upstream, x, \"upstream\", \"x\")\n    if (!is(downstream, \"List\"))\n        downstream <- as(downstream, \"List\")\n    downstream <- S4Vectors:::VH_recycle(downstream, x, \"downstream\", \"x\")\n    if (is(x, \"CompressedRangesList\")) {\n        unlisted_upstream <- unlist(upstream, use.names=FALSE)\n        unlisted_downstream <- unlist(downstream, use.names=FALSE)\n        new_unlistData <- FUN(x@unlistData,\n                              upstream=unlisted_upstream,\n                              downstream=unlisted_downstream,\n                              use.names=use.names)\n        ans <- BiocGenerics:::replaceSlots(x, unlistData=new_unlistData,\n                                              check=FALSE)\n        return(ans)\n    }\n    mendoapply(FUN, x, upstream, downstream, MoreArgs=list(use.names=use.names))\n}\n\nsetMethod(\"promoters\", \"RangesList\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE)\n        .RangesList_promoters(x, promoters, upstream, downstream,\n                              use.names=use.names)\n)\n\nsetMethod(\"terminators\", \"RangesList\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE)\n        .RangesList_promoters(x, terminators, upstream, downstream,\n                              use.names=use.names)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### reflect()\n###\n\nsetGeneric(\"reflect\", signature=\"x\",\n    function(x, bounds, use.names=TRUE)\n        standardGeneric(\"reflect\")\n)\n\nsetMethod(\"reflect\", \"IntegerRanges\",\n    function(x, bounds, use.names=TRUE)\n    {\n        if (is(x, \"NormalIRanges\"))\n            stop(\"reflecting a NormalIRanges object is not supported\")\n        if (!is(bounds, \"IntegerRanges\"))\n            stop(\"'bounds' must be an IntegerRanges object\")\n        if (length(x) > 1 && length(bounds) == 0)\n            stop(\"'bounds' is an empty IntegerRanges object\")\n        if (length(x) < length(bounds))\n            bounds <- head(bounds, length(x))\n        ans_start <- (2L * start(bounds) + width(bounds) - 1L) - end(x)\n        update_ranges(x, start=ans_start, width=width(x), use.names=use.names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### restrict()\n###\n\nsetGeneric(\"restrict\", signature=\"x\",\n    function(x, start=NA, end=NA, keep.all.ranges=FALSE, use.names=TRUE)\n        standardGeneric(\"restrict\")\n)\n\n### We distinguish 4 exclusive types of relationship between a range in 'x'\n### and its corresponding restriction interval (specified by 'start' and\n### 'end'):\n###   - Type 1: They have a non-empty intersection.\n###   - Type 2: The restriction interval is empty but its bounds are within\n###             the range in 'x'.\n###   - Type 3: The restriction interval is not empty and is adjacent to the\n###             range in 'x' i.e. the range in 'x' ends at start - 1 or starts\n###             at end - 1.\n###\n### drop.ranges.mode:\n###   0L: Ranges in 'x' that are empty after restriction are dropped.\n###   1L: Ranges in 'x' that are not overlapping and not even adjacent\n###       with the region of restriction are dropped.\n###       \"Not overlapping and not adjacent\" means that they end strictly\n###       before start - 1 or start strictly after end + 1.\n###       Those that are not overlapping but are however adjacent are kept\n###       (and are empty after restriction).\n###   2L: All ranges in 'x' are kept after restriction.\n### Note that the only mode compatible with a NormalIRanges object is 0L.\n.restrict_IntegerRanges <- function(x, start, end, drop.ranges.mode, use.names)\n{\n    if (!S4Vectors:::isNumericOrNAs(start))\n        stop(\"'start' must be a vector of integers\")\n    if (!is.integer(start))\n        start <- as.integer(start)\n    if (!S4Vectors:::isNumericOrNAs(end))\n        stop(\"'end' must be a vector of integers\")\n    if (!is.integer(end))\n        end <- as.integer(end)\n    if (length(x) != 0L) {\n        if (length(start) == 0L || length(start) > length(x))\n            stop(\"invalid 'start' length\")\n        if (length(end) == 0L || length(end) > length(x))\n            stop(\"invalid 'end' length\")\n    }\n    start <- S4Vectors:::recycleVector(start, length(x))\n    end <- S4Vectors:::recycleVector(end, length(x))\n    use.names <- S4Vectors:::normargUseNames(use.names)\n\n    ans_start <- start(x)\n    ans_end <- end(x)\n    if (use.names) ans_names <- names(x) else ans_names <- NULL\n    ans_mcols <- mcols(x, use.names=FALSE)\n\n    ## Compare ranges in 'x' with 'start'.\n    if (drop.ranges.mode == 0L)\n        far_too_left <- !is.na(start) & (ans_end < start)\n    else\n        far_too_left <- !is.na(start) & (ans_end < start - 1L)\n    if (drop.ranges.mode == 2L) {\n        ans_end[far_too_left] <- start[far_too_left] - 1L\n    } else {\n        ## Drop the ranges that are far too left with respect to the\n        ## region of restriction.\n        keep_idx <- which(!far_too_left)\n        ans_start <- ans_start[keep_idx]\n        ans_end <- ans_end[keep_idx]\n        if (!is.null(ans_names))\n            ans_names <- ans_names[keep_idx]\n        ans_mcols <- extractROWS(ans_mcols, keep_idx)\n        start <- start[keep_idx]\n        end <- end[keep_idx]\n    }\n    ## Fix 'ans_start'.\n    too_left <- !is.na(start) & (ans_start < start)\n    ans_start[too_left] <- start[too_left]\n\n    ## Compare ranges in 'x' with 'end'.\n    if (drop.ranges.mode == 0L)\n        far_too_right <- !is.na(end) & (ans_start > end)\n    else\n        far_too_right <- !is.na(end) & (ans_start > end + 1L)\n    if (drop.ranges.mode == 2L) {\n        ans_start[far_too_right] <- end[far_too_right] + 1L\n    } else {\n        ## Drop the ranges that are far too right with respect to the\n        ## region of restriction.\n        keep_idx <- which(!far_too_right)\n        ans_start <- ans_start[keep_idx]\n        ans_end <- ans_end[keep_idx]\n        if (!is.null(ans_names))\n            ans_names <- ans_names[keep_idx]\n        ans_mcols <- extractROWS(ans_mcols, keep_idx)\n        start <- start[keep_idx]\n        end <- end[keep_idx]\n    }\n    ## Fix 'ans_end'.\n    too_right <- !is.na(end) & (ans_end > end)\n    ans_end[too_right] <- end[too_right]\n\n    ans_width <- ans_end - ans_start + 1L\n    BiocGenerics:::replaceSlots(x, start=ans_start,\n                                   width=ans_width,\n                                   NAMES=ans_names,\n                                   mcols=ans_mcols,\n                                   check=FALSE)\n}\n\nsetMethod(\"restrict\", \"IntegerRanges\",\n    function(x, start=NA, end=NA, keep.all.ranges=FALSE, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(keep.all.ranges))\n            stop(\"'keep.all.ranges' must be TRUE or FALSE\")\n        use.names <- S4Vectors:::normargUseNames(use.names)\n        if (is(x, \"NormalIRanges\")) {\n            if (keep.all.ranges)\n                stop(\"'keep.all.ranges=TRUE' is not supported \",\n                     \"when 'x' is a NormalIRanges object\")\n            drop.ranges.mode <- 0L\n        } else {\n            if (keep.all.ranges)\n                drop.ranges.mode <- 2L\n            else\n                drop.ranges.mode <- 1L\n        }\n        .restrict_IntegerRanges(x, start, end, drop.ranges.mode, use.names)\n    }\n)\n\nsetMethod(\"restrict\", \"Views\",\n    function(x, start=NA, end=NA, keep.all.ranges=FALSE, use.names=TRUE)\n    {\n        new_ranges <- restrict(ranges(x), start=start, end=end,\n                                          keep.all.ranges=keep.all.ranges,\n                                          use.names=use.names)\n        BiocGenerics:::replaceSlots(x, ranges=new_ranges, check=FALSE)\n    }\n)\n\nsetMethod(\"restrict\", \"RangesList\",\n    function(x, start=NA, end=NA, keep.all.ranges=FALSE, use.names=TRUE)\n    {\n        if (!isTRUEorFALSE(keep.all.ranges))\n            stop(\"'keep.all.ranges' must be TRUE or FALSE\")\n        if (!is(start, \"List\"))\n            start <- as(start, \"List\")\n        start <- S4Vectors:::VH_recycle(start, x, \"start\", \"x\")\n        if (!is(end, \"List\"))\n            end <- as(end, \"List\")\n        end <- S4Vectors:::VH_recycle(end, x, \"end\", \"x\")\n\n        if (is(x, \"CompressedRangesList\")) {\n            if (!keep.all.ranges) {\n                drop <- (!is.na(end) & start(x) > end + 1L) |\n                    (!is.na(start) & end(x) < start - 1L)\n            }\n            unlisted_start <- unlist(start, use.names=FALSE)\n            unlisted_end <- unlist(end, use.names=FALSE)\n            new_unlistData <- restrict(x@unlistData,\n                                       start=unlisted_start,\n                                       end=unlisted_end,\n                                       keep.all.ranges=keep.all.ranges,\n                                       use.names=use.names)\n            if (keep.all.ranges) {\n                ans <- BiocGenerics:::replaceSlots(x, unlistData=new_unlistData,\n                                                   check=FALSE)\n            } else {\n                ans <- relist(new_unlistData,\n                              PartitioningByWidth(lengths(x) - sum(drop)))\n            }\n            return(ans)\n        }\n        mendoapply(restrict, x, start, end,\n                             MoreArgs=list(keep.all.ranges=keep.all.ranges,\n                                           use.names=use.names))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### threebands()\n###\n\nsetGeneric(\"threebands\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA)\n        standardGeneric(\"threebands\")\n)\n\n### Method for IRanges only!\nsetMethod(\"threebands\", \"IRanges\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        middle <- narrow(x, start=start, end=end, width=width, use.names=FALSE)\n        left <- right <- middle\n        left@start <- start(x)\n        left@width <- start(middle) - start(x)\n        right@start <- end(middle) + 1L\n        right@width <- end(x) - end(middle)\n        list(left=left, middle=middle, right=right)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Zooming (symmetrically scales the width).\n###\n### TODO: Implement a zoom() generic and methods and make the \"Ops\" method\n### below a simple convenience wrapper for zoom(). Recommend the use of zoom()\n### over \"Ops\" methods in packages and scripts. Reserve \"Ops\" methods as a\n### convenience when working interactively.\n###\n\nsetMethod(\"Ops\", c(\"Ranges\", \"numeric\"),\n    function(e1, e2)\n    {\n        if (S4Vectors:::anyMissing(e2))\n            stop(\"NA not allowed as zoom factor\")\n        if ((length(e1) < length(e2) && length(e1)) ||\n            (length(e1) && !length(e2)) ||\n            (length(e1) %% length(e2) != 0))\n            stop(\"zoom factor length not a multiple of number of ranges\")\n        if (.Generic == \"*\") {\n            e2 <- ifelse(e2 < 0, abs(1/e2), e2)\n            r <- e1\n            mid <- (start(r)+end(r))/2\n            w <- width(r)/e2\n            update_ranges(r, start = as.integer(ceiling(mid - w/2)), width = as.integer(floor(w)))\n        } else {\n            if (.Generic == \"-\") {\n                e2 <- -e2\n                .Generic <- \"+\"\n            }\n            if (.Generic == \"+\") {\n                if (any(-e2*2 > width(e1)))\n                    stop(\"adjustment would result in ranges with negative widths\")\n                update_ranges(e1, start = as.integer(start(e1) - e2), end = as.integer(end(e1) + e2))\n            }\n        }\n    }\n)\n\nsetMethod(\"Ops\", c(\"RangesList\", \"numeric\"),\n          function(e1, e2)\n          {\n            for (i in seq_len(length(e1)))\n              e1[[i]] <- callGeneric(e1[[i]], e2)\n            e1\n          })\n\nsetMethod(\"Ops\", c(\"CompressedRangesList\", \"numeric\"),\n          function(e1, e2)\n          {\n            relist(callGeneric(unlist(e1, use.names = FALSE), e2), e1)\n          })\n\n",
        "multisplit.R": "### =========================================================================\n### multisplit()\n### -------------------------------------------------------------------------\n###\n\n\nmultisplit <- function(x, f) {\n  if (!is.list(f) && !is(f, \"List\"))\n    stop(\"'f' must be a list\")\n  if (length(x) != length(f))\n    stop(\"Length of 'f' must equal length of 'x'\")\n  splitAsList(rep(x, elementNROWS(f)), unlist(f, use.names = FALSE))\n}\n\n",
        "nearest-methods.R": "### =========================================================================\n### nearest (and related) methods\n### -------------------------------------------------------------------------\n###\n\n\nsetClassUnion(\"IntegerRanges_OR_missing\", c(\"IntegerRanges\", \"missing\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### precede() and follow()\n###\n\nsetGeneric(\"precede\", function(x, subject = x, ...) standardGeneric(\"precede\"))\n\nsetMethod(\"precede\", c(\"IntegerRanges\", \"IntegerRanges_OR_missing\"),\n    function(x, subject, select = c(\"first\", \"all\"))\n    {\n      select <- match.arg(select)\n      s <- start(subject)\n      ord <- NULL\n      if (S4Vectors:::isNotSorted(s)) {\n        ord <- base::order(s)\n        s <- s[ord]\n      }\n      if (select == \"all\") {\n        srle <- Rle(s)\n        s <- runValue(srle)\n      }\n      i <- findInterval(end(x), s) + 1L\n      i[i > length(s)] <- NA\n      if (select == \"all\") {\n        vectorToHits(i, srle, ord)\n      } else {\n        if (!is.null(ord))\n          i <- ord[i]\n        i\n      }\n    }\n)\n\nsetGeneric(\"follow\", function(x, subject = x, ...) standardGeneric(\"follow\"))\n\nsetMethod(\"follow\", c(\"IntegerRanges\", \"IntegerRanges_OR_missing\"),\n    function(x, subject, select = c(\"last\", \"all\"))\n    {\n      select <- match.arg(select)\n      e <- end(subject)\n      ord <- NULL\n      if (S4Vectors:::isNotSorted(e)) {\n        ord <- base::order(e)\n        e <- e[ord]\n      }\n      if (select == \"all\") {\n        srle <- Rle(e)\n        e <- runValue(srle)\n      }\n      i <- findInterval(start(x) - 1L, e)\n      i[i == 0] <- NA        \n      if (select == \"all\") {\n        vectorToHits(i, srle, ord)\n      } else {\n        if (!is.null(ord))\n          i <- ord[i]\n        i\n      }\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nearest()\n###\n\n### Used in GenomicRanges.\n### TODO: Move to Hits-class.R\nvectorToHits <- function(i, srle, ord) {\n  lx <- length(i)\n  v <- !is.na(i)\n  i <- i[v]\n  w <- width(srle)[i]\n  subj <- unlist_as_integer(IRanges(start(srle)[i], width=w))\n  m <- cbind(queryHits = rep(seq(lx)[v], w),\n             subjectHits = if (!is.null(ord)) ord[subj] else subj)\n  if (!is.null(ord))\n    m <- m[orderIntegerPairs(m[,1L], m[,2L]),,drop=FALSE]\n  Hits(m[ , 1L], m[ , 2L], lx, length(srle), sort.by.query=TRUE)\n}\n\nsetGeneric(\"nearest\", function(x, subject, ...) standardGeneric(\"nearest\"))\n\nsetMethod(\"nearest\", c(\"IntegerRanges\", \"IntegerRanges_OR_missing\"),\n          function(x, subject, select = c(\"arbitrary\", \"all\"))\n          {\n            select <- match.arg(select)\n            if (!missing(subject)) {\n              ol <- findOverlaps(x, subject, maxgap = 0L, select = select)\n            } else {\n              subject <- x\n              ol <- findOverlaps(x, maxgap = 0L, select = select,\n                                 drop.self = TRUE)\n            }\n            if (select == \"all\") {\n              olv <- selectHits(ol, select=\"first\")\n            } else olv <- ol\n            x <- x[is.na(olv)]\n            before <- precede(x, subject,\n                              if (select == \"all\") \"all\" else \"first\")\n            after <- follow(x, subject,\n                            if (select == \"all\") \"all\" else \"last\")\n            if (select == \"all\") {\n              before0 <- before\n              before <- selectHits(before, select=\"first\")\n              after0 <- after\n              after <- selectHits(after, select=\"first\")\n            }\n            leftdist <- (start(subject)[before] - end(x))\n            rightdist <- (start(x) - end(subject)[after])\n            left <- leftdist < rightdist\n            left[is.na(left)] <- is.na(after)[is.na(left)]\n            if (select == \"all\") {\n              filterHits <- function(hits, i) {\n                m <- as.matrix(hits[as(hits, \"IRanges\")[i]])\n                m[,1L] <- map[m[,1L]]\n                m\n              }\n              map <- which(is.na(olv))\n              right <- !left\n              left[leftdist == rightdist] <- TRUE\n              m <- rbind(as.matrix(ol), filterHits(before0, left),\n                                        filterHits(after0, right))\n              m <- m[orderIntegerPairs(m[,1L], m[,2L]),, drop=FALSE]\n              ## unname() required because in case 'm' has only 1 row\n              ## 'm[ , 1L]' and 'm[ , 2L]' will return a named atomic vector\n              ol@from <- unname(m[ , 1L])\n              ol@to <- unname(m[ , 2L])\n            } else {\n              olv[is.na(olv)] <- ifelse(left, before, after)\n              ol <- olv\n            }\n            ol\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### distance()\n###\n\nsetGeneric(\"distance\",\n           function(x, y, ...) standardGeneric(\"distance\"))\n\nsetMethod(\"distance\", c(\"IntegerRanges\", \"IntegerRanges\"), \n    function(x, y) \n    {\n        max_start <- pmax.int(start(x), start(y))\n        min_end <- pmin.int(end(x), end(y))\n        pmax.int(max_start - min_end - 1L, 0L) \n    }\n)\n\nsetMethod(\"distance\", c(\"Pairs\", \"missing\"),\n          function(x, y) {\n              distance(first(x), second(x))\n          })\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### distanceToNearest()\n###\n\nsetGeneric(\"distanceToNearest\",\n           function(x, subject = x, ...) standardGeneric(\"distanceToNearest\"))\n\nsetMethod(\"distanceToNearest\", c(\"IntegerRanges\", \"IntegerRanges_OR_missing\"),\n    function(x, subject, select = c(\"arbitrary\", \"all\"))\n    {\n        select <- match.arg(select)\n        if (missing(subject)) {\n            subject <- x\n            x_nearest <- nearest(x, select = select)\n        } else {\n            x_nearest <- nearest(x, subject, select = select)\n        }\n        if (select == \"arbitrary\") {\n            queryHits <- seq_along(x)[!is.na(x_nearest)]\n            subjectHits <- x_nearest[!is.na(x_nearest)]\n        } else {\n            queryHits <- queryHits(x_nearest)\n            subjectHits <- subjectHits(x_nearest)\n        }\n\n        if (!length(subjectHits) || all(is.na(subjectHits))) {\n            Hits(nLnode=length(x), \n                 nRnode=length(subject),\n                 distance=integer(0),\n                 sort.by.query=TRUE)\n        } else {\n            distance = distance(x[queryHits], subject[subjectHits])\n            Hits(queryHits, subjectHits, length(x), length(subject), distance,\n                 sort.by.query=TRUE)\n        }\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selectNearest()\n###\n\nselectNearest <- function(hits, x, subject) {\n    hits <- as(hits, \"SortedByQueryHits\")\n    hitsByQuery <- relist(hits, as(hits, \"Partitioning\"))\n    dist <- distance(x[queryHits(hits)], subject[subjectHits(hits)])\n    distByQuery <- relist(dist, hitsByQuery)\n    unlist(hitsByQuery[distByQuery == min(distByQuery)])\n}\n",
        "range-squeezers.R": "### =========================================================================\n### Generic functions for squeezing the ranges out of a range-based object\n### -------------------------------------------------------------------------\n\n\n### Extract the ranges as an IRanges object.\nsetGeneric(\"ranges\", signature=\"x\",\n    function(x, use.names=TRUE, use.mcols=FALSE, ...)\n        standardGeneric(\"ranges\")\n)\n\n### Extract the ranges as an IRangesList object.\nsetGeneric(\"rglist\", signature=\"x\",\n    function(x, use.names=TRUE, use.mcols=FALSE, ...)\n        standardGeneric(\"rglist\")\n)\n\n### Pairs method.\nsetMethod(\"rglist\", \"Pairs\", function(x, use.names=TRUE, use.mcols=FALSE) {\n              stopifnot(isTRUEorFALSE(use.mcols))\n              rl <- zipup(ranges(first(x)), ranges(second(x)))\n              if (!use.mcols) {\n                  mcols(rl) <- NULL\n              }\n              rl\n          })\n\n",
        "read.Mask.R": "### =========================================================================\n### Read a mask from a file\n### -----------------------\n###\n### From an NCBI \"agp\" file (for chrY in hs b36v3):\n###   library(BSgenome.Hsapiens.NCBI.b36v3)\n###   file1 <- system.file(\"extdata\", \"hs_b36v3_chrY.agp\", package=\"IRanges\")\n###   mask1 <- read.agpMask(file1, seqname=\"chrY\", mask.width=length(Hsapiens$chrY))\n###\n### From an UCSC \"gap\" file (for chrY in hg18):\n###   library(BSgenome.Hsapiens.UCSC.hg18)\n###   file2 <- system.file(\"extdata\", \"chrY_gap.txt\", package=\"IRanges\")\n###   mask2 <- read.gapMask(file2, seqname=\"chrY\", mask.width=length(Hsapiens$chrY))\n###\n### From an UCSC \"lift\" file (for hg18):\n###   file3 <- system.file(\"extdata\", \"hg18liftAll.lft\", package=\"IRanges\")\n###   mask3 <- read.liftMask(file3, seqname=\"chr1\")\n###\n### From a RepeatMasker .out file (for chrM in ce2):\n###   library(BSgenome.Celegans.UCSC.ce2)\n###   file4 <- system.file(\"extdata\", \"ce2chrM.fa.out\", package=\"IRanges\")\n###   mask4 <- read.rmMask(file4, seqname=\"chrM\", mask.width=length(Celegans$chrM)) \n###\n### From a Tandem Repeats Finder .bed file (for chrM in ce2):\n###   file5 <- system.file(\"extdata\", \"ce2chrM.bed\", package=\"IRanges\")\n###   mask5 <- read.trfMask(file5, seqname=\"chrM\", mask.width=length(Celegans$chrM)) \n###\n### -------------------------------------------------------------------------\n\n\n.showDistinctSeqnamesAndStop <- function(seqnames)\n{\n    distinct_seqnames <- paste(\"\\\"\", unique(seqnames), \"\\\"\", sep=\"\")\n    distinct_seqnames <- paste(distinct_seqnames, collapse=\", \")\n    stop(length(distinct_seqnames), \" distinct seqnames found in this file: \", distinct_seqnames)\n}\n\n.newEmptyMask <- function(seqname, mask.width, mask.name, mask.desc, nofound_what=\"information\")\n{\n    msg <- paste(\"No \", nofound_what, \" found for sequence \\\"\",\n                 seqname, \"\\\" in this file. \", sep=\"\")\n    if (is.na(mask.width))\n        stop(msg, \"Please use the\\n\",\n             \"  'mask.width' argument to specify the width of the empty mask to\\n\",\n             \"  return (i.e. the length of the sequence this mask will be put on).\")\n    warning(msg, \"returning empty mask\")\n    ans <- Mask(mask.width)  # empty mask\n    names(ans) <- mask.name\n    desc(ans) <- paste(mask.desc, \"(empty)\")\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### read.agpMask() and read.gapMask() extract the AGAPS mask from an NCBI\n### \"agp\" file or a UCSC \"gap\" file, respectively.\n###\n\n.guessGapFileCOL2CLASS <- function(file)\n{\n    ## UCSC \"gap\" files generally have the 9 columns below except for some\n    ## organisms like Rhesus that have only 8 columns (no 'bin' column).\n    COL2CLASS <- c(\n        `bin`=\"integer\",\n        `chrom`=\"character\",\n        `chr_start`=\"integer\",\n        `chr_stop`=\"integer\",\n        `part_no`=\"integer\",\n        `part_type`=\"character\",\n        `gap_len`=\"integer\",\n        `gap_type`=\"character\",\n        `bridge`=\"character\"\n    )\n    line1 <- try(read.table(file, sep=\"\\t\",\n                            col.names=names(COL2CLASS),\n                            colClasses=COL2CLASS,\n                            nrows=1L,\n                            check.names=FALSE),\n                 silent=TRUE)\n    if (!inherits(line1, \"try-error\"))\n        return(COL2CLASS)\n    COL2CLASS <- COL2CLASS[-1L]\n    line1 <- try(read.table(file, sep=\"\\t\",\n                            col.names=names(COL2CLASS),\n                            colClasses=COL2CLASS,\n                            nrows=1L,\n                            check.names=FALSE),\n                 silent=TRUE)\n    if (!inherits(line1, \"try-error\"))\n        return(COL2CLASS)\n    stop(\"unable to guess the column names in \\\"gap\\\" file '\", file, \"', sorry\")\n}\n\n.read.agpORgapFile <- function(agp_or_gap, file)\n{\n    if (agp_or_gap == \"agp\") {\n        COL2CLASS <- c(\n            `chrom`=\"character\",\n            `chr_start`=\"integer\",\n            `chr_stop`=\"integer\",\n            `part_no`=\"integer\",\n            `part_type`=\"character\",\n            `gap_len`=\"character\",\n            `gap_type`=\"character\",\n            `linkage`=\"character\",\n            `empty`=\"character\"\n        )\n    } else if (agp_or_gap == \"gap\") {\n        COL2CLASS <- .guessGapFileCOL2CLASS(file)\n    } else {\n        stop(\"read.Mask internal error: please report\")\n    }\n    COLS <- c(\n        \"chrom\",\n        \"chr_start\",\n        \"chr_stop\",\n        \"part_type\",\n        \"gap_len\",\n        \"gap_type\"\n    )\n    COL2CLASS[!(names(COL2CLASS) %in% COLS)] <- \"NULL\"\n    data <- read.table(file,\n                       sep=\"\\t\",\n                       col.names=names(COL2CLASS),\n                       colClasses=COL2CLASS,\n                       check.names=FALSE,\n                       fill=TRUE)\n}\n\n.read.agpORgapMask <- function(agp_or_gap, file, seqname, mask.width,\n                               gap.types, use.gap.types)\n{\n    if (!isSingleString(seqname))\n        stop(\"'seqname' must be a single string\")\n    if (!isSingleNumberOrNA(mask.width))\n        stop(\"'mask.width' must be a single integer or 'NA'\")\n    if (!is.integer(mask.width))\n        mask.width <- as.integer(mask.width)\n    if (!is.null(gap.types) && (!is.character(gap.types)\n                                || S4Vectors:::anyMissing(gap.types)\n                                || anyDuplicated(gap.types)))\n        stop(\"'gap.types' must be 'NULL' or a character vector \",\n             \"with no NAs and no duplicated\")\n    if (!isTRUEorFALSE(use.gap.types))\n        stop(\"'use.gap.types' must be TRUE or FALSE\")\n    data <- .read.agpORgapFile(agp_or_gap, file)\n    if (seqname == \"?\")\n        .showDistinctSeqnamesAndStop(data$chrom)\n    data <- data[data$chrom == seqname, ]\n    ii <- data$part_type == \"N\"\n    if (agp_or_gap == \"agp\") {\n        data <- data[ii, ]\n    } else if (!all(ii)) {\n        warning(\"gap file contains gaps with a part_type that is not N\")\n    }\n    if (length(gap.types) == 1 && gap.types == \"?\") {\n        found_types <- paste(\"\\\"\", unique(data$gap_type), \"\\\"\", sep=\"\")\n        found_types <- paste(found_types, collapse=\", \")\n        stop(\"gap types found in this file for sequence \\\"\", seqname, \"\\\": \", found_types)\n    }\n    mask.name <- \"AGAPS\"\n    mask.desc <- \"assembly gaps\"\n    if (!is.null(gap.types)) {\n        data <- data[data$gap_type %in% gap.types, ]\n        mask.desc <- paste(mask.desc, \" [type=\", paste(gap.types, collapse=\"|\"), \"]\", sep=\"\")\n    }\n    if (nrow(data) == 0)\n        return(.newEmptyMask(seqname, mask.width, mask.name, mask.desc, mask.desc))\n    if (agp_or_gap == \"agp\")\n        ranges_start <- data$chr_start\n    else\n        ranges_start <- data$chr_start + 1L\n    ranges <- IRanges(start=ranges_start, width=as.integer(data$gap_len))\n    ## Sanity check\n    if (!identical(end(ranges), data$chr_stop))\n        stop(\"broken \\\"\", agp_or_gap, \"\\\" file: contains inconsistent \",\n             \"chr_start/chr_stop/gap_len values \",\n             \"for assembly gaps in sequence \\\"\", seqname, \"\\\"\")\n    if (use.gap.types) {\n        names(ranges) <- data$gap_type\n        if (S4Vectors:::isNotStrictlySorted(start(ranges)))\n            ranges <- ranges[base::order(start(ranges))]\n        if (!isNormal(ranges))\n            stop(\"cannot use the gap types when some gaps are adjacent or overlap\")\n        nir1 <- asNormalIRanges(ranges, force=FALSE)\n    } else {\n        nir1 <- asNormalIRanges(ranges, force=TRUE)\n    }\n    ## Don't use new2(): the validity of the new mask needs to be checked!\n    new2(\"MaskCollection\", nir_list=list(nir1), width=mask.width, active=TRUE,\n                           NAMES=mask.name, desc=mask.desc, check=FALSE)\n}\n\nread.agpMask <- function(file, seqname=\"?\", mask.width=NA, gap.types=NULL, use.gap.types=FALSE)\n    .read.agpORgapMask(\"agp\", file, seqname, mask.width, gap.types, use.gap.types)\n\nread.gapMask <- function(file, seqname=\"?\", mask.width=NA, gap.types=NULL, use.gap.types=FALSE)\n    .read.agpORgapMask(\"gap\", file, seqname, mask.width, gap.types, use.gap.types)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### read.liftMask() extracts the AGAPS mask from a UCSC \"lift\" file.\n###\n\n.read.liftFile <- function(file)\n{\n    COL2CLASS <- c(\n        `offset`=\"integer\",\n        `xxxx`=\"NULL\",  # not sure how to call this\n        `width`=\"integer\",\n        `seqname`=\"character\",\n        `seqlen`=\"integer\"\n    )\n    read.table(file,\n               col.names=names(COL2CLASS),\n               colClasses=COL2CLASS,\n               check.names=FALSE)\n}\n\nread.liftMask <- function(file, seqname=\"?\", mask.width=NA)\n{\n    if (!isSingleString(seqname))\n        stop(\"'seqname' must be a single string\")\n    if (!isSingleNumberOrNA(mask.width))\n        stop(\"'mask.width' must be a single integer or 'NA'\")\n    if (!is.integer(mask.width))\n        mask.width <- as.integer(mask.width)\n    data <- .read.liftFile(file)\n    if (seqname == \"?\")\n        .showDistinctSeqnamesAndStop(data$seqname)\n    data <- data[data$seqname == seqname, ]\n    if (nrow(data) == 0)\n        return(.newEmptyMask(seqname, mask.width, \"AGAPS\", \"assembly gaps\"))\n    ## Sanity checks\n    seqlen0 <- unique(data$seqlen)\n    if (length(seqlen0) != 1)\n        stop(\"broken \\\"lift\\\" file: contains different lengths \",\n             \"for sequence \\\"\", seqname, \"\\\"\")\n    if (!is.na(mask.width) && mask.width != seqlen0)\n        stop(\"when supplied, 'mask.width' must match the length found \",\n             \"in the file for sequence \\\"\", seqname, \"\\\"\")\n    contigs0 <- IRanges(start=data$offset+1, width=data$width)\n    contigs1 <- asNormalIRanges(contigs0, force=TRUE)\n    if (length(contigs1) != length(contigs0))\n        warning(\"some contigs are adjacent or overlapping\")\n    contigs <- Mask(seqlen0, start=start(contigs1), width=width(contigs1))\n    ans <- gaps(contigs)\n    names(ans) <- \"AGAPS\"\n    desc(ans) <- \"assembly gaps\"\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### read.rmMask() extracts the RM mask from a RepeatMasker .out file.\n###\n### See http://www.repeatmasker.org/webrepeatmaskerhelp.html for a\n### description of the RepeatMasker output format.\n###\n\n.read.rmFile <- function(file)\n{\n    COL2CLASS <- c(\n        `SW_score`=\"integer\",\n        `perc_div`=\"numeric\",\n        `perc_del`=\"numeric\",\n        `perc_ins`=\"numeric\",\n        `query_sequence`=\"character\",\n        `begin_in_query`=\"integer\",\n        `end_in_query`=\"integer\",\n        `left_in_query`=\"character\",\n        `C`=\"character\", \n        `matching_repeat`=\"character\",\n        `repeat_class_or_family`=\"character\",\n        `begin_in_repeat`=\"integer\",\n        `end_in_repeat`=\"integer\",\n        `left_in_repeat`=\"character\",\n        `ID`=\"character\"\n    )\n    COLS <- c(\"query_sequence\", \"begin_in_query\", \"end_in_query\", \"ID\")\n    COL2CLASS[!(names(COL2CLASS) %in% COLS)] <- \"NULL\"\n    read.table(file,\n               col.names=names(COL2CLASS),\n               colClasses=COL2CLASS,\n               skip=3,\n               check.names=FALSE)\n}\n\nread.rmMask <- function(file, seqname=\"?\", mask.width=NA, use.IDs=FALSE)\n{\n    if (!isSingleString(seqname))\n        stop(\"'seqname' must be a single string\")\n    if (!isSingleNumberOrNA(mask.width))\n        stop(\"'mask.width' must be a single integer or 'NA'\")\n    if (!is.integer(mask.width))\n        mask.width <- as.integer(mask.width)\n    if (!isTRUEorFALSE(use.IDs))\n        stop(\"'use.IDs' must be TRUE or FALSE\")\n    data <- .read.rmFile(file)\n    if (seqname == \"?\")\n        .showDistinctSeqnamesAndStop(data$query_sequence)\n    data <- data[data$query_sequence == seqname, ]\n    if (nrow(data) == 0)\n        return(.newEmptyMask(seqname, mask.width, \"RM\", \"RepeatMasker\"))\n    ranges <- IRanges(start=data$begin_in_query, end=data$end_in_query)\n    if (use.IDs) {\n        names(ranges) <- data$ID\n        if (S4Vectors:::isNotStrictlySorted(start(ranges)))\n            ranges <- ranges[base::order(start(ranges))]\n        if (!isNormal(ranges))\n            stop(\"cannot use the repeat IDs when some repeats are adjacent or overlap\")\n        nir1 <- asNormalIRanges(ranges, force=FALSE)\n    } else {\n        nir1 <- asNormalIRanges(ranges, force=TRUE)\n    }\n    ## Don't use new2(): the validity of the new mask needs to be checked!\n    new2(\"MaskCollection\", nir_list=list(nir1), width=mask.width, active=TRUE,\n                           NAMES=\"RM\", desc=\"RepeatMasker\", check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### read.trfMask() extracts the TRF mask from a Tandem Repeats Finder .bed\n### file.\n###\n\n.read.trfFile <- function(file)\n{\n    COL2CLASS <- c(\n        `chrom`=\"character\",\n        `chromStart`=\"integer\",\n        `chromEnd`=\"integer\",\n        `name`=\"character\",\n        `period`=\"integer\",\n        `copyNum`=\"numeric\",\n        `consensusSize`=\"integer\",\n        `perMatch`=\"integer\",\n        `perIndel`=\"integer\",\n        `score`=\"integer\",\n        `A`=\"integer\",\n        `C`=\"integer\",\n        `G`=\"integer\",\n        `T`=\"integer\",\n        `entropy`=\"numeric\",\n        `sequence`=\"character\"\n    )\n    COLS <- c(\"chrom\", \"chromStart\", \"chromEnd\")\n    COL2CLASS[!(names(COL2CLASS) %in% COLS)] <- \"NULL\"\n    read.table(file,\n               col.names=names(COL2CLASS),\n               colClasses=COL2CLASS,\n               check.names=FALSE)\n}\n\nread.trfMask <- function(file, seqname=\"?\", mask.width=NA)\n{\n    if (!isSingleString(seqname))\n        stop(\"'seqname' must be a single string\")\n    if (!isSingleNumberOrNA(mask.width))\n        stop(\"'mask.width' must be a single integer or 'NA'\")\n    if (!is.integer(mask.width))\n        mask.width <- as.integer(mask.width)\n    data <- .read.trfFile(file)\n    if (seqname == \"?\")\n        .showDistinctSeqnamesAndStop(data$chrom)\n    data <- data[data$chrom == seqname, ]\n    if (nrow(data) == 0)\n        return(.newEmptyMask(seqname, mask.width, \"TRF\", \"Tandem Repeats Finder\"))\n    ranges <- IRanges(start=data$chromStart+1, end=data$chromEnd)\n    nir1 <- asNormalIRanges(ranges, force=TRUE)\n    ## Don't use new2(): the validity of the new mask needs to be checked!\n    new2(\"MaskCollection\", nir_list=list(nir1), width=mask.width, active=TRUE,\n                           NAMES=\"TRF\", desc=\"Tandem Repeats Finder\", check=FALSE)\n}\n\n",
        "reverse-methods.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"reverse\" generic and methods.\n###\n\nsetGeneric(\"reverse\", function(x, ...) standardGeneric(\"reverse\"))\n\nsetMethod(\"reverse\", \"character\",\n    function(x, ...)\n    {\n        if (length(x) == 0)\n            return(x)\n        sapply(strsplit(x, NULL, fixed=TRUE),\n               function(xx) paste(rev(xx), collapse=\"\"))\n    }\n)\n\n### This method does NOT preserve normality.\n.IRanges.reverse <- function(x, ...)\n{\n    if (length(x) == 0L)\n        return(x)\n    args <- S4Vectors:::extraArgsAsList(NULL, ...)\n    argnames <- names(args)\n    n2p <- match(c(\"start\", \"end\", \"use.names\"), argnames)\n    if (is.na(n2p[1L])) {\n        start <- min(start(x))\n    } else {\n        start <- args[[n2p[1L]]]\n        if (!is.numeric(start))\n            stop(\"'start' must be a vector of integers\")\n        if (!is.integer(start))\n            start <- as.integer(start)\n        if (S4Vectors:::anyMissing(start))\n            stop(\"'start' contains NAs\")\n    }\n    if (is.na(n2p[2L])) {\n        end <- max(end(x))\n    } else {\n        end <- args[[n2p[2L]]]\n        if (!is.numeric(end))\n            stop(\"'end' must be a vector of integers\")\n        if (!is.integer(end))\n            end <- as.integer(end)\n        if (S4Vectors:::anyMissing(end))\n            stop(\"'end' contains NAs\")\n    }\n    if (!is.na(n2p[3L]) && !S4Vectors:::normargUseNames(args[[n2p[3L]]]))\n        x <- set_IRanges_names(x, NULL)\n    ## WARNING: -end(x) *must* appear first in this expression if we want\n    ## the supplied 'start' and 'end' to be recycled properly.\n    ## Remember that in R, because of the recycling, addition of numeric\n    ## vectors of different lengths is not associative i.e. in general\n    ## '(x + y) + z' is not the same as 'x + (y + z)'. For example:\n    ##     (integer(6) + 1:2) + 1:3  and  integer(6) + (1:2 + 1:3)\n    ## are not the same.\n    x@start[] <- -end(x) + start + end\n    x\n}\n\nsetMethod(\"reverse\", \"IRanges\", .IRanges.reverse)\n\nsetMethod(\"reverse\", \"NormalIRanges\",\n    function(x, ...)\n    {\n        ## callNextMethod() temporarily breaks 'x' as a NormalIRanges object\n        ## because the returned ranges are ordered from right to left.\n        x <- callNextMethod()\n        BiocGenerics:::replaceSlots(x, start=rev(start(x)),\n                                       width=rev(width(x)),\n                                       NAMES=rev(names(x)),\n                                       mcols=S4Vectors:::revROWS(mcols(x, use.names=FALSE)))\n    }\n)\n\nsetMethod(\"reverse\", \"Views\",\n    function(x, ...)\n    {\n        x@subject <- rev(subject(x))\n        x@ranges <- reverse(ranges(x), start=1L, end=length(subject(x)))\n        x\n    }\n)\n\nsetMethod(\"reverse\", \"MaskCollection\",\n    function(x, ...)\n    {\n        start <- 1L\n        end <- width(x)\n        x@nir_list <- lapply(nir_list(x),\n            function(nir) reverse(nir, start=start, end=end)\n        )\n        x\n    }\n)\n\n",
        "seqapply.R": "### =========================================================================\n### The stuff in this file should go somewhere else, probably close to\n### splitAsList() (currently defined in S4Vectors/R/split-methods.R)\n### -------------------------------------------------------------------------\n###\n\n## NOT exported.\n`splitAsList<-` <- function(x, f, drop = FALSE, ..., value) {\n  if (!isTRUEorFALSE(drop))\n    stop(\"'drop' must be TRUE or FALSE\")\n  if (NROW(x) != length(f))\n    stop(\"Length of 'f' must equal the length of 'x'\")\n  ind <- splitAsList(seq_len(NROW(x)), f, drop = drop)\n  if (length(ind) != length(value))\n    stop(\"Length of 'value' must equal the length of a split on 'f'\")\n  replaceROWS(x, unlist(ind, use.names=FALSE), unlist(value, use.names = FALSE))\n}\n\nsetMethod(\"unsplit\", \"List\", function(value, f, drop = FALSE) {\n  value_flat <- unlist(value, use.names = FALSE)\n  if (NROW(value_flat) != length(f))\n    stop(\"Length of 'unlist(value)' must equal length of 'f'\")\n  splitAsList(value_flat, f, drop = drop) <- value\n  if (!is.null(ROWNAMES(value_flat))) {\n    nms <- relist(ROWNAMES(value_flat), value)\n    splitAsList(ROWNAMES(value_flat), f, drop = drop) <- nms\n  }\n  value_flat\n})\n\nsetReplaceMethod(\"split\", \"Vector\", function(x, f, drop = FALSE, ..., value) {\n  splitAsList(x, f, drop = drop, ...) <- value\n  x\n})\n\n",
        "setops-methods.R": "### =========================================================================\n### Set operations\n### -------------------------------------------------------------------------\n###\n### 1) Vector-wise set operations: union, intersect, setdiff\n###\n###    When the input are IntegerRanges objects, the functions in that group\n###    interpret each supplied object ('x' or 'y') as a set of integer values.\n###    Therefore, if 2 IRanges objects 'x1' and 'x2' represent the same set\n###    of integers, then each of these functions will return the same result\n###    when 'x1' is replaced with 'x2' in the input. The returned IRanges\n###    object is guaranteed to be normal but is *not* promoted to\n###    NormalIRanges.\n###\n### 2) Element-wise (aka \"parallel\") set operations: punion, pintersect,\n###    psetdiff, pgap\n###\n###    The functions in that group take 2 *objects* of the same length and\n###    return an object of the same class and length as the first argument.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### union()\n###\n\n### Always return an IRanges *instance* whatever IntegerRanges derivatives\n### are passed to it (e.g. IPos, NCList or NormalIRanges), so does NOT act\n### like an endomorphism in general.\nsetMethod(\"union\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y)\n    {\n        ## We downgrade 'x' to an IRanges instance so 'c(x, y)' is guaranteed\n        ## to work (even e.g. if 'x' is a NormalIRanges object).\n        x <- as(x, \"IRanges\", strict=TRUE)\n        reduce(c(x, y), drop.empty.ranges=TRUE)\n    }\n)\n\nsetMethod(\"union\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n          function(x, y) mendoapply(union, x, y))\n\nsetMethod(\"union\", c(\"CompressedIRangesList\", \"CompressedIRangesList\"),\n          function(x, y) {\n            len <- max(length(x), length(y))\n            if (length(x) != len)\n              x <- x[S4Vectors:::recycleVector(seq_len(length(x)), len)]\n            if (length(y) != len)\n              y <- y[S4Vectors:::recycleVector(seq_len(length(y)), len)]\n            xy <- c(unlist(x, use.names = FALSE), unlist(y, use.names = FALSE))\n            xy_list <- split(xy, factor(c(togroup(PartitioningByWidth(x)),\n                                          togroup(PartitioningByWidth(y))),\n                                        seq_len(length(x))))\n            names(xy_list) <- names(x)\n            reduce(xy_list, drop.empty.ranges=TRUE)\n          })\n\nsetMethod(\"union\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n    callGeneric(first(x), second(x), ...)\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### intersect()\n###\n\n### Always return an IRanges *instance* whatever IntegerRanges derivatives\n### are passed to it (e.g. IPos, NCList or NormalIRanges), so does NOT act\n### like an endomorphism in general.\nsetMethod(\"intersect\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y)\n    {\n        if (length(x) == 0L)\n            return(x)\n        start <- min(c(start(x), start(y)))\n        end <- max(c(end(x), end(y)))\n        setdiff(x, gaps(y, start=start, end=end))\n    }\n)\n\nsetMethod(\"intersect\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n          function(x, y) mendoapply(intersect, x, y))\n\nsetMethod(\"intersect\", c(\"CompressedIRangesList\", \"CompressedIRangesList\"),\n          function(x, y) {\n            nonempty <- elementNROWS(x) != 0L\n            rx <- unlist(range(x), use.names = FALSE)\n            startx <- integer()\n            startx[nonempty] <- start(rx)\n            endx <- integer()\n            endx[nonempty] <- end(rx)\n            setdiff(x, gaps(y, start = startx, end = endx))\n          })\n\nsetMethod(\"intersect\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n    callGeneric(first(x), second(x), ...)\n})\n\nsetMethod(\"intersect\", c(\"CompressedAtomicList\", \"CompressedAtomicList\"),\n          function(x, y) {\n              fx <- if (!is(x, \"IntegerList\")) as(x, \"FactorList\") else x\n              fy <- if (!is(y, \"IntegerList\")) as(y, \"FactorList\") else y\n              m <- S4Vectors:::matchIntegerPairs(togroup(PartitioningByEnd(x)),\n                                                 unlist(fx, use.names=FALSE),\n                                                 togroup(PartitioningByEnd(y)),\n                                                 unlist(fy, use.names=FALSE),\n                                                 nomatch=0L)\n              m[duplicated(m)] <- 0L\n              x[relist(m > 0L, x)]\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### setdiff()\n###\n\n### Always return an IRanges *instance* whatever IntegerRanges derivatives\n### are passed to it (e.g. IPos, NCList or NormalIRanges), so does NOT act\n### like an endomorphism in general.\nsetMethod(\"setdiff\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y)\n    {\n        if (length(x) == 0L)\n            return(x)\n        start <- min(c(start(x), start(y)))\n        end <- max(c(end(x), end(y)))\n        gaps(union(gaps(x, start=start, end=end), y), start=start, end=end)\n    }\n)\n\nsetMethod(\"setdiff\", c(\"IntegerRangesList\", \"IntegerRangesList\"),\n          function(x, y) mendoapply(setdiff, x, y))\n\nsetMethod(\"setdiff\", c(\"CompressedIRangesList\", \"CompressedIRangesList\"),\n          function(x, y) {\n            nonempty <- elementNROWS(x) != 0L\n            rx <- unlist(range(x), use.names = FALSE)\n            startx <- rep(NA_integer_, length(x))\n            startx[nonempty] <- start(rx)\n            endx <- rep(NA_integer_, length(x))\n            endx[nonempty] <- end(rx)\n            gaps(union(gaps(x), y), start = startx, end = endx)\n          })\n\nsetMethod(\"setdiff\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n    callGeneric(first(x), second(x), ...)\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### punion()\n###\n\nsetGeneric(\"punion\", signature=c(\"x\", \"y\"),\n    function(x, y, ...) standardGeneric(\"punion\")\n)\n\nsetMethod(\"punion\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y, fill.gap=FALSE)\n    {\n        if (length(x) != length(y))\n            stop(\"'x' and 'y' must have the same length\")\n        if (!isTRUEorFALSE(fill.gap))\n            stop(\"'fill.gap' must be TRUE or FALSE\")\n        if (!fill.gap) {\n            gap <- pmax.int(start(x), start(y)) -\n                   pmin.int(end(x), end(y)) - 1L\n            if (any(gap > 0L))\n                stop(\"some pair of ranges have a gap within \",\n                     \"the 2 members of the pair.\\n\",\n                     \"  Use 'fill.gap=TRUE' to enforce their \",\n                     \"union by filling the gap.\")\n        }\n        ans_start <- pmin.int(start(x), start(y))\n        ans_end <- pmax.int(end(x), end(y))\n        ans_names <- names(x)\n        if (is.null(ans_names))\n            ans_names <- names(y)\n        IRanges(start=ans_start, end=ans_end, names=ans_names)\n    }\n)\n\nsetMethod(\"punion\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n              callGeneric(first(x), second(x), ...)\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pintersect()\n###\n\nsetGeneric(\"pintersect\", signature=c(\"x\", \"y\"),\n    function(x, y, ...) standardGeneric(\"pintersect\")\n)\n\nsetMethod(\"pintersect\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y, resolve.empty=c(\"none\", \"max.start\", \"start.x\"))\n    {\n        if (length(x) != length(y))\n            stop(\"'x' and 'y' must have the same length\")\n\n        ans_start <- pmax.int(start(x), start(y))\n        ans_end <- pmin.int(end(x), end(y))\n        ans_width <- ans_end - ans_start + 1L\n\n        keep_empty_x <- width(x) == 0L\n        if (any(keep_empty_x)) {\n            keep_empty_x <- keep_empty_x &\n              ((start(x) >= start(y) & start(x) <= end(y)) | \n               (start(x) == start(y) & width(y) == 0L))\n        }\n        if (any(keep_empty_x)) {\n            ans_start[keep_empty_x] <- start(x)[keep_empty_x]\n            ans_width[keep_empty_x] <- 0L\n        }\n\n        keep_empty_y <- width(y) == 0L\n        if (any(keep_empty_y)) {\n            keep_empty_y <- keep_empty_y &\n              start(y) >= start(x) & start(y) <= end(x)\n        }\n        if (any(keep_empty_y)) {\n            ans_start[keep_empty_y] <- start(y)[keep_empty_y]\n            ans_width[keep_empty_y] <- 0L\n        }\n\n        check_empty <- ans_width < 0L\n        check_empty[keep_empty_x | keep_empty_y] <- FALSE\n        if (any(check_empty)) {\n            resolve.empty <- match.arg(resolve.empty)\n            if (resolve.empty == \"none\") {\n                stop(\"some intersections produce ambiguous empty ranges.\\n\",\n                     \"  Use argument 'resolve.empty' to resolve them.\")\n            } else {\n                ans_width[check_empty] <- 0L\n                if (resolve.empty == \"start.x\")\n                    ans_start[check_empty] <- start(x)[check_empty]\n            }\n        }\n        ans_names <- names(x)\n        if (is.null(ans_names))\n            ans_names <- names(y)\n        IRanges(start=ans_start, width=ans_width, names=ans_names)\n    }\n)\n\nsetMethod(\"pintersect\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n              callGeneric(first(x), second(x), ...)\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### psetdiff()\n###\n\nsetGeneric(\"psetdiff\", signature=c(\"x\", \"y\"),\n    function(x, y, ...) standardGeneric(\"psetdiff\")\n)\n\nsetMethod(\"psetdiff\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y)\n    {\n        if (length(x) != length(y))\n            stop(\"'x' and 'y' must have the same length\")\n        ans_start <- start(x)\n        ans_end <- end(x)\n        if (any((start(y) > ans_start) & (end(y) < ans_end)))\n            stop(\"some ranges in 'y' have their end points strictly inside\\n\",\n                 \"  the range in 'x' that they need to be subtracted from.\\n\",\n                 \"  Cannot subtract them.\")\n        start2 <- pmax.int(ans_start, start(y))\n        end2 <- pmin.int(ans_end, end(y))\n        ii <- start2 <= end2\n        jj <- end2 == ans_end\n        kk <- ii & jj\n        ans_end[kk] <- start2[kk] - 1L\n        kk <- ii & (!jj)\n        ans_start[kk] <- end2[kk] + 1L\n        ans_names <- names(x)\n        if (is.null(ans_names))\n            ans_names <- names(y)\n        IRanges(start=ans_start, end=ans_end, names=ans_names)\n    }\n)\n\nsetMethod(\"psetdiff\", c(\"Pairs\", \"missing\"), function(x, y, ...) {\n              callGeneric(first(x), second(x), ...)\n          })\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pgap()\n###\n\nsetGeneric(\"pgap\", signature=c(\"x\", \"y\"),\n    function(x, y, ...) standardGeneric(\"pgap\")\n)\n\nsetMethod(\"pgap\", c(\"IntegerRanges\", \"IntegerRanges\"),\n    function(x, y)\n    {\n        if (length(x) != length(y))\n            stop(\"'x' and 'y' must have the same length\")\n        ans_end_plus1 <- pmax.int(start(x), start(y))\n        ans_start <- pmin.int(end(x), end(y)) + 1L\n        ans_width <- ans_end_plus1 - ans_start\n        ans_width[ans_width < 0L] <- 0L\n        ans_names <- names(x)\n        if (is.null(ans_names))\n            ans_names <- names(y)\n        IRanges(start=ans_start, width=ans_width, names=ans_names)\n    }\n)\n\n",
        "slice-methods.R": "### =========================================================================\n### Slice the bread\n### -------------------------------------------------------------------------\n\n\nsetGeneric(\"slice\", signature=\"x\",\n           function(x, lower=-Inf, upper=Inf, ...) standardGeneric(\"slice\"))\n\nsetMethod(\"slice\", \"Rle\",\n          function(x, lower = -Inf, upper = Inf,\n                   includeLower = TRUE, includeUpper = TRUE,\n                   rangesOnly = FALSE)\n          {\n              if (!isSingleNumber(lower)) {\n                  stop(\"'lower' must be a single number\")\n              }\n              if (!isSingleNumber(upper)) {\n                  stop(\"'upper' must be a single number\")\n              }\n              if (!isTRUEorFALSE(includeLower)) {\n                  stop(\"'includeLower' must be TRUE or FALSE\")\n              }\n              if (!isTRUEorFALSE(includeUpper)) {\n                  stop(\"'includeUpper' must be TRUE or FALSE\")\n              }\n              if (!isTRUEorFALSE(rangesOnly)) {\n                  stop(\"'rangesOnly' must be TRUE or FALSE\")\n              }\n              if (lower == -Inf) {\n                  ranges <- Rle(TRUE, length(x))\n              } else if (includeLower) {\n                  ranges <- (x >= lower)\n              } else {\n                  ranges <- (x > lower)\n              }\n              if (upper < Inf) {\n                  if (includeUpper) {\n                      ranges <- ranges & (x <= upper)\n                  } else {\n                      ranges <- ranges & (x < upper)\n                  }\n              }\n              if (rangesOnly) {\n                  as(ranges, \"IRanges\")\n              } else {\n                  Views(x, ranges)\n              }\n          })\n\nsetMethod(\"slice\", \"RleList\",\n          function(x, lower = -Inf, upper = Inf,\n                   includeLower = TRUE, includeUpper = TRUE,\n                   rangesOnly = FALSE)\n          {\n              if (!isSingleNumber(lower))\n                  stop(\"'lower' must be a single number\")\n              if (!isSingleNumber(upper))\n                  stop(\"'upper' must be a single number\")\n              if (!isTRUEorFALSE(includeLower))\n                  stop(\"'includeLower' must be TRUE or FALSE\")\n              if (!isTRUEorFALSE(includeUpper))\n                  stop(\"'includeUpper' must be TRUE or FALSE\")\n              if (!isTRUEorFALSE(rangesOnly))\n                  stop(\"'rangesOnly' must be TRUE or FALSE\")\n              if (lower == -Inf) {\n                  ranges <-\n                    RleList(lapply(elementNROWS(x),\n                                   function(len) Rle(TRUE, len)),\n                            compress=FALSE)\n              } else if (includeLower) {\n                  ranges <- (x >= lower)\n              } else {\n                  ranges <- (x > lower)\n              }\n              if (upper < Inf) {\n                  if (includeUpper) {\n                      ranges <- ranges & (x <= upper)\n                  } else {\n                      ranges <- ranges & (x < upper)\n                  }\n              }\n              if (rangesOnly) {\n                  as(ranges, \"CompressedIRangesList\")\n              } else {\n                  RleViewsList(rleList = x,\n                               rangesList = as(ranges, \"SimpleIRangesList\"))\n              }\n          })\n\nsetMethod(\"slice\", \"ANY\", function(x, lower=-Inf, upper=Inf, ...) {\n  slice(as(x, \"Rle\"), lower=lower, upper=upper, ...)\n})\n",
        "subsetting-utils.R": "### =========================================================================\n### Subsetting utility functions\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### RangesNSBS objects.\n###\n\nsetClass(\"RangesNSBS\",  # not exported\n    contains=\"NSBS\",\n    representation(\n        subscript=\"IRanges\"\n    )\n)\n\n### Construction methods.\n### Supplied arguments are trusted so we don't check them!\n\nsetMethod(\"NSBS\", \"IntegerRanges\",\n    function(i, x, exact=TRUE, strict.upper.bound=TRUE, allow.NAs=FALSE)\n    {\n        i_len <- length(i)\n        if (i_len == 0L) {\n            ## Return a NativeNSBS object of length 0.\n            i <- NULL\n            return(callGeneric())\n        }\n        x_NROW <- NROW(x)\n        if (is(i, \"UnstitchedIPos\")) {\n            ## Return a NativeNSBS object.\n            i <- i@pos\n            return(callGeneric())\n        }\n        if (is(i, \"StitchedIPos\"))\n            i <- i@pos_runs  # TODO: Use collapse() (or stitch()?) when\n                             # it's available\n        i_start <- start(i)\n        i_end <- end(i)\n        if (min(i_start) < 1L || strict.upper.bound && max(i_end) > x_NROW)\n            S4Vectors:::.subscript_error(\"subscript contains out-of-bounds \",\n                                         \"ranges\")\n        if (i_len > 1L) {\n            ans <- new2(\"RangesNSBS\", subscript=i,\n                                      upper_bound=x_NROW,\n                                      upper_bound_is_strict=strict.upper.bound,\n                                      check=FALSE)\n            return(ans)\n        }\n        if (i_end > i_start) {\n            ans <- new2(\"RangeNSBS\", subscript=c(i_start, i_end),\n                                     upper_bound=x_NROW,\n                                     upper_bound_is_strict=strict.upper.bound,\n                                     check=FALSE)\n            return(ans)\n        }\n        ## Return a NativeNSBS object of length <= 1.\n        if (i_end == i_start) {\n            i <- i_start\n        } else {\n            i <- NULL\n        }\n        callGeneric()\n    }\n)\n\n### Other methods.\n\nsetMethod(\"as.integer\", \"RangesNSBS\",\n    function(x) unlist_as_integer(x@subscript)\n)\n\nsetMethod(\"length\", \"RangesNSBS\", function(x) sum(width(x@subscript)))\n\nsetMethod(\"anyDuplicated\", \"RangesNSBS\",\n    function(x, incomparables=FALSE, ...) !isDisjoint(x@subscript)\n)\n\nsetMethod(\"isStrictlySorted\", \"RangesNSBS\", function(x) isNormal(x@subscript))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"extractROWS\" methods for subsetting *by* an IntegerRanges object.\n###\n\nsetMethod(\"extractROWS\", c(\"vector_OR_factor\", \"RangesNSBS\"),\n    function(x, i)\n    {\n        start <- start(i@subscript)\n        width <- width(i@subscript)\n        S4Vectors:::extract_ranges_from_vector_OR_factor(x, start, width)\n    }\n)\n\nsetMethod(\"extractROWS\", c(\"array\", \"RangesNSBS\"),\n    S4Vectors:::default_extractROWS\n)\nsetMethod(\"extractROWS\", c(\"data.frame\", \"RangesNSBS\"),\n    S4Vectors:::default_extractROWS\n)\n\nsetMethod(\"extractROWS\", c(\"Rle\", \"RangesNSBS\"),\n    function(x, i)\n    {\n        start <- start(i@subscript)\n        width <- width(i@subscript)\n        ans <- S4Vectors:::extract_ranges_from_Rle(x, start, width)\n        mcols(ans) <- extractROWS(mcols(x, use.names=FALSE), i)\n        ans\n    }\n)\n\n",
        "tile-methods.R": "### =========================================================================\n### \"tile\" methods\n### -------------------------------------------------------------------------\n###\n\n### TODO: We have a profileration of tools for creating these \"sliding\n### windows\" or \"tiles\": successiveIRanges(), tileGenome(), tile(), and now\n### slidingWindows(). With no visible coherent naming scheme. Introducing\n### a new verb each time we get frustrated because the existing tools don't\n### let us create tiles or windows exactly the way we'd like for the use case\n### of the day is not a sustainable strategy in the long run. This just adds\n### more and more confusion for the end user.\n### So some effort will need to be done towards unification of all these\n### tools. H.P. -- Oct 16, 2016.\n\nsetGeneric(\"tile\", function(x, n, width, ...) standardGeneric(\"tile\"),\n           signature=\"x\")\n\nsetMethod(\"tile\", \"IntegerRanges\", function(x, n, width, ...) {\n  if (!missing(n)) {\n    if (!missing(width))\n      stop(\"only one of 'n' or 'width' can be specified\")\n    if (any(IRanges::width(x) < n))\n      stop(\"some width(x) are less than 'n'\")\n    if (any(n < 0L))\n      stop(\"some 'n' are negative\")\n    n <- S4Vectors:::recycleVector(n, length(x))\n  }\n  if (!missing(width)) {\n    if (!missing(n))\n      stop(\"only one of 'n' or 'width' can be specified\")\n    if (any(width < 0L))\n      stop(\"some 'width' are negative\")\n    n <- ceiling(width(x) / width)\n  }\n  width <- IRanges::width(x) / n\n  ## The floor() is intentional for compatibility with Jim Kent's BigWig code\n  ## tileGenome() uses ceiling() instead\n  tile.end <- floor(unlist_as_integer(IRanges(rep(1L, length(n)), width=n)) *\n                    rep(width, n))\n  tile.end.abs <- tile.end + rep(start(x), n) - 1L\n  tile.width <- S4Vectors:::diffWithInitialZero(as.integer(tile.end.abs))\n  p <- PartitioningByWidth(n, names = names(x))\n  tile.width[start(p)] <- tile.end[start(p)]\n  relist(IRanges(width=tile.width, end=tile.end.abs), p)\n})\n\n### =========================================================================\n### \"slidingWindows\" methods\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"slidingWindows\",\n           function(x, width, step = 1L, ...) standardGeneric(\"slidingWindows\"),\n           signature=\"x\")\n\nsetMethod(\"slidingWindows\", \"IntegerRanges\", function(x, width, step = 1L) {\n    if (!isSingleNumber(width))\n        stop(\"'width' must be a single, non-NA number\")\n    if (!isSingleNumber(step))\n        stop(\"'step' must be a single, non-NA number\")\n    if (any(width < 0L))\n        stop(\"some 'width' are negative\")\n    if (any(step < 0L))\n        stop(\"some 'step' are negative\")\n    n <- ceiling(pmax(width(x) - width, 0L) / step) + 1L\n    window.starts <- unlist_as_integer(IRanges(rep(0L, length(n)), width=n)) *\n                     step + 1L\n    windows <- restrict(IRanges(window.starts, width=width),\n                        end=rep(width(x), n))\n    windows.abs <- shift(windows, rep(start(x), n) - 1L)\n    relist(windows.abs, PartitioningByWidth(n, names = names(x)))\n})\n",
        "windows-methods.R": "### =========================================================================\n### windows()\n### -------------------------------------------------------------------------\n\n\n### windows() is a \"parallel\" version of window() for list-like objects. That\n### is, it does 'mendoapply(window, x, start, end, width)' but uses a fast\n### implementation.\nsetGeneric(\"windows\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA) standardGeneric(\"windows\")\n)\n\n### NOT exported.\n### Low-level utility used by various \"windows\" methods.\nmake_IRanges_from_windows_args <- function(x, start=NA, end=NA, width=NA)\n{\n    x_eltNROWS <- elementNROWS(x)\n    if (!is(start, \"IntegerRanges\"))\n        return(solveUserSEW(x_eltNROWS, start=start, end=end, width=width))\n    if (!(identical(end, NA) && identical(width, NA)))\n        stop(wmsg(\"'end' or 'width' should not be specified or must be \",\n                  \"set to NA when 'start' is an IntegerRanges object\"))\n    if (!is(start, \"IRanges\"))\n        start <- as(start, \"IRanges\")\n    ir <- S4Vectors:::V_recycle(start, x, x_what=\"start\", skeleton_what=\"x\")\n    if (any(start(ir) < 1L) || any(end(ir) > x_eltNROWS))\n        stop(wmsg(\"'start' contains out-of-bounds ranges\"))\n    ir\n}\n\nsetMethod(\"windows\", \"list_OR_List\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        ir <- make_IRanges_from_windows_args(x, start, end, width)\n        if (length(x) == 0L)\n            return(x)\n\n        ## -- Slow path (loops over the list elements of 'x') --\n\n        #for (k in seq_along(x))\n        #    x[[k]] <- extractROWS(x[[k]], ir[k])\n        #return(x)\n\n        ## -- Fast path --\n\n        ## Unlist 'x' (preserving the inner names) and shift the ranges\n        ## in 'ir'.\n        if (is.list(x)) {\n            unlisted_x <- bindROWS(x[[1L]], x[-1L])\n        } else {\n            unlisted_x <- unlist(x, use.names=FALSE)\n        }\n        offsets <- c(0L, end(PartitioningByEnd(x))[-length(x)])\n        ir <- shift(ir, shift=offsets)\n\n        ## Subset.\n        unlisted_ans <- extractROWS(unlisted_x, ir)\n\n        ## Relist.\n        ans_breakpoints <- cumsum(width(ir))\n        ans_partitioning <- PartitioningByEnd(ans_breakpoints, names=names(x))\n        ans <- as(relist(unlisted_ans, ans_partitioning), class(x))\n\n        ## Propagate 'metadata(x)' and 'mcols(x)'.\n        if (is(x, \"List\")) {\n            metadata(ans) <- metadata(x)\n            mcols(ans) <- mcols(x, use.names=FALSE)\n        }\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### narrow()\n###\n### A recursive version of windows() i.e. on a list-like object it's\n### equivalent to:\n###\n###     mendoapply(narrow, x, start, end, width,\n###                        MoreArgs=list(use.names=use.names))\n###\n\nsetGeneric(\"narrow\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA, use.names=TRUE)\n        standardGeneric(\"narrow\")\n)\n\n### Should operate recursively on an ordinary list or an IntegerRangesList,\n### GenomicRangesList, DNAStrinSetList, or GAlignmentsList derivative.\n### But not on an IRanges, GRanges, DNAStringSet, or GAlignments object\n### where it's equivalent to windows().\nsetMethod(\"narrow\", \"ANY\",\n    function(x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        call_windows <- is(x, \"Ranges\") ||\n                        !is(x, \"list_OR_List\") ||\n                        !pcompareRecursively(x)\n        if (call_windows) {\n            ## We've reached a leaf in the recursion tree.\n            ans <- windows(x, start=start, end=end, width=width)\n            if (!S4Vectors:::normargUseNames(use.names))\n                names(ans) <- NULL\n            return(ans)\n        }\n\n        if (!is(start, \"List\"))\n            start <- as(start, \"List\")\n        start <- S4Vectors:::VH_recycle(start, x, \"start\", \"x\")\n        if (!is(width, \"List\"))\n            width <- as(width, \"List\")\n        width <- S4Vectors:::VH_recycle(width, x, \"width\", \"x\")\n        if (!is(end, \"List\"))\n            end <- as(end, \"List\")\n        end <- S4Vectors:::VH_recycle(end, x, \"end\", \"x\")\n\n        if (is(x, \"CompressedList\")) {\n            unlisted_start <- unlist(start, use.names=FALSE)\n            unlisted_end <- unlist(end, use.names=FALSE)\n            unlisted_width <- unlist(width, use.names=FALSE)\n            new_unlistData <- narrow(x@unlistData, start=unlisted_start,\n                                                   end=unlisted_end,\n                                                   width=unlisted_width,\n                                                   use.names=use.names)\n            ans <- BiocGenerics:::replaceSlots(x, unlistData=new_unlistData,\n                                                  check=FALSE)\n            return(ans)\n        }\n        mendoapply(narrow, x, start, end, width,\n                           MoreArgs=list(use.names=use.names))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### heads() and tails()\n###\n### These are just convenience wrappers around windows().\n###\n### They do 'mendoapply(head, x, n)' and 'mendoapply(tail, x, n)',\n### respectively, but use a fast implementation.\n###\n\n.normarg_n <- function(n, x_eltNROWS)\n{\n    if (!is.numeric(n))\n        stop(\"'n' must be an integer vector\")\n    if (!is.integer(n))\n        n <- as.integer(n)\n    if (any(is.na(n)))\n        stop(\"'n' cannot contain NAs\")\n    n <- pmin(x_eltNROWS, n)\n    neg_idx <- which(n < 0L)\n    if (length(neg_idx) != 0L)\n        n[neg_idx] <- pmax(n[neg_idx] + x_eltNROWS[neg_idx], 0L)\n    n\n}\n\nheads <- function(x, n=6L)\n{\n    x_eltNROWS <- unname(elementNROWS(x))\n    n <- .normarg_n(n, x_eltNROWS)\n    windows(x, start=1L, width=n)\n}\n\ntails <- function(x, n=6L)\n{\n    x_eltNROWS <- unname(elementNROWS(x))\n    n <- .normarg_n(n, x_eltNROWS)\n    windows(x, end=x_eltNROWS, width=n)\n}\n\n",
        "zzz.R": "###\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"IRanges\", libpath)\n}\n\n.test <- function() BiocGenerics:::testPackage(\"IRanges\")\n\n"
    },
    "XVector": {
        "OnDiskRaw-class.R": "### =========================================================================\n### OnDiskRaw objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"OnDiskRaw\",\n    representation(\"VIRTUAL\",\n        filepath=\"character\",          # a single string\n        length=\"integer\",              # a single non-negative integer\n        .cache=\"environment\",\n        .objname_in_cache=\"character\"  # a single string\n    ),\n    prototype(\n        .objname_in_cache=\"anonymous\"\n    )\n)\n\n### OnDiskRaw API:\n###   - length()\n###   - loadSequence()\n###   - readXRaw()\n\nsetMethod(\"length\", \"OnDiskRaw\", function(x) x@length)\n\n### Load a sequence of values from an on-disk raw vector, and return them in\n### a raw vector. Every OnDiskRaw concrete subclass needs to implement a\n### \"loadSequence\" method.\nsetGeneric(\"loadSequence\", signature=\"x\",\n    function(x, offset=0, length=NA) standardGeneric(\"loadSequence\")\n    #function(x, offset=0, length=NA, cyclic) standardGeneric(\"loadSequence\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Check/normalize 'offset' and 'length' args against the length of an\n### object.\n###\n\nnormargOffset <- function(offset, obj_length)\n{\n    if (!isSingleNumber(offset))\n        stop(\"'offset' must be a single integer\")\n    if (!is.integer(offset))\n        offset <- as.integer(offset)\n    if (offset < 0L)\n        stop(\"'offset' cannot be negative\")\n    if (offset > obj_length)\n        stop(\"'offset' cannot be greater than object length\")\n    offset\n}\n\nnormargLength <- function(length, obj_length, offset)\n{\n    if (!isSingleNumberOrNA(length))\n        stop(\"'length' must be a single integer or NA\")\n    if (!is.integer(length))\n        length <- as.integer(length)\n    if (is.na(length)) {\n        length <- obj_length - offset\n    } else {\n        if (length < 0L)\n            stop(\"'length' cannot be negative\")\n        if (offset + length > obj_length)\n            stop(\"invalid 'offset' / 'length' combination: would result in \",\n                 \"reading data\\n  beyond the object\")\n    }\n    length\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### readXRaw()\n###\n### Reads raw data from an OnDiskRaw object and returns it as an XRaw (or\n### derived) object. Provides a cache mechanism if the full on-disk object\n### is requested. Based on loadSequence().\n###\n\n### Increment NLINKS counter in 'cache' environment.\n.inc_NLINKS <- function(cache)\n{\n    NLINKS <- try(get(\"NLINKS\", envir=cache, inherits=FALSE), silent=TRUE)\n    if (is(NLINKS, \"try-error\"))\n        NLINKS <- 0L\n    NLINKS <- NLINKS + 1L\n    assign(\"NLINKS\", NLINKS, envir=cache)\n}\n\n### Decrement NLINKS counter in 'cache' environment.\n.dec_NLINKS <- function(cache)\n{\n    NLINKS <- get(\"NLINKS\", envir=cache, inherits=FALSE) - 1L\n    assign(\"NLINKS\", NLINKS, envir=cache)\n}\n\n### Return a new link to a cached object.\n### 'objname' is the name of the cached object.\n### 'cache' is the caching environment.\n### When the number of links for a given cached object reaches 0, then the\n### object is removed from the cache.\n.makeLinkToCachedObject <- function(objname, cache)\n{\n    .inc_NLINKS(cache)\n    ans <- new.env(parent=emptyenv())\n    reg.finalizer(ans,\n        function(e) {\n            if (.dec_NLINKS(cache) == 0L) {\n                if (getOption(\"verbose\"))\n                    cat(\"uncaching \", objname, \"\\n\", sep=\"\")\n                remove(list=objname, envir=cache)\n            }\n        }\n    )\n    ans\n}\n\n### 'Class' must be \"XRaw\" or the name of an XRaw concrete subclass.\n### Returns an instance of class 'Class'.\nreadXRaw <- function(Class, ondiskraw, offset=0, length=NA)\n{\n    if (!is(ondiskraw, \"OnDiskRaw\"))\n        stop(\"'ondiskraw' must be an OnDiskRaw object\")\n    ## Check 'offset'.\n    offset <- normargOffset(offset, length(ondiskraw))\n    ## Check 'length'.\n    length <- normargLength(length, length(ondiskraw), offset)\n\n    cache <- ondiskraw@.cache\n    objname <- ondiskraw@.objname_in_cache\n    ## The 'if (exists(objname, envir=cache)) get(objname, envir=cache)'\n    ## idiom is NOT reliable and should be avoided.\n    ## Because the symbol (objname) can disappear from the cache between\n    ## the moment we test for its presence and the moment we try to get it.\n    ## It's not paranoia: I've actually seen this happen! One possible\n    ## explanation for this is that the symbol was candidate for removal\n    ## from the cache but that removal didn't happen yet because gc() had\n    ## not yet been called (removal from the cache is implemented thru the\n    ## finalizers registered on the objects that are copied from the cache\n    ## and made available to the user). Then the call to get() would trigger\n    ## garbbage collection and that in turn would trigger the removal of\n    ## the symbol *before* get() had a chance to get to it. So it's better to\n    ## use 'try(get(...))': it's atomic, and should be 100% reliable!\n    ans_shared <- try(get(objname, envir=cache, inherits=FALSE), silent=TRUE)\n    if (is(ans_shared, \"try-error\")) {\n        val <- loadSequence(ondiskraw, offset=offset, length=length)\n        ans_shared <- SharedRaw(length, val)\n        if (offset != 0L || length != length(ondiskraw)) {\n            ans <- new(Class, shared=ans_shared, offset=0L, length=length)\n            return(ans)\n        }\n        if (getOption(\"verbose\"))\n            cat(\"caching \", objname, \"\\n\", sep=\"\")\n        assign(objname, ans_shared, envir=cache)\n    }\n    ans_shared@.link_to_cached_object <- .makeLinkToCachedObject(objname,\n                                                                 cache)\n    new(Class, shared=ans_shared, offset=offset, length=length)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .loadSequence()\n###\n### Load a sequence of values from a file containing a linear array of\n### fixed-size atomic values (logical, integer, double, complex, or raw).\n###\n\n### Support the same modes as readBin(), except \"character\" which doesn't\n### have fixed-size values.\n.sizeOnDisk <- function(what)\n{\n    switch(what,\n           logical=, integer=, int=4L,\n           numeric=, double=8L,\n           complex=16L,\n           raw=1L,\n           stop(what, \": unsupported mode\"))\n}\n\n### An alternative to direct use of seek() for skipping bytes in connection,\n### even when the connection doesn't support seek().\n.skipBytes <- function(con, n)\n{\n    if (!isSingleNumber(n) || n < 0)\n        stop(\"'n' must be a single non-negative number\")\n    ## Using seek() should be straightforward and fast. Nothing can beat\n    ## that. Unfortunately, base::seek() is notoriously unreliable on\n    ## Windows (see '?seek') but also appears to be broken in R-3.0.0 on\n    ## my 64-bit Ubuntu laptop when used on a gzfile connection.\n    ## TODO: Remove the '!is(con, \"gzfile\")' condition when seek() is fixed.\n    use_seek <- isSeekable(con) &&\n                .Platform$OS.type != \"windows\" &&\n                !is(con, \"gzfile\")\n    if (use_seek)\n        return(seek(con, n, origin=\"current\"))\n    ### Values to skip are read by small chunks of 8M values that we\n    ### don't keep in memory. This requires less memory than reading them\n    ### all at once, and thus is slightly faster.\n    chunk_size <- 8000000L\n    nloop <- n %/% chunk_size\n    for (i in seq_len(nloop))\n        readBin(con, \"raw\", n=chunk_size)\n    readBin(con, \"raw\", n = n %% chunk_size)\n}\n\n### 'obj_offset' and 'obj_length' are the offset (in bytes) and length (in\n### nb of array values) of a linear array of fixed-size atomic values called\n### the \"object\". 'offset' and 'length' are relative to the object and both\n### must be expressed in nb of array values.\n.loadSequence <- function(filepath, file_type, what,\n                          obj_offset, obj_length, offset=0, length=NA)\n{\n    ## Check 'obj_offset'. Should typically be a double.\n    if (!isSingleNumber(obj_offset) || obj_offset < 0)\n        stop(\"'obj_offset' must be a single non-negative number\")\n    ## Check 'obj_length'.\n    if (!isSingleNumber(obj_length))\n        stop(\"'obj_length' must be a single integer\")\n    if (!is.integer(obj_length))\n        obj_length <- as.integer(obj_length)\n    if (obj_length < 0L)\n        stop(\"'obj_length' cannot be negative\")\n    ## Check 'offset'.\n    offset <- normargOffset(offset, obj_length)\n    ## Check 'length'.\n    length <- normargLength(length, obj_length, offset)\n\n    con <- get(file_type)(filepath, open=\"rb\")\n    on.exit(close(con))\n    n <- obj_offset + as.double(offset) * .sizeOnDisk(what)\n    .skipBytes(con, n)\n    readBin(con, what, n=length, endian=\"big\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### DirectRaw -- A concrete OnDiskRaw subclass that treats the bytes stored\n###              in a file as the values of a raw vector.\n###\n\n.getFileSize <- function(filepath)\n{\n    if (!isSingleString(filepath))\n        stop(\"'filepath' must be a single string\")\n    ans <- file.info(filepath)$size\n    if (is.na(ans) || ans > .Machine$integer.max)\n        stop(\"file size not available or file too big \",\n             \"(size > '.Machine$integer.max')\")\n    as.integer(ans)\n}\n\nsetClass(\"DirectRaw\", contains=\"OnDiskRaw\")\n\nDirectRaw <- function(filepath)\n{\n    ans_length <- .getFileSize(filepath)\n    ans_cache <- new.env(parent=emptyenv())\n    new(\"DirectRaw\", filepath=filepath,\n                     length=ans_length,\n                     .cache=ans_cache)\n}\n\nsetMethod(\"loadSequence\", \"DirectRaw\",\n    function(x, offset=0, length=NA)\n    {\n        .loadSequence(x@filepath, \"file\", \"raw\",\n                      0, x@length, offset=offset, length=length)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SerializedRaw -- A concrete OnDiskRaw subclass for fast access to the\n###                  values stored in a serialized raw vector.\n###\n\n### Supports RDX2 and RDA2 formats only. These are the formats produced\n### when calling save() with 'ascii=FALSE' (the default) and 'ascii=TRUE',\n### respectively.\n.getRdaTypeAndFormat <- function(filepath)\n{\n    if (!isSingleString(filepath))\n        stop(\"'filepath' must be a single string\")\n    RDX2 <- charToRaw(\"RDX2\\nX\\n\")\n    RDA2 <- charToRaw(\"RDA2\\nA\\n\")\n    ## file(), gzfile(), bzfile(), and xzfile() don't necessarily return a\n    ## \"connection\" object with the type (i.e. first more specific class)\n    ## that corresponds to the function that was called. For example, when\n    ## called on a Xz file, gzfile() returns a \"connection\" object of type\n    ## \"xzfile\".\n    for (con_type in c(\"file\", \"gzfile\", \"bzfile\", \"xzfile\")) {\n        con <- get(con_type)(filepath, open=\"rb\")\n        buf <- readBin(con, \"raw\", n=7L)\n        if (identical(buf, RDX2)) {\n            on.exit(close(con))\n            file_format <- \"RDX2\"\n            break\n        }\n        if (identical(buf, RDA2)) {\n            on.exit(close(con))\n            file_format <- \"RDA2\"\n            break\n        }\n        close(con)\n    }\n    if (!identical(try(isOpen(con), silent=TRUE), TRUE))\n        stop(\"unknown file type/format for serialized R objects\")\n    list(file_type=class(con)[1L], file_format=file_format)\n}\n\n.filepos_envir <- new.env(parent=emptyenv())\n\n.get_filepos <- function()\n    get(\"filepos\", envir=.filepos_envir, inherits=FALSE)\n\n.set_filepos <- function(filepos)\n    assign(\"filepos\", filepos, envir=.filepos_envir)\n\n### An enhanced readBin() that keeps track of the current position in the\n### file. Needed because seek() is not supported or reliable on all\n### connections.\n.readBin2 <- function(con, what, n=1L)\n{\n    filepos <- .get_filepos()\n    filepos <- filepos + as.double(n) * .sizeOnDisk(what)\n    .set_filepos(filepos)\n    readBin(con, what, n=n, endian=\"big\")\n}\n\n### The length of a serialized object seems to be stored only for a CHARSXP,\n### an atomic vector (LGLSXP, INTSXP, REALSXP, CPLXSXP, STRSXP, RAWSXP),\n### a list (VECSXP), and an expressions vector (EXPRSXP).\n### See src/main/serialize.c in R source tree.\n.TYPES_WITH_LENGTH <- c(CHARSXP=9L,\n                        LGLSXP=10L, INTSXP=13L, REALSXP=14L,\n                        CPLXSXP=15L, STRSXP=16L, RAWSXP=24L,\n                        VECSXP=19L, EXPRSXP=20L)\n\n### Supports RDX2 and RDA2 formats only.\n.getFirstObjectInfoFromRda <- function(filepath)\n{\n    type_and_format <- .getRdaTypeAndFormat(filepath)\n    file_type <- type_and_format$file_type\n    file_format <- type_and_format$file_format\n    con <- get(file_type)(filepath, open=\"rb\")\n    on.exit(close(con))\n    obj_length <- NA_integer_\n    obj_offset <- NA_real_\n    .set_filepos(0)\n    if (file_format == \"RDX2\") {\n        .readBin2(con, \"raw\", n=31L)\n        obj_name_len <- .readBin2(con, \"integer\", n=1L)\n        obj_name <- rawToChar(.readBin2(con, \"raw\", n=obj_name_len))\n        flags <- .readBin2(con, \"raw\", n=4L)\n        obj_type <- as.integer(flags[4L])\n        other_flags <- as.integer(flags[3L])\n        is_obj <- as.logical(other_flags %% 2L)\n        has_attr <- as.logical((other_flags %/% 2L) %% 2L)\n        has_tag <- as.logical((other_flags %/% 4L) %% 2L)\n        if (obj_type %in% .TYPES_WITH_LENGTH) {\n            obj_length <- .readBin2(con, \"integer\", n=1L)\n            if (obj_length < -1L)\n                stop(\"negative serialized length for vector\")\n            if (obj_length == -1L) {\n                ## Length of a long vector is encoded with 2 integers.\n                len1len2 <- .readBin2(con, \"integer\", n=2L)\n                ## Compute length as a double.\n                obj_length <- len1len2[1L] * (2L^32L) + len1len2[2L]\n            }\n            obj_offset <- .get_filepos()\n        }\n    } else if (file_format == \"RDA2\") {\n        buf <- readLines(con, n=11L)\n        obj_name <- buf[10L]\n        flags <- as.numeric(buf[11L])\n        obj_type <- as.integer(flags %% 256L)\n        other_flags <- as.integer(flags %/% 256L)\n        is_obj <- as.logical(other_flags %% 2L)\n        has_attr <- as.logical((other_flags %/% 2L) %% 2L)\n        has_tag <- as.logical((other_flags %/% 4L) %% 2L)\n        if (obj_type %in% .TYPES_WITH_LENGTH) {\n            obj_length <- as.integer(readLines(con, n=1L))\n            if (obj_length < -1L)\n                stop(\"negative serialized length for vector\")\n            if (obj_length == -1L) {\n                ## Length of a long vector is encoded with 2 integers.\n                len1len2 <- as.integer(readLines(con, n=2L))\n                ## Compute length as a double.\n                obj_length <- len1len2[1L] * (2L^32L) + len1len2[2L]\n            }\n        }\n    }\n    ans2 <- list(obj_name=obj_name,\n                 obj_type=obj_type,\n                 is_obj=is_obj,\n                 has_attr=has_attr,\n                 has_tag=has_tag,\n                 obj_length=obj_length,\n                 obj_offset=obj_offset)\n    c(type_and_format, ans2)\n}\n\n### Works on a serialized logical, integer, double, complex, or raw vector.\n### Extracts only the vector values. All attributes are ignored.\n.loadSequenceFromRda <- function(filepath, offset=0, length=NA)\n{\n    info <- .getFirstObjectInfoFromRda(filepath)\n    file_type <- info$file_type\n    file_format <- info$file_format\n    obj_type <- info$obj_type\n    obj_length <- info$obj_length\n    obj_offset <- info$obj_offset\n\n    if (is.na(obj_length))\n        stop(\"serialized object not a vector (has no length)\")\n    if (!is.integer(obj_length))\n        stop(\"serialized long vectors are not supported\")\n    type <- names(.TYPES_WITH_LENGTH)[match(obj_type, .TYPES_WITH_LENGTH)]\n    what <- switch(type,\n                   LGLSXP=\"logical\",\n                   INTSXP=\"integer\",\n                   REALSXP=\"double\",\n                   CPLXSXP=\"complex\",\n                   RAWSXP=\"raw\",\n                   stop(type, \": unsupported type of serialized vector\"))\n    if (file_format == \"RDX2\") {\n        ans <- .loadSequence(filepath, file_type, what,\n                             obj_offset, obj_length,\n                             offset=offset, length=length)\n    } else {\n        stop(file_format, \" format not supported yet\")\n    }\n    ans\n}\n\nsetClass(\"SerializedRaw\",\n    contains=\"OnDiskRaw\",\n    representation(\n        file_type=\"character\",\n        file_format=\"character\",\n        obj_offset=\"numeric\"  # not integer, so works on a file > 2 Gb\n    )\n)\n\nSerializedRaw <- function(filepath)\n{\n    info <- .getFirstObjectInfoFromRda(filepath)\n    file_type <- info$file_type\n    file_format <- info$file_format\n    obj_type <- info$obj_type\n    obj_length <- info$obj_length\n    obj_offset <- info$obj_offset\n\n    if (file_format != \"RDX2\")\n        stop(\"Object in file was serialized in the \", file_format, \" format, \",\n             \"which is not a binary\\n  format. save() should be called with \",\n             \"'ascii=FALSE' (the default) in order to\\n  produce a binary \",\n             \"file that can be used in a SerializedRaw object.\")\n    ## TODO: Remove this when seek() is fixed.\n    if (file_type != \"file\")\n        warning(\"The '\", filepath, \"' file is compressed (type: \\\"\",\n                file_type, \"\\\").\\n\",\n                \"  At this moment (i.e. in R <= 3.0.0), seek() is reliable \",\n                \"only on an\\n  uncompressed file (type: \\\"file\\\"), so it \",\n                \"cannot be used for fast access\\n  to the data in your file. \",\n                \"This means that loadSequence() will be slow on\\n  your \",\n                \"SerializedRaw object. For much faster access to the data, \",\n                \"consider\\n  using an uncompressed '.rda' file instead. \",\n                \"This is obtained by using\\n  save() with 'compress=FALSE'.\")\n    if (obj_type != .TYPES_WITH_LENGTH[[\"RAWSXP\"]])\n        stop(\"serialized object not a raw vector\")\n    if (!is.integer(obj_length))\n        stop(\"serialized object is a long raw vector -> not supported\")\n    ans_cache <- new.env(parent=emptyenv())\n    new(\"SerializedRaw\", filepath=filepath,\n                         length=obj_length,\n                         .cache=ans_cache,\n                         file_type=file_type,\n                         file_format=file_format,\n                         obj_offset=obj_offset)\n}\n\nsetMethod(\"loadSequence\", \"SerializedRaw\",\n    function(x, offset=0, length=NA)\n    {\n        .loadSequence(x@filepath, x@file_type, \"raw\",\n                      x@obj_offset, x@length,\n                      offset=offset, length=length)\n    }\n)\n\n\n",
        "RDS-random-access.R": "### =========================================================================\n### Random access to the elements of a serialized atomic vector or array\n### -------------------------------------------------------------------------\n\n\n### Should probably move this to R/io-utils.R\n.open_input_file <- function(file)\n{\n    filexp_list <- open_input_files(file)\n    stopifnot(length(filexp_list) == 1L)\n    filexp_list[[1L]]\n}\n\n.read_RDS_file <- function(file, mode, attribs_dump=NULL)\n{\n    filexp <- .open_input_file(file)\n    .Call(\"RDS_read_file\", filexp, mode, attribs_dump, PACKAGE=\"XVector\")\n}\n\nread_RDS <- function(file, attribs.only=FALSE)\n{\n    mode <- if (attribs.only) 3L else 0L\n    attribs_dump <- new.env(parent=emptyenv())\n    ans <- .read_RDS_file(file, mode, attribs_dump=attribs_dump)\n    if (attribs.only)\n        ans <- attribs_dump\n    ans\n}\n\nread_RDS_typeof_and_length <- function(file) .read_RDS_file(file, 4L)\n\nextract_subvector_from_RDS_vector <- function(file, pos)\n{\n    filexp <- .open_input_file(file)\n    .Call(\"RDS_extract_subvector\", filexp, pos, PACKAGE=\"XVector\")\n}\n\nextract_subarray_from_RDS_array <- function(file, index)\n{\n    attribs_dump <- read_RDS(file, attribs.only=TRUE)\n    x_dim <- try(get(\"dim\", envir=attribs_dump, inherits=FALSE), silent=TRUE)\n    if (inherits(x_dim , \"try-error\"))\n        stop(\"serialized object is not an array\")\n    filexp <- .open_input_file(file)\n    .Call(\"RDS_extract_subarray\", filexp, x_dim, index, PACKAGE=\"XVector\")\n}\n\n",
        "RdaCollection-class.R": "### =========================================================================\n### RdaCollection objects\n### -------------------------------------------------------------------------\n###\n### June 2020: THE RdaCollection CLASS IS SUPERSEDED BY THE RdsCollection\n### CLASS!\n### TODO: Deprecate the RdaCollection class.\n###\n### An RdaCollection object points to a collection of serialized R objects\n### stored as 1 object per rda file, all located in the same folder on the\n### file system. In addition the name of each rda file must be <objname>.rda,\n### where <objname> is the name of the serialized object. Each serialized\n### object must have a name that is unique within the RdaCollection object.\n###\n\nsetClass(\"RdaCollection\",\n    representation(\n        dirpath=\"character\",   # a single string\n        objnames=\"character\"   # a vector of unique object names (no NAs, no\n                               # empty strings)\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 3 low-level helper functions.\n###\n\n.check_objname <- function(objname, x_objnames)\n{\n    not_ok_idx <- which(!(objname %in% x_objnames))\n    nb_not_ok_idx <- length(not_ok_idx)\n    if (nb_not_ok_idx != 0L) {\n        if (nb_not_ok_idx == 1L) {\n            what <- \"name\"\n        } else {\n            what <- \"names\"\n        }\n        objnames_in_1string <- paste(objname[not_ok_idx], collapse=\", \")\n        stop(\"invalid object \", what, \": \", objnames_in_1string)\n    }\n}\n\n### Recycles shortest arg along longest.\n.get_rdapath <- function(dirpath, objname)\n{\n    if (length(objname) == 0L)\n        return(character(0))\n    filename <- paste0(objname, \".rda\")\n    file.path(dirpath, filename)\n}\n\n.load_serialized_object <- function(dirpath, objname)\n{\n    filepath <- .get_rdapath(dirpath, objname)\n    tempenv <- new.env(parent=emptyenv())\n    loaded_names <- load(filepath, envir=tempenv)\n    if (length(loaded_names) != 1L)\n        stop(\"file '\", filepath, \"' contains 0 or more \",\n             \"than 1 serialized object\")\n    if (loaded_names != objname)\n        stop(\"serialized object in file '\", filepath, \"' \",\n             \"doesn't have the expected name (expected: \", objname,\n             \" -- current: \", loaded_names, \")\")\n    get(objname, envir=tempenv)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters.\n###\n\nsetMethod(\"length\", \"RdaCollection\", function(x) length(x@objnames))\n\nsetMethod(\"names\", \"RdaCollection\", function(x) x@objnames)\n\nsetGeneric(\"rdaPath\", signature=\"x\",\n    function(x, objname) standardGeneric(\"rdaPath\")\n)\n\n### Vectorized with respect to 'objname'.\nsetMethod(\"rdaPath\", \"RdaCollection\",\n    function(x, objname)\n    {\n        if (!is.character(objname))\n            stop(\"'objname' must be a character vector\")\n        .check_objname(objname, names(x))\n        .get_rdapath(x@dirpath, objname)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.RdaCollection <- function(x)\n{\n    x_dirpath <- x@dirpath\n    x_objnames <- x@objnames\n    if (!is.character(x_objnames) || !is.null(names(x_objnames)))\n        return(\"\\\"objnames\\\" slot must be an unnamed character vector\")\n    if (anyDuplicated(x_objnames))\n        return(\"\\\"objnames\\\" slot contains duplicates\")\n    if (any(x_objnames %in% c(NA_character_, \"\")))\n        return(\"\\\"objnames\\\" slot contains NAs or empty strings\")\n\n    ## Only checks that all the rda files exist. Does NOT try to check\n    ## their content (that would be too expensive).\n    filepaths <- .get_rdapath(x_dirpath, x_objnames)\n    missing_idx <- which(!file.exists(filepaths))\n    nb_missing <- length(missing_idx)\n    if (nb_missing != 0L) {\n        if (nb_missing == 1L) {\n            what <- \"file\"\n            is_or_are <- \"is\"\n        } else {\n            what <- \"files\"\n            is_or_are <- \"are\"\n        }\n        filepaths_in_1string <-\n            paste(paste0(\"'\", filepaths[missing_idx], \"'\"), collapse=\", \")\n        is_or_are <- ifelse(length(missing_idx) == 1L, \"is\", \"are\")\n        msg <- c(what, filepaths_in_1string, is_or_are, \"missing\")\n        return(paste(msg, collapse=\" \"))\n    }\n    NULL\n}\n\nsetValidity2(\"RdaCollection\", .valid.RdaCollection)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor.\n###\n\nRdaCollection <- function(dirpath, objnames)\n{\n    new(\"RdaCollection\", dirpath=dirpath, objnames=objnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"[[\" method (list-element extraction).\n###\n### We only support subetting by name.\n###\n\nsetMethod(\"[[\", \"RdaCollection\",\n    function(x, i, j, ...)\n    {\n        if (!missing(j) || length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        if (!is.character(i))\n            stop(\"an RdaCollection object can only be subsetted by name\")\n        if (length(i) < 1L)\n            stop(\"attempt to select less than one element\")\n        if (length(i) > 1L)\n            stop(\"attempt to select more than one element\")\n        .check_objname(i, names(x))\n        .load_serialized_object(x@dirpath, i)\n    }\n)\n\n",
        "RdsCollection-class.R": "### =========================================================================\n### RdsCollection objects\n### -------------------------------------------------------------------------\n###\n### An RdsCollection object points to a collection of serialized R objects\n### stored as 1 object per .rds file, all located in the same directory on\n### the file system.\n###\n\nsetClass(\"RdsCollection\",\n    contains=\"List\",\n    representation(\n        dirpath=\"character\",   # Absolute path to an existing directory.\n        filenames=\"character\"  # Vector of file names. The vector itself\n                               # must have names on it.\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"RdsCollection\",\n    function(x) c(\"filenames\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n### Similarly to validity methods, helper functions used by the validity\n### method must return TRUE if the component to validate is valid, or a single\n### string describing why it's not. With a small difference: while validity\n### methods in general are allowed to return a character vector of arbitrary\n### length describing a list of problems, our helper functions are only\n### allowed to return a single string (or a TRUE). The returned string must\n### describe the first encountered problem.\n###\n\n.validate_dirpath <- function(dirpath, what=\"the 'dirpath' slot\")\n{\n    if (!isSingleString(dirpath))\n        return(paste0(what, \" must be a single string specifying the path \",\n                      \"to the directory where the .rds files are located\"))\n    if (!dir.exists(dirpath))\n        return(paste0(what, \" must contain the path to an existing directory\"))\n    TRUE\n}\n\n.RDS_FILEEXT <- \".rds\"\n\n.bad_files_msg <- function(filenames, in_what, be_what)\n{\n    filenames_in1string <- paste0(paste0(\"\\\"\", filenames, \"\\\"\"), collapse=\", \")\n    paste0(\"All the files specified in \", in_what, \" must be \", be_what, \". \",\n           \"The following are not: \", filenames_in1string, \".\")\n}\n\n.validate_filenames <- function(filenames, dirpath, what=\"the 'filenames' slot\")\n{\n    if (!is.character(filenames))\n        return(paste0(what, \" must be a character vector\"))\n\n    if (anyNA(filenames))\n        return(paste0(what, \" cannot contain NAs\"))\n\n    ## Check extension.\n    suffix_ends <- nchar(filenames)\n    suffix_starts <- suffix_ends - nchar(.RDS_FILEEXT) + 1L\n    suffixes <- substr(filenames, suffix_starts, suffix_ends)\n    if (!all(suffixes == .RDS_FILEEXT))\n        return(paste0(\"all filenames in \", what, \" must have \",\n                      \"file extension \\\"\", .RDS_FILEEXT, \"\\\"\"))\n\n    ## Check that the .rds files exist.\n    filepaths <- file.path(dirpath, filenames)\n    missing_idx <- which(!file.exists(filepaths))\n    if (length(missing_idx) != 0L) {\n        be_what <- paste0(\"present in directory \\\"\", dirpath, \"\\\"\")\n        return(.bad_files_msg(filenames[missing_idx], what, be_what))\n    }\n\n    ## Check that the .rds files are valid RDS files.\n    ## Do NOT try to check their content, that would be too expensive!\n    not_ok <- vapply(filepaths,\n        function(filepath) {\n            inherits(try(infoRDS(filepath), silent=TRUE), \"try-error\")\n        },\n        logical(1)\n    )\n    not_ok_idx <- which(not_ok)\n    if (length(not_ok_idx) != 0L)\n        return(.bad_files_msg(filenames[not_ok_idx], what, \"valid RDS files\"))\n\n    TRUE\n}\n\n.validate_filenames_names <- function(names, what=\"the 'filenames' slot\")\n{\n    if (is.null(names))\n        return(paste0(what, \" must have names on it\"))\n    if (any(names %in% c(NA_character_, \"\")))\n        return(paste0(\"the names on \", what, \" cannot contain NAs \",\n                      \"or empty strings\"))\n    TRUE\n}\n\n.validate_RdsCollection <- function(x)\n{\n    ## Validate the 'dirpath' slot.\n    msg <- .validate_dirpath(x@dirpath)\n    if (!isTRUE(msg))\n        return(msg)\n    abspath <- file_path_as_absolute(x@dirpath)\n    if (abspath != x@dirpath)\n        return(paste0(\"the 'dirpath' slot must contain the absolute \",\n                      \"path (\", abspath, \") to directory \", x@dirpath))\n\n    ## Validate the 'filenames' slot.\n    msg <- .validate_filenames(x@filenames, x@dirpath)\n    if (!isTRUE(msg))\n        return(msg)\n\n    ## Validate the names on the 'filenames' slot.\n    msg <- .validate_filenames_names(names(x@filenames))\n    if (!isTRUE(msg))\n        return(msg)\n\n    TRUE\n}\n\nsetValidity2(\"RdsCollection\", .validate_RdsCollection)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nRdsCollection <- function(path=\".\", filenames=NULL)\n{\n\n    msg <- .validate_dirpath(path, what=\"'path'\")\n    if (!isTRUE(msg))\n        stop(wmsg(msg))\n\n    check <- FALSE\n    if (is.null(filenames)) {\n        ## Autogenerate the filenames.\n        pattern <- paste0(\"\\\\\", .RDS_FILEEXT, \"$\")\n        filenames <- dir(path, pattern=pattern, all.files=TRUE)\n        check <- TRUE\n    } else {\n        msg <- .validate_filenames(filenames, path, what=\"'filenames'\")\n        if (!isTRUE(msg))\n            stop(wmsg(msg))\n    }\n\n    names <- names(filenames)\n    if (is.null(names)) {\n        ## Infer names from the filenames.\n        noext_ends <- nchar(filenames) - nchar(.RDS_FILEEXT)\n        noext_filenames <- substr(filenames, 1L, noext_ends)\n        names(filenames) <- noext_filenames\n        check <- TRUE\n    } else {\n        msg <- .validate_filenames_names(names, what=\"'filenames'\")\n        if (!isTRUE(msg))\n            stop(wmsg(msg))\n    }\n\n    new2(\"RdsCollection\", dirpath=file_path_as_absolute(path),\n                          filenames=filenames,\n                          check=check)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"path\", \"RdsCollection\", function(object) object@dirpath)\n\nsetMethod(\"names\", \"RdsCollection\", function(x) names(x@filenames))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"extractROWS\", \"RdsCollection\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x)\n        x@filenames <- x@filenames[i]\n        x\n    }\n)\n\nsetMethod(\"getListElement\", \"RdsCollection\",\n    function(x, i, exact=TRUE)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x, exact=exact)\n        readRDS(file.path(path(x), x@filenames[[i]]))\n    }\n)\n\n",
        "SharedDouble-class.R": "### =========================================================================\n### SharedDouble objects\n### -------------------------------------------------------------------------\n###\n### A SharedDouble object is an external pointer to an ordinary double\n### vector.\n###\n\nsetClass(\"SharedDouble\", contains=\"SharedVector\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Initialization.\n###\n### Note that, unlike 'numeric(99)', 'SharedDouble(99)' does NOT initialize its\n### data. Specify the 'val' argument if you want data initialization.\n###\n\nSharedDouble <- function(length=0L, val=NULL)\n{\n    if (!isSingleNumber(length) || length < 0)\n        stop(\"'length' must be a single non-negative integer\")\n    if (!is.integer(length))\n        length <- as.integer(length)\n    if (!is.null(val)) {\n        if (!is.numeric(val))\n            stop(\"'val' must be a numeric vector\")\n        if (!storage.mode(val) == \"double\")\n            storage.mode(val) <- \"double\"\n    }\n    .Call2(\"SharedDouble_new\", length, val, PACKAGE=\"XVector\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.SharedDouble <- function(x)\n{\n    if (!tagIsVector(x@xp, tagtype=\"double\"))\n        return(problemIfNotExternalVector(\"'x@xp'\",\n                                          tagmustbe=\"a double vector\"))\n    NULL\n}\n\nsetValidity2(\"SharedDouble\", .valid.SharedDouble)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Read/write functions.\n### These are almost safe wrappers to unsafe C functions (\"almost\" because\n### they don't check for NAs in their arguments).\n### If length(i) == 0 then the read functions return an empty vector\n### and the write functions don't do anything.\n###\n\nSharedDouble.read <- function(x, i, imax=integer(0))\n{\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedDouble_read_nums_from_i1i2\", x, i, imax, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedDouble_read_nums_from_subscript\", x, i, PACKAGE=\"XVector\")\n    }\n}\n\nSharedDouble.write <- function(x, i, imax=integer(0), value)\n{\n    if (!is.numeric(value))\n        stop(\"'value' must be a numeric vector\")\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedDouble_write_nums_to_i1i2\", x, i, imax, value, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedDouble_write_nums_to_subscript\", x, i, value, PACKAGE=\"XVector\")\n    }\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetMethod(\"as.numeric\", \"SharedDouble\",\n    function(x, ...) SharedDouble.read(x, 1L, length(x))\n)\n\n",
        "SharedInteger-class.R": "### =========================================================================\n### SharedInteger objects\n### -------------------------------------------------------------------------\n###\n### A SharedInteger object is an external pointer to an ordinary integer\n### vector.\n###\n\nsetClass(\"SharedInteger\", contains=\"SharedVector\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Initialization.\n###\n### Note that, unlike 'integer(99)', 'SharedInteger(99)' does NOT initialize its\n### data. Specify the 'val' argument if you want data initialization.\n###\n\nSharedInteger <- function(length=0L, val=NULL)\n{\n    if (!isSingleNumber(length) || length < 0)\n        stop(\"'length' must be a single non-negative integer\")\n    if (!is.integer(length))\n        length <- as.integer(length)\n    if (!is.null(val)) {\n        if (!is.numeric(val))\n            stop(\"'val' must be a numeric vector\")\n        if (!storage.mode(val) == \"integer\")\n            storage.mode(val) <- \"integer\"\n    }\n    .Call2(\"SharedInteger_new\", length, val, PACKAGE=\"XVector\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.SharedInteger <- function(x)\n{\n    if (!tagIsVector(x@xp, tagtype=\"integer\"))\n        return(problemIfNotExternalVector(\"'x@xp'\",\n                                          tagmustbe=\"an integer vector\"))\n    NULL\n}\n\nsetValidity2(\"SharedInteger\", .valid.SharedInteger)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Read/write functions.\n### These are almost safe wrappers to unsafe C functions (\"almost\" because\n### they don't check for NAs in their arguments).\n### If length(i) == 0 then the read functions return an empty vector\n### and the write functions don't do anything.\n###\n\nSharedInteger.read <- function(x, i, imax=integer(0))\n{\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedInteger_read_ints_from_i1i2\", x, i, imax, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedInteger_read_ints_from_subscript\", x, i, PACKAGE=\"XVector\")\n    }\n}\n\nSharedInteger.write <- function(x, i, imax=integer(0), value)\n{\n    if (!is.integer(value))\n        stop(\"'value' must be an integer vector\")\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedInteger_write_ints_to_i1i2\", x, i, imax, value, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedInteger_write_ints_to_subscript\", x, i, value, PACKAGE=\"XVector\")\n    }\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetMethod(\"as.integer\", \"SharedInteger\",\n    function(x, ...) SharedInteger.read(x, 1L, length(x))\n)\n\n",
        "SharedRaw-class.R": "### =========================================================================\n### SharedRaw objects and SharedRaw_Pool objects\n### -------------------------------------------------------------------------\n###\n### A SharedRaw object is an external pointer to an ordinary raw vector.\n### A SharedRaw_Pool object is *conceptually* a list of SharedRaw\n### objects but is actually NOT *implemented* as a list of such objects.\n### See SharedVector-class.R file for the representation details.\n###\n\nsetClass(\"SharedRaw\", contains=\"SharedVector\")\n\nsetClass(\"SharedRaw_Pool\", contains=\"SharedVector_Pool\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Initialization.\n###\n\n### Note that, unlike 'raw(99)', 'SharedRaw(99)' does NOT initialize its\n### data. Specify the 'val' argument if you want data initialization.\nSharedRaw <- function(length=0L, val=NULL)\n{\n    if (!isSingleNumber(length) || length < 0)\n        stop(\"'length' must be a single non-negative integer\")\n    if (!is.integer(length))\n        length <- as.integer(length)\n    if (!is.null(val) && !is.raw(val)) {\n        if (is.numeric(val)) {\n            val <- as.raw(val)\n        } else if (isSingleString(val)) {\n            val <- charToRaw(val)\n        } else {\n            stop(\"don't know how to turn 'val' into a raw vector\")\n        }\n    }\n    .Call2(\"SharedRaw_new\", length, val, PACKAGE=\"XVector\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some low-level methods.\n###\n\nsetMethod(\"[[\", \"SharedRaw_Pool\",\n    function(x, i, j, ...)\n    {\n        if (!isSingleInteger(i) || i < 1L || i > length(x))\n            stop(\"invalid subscript\")\n        ans <- SharedRaw()\n        ans@xp <- x@xp_list[[i]]\n        ans@.link_to_cached_object <- x@.link_to_cached_object_list[[i]]\n        ans\n    }\n)\n\nsetReplaceMethod(\"[[\", \"SharedRaw_Pool\",\n    function(x, i, j, ..., value)\n    {\n        if (!isSingleInteger(i) || i < 1L || i > length(x))\n            stop(\"invalid subscript\")\n        if (class(value) != \"SharedRaw\")\n            stop(\"replacement value must be a SharedRaw instance\")\n        x@xp_list[[i]] <- value@xp\n        x@.link_to_cached_object_list[[i]] <- value@.link_to_cached_object\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.SharedRaw <- function(x)\n{\n    if (!tagIsVector(x@xp, tagtype=\"raw\"))\n        return(problemIfNotExternalVector(\"'x@xp'\",\n                                          tagmustbe=\"a raw vector\"))\n    NULL\n}\n\nsetValidity2(\"SharedRaw\", .valid.SharedRaw)\n\n.valid.SharedRaw_Pool <- function(x)\n{\n    if (!all(sapply(x@xp_list,\n                    function(elt) tagIsVector(elt, tagtype=\"raw\"))))\n        return(problemIfNotExternalVector(\"each element in 'x@xp_list'\",\n                                          tagmustbe=\"a raw vector\"))\n    NULL\n}\n\nsetValidity2(\"SharedRaw_Pool\", .valid.SharedRaw_Pool)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_character_from_SharedRaw_by_positions() and\n### extract_character_from_SharedRaw_by_ranges()\n###\n\n### Typical use:\n###   x <- SharedRaw(5, charToRaw(\"Hello\"))\n###   extract_character_from_SharedRaw_by_positions(x, 5:2)\n###   extract_character_from_SharedRaw_by_positions(x, 5:2, collapse=TRUE)\nextract_character_from_SharedRaw_by_positions <- function(x, pos,\n                                                          collapse=FALSE,\n                                                          lkup=NULL)\n{\n    .Call(\"C_extract_character_from_SharedRaw_by_positions\",\n          x, pos, collapse, lkup,\n          PACKAGE=\"XVector\")\n}\n\n### Typical use:\n###   x <- SharedRaw(5, charToRaw(\"Hello\"))\n###   extract_character_from_SharedRaw_by_ranges(x, 3:1, c(2:1, 4L))\n###   extract_character_from_SharedRaw_by_ranges(x, 3:1, c(2:1, 4L),\n###                                              collapse=TRUE)\nextract_character_from_SharedRaw_by_ranges <- function(x, start, width,\n                                                       collapse=FALSE,\n                                                       lkup=NULL)\n{\n    .Call(\"C_extract_character_from_SharedRaw_by_ranges\",\n          x, start, width, collapse, lkup,\n          PACKAGE=\"XVector\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Read/write functions\n###\n### NOTE: This is pretty old stuff! Some of it is now superseded by more\n### modern extract_character_from_SharedRaw_by_positions() and\n### extract_character_from_SharedRaw_by_ranges() above.\n###\n### These are almost safe wrappers to unsafe C functions (\"almost\" because\n### they don't check for NAs in their arguments).\n### If length(i) == 0 then the read functions return an empty vector\n### and the write functions don't do anything.\n\nSharedRaw.readInts <- function(x, i, imax=integer(0))\n{\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedRaw_read_ints_from_i1i2\", x, i, imax, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedRaw_read_ints_from_subscript\", x, i, PACKAGE=\"XVector\")\n    }\n}\n\nSharedRaw.writeInts <- function(x, i, imax=integer(0), value)\n{\n    if (!is.integer(value))\n        stop(\"'value' must be an integer vector\")\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedRaw_write_ints_to_i1i2\", x, i, imax, value, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedRaw_write_ints_to_subscript\", x, i, value, PACKAGE=\"XVector\")\n    }\n    x\n}\n\n### 'dec_lkup' must be NULL or a vector of integers\nSharedRaw.read <- function(x, i, imax=integer(0), dec_lkup=NULL)\n{\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        if (is.null(dec_lkup))\n            .Call2(\"SharedRaw_read_chars_from_i1i2\",\n                  x, i, imax, PACKAGE=\"XVector\")\n        else\n            .Call2(\"SharedRaw_read_enc_chars_from_i1i2\",\n                  x, i, imax, dec_lkup, PACKAGE=\"XVector\")\n    } else {\n        if (is.null(dec_lkup))\n            .Call2(\"SharedRaw_read_chars_from_subscript\",\n                  x, i, PACKAGE=\"XVector\")\n        else\n            .Call2(\"SharedRaw_read_enc_chars_from_subscript\",\n                  x, i, dec_lkup, PACKAGE=\"XVector\")\n    }\n}\n\n### 'enc_lkup' must be NULL or a vector of integers\nSharedRaw.write <- function(x, i, imax=integer(0), value, enc_lkup=NULL)\n{\n    if (!isSingleString(value))\n        stop(\"'value' must be a single string\")\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        if (is.null(enc_lkup))\n            .Call2(\"SharedRaw_write_chars_to_i1i2\",\n                  x, i, imax, value, PACKAGE=\"XVector\")\n        else\n            .Call2(\"SharedRaw_write_enc_chars_to_i1i2\",\n                  x, i, imax, value, enc_lkup, PACKAGE=\"XVector\")\n    } else {\n        if (is.null(enc_lkup))\n            .Call2(\"SharedRaw_write_chars_to_subscript\",\n                  x, i, value, PACKAGE=\"XVector\")\n        else\n            .Call2(\"SharedRaw_write_enc_chars_to_subscript\",\n                  x, i, value, enc_lkup, PACKAGE=\"XVector\")\n    }\n    x\n}\n\n### 'lkup' must be a vector of complexes\nSharedRaw.readComplexes <- function(x, i, imax=integer(0), lkup)\n{\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        .Call2(\"SharedRaw_read_complexes_from_i1i2\",\n              x, i, imax, lkup, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedRaw_read_complexes_from_subscript\",\n              x, i, lkup, PACKAGE=\"XVector\")\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n### TODO: add the \"as.raw\" and \"as.character\" methods.\n###\n\nsetMethod(\"as.integer\", \"SharedRaw\",\n    function(x, ...)\n    {\n        SharedRaw.readInts(x, 1L, length(x))\n    }\n)\n\n### Typical use:\n###   x <- SharedRaw(15, as.raw(65))\n###   toString(x)\n###   x <- SharedRaw(5, charToRaw(\"Hello\"))\n###   toString(x)\n### This should always rewrite the content of a SharedRaw object\n### to itself, without any modification:\n###   SharedRaw.write(x, 1, length(x), value=toString(x))\n### whatever the content of 'x' is!\nsetMethod(\"toString\", \"SharedRaw\",\n    function(x, ...) SharedRaw.read(x, 1, length(x))\n)\n\n",
        "SharedVector-class.R": "### =========================================================================\n### SharedVector and SharedVector_Pool objects\n### -------------------------------------------------------------------------\n###\n### A SharedVector object is an external pointer to an ordinary vector.\n### A SharedVector_Pool object is *conceptually* a list of SharedVector\n### objects but is actually NOT *implemented* as a list of such objects.\n### This is to avoid having to generate long lists of S4 objects which the\n### current S4 implementation is *very* inefficient at.\n###\n\nsetClass(\"SharedVector\",\n    representation(\"VIRTUAL\",\n        xp=\"externalptr\",\n        ## Any object that is never copied on assignment would be fine here.\n        ## See R/BSgenome-class.R in the BSgenome package for how this slot\n        ## is used for automatic uncaching of the sequences of a BSgenome\n        ## object.\n        .link_to_cached_object=\"environment\"\n    ),\n    prototype(\n        .link_to_cached_object=new.env(hash=FALSE, parent=emptyenv())\n    )\n)\n\nsetClass(\"SharedVector_Pool\",\n    representation(\"VIRTUAL\",\n        xp_list=\"list\",\n        .link_to_cached_object_list=\"list\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level utilities operating directly on an externalptr object.\n###\n\n.get_tag <- function(x)\n{\n    if (!is(x, \"externalptr\"))\n        stop(\"'x' must be an externalptr object\")\n    .Call2(\"externalptr_get_tag\", x, PACKAGE=\"XVector\")\n}\n\n.set_tag <- function(x, tag)\n{\n    if (!is(x, \"externalptr\"))\n        stop(\"'x' must be an externalptr object\")\n    .Call2(\"externalptr_set_tag\", x, tag, PACKAGE=\"XVector\")\n}\n\n.taglength <- function(x)\n{\n    if (!is(x, \"externalptr\"))\n        stop(\"'x' must be an externalptr object\")\n    .Call2(\"externalptr_taglength\", x, PACKAGE=\"XVector\")\n}\n\n.tagtype <- function(x)\n{\n    if (!is(x, \"externalptr\"))\n        stop(\"'x' must be an externalptr object\")\n    .Call2(\"externalptr_tagtype\", x, PACKAGE=\"XVector\")\n}\n\ntagIsVector <- function(x, tagtype=NA)\n{\n    if (!is(x, \"externalptr\"))\n        stop(\"'x' must be an externalptr object\")\n    x_tagtype <- .tagtype(x)\n    if (!is.na(tagtype))\n        return(x_tagtype == tagtype)\n    return(x_tagtype == \"double\" || extends(x_tagtype, \"vector\"))\n}\n\nnewExternalptrWithTag <- function(tag=NULL)\n{\n    xp <- .Call2(\"externalptr_new\", PACKAGE=\"XVector\")\n    .set_tag(xp, tag)\n}\n\n### Helper function (for debugging purpose).\n### Print some info about an externalptr object.\n### Typical use:\n###   show(new(\"externalptr\"))\nsetMethod(\"show\", \"externalptr\",\n    function(object)\n        .Call2(\"externalptr_show\", object, PACKAGE=\"XVector\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SharedVector constructor.\n###\n\n### Just dispatches on the specific constructor function (each SharedVector\n### concrete subclass should define a constructor function with arguments\n### 'length' and 'val').\nSharedVector <- function(Class, length=0L, val=NULL)\n{\n    FUN <- match.fun(Class)\n    FUN(length=length, val=val)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SharedVector getters.\n###\n\nsetMethod(\"length\", \"SharedVector\", function(x) .taglength(x@xp))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method for SharedVector objects.\n###\n\n### Return the hexadecimal representation of the address of the first\n### element of the tag (i.e. the first element of the external vector).\n.address0 <- function(x) .Call2(\"SharedVector_address0\", x, PACKAGE=\"XVector\")\n\n.oneLineDesc <- function(x)\n    paste(class(x), \" of length \", length(x),\n          \" (data starting at address \", .address0(x), \")\", sep=\"\")\n\nsetMethod(\"show\", \"SharedVector\",\n    function(object)\n    {\n        cat(.oneLineDesc(object), \"\\n\", sep=\"\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SharedVector_Pool low-level constructors.\n###\n\n### 'SharedVector_subclass' should be the name of a SharedVector concrete\n### subclass (i.e. currently one of \"SharedRaw\", \"SharedInteger\", or\n### \"SharedDouble\").\nnew_SharedVector_Pool_from_list_of_SharedVector <-\n    function(SharedVector_subclass, x)\n{\n    if (length(x) != 0L) {\n        ## We use 'class(x_elt) == SharedVector_subclass' instead of more\n        ## common idiom 'is(x_elt, SharedVector_subclass)' because (1) it's\n        ## faster, and (2) the SharedVector concrete subclasses should never\n        ## be extended anyway (i.e. they're conceptually \"final classes\" to\n        ## use Java terminology).\n        ok <- lapply(x, function(x_elt) class(x_elt) == SharedVector_subclass)\n        if (!all(unlist(ok)))\n            stop(\"all elements in 'x' must be \", SharedVector_subclass,\n                 \" instances\")\n    }\n    ans_xp_list <- lapply(x, function(x_elt) x_elt@xp)\n    ans_link_to_cached_object_list <- lapply(x,\n                                        function(x_elt)\n                                          x_elt@.link_to_cached_object)\n    ans_class <- paste(SharedVector_subclass, \"_Pool\", sep=\"\")\n    new2(ans_class,\n         xp_list=ans_xp_list,\n         .link_to_cached_object_list=ans_link_to_cached_object_list,\n         check=FALSE)\n}\n\n### If 'x' is a SharedVector object, then\n###\n###     new_SharedVector_Pool_from_SharedVector(x)[[1L]]\n###\n### will be identical to 'x'.\nnew_SharedVector_Pool_from_SharedVector <- function(x)\n{\n    new_SharedVector_Pool_from_list_of_SharedVector(class(x), list(x))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SharedVector_Pool low-level methods.\n###\n\nsetMethod(\"length\", \"SharedVector_Pool\", function(x) length(x@xp_list))\n\nsetMethod(\"width\", \"SharedVector_Pool\",\n    function(x)\n        if (length(x) == 0L) integer(0) else sapply(x@xp_list, .taglength)\n)\n\nsetMethod(\"show\", \"SharedVector_Pool\",\n    function(object)\n    {\n        cat(class(object), \" of length \", length(object), \"\\n\", sep=\"\")\n        for (i in seq_len(length(object)))\n            cat(i, \": \", .oneLineDesc(object[[i]]), \"\\n\", sep=\"\")\n    }\n)\n\nsetAs(\"SharedVector\", \"SharedVector_Pool\",\n    function(from) new_SharedVector_Pool_from_SharedVector(from)\n)\n\n### For internal use only. No argument checking!\nsetMethod(\"c\", \"SharedVector_Pool\",\n    function(x, ..., recursive=FALSE)\n    {\n        if (!identical(recursive, FALSE))\n            stop(\"\\\"c\\\" method for SharedVector_Pool objects \",\n                 \"does not support the 'recursive' argument\")\n        x@xp_list <-\n            do.call(c, lapply(unname(list(x, ...)),\n                              function(arg) arg@xp_list))\n        x@.link_to_cached_object_list <-\n            do.call(c, lapply(unname(list(x, ...)),\n                              function(arg) arg@.link_to_cached_object_list))\n        x\n    }\n)\n\n### For internal use only. No argument checking!\nsetMethod(\"[\", \"SharedVector_Pool\",\n    function(x, i, j, ..., drop=TRUE)\n    {\n        x@xp_list <- x@xp_list[i]\n        x@.link_to_cached_object_list <- x@.link_to_cached_object_list[i]\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\nproblemIfNotExternalVector <- function(what, tagmustbe=\"a vector\")\n{\n    msg <- paste(what, \"must be an external pointer to\", tagmustbe)\n    return(msg)\n}\n\n.valid.SharedVector <- function(x)\n{\n    if (!tagIsVector(x@xp))\n        return(problemIfNotExternalVector(\"'x@xp'\"))\n    NULL\n}\n\nsetValidity2(\"SharedVector\", .valid.SharedVector)\n\n.valid.SharedVector_Pool <- function(x)\n{\n    if (length(x@xp_list) != length(x@.link_to_cached_object_list))\n        return(\"'x@xp_list' and 'x@.link_to_cached_object_list' must have the same length\")\n    if (!all(sapply(x@xp_list,\n                    function(elt) tagIsVector(elt))))\n        return(problemIfNotExternalVector(\"each element in 'x@xp_list'\"))\n    if (!all(sapply(x@.link_to_cached_object_list,\n                    function(elt) is.environment(elt))))\n        return(\"each element in 'x@.link_to_cached_object_list' must be an environment\")\n    NULL\n}\n\nsetValidity2(\"SharedVector_Pool\", .valid.SharedVector_Pool)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Data comparison.\n###\n### A wrapper to the very fast memcmp() C-function.\n### Arguments MUST be the following or it will crash R:\n###   x1, x2: SharedVector objects\n###   start1, start2, width: single integers\n### In addition: 1 <= start1 <= start1+width-1 <= length(x1)\n###              1 <= start2 <= start2+width-1 <= length(x2)\n### WARNING: This function is voluntarly unsafe (it doesn't check its\n### arguments) because we want it to be the fastest possible!\n###\n\nSharedVector.compare <- function(x1, start1, x2, start2, width)\n    .Call2(\"SharedVector_memcmp\",\n          x1, start1, x2, start2, width, PACKAGE=\"XVector\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level copy.\n###\n\n### 'lkup' must be NULL or an integer vector.\nSharedVector.copy <- function(dest, i, imax=integer(0), src, lkup=NULL)\n{\n    if (!is(src, \"SharedVector\"))\n        stop(\"'src' must be a SharedVector object\")\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(i) == 1) {\n        if (length(imax) == 0)\n            imax <- i\n        else\n            imax <- as.integer(imax)\n        width <- imax - i + 1L\n        .Call2(\"SharedVector_Ocopy_from_start\",\n              dest, src, i, width, lkup, FALSE, PACKAGE=\"XVector\")\n    } else {\n        .Call2(\"SharedVector_Ocopy_from_subscript\",\n              dest, src, i, lkup, PACKAGE=\"XVector\")\n    }\n    dest\n}\n\n### 'lkup' must be NULL or an integer vector.\nSharedVector.reverseCopy <- function(dest, i, imax=integer(0), src, lkup=NULL)\n{\n    if (!is(src, \"SharedVector\"))\n        stop(\"'src' must be a SharedVector object\")\n    if (length(i) != 1)\n        stop(\"'i' must be a single integer\")\n    if (!is.integer(i))\n        i <- as.integer(i)\n    if (length(imax) == 0)\n        imax <- i\n    else\n        imax <- as.integer(imax)\n    width <- imax - i + 1L\n    .Call2(\"SharedVector_Ocopy_from_start\",\n          dest, src, i, width, lkup, TRUE, PACKAGE=\"XVector\")\n    dest\n}\n\n### 'lkup' must be NULL or an integer vector.\nSharedVector.mcopy <- function(dest, dest.offset, src, src.start, src.width,\n                               lkup=NULL, reverse=FALSE)\n{\n    if (!isSingleInteger(dest.offset))\n        stop(\"'dest.offset' must be a single integer\")\n    if (!is(src, \"SharedVector\"))\n        stop(\"'src' must be a SharedVector object\")\n    if (!is.integer(src.start) || !is.integer(src.width))\n        stop(\"'src.start' and 'src.width' must be integer vectors\")\n    if (!isTRUEorFALSE(reverse))\n        stop(\"'reverse' must be TRUE or FALSE\")\n    .Call2(\"SharedVector_mcopy\",\n          dest, dest.offset, src, src.start, src.width, lkup, reverse,\n          PACKAGE=\"XVector\")\n    dest\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### Works as long as as.integer() works on 'x'.\nsetMethod(\"as.numeric\", \"SharedVector\",\n    function(x, ...) as.numeric(as.integer(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Address comparison.\n###\n### Be careful with the semantic of the \"==\" operator: the addresses are\n### compared, not the data they are pointing at!\n###\n\n### Return the hexadecimal address of any R object in a string.\naddress <- function(x)\n    .Call2(\"get_object_address\", x, PACKAGE=\"XVector\")\n\n### 'x' must be a list. Fast implementation of sapply(x, address).\naddresses <- function(x)\n    .Call2(\"get_list_addresses\", x, PACKAGE=\"XVector\")\n\nsetMethod(\"==\", signature(e1=\"SharedVector\", e2=\"SharedVector\"),\n    function(e1, e2) address(e1@xp) == address(e2@xp)\n)\n\nsetMethod(\"!=\", signature(e1=\"SharedVector\", e2=\"SharedVector\"),\n    function(e1, e2) address(e1@xp) != address(e2@xp)\n)\n\n",
        "XDouble-class.R": "### =========================================================================\n### XDouble objects\n### -------------------------------------------------------------------------\n###\n### The XDouble class is a container for storing an \"external double\n### vector\" i.e. a *single* view on a SharedDouble object.\n###\n### IMPORTANT NOTE: Our concept/representation/implementation of \"external\n### vector\" in general differ significantly from those found in the\n### externalVector package!\n###\n\nsetClass(\"XDouble\",\n    contains=\"XVector\",\n    representation(\n        shared=\"SharedDouble\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Initialization.\n###\n\nsetMethod(\"initialize\", \"XDouble\",\n    function(.Object, length=0L, val=NULL)\n    {\n        if (!isSingleNumber(length) || length < 0)\n            stop(\"'length' must be a single non-negative integer\")\n        if (!is.integer(length))\n            length <- as.integer(length)\n        .Object@shared <- SharedDouble(length=length, val=val)\n        .Object@offset <- 0L\n        .Object@length <- length\n        .Object\n    }\n)\n\nXDouble <- function(length=base::length(val), val=NULL)\n    new2(\"XDouble\", length=length, val=val, check=FALSE)\n\n### Just an alias for XDouble().\nXNumeric <- function(...) XDouble(...)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### From standard vectors to XDouble objects:\nsetAs(\"numeric\", \"XDouble\", function(from) XDouble(length(from), val=from))\nsetAs(\"numeric\", \"XVector\", function(from) as(from, \"XDouble\"))\n\n### From XDouble objects to standard vectors:\nsetMethod(\"as.numeric\", \"XDouble\",\n    function(x, ...) SharedDouble.read(x@shared, x@offset + 1L, x@offset + x@length)\n)\nsetMethod(\"as.vector\", \"XDouble\",\n    function(x, mode=\"any\")\n    {\n        if (!identical(mode, \"any\"))\n            stop(\"\\\"as.vector\\\" method for XDouble objects \",\n                 \"does not support the 'mode' argument\")\n        as.numeric(x)\n    }\n)\n\n",
        "XDoubleViews-class.R": "### =========================================================================\n### XDoubleViews objects\n### -------------------------------------------------------------------------\n###\n\n\n### The XDoubleViews class is the basic container for storing a set of views\n### (start/end locations) on the same XDouble object, called the \"subject\"\n### vector.\nsetClass(\"XDoubleViews\",\n    contains=\"Views\",\n    representation(\n        subject=\"XDouble\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### User-friendly constructor.\n###\n\nsetMethod(\"Views\", \"XDouble\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n        IRanges:::new_Views(subject,\n                            start=start, end=end, width=width, names=names,\n                            Class=\"XDoubleViews\")\n)\n\nsetMethod(\"Views\", \"numeric\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n    {\n        xsubject <- as(subject, \"XDouble\")\n        Views(xsubject, start=start, end=end, width=width, names=names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\n### The 2 helper functions below convert a given view on an XDouble object\n### into a character-string.\n### Both assume that 'start' <= 'end' (so they don't check it) and\n### padd the result with spaces to produce the \"margin effect\"\n### if 'start' or 'end' are out of limits.\n\nXDoubleViews.show_vframe_header <- function(iW, startW, endW, widthW)\n{\n    cat(format(\"\", width=iW+1),\n        format(\"start\", width=startW, justify=\"right\"), \" \",\n        format(\"end\", width=endW, justify=\"right\"), \" \",\n        format(\"width\", width=widthW, justify=\"right\"), \"\\n\",\n        sep=\"\")\n}\n\nXDoubleViews.show_vframe_line <- function(x, i, iW, startW, endW, widthW)\n{\n    lsx <- length(subject(x))\n    start <- start(x)[i]\n    end <- end(x)[i]\n    width <- end - start + 1\n    snippetWidth <- getOption(\"width\") - 6 - iW - startW - endW - widthW\n    if (width > 0 && lsx > 0 && start <= lsx && end >= 1) {\n        snippet <- S4Vectors:::toNumSnippet(subseq(subject(x),\n                                                   start=max(min(start,lsx),1),\n                                                   end=max(min(end,lsx),1)),\n                                            snippetWidth)\n    } else {\n       snippet <- \" \"\n    }\n    cat(format(paste(\"[\", i,\"]\", sep=\"\"), width=iW, justify=\"right\"), \" \",\n        format(start, width=startW, justify=\"right\"), \" \",\n        format(end, width=endW, justify=\"right\"), \" \",\n        format(width, width=widthW, justify=\"right\"), \" \",\n        \"[\", snippet, \"]\\n\",\n        sep=\"\")\n}\n\n### 'half_nrow' must be >= 1\nXDoubleViews.show_vframe <- function(x, half_nrow=9L)\n{\n    cat(\"\\nviews:\")\n    lx <- length(x)\n    if (lx == 0)\n        cat(\" NONE\\n\")\n    else {\n        cat(\"\\n\")\n        iW <- nchar(as.character(lx)) + 2 # 2 for the brackets\n        startMax <- max(start(x))\n        startW <- max(nchar(startMax), nchar(\"start\"))\n        endMax <- max(end(x))\n        endW <- max(nchar(endMax), nchar(\"end\"))\n        widthMax <- max(width(x))\n        widthW <- max(nchar(widthMax), nchar(\"width\"))\n        XDoubleViews.show_vframe_header(iW, startW, endW, widthW)\n        if (lx <= 2*half_nrow+1) {\n            for (i in seq_len(lx))\n                XDoubleViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        } else {\n            for (i in 1:half_nrow)\n                XDoubleViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n            cat(format(\"...\", width=iW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=startW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=endW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=widthW, justify=\"right\"),\n                \" ...\\n\", sep=\"\")\n            for (i in (lx-half_nrow+1L):lx)\n                XDoubleViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        }\n    }\n}\n\nsetMethod(\"show\", \"XDoubleViews\",\n    function(object)\n    {\n        subject <- subject(object)\n        lsub <- length(subject)\n        cat(\"Views on a \", lsub, \"-double \", class(subject), \" subject\", sep=\"\")\n        cat(\"\\nsubject: \", S4Vectors:::toNumSnippet(subject, getOption(\"width\")-9), sep=\"\")\n        XDoubleViews.show_vframe(object)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Equality.\n###\n\n### Assume that 'start1', 'end1', 'start2', 'end2' are single integers\n### and that start1 <= end1 and start2 <= end2.\nXDoubleViews.view1_equal_view2 <- function(x1, start1, end1, x2, start2, end2)\n{\n    one <- as.integer(1)\n    w1 <- end1 - start1 + one\n    w2 <- end2 - start2 + one\n    if (w1 != w2)\n        return(FALSE)\n\n    lx1 <- length(x1)\n    isBlank1 <- end1 < one || start1 > lx1\n    lx2 <- length(x2)\n    isBlank2 <- end2 < one || start2 > lx2\n    if (isBlank1 && isBlank2)\n        return(TRUE)\n    if (isBlank1 || isBlank2)\n        return(FALSE)\n\n    # Left margin\n    LmarginSize1 <- start1 < one\n    LmarginSize2 <- start2 < one\n    if (LmarginSize1 != LmarginSize2)\n        return(FALSE)\n    if (LmarginSize1) {\n        # Both views have a left margin\n        if (start1 != start2)\n            return(FALSE)\n        start1 <- one\n        start2 <- one\n    }\n\n    # Right margin\n    RmarginSize1 <- end1 > lx1\n    RmarginSize2 <- end2 > lx2\n    if (RmarginSize1 != RmarginSize2)\n        return(FALSE)\n    if (RmarginSize1) {\n        # Both views have a right margin\n        if (end1 - lx1 != end2 - lx2)\n            return(FALSE)\n        end1 <- lx1\n        end2 <- lx2\n    }\n\n    # At this point, we can trust that 1 <= start1 <= end1 <= lx1\n    # and that 1 <= start2 <= end2 <= lx2.\n    subseq(x1, start=start1, end=end1) == subseq(x2, start=start2, end=end2)\n}\n\n### 'x' and 'y' must be XDoubleViews objects.\n### Returns a logical vector of length max(length(x), length(y)).\n### Recycle its arguments.\nXDoubleViews.equal <- function(x, y)\n{\n    lx <- length(x)\n    ly <- length(y)\n    if (lx < ly) {\n        tmp <- x\n        x <- y\n        y <- tmp\n        tmp <- lx\n        lx <- ly\n        ly <- tmp\n    }\n    if (ly == 0)\n        return(logical(0))\n    # Now we are sure that lx >= ly >= 1\n    ans <- logical(lx)\n    j <- 1\n    for (i in seq_len(lx)) {\n        ans[i] <- XDoubleViews.view1_equal_view2(\n                          subject(x), start(x)[i], end(x)[i],\n                          subject(y), start(y)[j], end(y)[j])\n        # Recycle\n        if (j < ly) j <- j + 1 else j <- 1\n    }\n    if (j != 1)\n        warning(paste(\"longer object length\",\n                      \"is not a multiple of shorter object length\"))\n    ans\n}\n\n### These methods are called if at least one side of the \"==\" (or \"!=\")\n### operator is an XDoubleViews object. They have precedence over the\n### corresponding methods defined for XDouble objects, i.e. they will\n### be called if one side is an XDoubleViews object and the other side\n### is an XDouble object.\n\nsetMethod(\"==\", signature(e1=\"XDoubleViews\", e2=\"XDoubleViews\"),\n    function(e1, e2)\n    {\n        XDoubleViews.equal(e1, e2)\n    }\n)\nsetMethod(\"==\", signature(e1=\"XDoubleViews\", e2=\"XDouble\"),\n    function(e1, e2)\n    {\n        XDoubleViews.equal(e1, as(e2, \"Views\"))\n    }\n)\nsetMethod(\"==\", signature(e1=\"XDoubleViews\", e2=\"numeric\"),\n    function(e1, e2)\n    {\n        if (length(e2) == 0 || S4Vectors:::anyMissing(e2))\n            stop(\"comparison between an XDoubleViews object and an integer \",\n                 \"vector of length 0 or with NAs is not supported\")\n        XDoubleViews.equal(e1, as(e2, \"Views\"))\n    }\n)\nsetMethod(\"==\", signature(e1=\"XDouble\", e2=\"XDoubleViews\"),\n    function(e1, e2) e2 == e1\n)\nsetMethod(\"==\", signature(e1=\"numeric\", e2=\"XDoubleViews\"),\n    function(e1, e2) e2 == e1\n)\n\n",
        "XInteger-class.R": "### =========================================================================\n### XInteger objects\n### -------------------------------------------------------------------------\n###\n### The XInteger class is a container for storing an \"external integer\n### vector\" i.e. a *single* view on a SharedInteger object.\n###\n### IMPORTANT NOTE: Our concept/representation/implementation of \"external\n### vector\" in general differ significantly from those found in the\n### externalVector package!\n###\n\nsetClass(\"XInteger\",\n    contains=\"XVector\",\n    representation(\n        shared=\"SharedInteger\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Initialization.\n###\n\nsetMethod(\"initialize\", \"XInteger\",\n    function(.Object, length=0L, val=NULL)\n    {\n        if (!isSingleNumber(length) || length < 0)\n            stop(\"'length' must be a single non-negative integer\")\n        if (!is.integer(length))\n            length <- as.integer(length)\n        .Object@shared <- SharedInteger(length=length, val=val)\n        .Object@offset <- 0L\n        .Object@length <- length\n        .Object\n    }\n)\n\nXInteger <- function(length=base::length(val), val=NULL)\n    new2(\"XInteger\", length=length, val=val, check=FALSE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### From standard vectors to XInteger objects:\nsetAs(\"numeric\", \"XInteger\", function(from) XInteger(length(from), val=from))\nsetAs(\"integer\", \"XVector\", function(from) as(from, \"XInteger\"))\n\n### From XInteger objects to standard vectors:\nsetMethod(\"as.integer\", \"XInteger\",\n    function(x, ...) SharedInteger.read(x@shared, x@offset + 1L, x@offset + x@length)\n)\nsetMethod(\"as.vector\", \"XInteger\",\n    function(x, mode=\"any\")\n    { \n        if (!identical(mode, \"any\"))\n            stop(\"\\\"as.vector\\\" method for XInteger objects \",\n                 \"does not support the 'mode' argument\")\n        as.integer(x)\n    }\n)\n\n",
        "XIntegerViews-class.R": "### =========================================================================\n### XIntegerViews objects\n### -------------------------------------------------------------------------\n###\n\n\n### The XIntegerViews class is the basic container for storing a set of views\n### (start/end locations) on the same XInteger object, called the \"subject\"\n### vector.\nsetClass(\"XIntegerViews\",\n    contains=\"Views\",\n    representation(\n        subject=\"XInteger\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### User-friendly constructor.\n###\n\nsetMethod(\"Views\", \"XInteger\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n        IRanges:::new_Views(subject,\n                            start=start, end=end, width=width, names=names,\n                            Class=\"XIntegerViews\")\n)\n\nsetMethod(\"Views\", \"integer\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n    {\n        xsubject <- as(subject, \"XInteger\")\n        Views(xsubject, start=start, end=end, width=width, names=names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\n### The 2 helper functions below convert a given view on an XInteger object\n### into a character-string.\n### Both assume that 'start' <= 'end' (so they don't check it) and\n### padd the result with spaces to produce the \"margin effect\"\n### if 'start' or 'end' are out of limits.\n\nXIntegerViews.show_vframe_header <- function(iW, startW, endW, widthW)\n{\n    cat(format(\"\", width=iW+1),\n        format(\"start\", width=startW, justify=\"right\"), \" \",\n        format(\"end\", width=endW, justify=\"right\"), \" \",\n        format(\"width\", width=widthW, justify=\"right\"), \"\\n\",\n        sep=\"\")\n}\n\nXIntegerViews.show_vframe_line <- function(x, i, iW, startW, endW, widthW)\n{\n    lsx <- length(subject(x))\n    start <- start(x)[i]\n    end <- end(x)[i]\n    width <- end - start + 1\n    snippetWidth <- getOption(\"width\") - 6 - iW - startW - endW - widthW\n    if (width > 0 && lsx > 0 && start <= lsx && end >= 1) {\n        snippet <- S4Vectors:::toNumSnippet(subseq(subject(x),\n                                                   start=max(min(start,lsx),1),\n                                                   end=max(min(end,lsx),1)),\n                                            snippetWidth)\n    } else {\n       snippet <- \" \"\n    }\n    cat(format(paste(\"[\", i,\"]\", sep=\"\"), width=iW, justify=\"right\"), \" \",\n        format(start, width=startW, justify=\"right\"), \" \",\n        format(end, width=endW, justify=\"right\"), \" \",\n        format(width, width=widthW, justify=\"right\"), \" \",\n        \"[\", snippet, \"]\\n\",\n        sep=\"\")\n}\n\n### 'half_nrow' must be >= 1\nXIntegerViews.show_vframe <- function(x, half_nrow=9L)\n{\n    cat(\"\\nviews:\")\n    lx <- length(x)\n    if (lx == 0)\n        cat(\" NONE\\n\")\n    else {\n        cat(\"\\n\")\n        iW <- nchar(as.character(lx)) + 2 # 2 for the brackets\n        startMax <- max(start(x))\n        startW <- max(nchar(startMax), nchar(\"start\"))\n        endMax <- max(end(x))\n        endW <- max(nchar(endMax), nchar(\"end\"))\n        widthMax <- max(width(x))\n        widthW <- max(nchar(widthMax), nchar(\"width\"))\n        XIntegerViews.show_vframe_header(iW, startW, endW, widthW)\n        if (lx <= 2*half_nrow+1) {\n            for (i in seq_len(lx))\n                XIntegerViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        } else {\n            for (i in 1:half_nrow)\n                XIntegerViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n            cat(format(\"...\", width=iW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=startW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=endW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=widthW, justify=\"right\"),\n                \" ...\\n\", sep=\"\")\n            for (i in (lx-half_nrow+1L):lx)\n                XIntegerViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        }\n    }\n}\n\nsetMethod(\"show\", \"XIntegerViews\",\n    function(object)\n    {\n        subject <- subject(object)\n        lsub <- length(subject)\n        cat(\"Views on a \", lsub, \"-integer \", class(subject), \" subject\", sep=\"\")\n        cat(\"\\nsubject: \", S4Vectors:::toNumSnippet(subject, getOption(\"width\")-9), sep=\"\")\n        XIntegerViews.show_vframe(object)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Equality.\n###\n\n### Assume that 'start1', 'end1', 'start2', 'end2' are single integers\n### and that start1 <= end1 and start2 <= end2.\nXIntegerViews.view1_equal_view2 <- function(x1, start1, end1, x2, start2, end2)\n{\n    one <- as.integer(1)\n    w1 <- end1 - start1 + one\n    w2 <- end2 - start2 + one\n    if (w1 != w2)\n        return(FALSE)\n\n    lx1 <- length(x1)\n    isBlank1 <- end1 < one || start1 > lx1\n    lx2 <- length(x2)\n    isBlank2 <- end2 < one || start2 > lx2\n    if (isBlank1 && isBlank2)\n        return(TRUE)\n    if (isBlank1 || isBlank2)\n        return(FALSE)\n\n    # Left margin\n    LmarginSize1 <- start1 < one\n    LmarginSize2 <- start2 < one\n    if (LmarginSize1 != LmarginSize2)\n        return(FALSE)\n    if (LmarginSize1) {\n        # Both views have a left margin\n        if (start1 != start2)\n            return(FALSE)\n        start1 <- one\n        start2 <- one\n    }\n\n    # Right margin\n    RmarginSize1 <- end1 > lx1\n    RmarginSize2 <- end2 > lx2\n    if (RmarginSize1 != RmarginSize2)\n        return(FALSE)\n    if (RmarginSize1) {\n        # Both views have a right margin\n        if (end1 - lx1 != end2 - lx2)\n            return(FALSE)\n        end1 <- lx1\n        end2 <- lx2\n    }\n\n    # At this point, we can trust that 1 <= start1 <= end1 <= lx1\n    # and that 1 <= start2 <= end2 <= lx2.\n    subseq(x1, start=start1, end=end1) == subseq(x2, start=start2, end=end2)\n}\n\n### 'x' and 'y' must be XIntegerViews objects.\n### Returns a logical vector of length max(length(x), length(y)).\n### Recycle its arguments.\nXIntegerViews.equal <- function(x, y)\n{\n    lx <- length(x)\n    ly <- length(y)\n    if (lx < ly) {\n        tmp <- x\n        x <- y\n        y <- tmp\n        tmp <- lx\n        lx <- ly\n        ly <- tmp\n    }\n    if (ly == 0)\n        return(logical(0))\n    # Now we are sure that lx >= ly >= 1\n    ans <- logical(lx)\n    j <- 1\n    for (i in seq_len(lx)) {\n        ans[i] <- XIntegerViews.view1_equal_view2(\n                      subject(x), start(x)[i], end(x)[i],\n                      subject(y), start(y)[j], end(y)[j])\n        # Recycle\n        if (j < ly) j <- j + 1 else j <- 1\n    }\n    if (j != 1)\n        warning(paste(\"longer object length\",\n                      \"is not a multiple of shorter object length\"))\n    ans\n}\n\n### These methods are called if at least one side of the \"==\" (or \"!=\")\n### operator is an XIntegerViews object. They have precedence over the\n### corresponding methods defined for XInteger objects, i.e. they will\n### be called if one side is an XIntegerViews object and the other side\n### is an XInteger object.\n\nsetMethod(\"==\", signature(e1=\"XIntegerViews\", e2=\"XIntegerViews\"),\n    function(e1, e2)\n    {\n        XIntegerViews.equal(e1, e2)\n    }\n)\nsetMethod(\"==\", signature(e1=\"XIntegerViews\", e2=\"XInteger\"),\n    function(e1, e2)\n    {\n        XIntegerViews.equal(e1, as(e2, \"Views\"))\n    }\n)\nsetMethod(\"==\", signature(e1=\"XIntegerViews\", e2=\"integer\"),\n    function(e1, e2)\n    {\n        if (length(e2) == 0 || S4Vectors:::anyMissing(e2))\n            stop(\"comparison between an XIntegerViews object and an integer \",\n                 \"vector of length 0 or with NAs is not supported\")\n        XIntegerViews.equal(e1, as(e2, \"Views\"))\n    }\n)\nsetMethod(\"==\", signature(e1=\"XInteger\", e2=\"XIntegerViews\"),\n    function(e1, e2) e2 == e1\n)\nsetMethod(\"==\", signature(e1=\"integer\", e2=\"XIntegerViews\"),\n    function(e1, e2) e2 == e1\n)\n\n",
        "XRaw-class.R": "### =========================================================================\n### XRaw objects\n### -------------------------------------------------------------------------\n###\n### The XRaw class is a container for storing an \"external raw vector\"\n### i.e. a *single* view on a SharedRaw object.\n###\n### IMPORTANT NOTE: Our concept/representation/implementation of \"external\n### vector\" in general differ significantly from those found in the\n### externalVector package!\n###\n\nsetClass(\"XRaw\",\n    contains=\"XVector\",\n    representation(\n        shared=\"SharedRaw\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Initialization.\n###\n\nXRaw <- function(length=0L, val=NULL)\n{\n    if (!isSingleNumber(length) || length < 0L)\n        stop(\"'length' must be a single non-negative integer\")\n    if (!is.integer(length))\n        length <- as.integer(length)\n    new2(\"XRaw\", shared=SharedRaw(length=length, val=val), length=length,\n         check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_character_from_XRaw_by_positions() and\n### extract_character_from_XRaw_by_ranges()\n###\n\n### Typical use:\n###   x <- subseq(as(charToRaw(\"--Hello--\"), \"XRaw\"), 3, 7)\n###   extract_character_from_XRaw_by_positions(x, 5:2)\n###   extract_character_from_XRaw_by_positions(x, 5:2, collapse=TRUE)\n###   lkup <- S4Vectors:::TOUPPER_LOOKUP\n###   extract_character_from_XRaw_by_positions(x, 5:2, lkup=lkup)\n###   extract_character_from_XRaw_by_positions(x, 5:2, collapse=TRUE, lkup=lkup)\nextract_character_from_XRaw_by_positions <- function(x, pos,\n                                                     collapse=FALSE,\n                                                     lkup=NULL)\n{\n    .Call(\"C_extract_character_from_XRaw_by_positions\",\n          x, pos, collapse, lkup,\n          PACKAGE=\"XVector\")\n}\n\n### Typical use:\n###   x <- subseq(as(charToRaw(\"--Hello--\"), \"XRaw\"), 3, 7)\n###   extract_character_from_XRaw_by_ranges(x, 3:1, c(2:1, 4L))\n###   extract_character_from_XRaw_by_ranges(x, 3:1, c(2:1, 4L), collapse=TRUE)\n###   lkup <- S4Vectors:::TOUPPER_LOOKUP\n###   extract_character_from_XRaw_by_ranges(x, 3:1, c(2:1, 4L), lkup=lkup)\n###   extract_character_from_XRaw_by_ranges(x, 3:1, c(2:1, 4L), collapse=TRUE,\n###                                         lkup=lkup)\nextract_character_from_XRaw_by_ranges <- function(x, start, width,\n                                                  collapse=FALSE, lkup=NULL)\n{\n    .Call(\"C_extract_character_from_XRaw_by_ranges\",\n          x, start, width, collapse, lkup,\n          PACKAGE=\"XVector\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### From standard vectors to XRaw objects:\nsetAs(\"raw\", \"XRaw\", function(from) XRaw(length(from), val=from))\nsetAs(\"raw\", \"XVector\", function(from) as(from, \"XRaw\"))\nsetAs(\"numeric\", \"XRaw\", function(from) XRaw(length(from), val=from))\n\n### From XRaw objects to standard vectors:\n### TODO: Modify SharedRaw.read() so it returns a raw vector instead of a\n### character string, and use it here.\nsetMethod(\"as.raw\", \"XRaw\", function(x) as.raw(as.integer(x)))\nsetMethod(\"as.integer\", \"XRaw\",\n    function(x, ...) SharedRaw.readInts(x@shared, x@offset + 1L, x@offset + x@length)\n)\nsetMethod(\"as.vector\", \"XRaw\",\n    function(x, mode=\"any\")\n    { \n        if (!identical(mode, \"any\"))\n            stop(\"\\\"as.vector\\\" method for XRaw objects \",\n                 \"does not support the 'mode' argument\")\n        as.raw(x)\n    }\n)\n\n",
        "XRawList-class.R": "### =========================================================================\n### XRawList objects\n### -------------------------------------------------------------------------\n###\n### An XRawList object is *conceptually* a list of XRaw objects\n### but is actually not *implemented* as a list of such objects.\n### This is to avoid having to generate long lists of S4 objects which the\n### current S4 implementation is *very* inefficient at.\n###\n\nsetClass(\"XRawList\",\n    contains=\"XVectorList\",\n    representation(\n        pool=\"SharedRaw_Pool\"\n    ),\n    prototype(\n        elementType=\"XRaw\"\n    )\n)\n\n",
        "XRawList-comparison.R": "### =========================================================================\n### Comparing and ordering the elements in one or more XRawList objects\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompare()\n###\n\nsetMethod(\"pcompare\", c(\"XRawList\", \"XRawList\"),\n    function(x, y)\n        .Call2(\"XRawList_pcompare\", x, y, PACKAGE=\"XVector\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Element-wise (aka \"parallel\") comparison of 2 XRawList objects.\n###\n### We only need to implement \"==\" and \"<=\" methods. The other comparison\n### binary operators (!=, >=, <, >) will then work out-of-the-box on\n### XRawList objects thanks to the methods for Vector objects.\n###\n\nsetMethod(\"==\", c(\"XRawList\", \"XRawList\"),\n    function(e1, e2) pcompare(e1, e2) == 0L\n)\n\nsetMethod(\"<=\", c(\"XRawList\", \"XRawList\"),\n    function(e1, e2) pcompare(e1, e2) <= 0L\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match() and duplicated()\n###\n\nsetMethod(\"match\", c(\"XRawList\", \"XRawList\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL)\n    {\n        if (!is.numeric(nomatch) || length(nomatch) != 1L)\n            stop(\"'nomatch' must be a single integer value\")\n        if (!is.integer(nomatch))\n            nomatch <- as.integer(nomatch)\n        if (!is.null(incomparables))\n            stop(\"\\\"match\\\" method for XRawList objects \",\n                 \"only accepts 'incomparables=NULL'\")\n        .Call2(\"XRawList_match_hash\", x, table, nomatch, PACKAGE=\"XVector\")\n    }\n)\n\n.selfmatchXRawList <- function(x)\n{\n    .Call2(\"XRawList_selfmatch_hash\", x, PACKAGE=\"XVector\")\n}\n\n.duplicated.XRawList <- function(x, incomparables=FALSE)\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"\\\"duplicated\\\" method for XRawList objects \",\n             \"only accepts 'incomparables=FALSE'\")\n    sm <- .selfmatchXRawList(x)\n    sm != seq_len(length(sm))\n}\n### S3/S4 combo for duplicated.XRawList\nduplicated.XRawList <- function(x, incomparables=FALSE, ...)\n    .duplicated.XRawList(x, incomparables=incomparables, ...)\nsetMethod(\"duplicated\", \"XRawList\", duplicated.XRawList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### order() and related methods\n###\n\nsetMethod(\"is.unsorted\", \"XRawList\",\n    function(x, na.rm=FALSE, strictly=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(\"\\\"is.unsorted\\\" method for XRawList objects \",\n                    \"ignores the 'na.rm' argument\")\n        if (!isTRUEorFALSE(strictly))\n            stop(\"'strictly' must be TRUE or FALSE\")\n        .Call2(\"XRawList_is_unsorted\", x, strictly, PACKAGE=\"XVector\")\n    }\n)\n\n### 'na.last' is pointless (XRawList objects don't contain NAs) so is ignored.\n### 'method' is also ignored at the moment.\nsetMethod(\"order\", \"XRawList\",\n    function(..., na.last=TRUE, decreasing=FALSE,\n                  method=c(\"auto\", \"shell\", \"radix\"))\n    {\n        ## Turn off this warning for now since it triggers spurious warnings\n        ## when calling sort() on an XRawList derivative. The root of the\n        ## problem is inconsistent defaults for 'na.last' between order()\n        ## and sort(), as reported here:\n        ##   https://stat.ethz.ch/pipermail/r-devel/2015-November/072012.html\n        #if (!identical(na.last, TRUE))\n        #    warning(\"\\\"order\\\" method for XRawList objects \",\n        #            \"ignores the 'na.last' argument\")\n        if (!isTRUEorFALSE(decreasing))\n            stop(\"'decreasing' must be TRUE or FALSE\")\n        ## All arguments in '...' are guaranteed to be XRawList objects.\n        args <- list(...)\n        if (length(args) == 1L) {\n            x <- args[[1L]]\n            return(.Call2(\"XRawList_order\", x, decreasing, PACKAGE=\"XVector\"))\n        }\n        stop(\"\\\"order\\\" method for XRawList objects \",\n             \"only takes 1 XRawList object for now, sorry\")\n    }\n)\n\nsetMethod(\"rank\", \"XRawList\",\n    function(x, na.last=TRUE,\n             ties.method=c(\"average\", \"first\", \"random\", \"max\", \"min\"))\n    {\n        if (!identical(na.last, TRUE))\n            warning(\"\\\"rank\\\" method for XRawList objects \",\n                    \"ignores the 'na.last' argument\")\n        ties.method <- match.arg(ties.method)\n        if (!(ties.method %in% c(\"first\", \"min\")))\n            stop(\"\\\"rank\\\" method for XRawList objects supports \",\n                 \"only 'ties.method=\\\"first\\\"' and 'ties.method=\\\"min\\\"'\")\n        .Call2(\"XRawList_rank\", x, ties.method, PACKAGE=\"XVector\")\n    }\n)\n\n",
        "XVector-class.R": "### =========================================================================\n### XVector objects\n### -------------------------------------------------------------------------\n###\n### The XVector virtual class is a general container for storing\n### an \"external vector\" i.e. a *single* view on a SharedVector object.\n###\n### IMPORTANT NOTE: Our concept/representation/implementation of \"external\n### vector\" differ significantly from those found in the externalVector\n### package!\n###\n\nsetClass(\"XVector\",\n    contains=\"Vector\",\n    representation(\n        \"VIRTUAL\",\n        shared=\"SharedVector\",\n        offset=\"integer\",  # a single integer\n        length=\"integer\"   # a single integer\n    ),\n    prototype(\n        offset=0L,\n        length=0L\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"length\", \"XVector\", function(x) x@length)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"extractROWS\", \"XVector\",\n    function(x, i)\n    {\n        i <- normalizeSingleBracketSubscript(i, x)\n        new_shared <- SharedVector(class(x@shared), length=length(i))\n        SharedVector.copy(new_shared, x@offset + i, src=x@shared)\n        x@shared <- new_shared\n        x@offset <- 0L\n        x@length <- length(new_shared)\n        x@elementMetadata <- extractROWS(x@elementMetadata, i)\n        x\n    }\n)\n\n### Extracts a linear subsequence without copying the sequence data!\nsetGeneric(\"subseq\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA) standardGeneric(\"subseq\")\n)\n\n### Replace a linear subsequence.\nsetGeneric(\"subseq<-\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA, value) standardGeneric(\"subseq<-\")\n)\n\nsetMethod(\"subseq\", \"XVector\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        solved_SEW <- IRanges:::solveUserSEWForSingleSeq(length(x),\n                                                         start, end, width)\n        x@offset <- x@offset + start(solved_SEW) - 1L\n        x@length <- width(solved_SEW)\n        mcols(x) <- extractROWS(mcols(x, use.names=FALSE), solved_SEW)\n        x\n    }\n)\n\nsetReplaceMethod(\"subseq\", \"XVector\",\n    function(x, start=NA, end=NA, width=NA, value)\n    {\n        solved_SEW <- IRanges:::solveUserSEWForSingleSeq(length(x),\n                                                         start, end, width)\n        if (!is.null(value)) {\n            if (!is(value, class(x)))\n                stop(\"'value' must be a \", class(x), \" object or NULL\")\n        }\n        c(subseq(x, end=start(solved_SEW)-1L),\n          value,\n          subseq(x, start=end(solved_SEW)+1L))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### Works as long as as.integer() works on 'x'.\nsetMethod(\"as.numeric\", \"XVector\",\n    function(x, ...) as.numeric(as.integer(x))\n)\n\nsetAs(\"XVector\", \"Rle\", function(from) {\n  Rle(as.vector(from))\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method\n###\n\nsetMethod(\"show\", \"XVector\",\n    function(object)\n    {\n        lo <- length(object)\n        cat(class(object), \" of length \", lo, \"\\n\", sep=\"\")\n        if (lo != 0L)\n            cat(\" [1] \", S4Vectors:::toNumSnippet(object, getOption(\"width\")-5), \"\\n\", sep=\"\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.concatenate_XVector_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- S4Vectors:::prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ans_len <- suppressWarnings(sum(lengths(all_objects)))\n    if (is.na(ans_len))\n        stop(\"too many vector elements to concatenate\")\n\n    ## 1. Take care of the parallel slots\n\n    ## Call method for Vector objects to concatenate all the parallel\n    ## slots (only \"elementMetadata\" in the case of XVector) and stick them\n    ## into 'ans'. Note that the resulting 'ans' can be an invalid object\n    ## because its \"elementMetadata\" slot can be longer (i.e. have more rows)\n    ## than 'ans' itself so we use 'check=FALSE' to skip validation.\n    ans <- callNextMethod(x, objects, use.names=use.names,\n                                      ignore.mcols=ignore.mcols,\n                                      check=FALSE)\n\n    ## 2. Take care of the non-parallel slots\n\n    ans_shared <- SharedVector(class(x@shared), length=ans_len)\n    dest_offset <- 0L\n    for (object in all_objects) {\n        object_len <- length(object)\n        if (object_len == 0L)  # would be TRUE on NULLs too...\n            next\n        ## From here 'object' is guaranteed to be an XVector object.\n        src <- object@shared\n        src_start <- object@offset + 1L\n        SharedVector.mcopy(ans_shared, dest_offset, src, src_start, object_len)\n        dest_offset <- dest_offset + object_len\n    }\n\n    BiocGenerics:::replaceSlots(ans, shared=ans_shared,\n                                     offset=0L,\n                                     length=ans_len,\n                                     check=check)\n}\n\nsetMethod(\"bindROWS\", \"XVector\", .concatenate_XVector_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Equality\n###\n\n.XVector.equal <- function(x, y)\n{\n    if (class(x) != class(y) || x@length != y@length)\n        return(FALSE)\n    ans <- !SharedVector.compare(x@shared, x@offset + 1L,\n                                 y@shared, y@offset + 1L,\n                                 x@length)\n    as.logical(ans)\n}\n\nsetMethod(\"==\", signature(e1=\"XVector\", e2=\"XVector\"),\n    function(e1, e2) .XVector.equal(e1, e2)\n)\n\n",
        "XVectorList-class.R": "### =========================================================================\n### XVectorList objects\n### -------------------------------------------------------------------------\n###\n### An XVectorList object is *conceptually* a list of XVector objects\n### but is actually not *implemented* as a list of such objects.\n### This is to avoid having to generate long lists of S4 objects which the\n### current S4 implementation is *very* inefficient at.\n###\n\n\nsetClass(\"GroupedIRanges\",\n    contains=\"IRanges\",\n    representation(\n        group=\"integer\"\n    )\n)\n\nsetClass(\"XVectorList\",\n    contains=\"List\",\n    representation(\n        \"VIRTUAL\",\n        pool=\"SharedVector_Pool\",\n        ranges=\"GroupedIRanges\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\n\n### Ugly workaround a serious callNextMethod inefficiency reported here:\n###   https://bugs.r-project.org/bugzilla/show_bug.cgi?id=16974\n.GroupedIRanges_parallel_slot_names <-\n    c(\"group\", parallel_slot_names(new(\"IRanges\")))\n\nsetMethod(\"parallel_slot_names\", \"GroupedIRanges\",\n    #function(x) c(\"group\", callNextMethod())\n    function(x) .GroupedIRanges_parallel_slot_names\n)\n\nsetMethod(\"parallel_slot_names\", \"XVectorList\",\n    function(x) c(\"ranges\", callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### GroupedIRanges methods\n###\n\n.valid.GroupedIRanges <- function(x)\n{\n    if (length(x@group) != length(x))\n        return(\"slot \\\"group\\\" slot must have same length as object\")\n    NULL\n}\n\nsetValidity2(\"GroupedIRanges\", .valid.GroupedIRanges)\n\nsetMethod(\"as.data.frame\", \"GroupedIRanges\",\n    function(x, row.names=NULL, optional=FALSE, ...)\n        cbind(group=x@group, callNextMethod(), stringsAsFactors=FALSE)\n)\n\nsetMethod(\"show\", \"GroupedIRanges\",\n    function(object) show(as.data.frame(object))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### XVectorList accessors\n###\n\nsetMethod(\"width\", \"XVectorList\", function(x) width(x@ranges))\n\nsetMethod(\"elementNROWS\", \"XVectorList\", function(x) width(x))\n\nsetMethod(\"names\", \"XVectorList\", function(x) names(x@ranges))\n\nsetReplaceMethod(\"names\", \"XVectorList\",\n    function(x, value)\n    {\n        names(x@ranges) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 2 internal bookkeeping functions to keep the XVectorList \"pool\" slot\n### clean and tidy\n###\n\n### Used in \"extractROWS\" method for XVectorList objects.\n.dropUnusedPoolElts <- function(x)\n{\n    pool_len <- length(x@pool)\n    if (pool_len == 0L)\n        return(x)\n    keep_it <- logical(pool_len)\n    keep_it[x@ranges@group] <- TRUE\n    keep_idx <- which(keep_it)\n    remap <- integer(pool_len)\n    remap[keep_idx] <- seq_len(length(keep_idx))\n    x@pool <- x@pool[keep_idx]\n    x@ranges@group <- remap[x@ranges@group]\n    x\n}\n\n### Used in \"c\" method for XVectorList objects and in\n### new_XVectorList_from_list_of_XVector() constructor.\n.dropDuplicatedPoolElts <- function(x)\n{\n    pool_len <- length(x@pool)\n    if (pool_len == 0L)\n        return(x)\n    addr <- addresses(x@pool@xp_list)\n    keep_idx <- which(!duplicated(addr))\n    remap <- match(addr, addr[keep_idx])\n    x@pool <- x@pool[keep_idx]\n    x@ranges@group <- remap[x@ranges@group]\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### XVectorList constructors\n###\n\nnew_XVectorList_from_list_of_XVector <- function(classname, x)\n{\n    if (!is.list(x))\n        stop(\"'x' must be a list\")\n    x_names <- names(x)\n    if (!is.null(x_names))\n        names(x) <- NULL\n    ans_elementType <- elementType(new(classname))\n    x_len <- length(x)\n    if (x_len != 0L) {\n        ok <- lapply(x, function(x_elt) is(x_elt, ans_elementType))\n        if (!all(unlist(ok)))\n            stop(\"all elements in 'x' must be \", ans_elementType,\n                 \" objects\")\n    }\n    elt0 <- new(ans_elementType)\n    ans_pool_class <- class(elt0@shared)\n    shared_list <- lapply(x, function(x_elt) x_elt@shared)\n    ans_pool <- new_SharedVector_Pool_from_list_of_SharedVector(ans_pool_class,\n                                                                shared_list)\n    if (x_len == 0L) {\n        ans_ranges <- new2(\"GroupedIRanges\", check=FALSE)\n    } else {\n        ans_ranges_start <- unlist(lapply(x, function(x_elt) x_elt@offset)) +\n                            1L\n        ans_ranges_width <- unlist(lapply(x, function(x_elt) x_elt@length))\n        ans_ranges_group <- seq_len(x_len)\n        ans_ranges <- new2(\"GroupedIRanges\", start=ans_ranges_start,\n                                             width=ans_ranges_width,\n                                             group=ans_ranges_group,\n                                             check=FALSE)\n    }\n    ans <- new2(classname, pool=ans_pool, ranges=ans_ranges, check=FALSE)\n    ans <- .dropDuplicatedPoolElts(ans)\n    if (!is.null(x_names))\n        names(ans) <- x_names\n    ans\n}\n\n### Produces an XVectorList object of the given length with empty elements.\nXVectorList <- function(classname, length=0L)\n{\n    elt0 <- new(elementType(new(classname)))\n    ans1_pool <- as(elt0@shared, \"SharedVector_Pool\")\n    ans1_ranges <- new(\"GroupedIRanges\", IRanges(start=1L, width=0L), group=1L)\n    ans1 <- new2(classname, pool=ans1_pool, ranges=ans1_ranges, check=FALSE)\n    rep.int(ans1, length)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going from XVector to XVectorList with extractList() and family\n###\n\nsetMethod(\"relistToClass\", \"XVector\",\n    function(x) paste0(class(x), \"List\")\n)\n\n### Takes one XVector object ('x') and a IntegerRanges object ('i') defining\n### 1-based ranges on 'x' (conceptually equivalent to defining views on\n### subject 'x').\n.unsafe.extractList <- function(x, i)\n{\n    ans_class <- relistToClass(x)\n    ans_pool <- as(x@shared, \"SharedVector_Pool\")\n    if (!is(i, \"IRanges\"))\n        i <- as(i, \"IRanges\")\n    ranges_group <- rep.int(1L, length(i))\n    ans_ranges <- new2(\"GroupedIRanges\",\n                       shift(i, x@offset),\n                       group=ranges_group, check=FALSE)\n    new2(ans_class, pool=ans_pool, ranges=ans_ranges, check=FALSE)\n}\n\n### Does not copy the sequence data!\nsetMethod(\"relist\", c(\"XVector\", \"PartitioningByEnd\"),\n    function(flesh, skeleton)\n    {\n        skeleton_len <- length(skeleton)\n        if (skeleton_len == 0L) {\n            flesh_len2 <- 0L\n        } else {\n            flesh_len2 <- end(skeleton)[skeleton_len]\n        }\n        if (length(flesh) != flesh_len2)\n            stop(\"shape of 'skeleton' is not compatible with 'length(flesh)'\")\n        .unsafe.extractList(flesh, skeleton)\n    }\n)\n\n### Does not copy the sequence data!\nsetMethod(\"extractList\", c(\"XVector\", \"IntegerRanges\"),\n    function(x, i)\n    {\n        if (length(i) != 0L\n         && (min(start(i)) < 1L || max(end(i)) > length(x)))\n            stop(\"some ranges are out of bounds\")\n        .unsafe.extractList(x, i)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### XVectorList subsetting\n###\n\n.getListElement_XVectorList <- function(x, i, exact=TRUE)\n{\n    i2 <- normalizeDoubleBracketSubscript(i, x, exact=exact,\n                                          allow.NA=TRUE,\n                                          allow.nomatch=TRUE)\n    if (is.na(i2))\n        return(NULL)\n    ans_class <- elementType(x)\n    ans_shared <- x@pool[[x@ranges@group[i2]]]\n    ans_offset <- x@ranges@start[i2] - 1L\n    ans_length <- x@ranges@width[i2]\n    new2(ans_class, shared=ans_shared,\n                    offset=ans_offset,\n                    length=ans_length,\n                    check=FALSE)\n}\n\nsetMethod(\"getListElement\", \"XVectorList\", .getListElement_XVectorList)\n\n### Drop unused pool elements.\nsetMethod(\"extractROWS\", \"XVectorList\",\n    function(x, i) .dropUnusedPoolElts(callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### subseq()\n###\n\nsetMethod(\"subseq\", \"XVectorList\",\n    function(x, start=NA, end=NA, width=NA)\n        narrow(x, start=start, end=end, width=width)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n.concatenate_XVectorList_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    objects <- S4Vectors:::prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ## 1. Take care of the parallel slots\n\n    ## Call method for Vector objects to concatenate all the parallel slots\n    ## (i.e. \"ranges\" and \"elementMetadata\" in the case of XVectorList) and\n    ## stick them into 'ans'. Note that the resulting 'ans' can be an invalid\n    ## object so we use 'check=FALSE' to skip validation.\n    ans <- callNextMethod(x, objects, use.names=use.names,\n                                      ignore.mcols=ignore.mcols,\n                                      check=FALSE)\n\n    ## 2. Take care of the non-parallel slots\n\n    ## Concatenate the \"pool\" slots.\n    pool_list <- lapply(all_objects, slot, \"pool\")\n    ans_pool <- do.call(c, pool_list)\n\n    ## 3. Fix parallel slot \"ranges\"\n\n    ans_ranges <- ans@ranges\n    breakpoints <- cumsum(lengths(pool_list))\n    offsets <- c(0L, breakpoints[-length(breakpoints)])\n    offsets <- rep.int(offsets, lengths(all_objects))\n    ans_ranges@group <- ans_ranges@group + offsets\n    if (!(use.names || is.null(names(ans_ranges))))\n        names(ans_ranges) <- NULL\n\n    ans <- BiocGenerics:::replaceSlots(ans, pool=ans_pool,\n                                            ranges=ans_ranges,\n                                            check=check)\n    .dropDuplicatedPoolElts(ans)\n}\n\nsetMethod(\"bindROWS\", \"XVectorList\", .concatenate_XVectorList_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show method for data column\n###\n\nsetMethod(\"showAsCell\", \"XVectorList\", function(object) as.character(object))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unsplit_list_of_XVectorList()\n###\n### Not intended for the end user.\n###\n### 'f' must be a factor with number of levels equal to 'length(x)' and\n### length equal to 'sum(lengths(x))'.\nunsplit_list_of_XVectorList <- function(classname, x, f)\n{\n    ans <- XVectorList(classname, length(f))\n    unlisted_x <- do.call(c, unname(x))\n    idx <- unname(split(seq_len(length(f)), f))\n    ans[unlist(idx)] <- unlisted_x\n    ans\n}\n\n",
        "compact-methods.R": "### =========================================================================\n### Object compaction\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### xvcopy()\n###\n### Internal compact() support function. Not intended to be called directly.\n###\n\nsetGeneric(\"xvcopy\", signature=\"x\",\n    function(x, start=NA, end=NA, width=NA, lkup=NULL, reverse=FALSE)\n        standardGeneric(\"xvcopy\")\n)\n\n### Downgrades 'x' to one of the 3 concrete direct subclasses of SharedVector\n### (SharedRaw, SharedInteger or SharedDouble). But those subclasses should\n### not be extended anyway (like final classes in Java).\nsetMethod(\"xvcopy\", \"SharedVector\",\n    function(x, start=NA, end=NA, width=NA, lkup=NULL, reverse=FALSE)\n    {\n        solved_SEW <- solveUserSEW(length(x), start=start, end=end, width=width)\n        ans_length <- width(solved_SEW)\n        ans <- SharedVector(class(x), length=ans_length)\n        SharedVector.mcopy(ans, 0L, x, start(solved_SEW), ans_length,\n                           lkup=lkup, reverse=reverse)\n        return(ans)\n    }\n)\n\n### Like the \"subseq\" method for XVector objects, this is an endomorphism.\nsetMethod(\"xvcopy\", \"XVector\",\n    function(x, start=NA, end=NA, width=NA, lkup=NULL, reverse=FALSE)\n    {\n        y <- subseq(x, start=start, end=end, width=width)\n        y@shared <- xvcopy(y@shared, start=y@offset+1L,\n                                     width=y@length,\n                                     lkup=lkup, reverse=reverse)\n        y@offset <- 0L\n        y\n    }\n)\n\nsetMethod(\"xvcopy\", \"SharedVector_Pool\",\n    function(x, start=NA, end=NA, width=NA, lkup=NULL, reverse=FALSE)\n    {\n        solved_SEW <- solveUserSEW(width(x), start=start, end=end, width=width)\n        shared_vector_list <- lapply(seq_len(length(x)),\n                              function(i)\n                                  xvcopy(x[[i]], start=start(solved_SEW)[i],\n                                                 width=width(solved_SEW)[i],\n                                                 lkup=lkup, reverse=reverse))\n        new2(class(x),\n             xp_list=lapply(shared_vector_list, function(xv) xv@xp),\n             .link_to_cached_object_list=lapply(shared_vector_list,\n                                         function(xv) xv@.link_to_cached_object),\n             check=FALSE)\n    }\n)\n\n### Like the \"subseq\" method for XVectorList objects, this is an endomorphism.\n### TODO: Make this a method for XVectorList objects.\nsetMethod(\"xvcopy\", \"XRawList\",\n    function(x, start=NA, end=NA, width=NA, lkup=NULL, reverse=FALSE)\n    {\n        y <- narrow(x, start=start, end=end, width=width)\n        all_groups <- unique(y@ranges@group)\n        for (group in all_groups) {\n            ii <- which(y@ranges@group == group)\n            ranges <- as(y@ranges[ii], \"IRanges\")\n            frame <- reduce(ranges, with.inframe.attrib=TRUE)\n            shared_length <- sum(width(frame))\n            shared <- SharedRaw(shared_length)\n            SharedVector.mcopy(shared, 0L,\n                               y@pool[[group]], start(frame), width(frame),\n                               lkup=lkup, reverse=reverse)\n            y@pool[[group]] <- shared\n            inframe <- attr(frame, \"inframe\")\n            if (reverse)\n                ## We supply start=1 so reverse() doesn't have to determine\n                ## it (by calling 'min(start(inframe))').\n                inframe <- reverse(inframe, start=1L)\n            y@ranges@start[ii] <- start(inframe)\n            y@ranges@width[ii] <- width(inframe)\n        }\n        y\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### compact()\n###\n\nsetGeneric(\"compact\", signature=\"x\",\n    function(x, check=TRUE, ...) standardGeneric(\"compact\")\n)\n\nsetMethod(\"compact\", \"ANY\",\n    function(x, check=TRUE, ...)\n    {\n        if (is.list(x)) {\n            ## By assigning to x[], we keep all the attributes (e.g. the\n            ## row.names if 'x' is a data.frame).\n            x[] <- lapply(x, compact)\n            return(x)\n        }\n        if (isS4(x)) {\n            for (name in slotNames(x))\n                slot(x, name, check=check) <-\n                    compact(slot(x, name), check=check, ...)\n            return(x)\n        }\n        x\n    }\n)\n\n### Both methods below first try to compact all the slots separately by\n### calling the default \"compact\" method. In particular this could potentially\n### achieve some real compaction of the \"elementMetadata\" and \"metadata\" slots.\nsetMethod(\"compact\", \"XVector\",\n    function(x, check=TRUE, ...)\n    {\n        x <- callNextMethod()\n        xvcopy(x)\n    }\n)\n\nsetMethod(\"compact\", \"XVectorList\",\n    function(x, check=TRUE, ...)\n    {\n        x <- callNextMethod()\n        xvcopy(x)\n    }\n)\n\n",
        "intra-range-methods.R": "### =========================================================================\n### Intra-range methods\n### -------------------------------------------------------------------------\n###\n\n\n### The default \"narrow\" method calls windows() so we only need to implement\n### a \"windows\" method for XVectorList objects to make narrow() work on these\n### objects.\nsetMethod(\"windows\", \"XVectorList\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        x@ranges <- windows(x@ranges, start=start, end=end, width=width)\n        x\n    }\n)\n\nsetMethod(\"threebands\", \"XVectorList\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        threeranges <- threebands(x@ranges, start=start, end=end, width=width)\n        left <- right <- x\n        left@ranges <- threeranges$left\n        x@ranges <- threeranges$middle\n        right@ranges <- threeranges$right\n        list(left=left, middle=x, right=right)\n    }\n)\n\n",
        "io-utils.R": "### =========================================================================\n### Some low-level (not exported) I/O utility functions\n### -------------------------------------------------------------------------\n###\n### Unless stated otherwise, nothing in this file is exported.\n###\n\n\nnew_input_filexp <- function(filepath)\n{\n    .Call2(\"new_input_filexp\", filepath, PACKAGE=\"XVector\")\n}\n\nrewind_filexp <- function(filexp)\n{\n    .Call2(\"rewind_filexp\", filexp, PACKAGE=\"XVector\")\n}\n\nnew_output_filexp <- function(filepath, append, compress, compression_level)\n{\n    .Call2(\"new_output_filexp\",\n           filepath, append,\n           compress, compression_level,\n           PACKAGE=\"XVector\")\n}\n\nclose_filexp <- function(filexp)\n{\n    .Call2(\"close_filexp\", filexp, PACKAGE=\"XVector\")\n}\n\n.normarg_input_filepath <- function(filepath)\n{\n    if (!is.character(filepath) || any(is.na(filepath)))\n        stop(wmsg(\"'filepath' must be a character vector with no NAs\"))\n    ## First pass: expand local paths and download any remote file.\n    filepath2 <- character(length(filepath))\n    for (i in seq_len(length(filepath))) {\n        fp <- filepath[i]\n        con <- file(fp)\n        con_class <- class(con)[1L]\n        close(con)\n        if (con_class == \"url\") {\n            filepath2[i] <- tempfile()\n            download.file(fp, filepath2[i])\n        } else {\n            filepath2[i] <- path.expand(fp)\n        }\n    }\n    ## Second pass: check the type of the local files (all files are\n    ## now local).\n    filetype <- character(length(filepath2))\n    for (i in seq_len(length(filepath2))) {\n        fp <- filepath2[i]\n        con <- file(fp)\n        filetype[i] <- base::summary(con)$class\n        close(con)\n        if (!(filetype[i] %in% c(\"file\", \"gzfile\")))\n            stop(wmsg(\"file \\\"\", filepath[i], \"\\\" \",\n                      \"has unsupported type: \", filetype[i]))\n    }\n    names(filepath2) <- filetype\n    filepath2\n}\n\n### Return a named list of \"file external pointers\".\nopen_input_files <- function(filepath)\n{\n    filepath2 <- .normarg_input_filepath(filepath)\n    ans <- lapply(filepath2,\n           function(fp)\n           {\n               filexp <- new_input_filexp(fp)\n               reg.finalizer(filexp, close_filexp, onexit=TRUE)\n               filexp\n           })\n    names(ans) <- filepath\n    ans\n}\n\n.normarg_compress <- function(compress)\n{\n    if (isTRUEorFALSE(compress)) {\n        if (compress)\n            return(\"gzip\")\n        return(\"no\")\n    }\n    if (isSingleString(compress)) {\n        # Types of compression supported by save():\n        #VALID_COMPRESS <- c(\"no\", \"gzip\", \"bzip2\", \"xz\")\n        VALID_COMPRESS <- c(\"no\", \"gzip\")\n        if (!(compress %in% VALID_COMPRESS))\n            stop(wmsg(\"when 'compress' is a single string, it must be one of \",\n                      paste(paste0(\"\\\"\", VALID_COMPRESS, \"\\\"\"),\n                            collapse=\", \")))\n        return(compress)\n    }\n    stop(wmsg(\"'compress' must be TRUE or FALSE or a single string\"))\n}\n\n.normarg_compression_level <- function(compression_level, compress)\n{\n    if (!isSingleNumberOrNA(compression_level))\n        stop(wmsg(\"'compression_level' must be a single number or NA\"))\n    if (is.na(compression_level))\n        return(switch(compress, no=0L, gzip=6L, bzip2=9L, xz=9L))\n    if (!is.integer(compression_level))\n        compression_level <- as.integer(compression_level)\n    if (compression_level < 0L)\n        stop(wmsg(\"'compression_level' cannot be negative\"))\n    compression_level\n}\n\n### Return a named list of one \"file external pointer\".\nopen_output_file <- function(filepath, append=FALSE,\n                             compress=FALSE, compression_level=NA)\n{\n    if (!isSingleString(filepath))\n        stop(wmsg(\"'filepath' must be a single string\"))\n    if (!isTRUEorFALSE(append))\n        stop(wmsg(\"'append' must be TRUE or FALSE\"))\n    compress <- .normarg_compress(compress)\n    compression_level <- .normarg_compression_level(compression_level, compress)\n    filepath2 <- path.expand(filepath)\n    filexp <- new_output_filexp(filepath2, append,\n                                compress, compression_level)\n    reg.finalizer(filexp, close_filexp, onexit=TRUE)\n    ans <- list(filexp)\n    names(ans) <- filepath\n    ans\n}\n\n",
        "reverse-methods.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"reverse\" methods.\n###\n\nsetMethod(\"reverse\", \"XVector\", function(x, ...) xvcopy(x, reverse=TRUE))\n\nsetMethod(\"rev\", \"XVector\", function(x) reverse(x))\n\nsetMethod(\"reverse\", \"XVectorList\", function(x, ...) xvcopy(x, reverse=TRUE))\n\n",
        "slice-methods.R": "### =========================================================================\n### Slice the bread\n### -------------------------------------------------------------------------\n\n\nsetMethod(\"slice\", \"integer\",\n    function(x, lower=-.Machine$integer.max, upper=.Machine$integer.max)\n        slice(as(x, \"XInteger\"), lower=lower, upper=upper)\n)\n\nsetMethod(\"slice\", \"XInteger\",\n    function(x, lower=-.Machine$integer.max, upper=.Machine$integer.max)\n    {\n        if (!isSingleNumber(lower))\n            stop(\"'lower' must be a single integer\")\n        if (!is.integer(lower))\n            lower <- as.integer(lower)\n        if (!isSingleNumber(upper))\n            stop(\"'upper' must be a single integer\")\n        if (!is.integer(upper))\n            upper <- as.integer(upper)\n        ranges <- .Call2(\"XInteger_slice\", x, lower, upper,\n                        PACKAGE=\"XVector\")\n        Views(x, ranges)\n    }\n)\n\nsetMethod(\"slice\", \"numeric\",\n    function(x, lower=-Inf, upper=Inf,\n             includeLower=TRUE, includeUpper=TRUE, rangesOnly=FALSE)\n        slice(as(x, \"XDouble\"), lower=lower, upper=upper,\n              includeLower=includeLower, includeUpper=includeUpper,\n              rangesOnly=rangesOnly)\n)\n\nsetMethod(\"slice\", \"XDouble\",\n    function(x, lower=-.Machine$double.xmax, upper=.Machine$double.xmax,\n             includeLower=TRUE, includeUpper=TRUE, rangesOnly=FALSE)\n    {\n        if (!isSingleNumber(lower))\n            stop(\"'lower' must be a single integer\")\n        if (!is.numeric(lower))\n            lower <- as.numeric(lower)\n        if (!isSingleNumber(upper))\n            stop(\"'upper' must be a single integer\")\n        if (!is.numeric(upper))\n            upper <- as.numeric(upper)\n        if (!isTRUEorFALSE(includeLower))\n            stop(\"'includeLower' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(includeUpper))\n            stop(\"'includeUpper' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(rangesOnly))\n            stop(\"'rangesOnly' must be TRUE or FALSE\")\n\n        ranges <- .Call2(\"XDouble_slice\", x, lower, upper, includeLower,\n                        includeUpper, PACKAGE=\"XVector\")\n        if (rangesOnly) {\n            ranges\n        } else {\n            Views(x, ranges)\n        }\n    }\n)\n\n",
        "updateObject-methods.R": "### ###################################################################\n### Update methods\n### ###################################################################\n\n\n## \"XVector\" -> \"XVector\"\nsetMethod(\"updateObject\", signature(object=\"XVector\"),\n          function(object, ..., verbose=FALSE) {\n              if (verbose) message(\"updateObject(object = 'XVector')\")\n              if (!(\"metadata\" %in% names(attributes(object)))) {\n                  object <-\n                    new(class(object),\n                        shared = slot(object, \"shared\"),\n                        offset = slot(object, \"offset\"),\n                        length = slot(object, \"length\"))\n              }\n              object\n          })\n\n## \"XIntegerViews\" -> \"XIntegerViews\"\nsetMethod(\"updateObject\", signature(object=\"XIntegerViews\"),\n          function(object, ..., verbose=FALSE) {\n              if (verbose) message(\"updateObject(object = 'XIntegerViews')\")\n              if (!(\"metadata\" %in% names(attributes(object)))) {\n                  object <-\n                    new(\"XIntegerViews\",\n                        subject = updateObject(slot(object, \"subject\")),\n                        start = slot(object, \"start\"),\n                        width = slot(object, \"width\"),\n                        NAMES = slot(object, \"NAMES\"))\n              }\n              object\n          })\n\n",
        "view-summarization-methods.R": "### =========================================================================\n### Summarize views on an XInteger or XDouble object\n###\n\n\nsetMethod(\"viewMins\", \"XIntegerViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XIntegerViews_summary1\", x, na.rm, \"viewMins\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewMins\", \"XDoubleViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XDoubleViews_summary1\", x, na.rm, \"viewMins\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewMaxs\", \"XIntegerViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XIntegerViews_summary1\", x, na.rm, \"viewMaxs\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewMaxs\", \"XDoubleViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XDoubleViews_summary1\", x, na.rm, \"viewMaxs\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewSums\", \"XIntegerViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XIntegerViews_summary1\", x, na.rm, \"viewSums\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewSums\", \"XDoubleViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XDoubleViews_summary1\", x, na.rm, \"viewSums\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewMeans\", \"XIntegerViews\",\n    function(x, na.rm=FALSE) {\n        if (!isTRUEorFALSE(na.rm))\n            stop(\"'na.rm' must be TRUE or FALSE\")\n        if (na.rm) {\n            n <-\n              viewSums(Views(!is.na(Rle(as.integer(subject(x)))), as(x, \"Rle\")))\n        } else {\n            n <- width(x)\n        }\n        viewSums(x, na.rm = na.rm) / n\n    }\n)\n\nsetMethod(\"viewMeans\", \"XDoubleViews\",\n    function(x, na.rm=FALSE) {\n        if (!isTRUEorFALSE(na.rm))\n            stop(\"'na.rm' must be TRUE or FALSE\")\n        if (na.rm) {\n            n <-\n              viewSums(Views(!is.na(Rle(as.numeric(subject(x)))), as(x, \"Rle\")))\n        } else {\n            n <- width(x)\n        }\n        viewSums(x, na.rm = na.rm) / n\n    }\n)\n\nsetMethod(\"viewWhichMins\", \"XIntegerViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XIntegerViews_summary2\", x, na.rm, \"viewWhichMins\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewWhichMins\", \"XDoubleViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XDoubleViews_summary2\", x, na.rm, \"viewWhichMins\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewWhichMaxs\", \"XIntegerViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XIntegerViews_summary2\", x, na.rm, \"viewWhichMaxs\",\n              PACKAGE=\"XVector\")\n)\n\nsetMethod(\"viewWhichMaxs\", \"XDoubleViews\",\n    function(x, na.rm=FALSE)\n        .Call2(\"XDoubleViews_summary2\", x, na.rm, \"viewWhichMaxs\",\n              PACKAGE=\"XVector\")\n)\n\n",
        "zzz.R": "###\n\n.onLoad <- function(libname, pkgname)\n{\n    ## -- HACK! --\n    ## The purpose of this 2nd hack below is to fix the prototypes of the\n    ## following classes: SharedRaw, SharedInteger, SharedDouble, XRaw,\n    ## XInteger and XDouble. Without this hack, calling new() on any of those\n    ## classes (with e.g. 'new(\"SharedRaw\")') returns an invalid object.\n    ## In order to \"fix\" those prototypes, we cannot use the standard\n    ## mechanism (which is to specify default slot values in the prototype\n    ## part of the setClass() statements) because the DLL of the package needs\n    ## to be loaded before those default values can be produced.\n\n    ## Note that we must fix the prototypes of the 3 SharedVector concrete\n    ## subclasses defined in this package *before* we fix the prototypes of\n    ## the 3 XVector concrete subclasses defined in this package.\n\n    ## 3 SharedVector concrete subclasses:\n    S4Vectors:::setDefaultSlotValue(\"SharedRaw\", \"xp\",\n                        newExternalptrWithTag(raw(0L)),\n                        where=asNamespace(pkgname))\n\n    S4Vectors:::setDefaultSlotValue(\"SharedInteger\", \"xp\",\n                        newExternalptrWithTag(integer(0L)),\n                        where=asNamespace(pkgname))\n\n    S4Vectors:::setDefaultSlotValue(\"SharedDouble\", \"xp\",\n                        newExternalptrWithTag(double(0L)),\n                        where=asNamespace(pkgname))\n\n    ## 3 XVector concrete subclasses:\n    S4Vectors:::setDefaultSlotValue(\"XRaw\", \"shared\",\n                        new(\"SharedRaw\"),  # is fixed now!\n                        where=asNamespace(pkgname))\n\n    S4Vectors:::setDefaultSlotValue(\"XInteger\", \"shared\",\n                        new(\"SharedInteger\"),  # is fixed now!\n                        where=asNamespace(pkgname))\n\n    S4Vectors:::setDefaultSlotValue(\"XDouble\", \"shared\",\n                        new(\"SharedDouble\"),  # is fixed now!\n                        where=asNamespace(pkgname))\n}\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"XVector\", libpath)\n}\n\n.test <- function() BiocGenerics:::testPackage(\"XVector\")\n\n"
    },
    "Biobase": {
        "AllGenerics.R": "setGeneric(\"abstract\",        function(object) standardGeneric(\"abstract\"))\nsetGeneric(\"aggenv\",          function(object) standardGeneric(\"aggenv\"))\nsetGeneric(\"aggfun\",          function(object) standardGeneric(\"aggfun\"))\nsetGeneric(\"annotatedDataFrameFrom\", function(object, byrow, ...) standardGeneric(\"annotatedDataFrameFrom\"))\nsetGeneric(\"assayData\",       function(object)standardGeneric(\"assayData\"))\nsetGeneric(\"assayData<-\",     function(object, value) standardGeneric(\"assayData<-\"))\nsetGeneric(\"channelNames\",    function(object, ...) standardGeneric(\"channelNames\"))\nsetGeneric(\"channel\",         function(object, name, ...) standardGeneric(\"channel\"))\nsetGeneric(\"content\",         function(object) standardGeneric(\"content\"))\nsetGeneric(\"description\",     function(object, ...)\n           standardGeneric(\"description\"))\nsetGeneric(\"description<-\",   function(object, value) standardGeneric(\"description<-\"))\nsetGeneric(\"dimnames\")\nsetGeneric(\"dimnames<-\")\nsetGeneric(\"dimLabels\",       function(object) standardGeneric(\"dimLabels\"))\nsetGeneric(\"dimLabels<-\",     function(object, value) standardGeneric(\"dimLabels<-\"))\nsetGeneric(\"esApply\",          function(X, MARGIN, FUN, ...) standardGeneric(\"esApply\"),\n           signature=c(\"X\"))\nsetGeneric(\"experimentData\",  function(object) standardGeneric(\"experimentData\"))\nsetGeneric(\"experimentData<-\",function(object, value) standardGeneric(\"experimentData<-\"))\nsetGeneric(\"expinfo\",         function(object) standardGeneric(\"expinfo\"))\nsetGeneric(\"exprs\",           function(object) standardGeneric(\"exprs\"))\nsetGeneric(\"exprs<-\",         function(object, value) standardGeneric(\"exprs<-\"))\nsetGeneric(\"featureNames\",    function(object) standardGeneric(\"featureNames\"))\nsetGeneric(\"featureNames<-\",  function(object, value) standardGeneric(\"featureNames<-\"))\nsetGeneric(\"featureData\",     function(object) standardGeneric(\"featureData\"))\nsetGeneric(\"featureData<-\",   function(object, value) standardGeneric(\"featureData<-\"))\nsetGeneric(\"fData\",           function(object) standardGeneric(\"fData\"))\nsetGeneric(\"fData<-\",         function(object, value) standardGeneric(\"fData<-\"))\nsetGeneric(\"fvarLabels\",      function(object) standardGeneric(\"fvarLabels\"))\nsetGeneric(\"fvarLabels<-\",    function(object, value) standardGeneric(\"fvarLabels<-\"))\nsetGeneric(\"fvarMetadata\",    function(object) standardGeneric(\"fvarMetadata\"))\nsetGeneric(\"fvarMetadata<-\",  function(object, value) standardGeneric(\"fvarMetadata<-\"))\nsetGeneric(\"hybridizations\",  function(object) standardGeneric(\"hybridizations\"))\nsetGeneric(\"initfun\",         function(object) standardGeneric(\"initfun\"))\nsetGeneric(\"locked\",          function(object) standardGeneric(\"locked\"))\nsetGeneric(\"makeDataPackage\", function(object, author, email,\n                                       packageName=deparse(substitute(object)),\n                                       packageVersion=package_version(\"1.0.0\"),\n                                       license=\"Artistic-2.0\",\n                                       biocViews=\"ExperimentData\",\n                                       filePath=tempdir(), ...) standardGeneric(\"makeDataPackage\"),\n           signature=\"object\")\nsetGeneric(\"normControls\",    function(object) standardGeneric(\"normControls\"))\nsetGeneric(\"notes\",           function(object) standardGeneric(\"notes\"))\nsetGeneric(\"notes<-\",         function(object, value) standardGeneric(\"notes<-\"))\nsetGeneric(\"otherInfo\",       function(object) standardGeneric(\"otherInfo\"))\nsetGeneric(\"pData\",           function(object) standardGeneric(\"pData\"))\nsetGeneric(\"pData<-\",         function(object, value) standardGeneric(\"pData<-\"))\nsetGeneric(\"phenoData\",       function(object) standardGeneric(\"phenoData\"))\nsetGeneric(\"phenoData<-\",     function(object, value) standardGeneric(\"phenoData<-\"))\nsetGeneric(\"preproc\",         function(object) standardGeneric(\"preproc\"))\nsetGeneric(\"preproc<-\",       function(object, value) standardGeneric(\"preproc<-\"))\nsetGeneric(\"protocolData\",    function(object) standardGeneric(\"protocolData\"))\nsetGeneric(\"protocolData<-\",  function(object, value) standardGeneric(\"protocolData<-\"))\nsetGeneric(\"pubMedIds\",       function(object) standardGeneric(\"pubMedIds\"))\nsetGeneric(\"pubMedIds<-\",     function(object, value) standardGeneric(\"pubMedIds<-\"))\nsetGeneric(\"sampleNames\",     function(object) standardGeneric(\"sampleNames\"))\nsetGeneric(\"sampleNames<-\",   function(object, value) standardGeneric(\"sampleNames<-\"))\nsetGeneric(\"samples\",         function(object) standardGeneric(\"samples\"))\nsetGeneric(\"se.exprs\",        function(object) standardGeneric(\"se.exprs\"))\nsetGeneric(\"se.exprs<-\",      function(object, value) standardGeneric(\"se.exprs<-\"))\nsetGeneric(\"selectChannels\",  function(object, names, ...) standardGeneric(\"selectChannels\"))\nsetGeneric(\"selectSomeIndex\", function(object, ...) standardGeneric(\"selectSomeIndex\"))\nsetGeneric(\"snpCall\",        function(object, ...) standardGeneric(\"snpCall\"))\nsetGeneric(\"snpCall<-\",      function(object, ..., value) standardGeneric(\"snpCall<-\"))\nsetGeneric(\"snpCallProbability\",   function(object, ...) standardGeneric(\"snpCallProbability\"))\nsetGeneric(\"snpCallProbability<-\", function(object, ..., value) standardGeneric(\"snpCallProbability<-\"))\nsetGeneric(\"storageMode\",     function(object) standardGeneric(\"storageMode\"))\nsetGeneric(\"storageMode<-\",   function(object, value) standardGeneric(\"storageMode<-\"))\nsetGeneric(\"varLabels\",       function(object) standardGeneric(\"varLabels\"))\nsetGeneric(\"varLabels<-\",     function(object, value) standardGeneric(\"varLabels<-\"))\nsetGeneric(\"varMetadata\",     function(object) standardGeneric(\"varMetadata\"))\nsetGeneric(\"varMetadata<-\",   function(object, value) standardGeneric(\"varMetadata<-\"))\nsetGeneric(\"write.exprs\",     function(x,...) standardGeneric(\"write.exprs\"))\n## Version-related generics\nsetGeneric(\"classVersion\",    function(object) standardGeneric(\"classVersion\"))\nsetGeneric(\"classVersion<-\",  function(object, value) standardGeneric(\"classVersion<-\"))\nsetGeneric(\"isCurrent\",       function(object, value) standardGeneric(\"isCurrent\"))\nsetGeneric(\"isVersioned\",     function(object) standardGeneric(\"isVersioned\"))\n## updateObjectTo\nsetGeneric(\"updateObjectTo\",\n           function(object, template, ..., verbose=FALSE) {\n               result <- standardGeneric(\"updateObjectTo\")\n               if (!is(result, class(template))) # or strict equality?\n                 stop(\"updateObjectTo returned class '\", class(result), \"' \",\n                      \"expected class '\", class(template), \"'\")\n               validObject(result)\n               result\n           })\n\n\n\n## Generics for Constructors: AnnotatedDataFrame and ExpresssionSet\n\nsetGeneric(\"AnnotatedDataFrame\", function(data, varMetadata, ...)\n           standardGeneric(\"AnnotatedDataFrame\"))\n\n\nsetGeneric(\"ExpressionSet\",\n           function(assayData,\n                    phenoData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n                    featureData=annotatedDataFrameFrom(assayData, byrow=TRUE),\n                    experimentData=MIAME(),\n                    annotation=character(),\n                    protocolData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n                    ...)\n           standardGeneric(\"ExpressionSet\"),\n           signature=\"assayData\")\n",
        "DataClasses.R": "# ==========================================================================\n# aggregator: a simple aggregator (R. Gentleman, 2001)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# Data are aggregated in the environment env if they are not there then the\n# get assigned with initfun, if they are there they get aggregated with agfun\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.aggregator <- setClass(\"aggregator\",\n   representation(\n      aggenv  = \"environment\",\n      initfun = \"function\",\n      aggfun  = \"function\"\n   ),\n   prototype = list(\n      initfun = function(name, val) 1,\n      aggfun  = function(name, current, val) current + 1\n   )\n)\n# ==========================================================================\n# container: lists containing objects of specified class (R. Gentleman, 2001)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.container <- setClass(\"container\",\n   representation(\n      x       = \"list\",\n      content = \"character\",\n      locked  = \"logical\"\n   ),\n   prototype = list(\n      x       = vector(\"list\", 0),\n      content = \"object\",\n      locked  = FALSE\n   )\n)\n# ==========================================================================\n# phenoData (DEFUNCT)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetClass(\"phenoData\",\n   representation(\n      pData       = \"data.frame\",\n      varLabels   = \"list\",\n      varMetadata = \"data.frame\"\n   ),\n   contains=\"Versioned\",\n   validity = function(object) {\n       paste(\"class phenoData is defunct,\",\n             \"convert using as(<<object>>, \\\"AnnotatedDataFrame\\\")\")\n   }\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetOldClass(\"data.frame\")\nsetClassUnion(\"data.frameOrNULL\", c(\"data.frame\", \"NULL\"))\n\n\n# ==========================================================================\n# MIAxE: a VIRTUAL class for experiment meta-data \n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.MIAxe <- setClass(\"MIAxE\",\n    representation(\"VIRTUAL\"),\n    contains=\"Versioned\",\n    prototype = prototype(.Versioned(versions=c(MIAxE=\"1.0.0\")))\n    )\n \n\n# MIAME: a class for microarray data - MIAME information (Rafael A. Irizarry)\n# More info: http://www.mged.org/Workgroups/MIAME/miame_1.1.html\n.MIAME <- setClass(\"MIAME\",\n   representation(\n      name           = \"character\",\n      lab            = \"character\",\n      contact        = \"character\",\n      title          = \"character\",\n      abstract       = \"character\",\n      url            = \"character\",\n      pubMedIds      = \"character\",\n      samples        = \"list\",\n      hybridizations = \"list\",\n      normControls   = \"list\",\n      preprocessing  = \"list\",\n      other          = \"list\"\n   ),\n   contains=c(\"MIAxE\"),\n   prototype = prototype(\n      .Versioned(versions=c(classVersion(\"MIAxE\"), MIAME=\"1.1.0\")),\n      name           = \"\",\n      lab            = \"\",\n      contact        = \"\",\n      title          = \"\",\n      abstract       = \"\",\n      url            = \"\",\n      pubMedIds      = \"\",\n      samples        = list(),\n      hybridizations = list(),\n      normControls   = list(),\n      preprocessing  = list(),\n      other          = list()\n   )\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# trick so that Plobs works\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetClassUnion(\"characterORMIAME\", c(\"MIAME\", \"character\"))\n# ==========================================================================\n# annotatedDataset (DEFUNCT)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetClass(\"annotatedDataset\",\n   representation(\n      reporterInfo = \"data.frameOrNULL\",\n      phenoData    = \"phenoData\",\n      \"VIRTUAL\"\n   ),\n   contains=c(\"VersionedBiobase\"))\n# ==========================================================================\n# AnnotatedDataFrame: A data.frame, with annotations about columns named\n# in the data slot contained in the metadata slot. The data slot has\n# columns identifying different entities (e.g., genes, samples) and\n# the columns contain attributes of those entities (e.g., control or\n# spike-in information for genes, age or sex for samples). The number\n# of columns in the data slot equals the number of rows in the\n# metadata slot.\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.AnnotatedDataFrame <- setClass(\"AnnotatedDataFrame\",\n         representation(varMetadata = \"data.frame\",\n                        data = \"data.frame\",\n                        dimLabels = \"character\"),\n         contains=c(\"Versioned\"),\n         prototype = prototype(\n           .Versioned(versions=list(AnnotatedDataFrame=\"1.1.0\")),\n           varMetadata = new( \"data.frame\" ),\n           data = new( \"data.frame\" ),\n           dimLabels=c(\"rowNames\", \"columnNames\")))\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetClassUnion(\"AssayData\", c(\"list\", \"environment\"))\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# eSet: A VIRTUAL class containing assay data (typically, one or many\n# different sets of results obtained from one or many samples in a\n# single experiment), phenotypic data (describing the samples involved\n# in the experiment), experimental data (describing the methods and\n# protocols used), and an annotation (linking to separately maintained\n# chip annotation information).\n#\n# When assayData contains several sets of results, each set must have\n# the same dimension (e.g., columns representing genes, rows\n# representing samples, all assayData members providing information\n# for the same number of genes and samples).\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.eSet <- setClass(\"eSet\",\n         representation(assayData = \"AssayData\",\n                        phenoData = \"AnnotatedDataFrame\",\n                        featureData = \"AnnotatedDataFrame\",\n                        experimentData = \"MIAxE\",\n                        annotation = \"character\",\n                        protocolData=\"AnnotatedDataFrame\",\n                        \"VIRTUAL\"),\n         contains=\"VersionedBiobase\",\n         prototype = prototype(\n           .VersionedBiobase(versions=c(eSet=\"1.3.0\")),\n               assayData = list(), # use initialize to set as env, so\n                                   # different instances have\n                                   # different envs\n               phenoData = .AnnotatedDataFrame(\n                 dimLabels=c(\"sampleNames\", \"sampleColumns\")),\n               featureData = .AnnotatedDataFrame(\n                 dimLabels=c(\"featureNames\", \"featureColumns\")),\n               annotation = character(),\n               protocolData = .AnnotatedDataFrame(\n                 dimLabels=c(\"sampleNames\", \"sampleColumns\"))))\n.ExpressionSet <- setClass(\"ExpressionSet\",\n         representation(experimentData=\"MIAME\"),\n         contains = \"eSet\",\n         prototype = prototype(\n           .VersionedBiobase(\n               versions=c(classVersion(\"eSet\"), ExpressionSet=\"1.0.0\")),\n               experimentData=.MIAME()))\n.NChannelSet <- setClass(\"NChannelSet\",\n         contains = \"eSet\",\n         prototype = prototype(\n           .VersionedBiobase(\n               versions=c(classVersion(\"eSet\"), NChannelSet=\"1.0.0\")),\n           phenoData = .AnnotatedDataFrame(\n             data=data.frame(),\n             varMetadata=data.frame(\n               labelDescription=character(0),\n               channelDescription=factor()))))\n.MultiSet <- setClass(\"MultiSet\",      # any element in assayData slot\n         contains = \"eSet\",\n         prototype = prototype(\n           .VersionedBiobase(\n               versions=c(classVersion(\"eSet\"), MultiSet=\"1.0.0\"))))\n.SnpSet <- setClass(\"SnpSet\",                      # call, callProbability\n         contains = \"eSet\",\n         prototype = prototype(\n           .VersionedBiobase(\n               versions=c(classVersion(\"eSet\"), SnpSet=\"1.0.0\"))))\n# ==========================================================================\n# exprSet (DEFUNCT)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetClass(\"exprSet\",\n   representation(\n      exprs       = \"matrix\",\n      se.exprs    = \"matrix\",\n      description = \"characterORMIAME\",\n      annotation  = \"character\",\n      notes       = \"character\"\n   ),\n   contains = c(\"annotatedDataset\"), # contains VersionedBiobase implicitly\n   validity = function(object)\n         paste(\"class exprSet is defunct,\",\n               \"convert using as(<<object>>, \\\"ExpressionSet\\\")\")\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n.ScalarObject <- setClass(\"ScalarObject\", contains=\"VIRTUAL\",\n         validity=function(object) {\n             if (length(object) != 1L)\n               paste(class(object), \"must have length one\")\n             else\n               TRUE\n         })\n\n.ScalarLogical <- setClass(\"ScalarLogical\",\n    contains=c(\"ScalarObject\", \"logical\"),\n    prototype=NA)\n\n.ScalarCharacter <- setClass(\"ScalarCharacter\",\n    contains=c(\"ScalarObject\", \"character\"),\n    prototype=\"\")\n\n.ScalarInteger <- setClass(\"ScalarInteger\",\n    contains=c(\"ScalarObject\", \"integer\"),\n    prototype=NA_integer_)\n\n.ScalarNumeric <- setClass(\"ScalarNumeric\",\n    contains=c(\"ScalarObject\", \"numeric\"),\n    prototype=NA_real_)\n",
        "VersionedClasses.R": "## Versions previously defined\n.VersionsNull <- setClass(\"VersionsNull\", contains=\"Versions\")\n.Versioned <- setClass(\"Versioned\",\n    representation(.__classVersion__ = \"Versions\"))\n.VersionedBiobase <- setClass(\"VersionedBiobase\",\n    contains=\"Versioned\",\n    prototype=prototype(\n      .__classVersion__ = .Versions(\n        R = getRversion(),\n        Biobase = package_version(packageDescription(\"Biobase\", NULL, \"Version\")))))\n",
        "VersionsClass.R": "## ==========================================================================\n## Versions: version string information\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n## methods and class defined together so available for prototypes elsewhere\n\n.Versions <- setClass(\"Versions\", contains=\"list\")\n\nsetMethod(\"initialize\", signature(.Object=\"Versions\"),\n          function(.Object, ...) callNextMethod(.Object, .asValidVersions(list(...))))\n\n.isValidVersion <- function(versions) {\n    tryCatch(all(as.integer(versions)==versions) &&\n             all(versions >= 0) &&\n             length(versions) > 1,\n             error=function(err) FALSE,\n             warning=function(warn) {})\n}\n\n.asValidVersions <- function(versions) {\n    res <- list()\n    for (i in seq(along.with=versions))\n      res[i] <-\n        if (!is.character(versions[[i]]) &&\n            .isValidVersion(versions[[i]]))\n            versions[i]\n        else\n            unclass(numeric_version(versions[[i]]))\n    names(res) <- names(versions)\n    res\n}\n\n## update\n\nsetMethod(\"updateObject\", signature(object=\"Versions\"),\n          function(object, ..., verbose=FALSE) {\n              if (verbose) message(\"updateObject(object = 'Versions')\")\n              if (!isS4(object)) do.call(new, c(\"Versions\", object))\n              else object\n      })\n\n## access\n\nsetMethod(\"[\",\n          signature=signature(x=\"Versions\"),\n          function(x, i, j, ..., drop = FALSE) {\n              ## 'dispatch' on i to avoid S4 complaint about j 'missing'\n              if (is(i, \"character\") &&\n                  !all(i %in% names(x))) {\n                  bad <- unique(i[!i %in% names(x)])\n                  cl <- deparse(match.call()[[2]])\n                  stop(sprintf(\"'[' indices '%s' not found in '%s'\",\n                               paste(bad, collapse=\"', '\"),\n                               cl))\n              }\n              as(callNextMethod(), \"Versions\")\n          })\n\n## assign\n\nsetReplaceMethod(\"[\", signature(x=\"Versions\"),\n                 function(x, i, j, value) {\n                     lst <- x@.Data\n                     names(lst) <- names(x)\n                     lst[i] <- .asValidVersions(value)\n                     x@.Data <- lst\n                     names(x) <- names(lst)\n                     x\n                 })\n\nsetReplaceMethod(\"[[\", signature(x=\"Versions\"),\n                 function(x, i, j, value) {\n                     lst <- x@.Data\n                     names(lst) <- names(x)\n                     lst[[i]] <- unlist(.asValidVersions(value))\n                     x@.Data <- lst\n                     names(x) <- names(lst)\n                     x\n                 })\n\nsetReplaceMethod(\"$\", signature(x=\"Versions\"),\n                 function(x, name, value) { x[[name]] <- value; x })\n\n## Compare\n\n.as.numeric_version <- function(x)\n    numeric_version(as(x, \"character\"))\n    \n.canVersionCompare <- function(e1, e2) {\n    if (length(e1) != length(e2))\n        stop(sprintf(\"cannot compare versions with length '%d', '%d'\",\n                     length(e1), length(e2)))\n    if (length(e1)>1 &&\n        (!all(names(e1) %in% names(e2)) ||\n         !all(names(e2) %in% names(e1))))\n        stop(\"cannot compare versions with different names\")\n    TRUE\n}\n\nsetMethod(\"Compare\",\n          signature=signature(\n            e1=\"Versions\",\n            e2=\"Versions\"),\n          function(e1, e2) {\n              .canVersionCompare(e1, e2)\n              e2 <- e2[names(e1)]\n              e1 <- .as.numeric_version(e1)\n              e2 <- .as.numeric_version(e2)\n              callNextMethod(e1, e2)\n          })\n\nsetMethod(\"Compare\",\n          signature=signature(\n            e1=\"Versions\",\n            e2=\"character\"),\n          function(e1, e2) {\n              .canVersionCompare(e1, e2)\n              if (length(e2) > 1)\n                  e2 <- e2[names(e1)]\n              e1 <- .as.numeric_version(e1)\n              e2 <- numeric_version(e2)\n              callNextMethod(e1, e2)\n          })\n\nsetMethod(\"Compare\",\n          signature=signature(\n            e1=\"character\",\n            e2=\"Versions\"),\n          function(e1, e2) callGeneric(e2,e1))\n\n## show\n\nsetAs(\"Versions\", \"character\",\n      function(from) {\n          if (length(from)) sapply(from, paste, collapse=\".\")\n          else \"Versioned; no version string\"\n      })\n\nsetMethod(\"show\", signature(object=\"Versions\"),\n          function(object) print(as(object, \"character\")))\n",
        "anyMissing.R": "anyMissing <- function(x=NULL) {\r\n  .Call(\"anyMissing\", x);\r\n}\r\n\r\n\r\n############################################################################\r\n# HISTORY:\r\n# 2007-08-14\r\n# o Created. See also R-devel thread \"hasNA()/anyNA()?\" on 2007-08-13.\r\n############################################################################\r\n",
        "environment.R": "# ==========================================================================\n# Functions to operate with the environment:\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# .initContents; .buildBiobaseOpts;\n# multiassign; copyEnv\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.initContents <- function() {\n   makeG = TRUE\n   if( isGeneric(\"contents\", where = .GlobalEnv ) )\n       if( identical(names(formals(contents)), c(\"object\", \"all.names\")) )\n            makeG = FALSE\n   if(makeG)\n     setGeneric(\"contents\", function(object, all.names)\n                         standardGeneric(\"contents\"))\n\n\n   setMethod(\"contents\", \"environment\",\n      function(object, all.names) {\n         if (missing(all.names))\n            all.names <- FALSE\n         as.list(object, all.names=all.names)\n     }\n   )\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.buildBiobaseOpts <- function() {\n    BioC <- getOption(\"BioC\")\n    if (is.null(BioC)) {\n        BioC <- list()\n        class(BioC) <- \"BioCOptions\"\n    }\n    Base <- BioC$Base\n    if (is.null(Base)) {\n        Base <- list()\n        class(Base) <- \"BioCPkg\"\n    }\n    if (is.null(Base$urls))\n        Base$urls <- list( bioc = \"http://bioconductor.org\")\n    ##RI: I added this to make my life easier. Should it be TRUE?\n    ##AJR: NO.  I've run across a few cases when it would completely\n    ##     break functionality, i.e. when tcltk isn't part of the R\n    ##     package (on weird, and development-based machines\n    if (is.null(Base$use.widgets))\n        Base$use.widgets <- FALSE\n    BioC$Base <- Base\n    options(\"BioC\"=BioC)\n}\n# ==========================================================================\n# RG:\n# multiput and multiget\n# ideally these will be internalized at some point\n# FIXME: I think Luke's Dynamic variables should be used rather than\n# the on.exit kludge\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nmultiassign <- function (x, value, envir = parent.frame(), inherits = FALSE) {\n   if( ! is.environment(envir) )\n      stop(\"envir argument is not an environment\")\n   if( missing(value) ) {\n      nx <- names(x)\n      if( any(nchar(nx) == 0) )\n         stop(\"value is missing and x does not have named components\")\n      value <- x\n      x <- nx\n   }\n   lenx <- length(x)\n   for(i in 1:lenx) {\n      i2 <- (i-1)%%lenx+1\n      if( is.list(x) ) {\n         if( is.list(value) )\n            assign(x[[i]], value[[i2]], envir=envir, inherits=inherits)\n         else\n            assign(x[[i]], value[i2], envir=envir, inherits=inherits)\n      }\n      else {\n         if( is.list(value) )\n            assign(x[i], value[[i2]], envir=envir, inherits=inherits)\n         else\n            assign(x[i], value[i2], envir=envir, inherits=inherits)\n      }\n   }\n}\n\n\n\n#### Functions for lists and environments\n\nlistLen <- function(x)\n    lengths(x)\n\n\n.new_env_size <- function(n) {\n    ## helper function returns suggested size for new environments that\n    ## will be used as hashtables given expected number of elements 'n'.\n    max(29L, as.integer(n * 1.20))\n}\n\ncopyEnv <- function(oldEnv, newEnv, all.names=FALSE) {\n    if (missing(newEnv))\n      newEnv <- new.env(hash=TRUE,\n                        parent=parent.env(oldEnv),\n                        size=.new_env_size(length(oldEnv)))\n    nms <- ls(oldEnv, all.names = all.names)\n    for (nm in nms)\n        newEnv[[nm]] <- oldEnv[[nm]]\n\n    newEnv\n}\n\n\n## Deprecated in v 2.11.2\nl2e <- function(vals, envir) {\n    .Defunct(\"list2env\", package=\"base\")\n}\n",
        "methods-AnnotatedDataFrame.R": "setMethod(\"initialize\", signature(.Object=\"AnnotatedDataFrame\"),\n          function(.Object, data = data.frame(), varMetadata = data.frame(),\n                   ...)\n{\n    tryCatch({\n        if (missing(varMetadata)) {\n            if (!missing(data)) checkClass(data, \"data.frame\", class(.Object))\n            varMetadata <- data.frame(\n                labelDescription = rep.int(NA_character_, ncol(data)),\n                stringsAsFactors = FALSE\n            )\n            row.names(varMetadata) <- as.character(colnames(data))\n        } else {\n            checkClass(varMetadata, \"data.frame\", class(.Object))\n            if (!\"labelDescription\" %in% colnames(varMetadata))\n                varMetadata[[\"labelDescription\"]] <-\n                    rep.int(NA_character_, nrow(varMetadata))\n            row.names(varMetadata) <- names(data)\n        }\n        varMetadata[[\"labelDescription\"]] <-\n            as.character(varMetadata[[\"labelDescription\"]])\n    }, error=function(err) {\n        stop(conditionMessage(err),\n             \"\\n  AnnotatedDataFrame 'initialize' could not update varMetadata:\",\n             \"\\n  perhaps pData and varMetadata are inconsistent?\")\n    })\n    callNextMethod(.Object, data=data, varMetadata=varMetadata, ...)\n})\n\nvalidAnnotatedDataFrame <- function( object ) \n{\n    msg <- NULL\n    if (!is(object, \"AnnotatedDataFrame\"))\n        msg <- c(msg, paste(\"cannot validate\", class(object),\n                            \"as AnnotatedDataFrame\" ))\n    if (length(row.names(varMetadata(object))) !=\n        length(colnames(pData(object))))\n        msg <- c(msg, paste(\"all AnnotatedDataFrame pData column names\",\n                            \"must be present as rows in varMetadata\",\n                            \"and vice versa\"))\n    else if (any(row.names(varMetadata(object)) != colnames(pData(object))))\n      msg <- c(msg, paste(\"AnnotatedDataFrame colnames of data differ\",\n                          \"from row.names of varMetadata\"))\n    if ( !(\"labelDescription\" %in% colnames(varMetadata(object))))\n      msg <- c(msg, paste(\"AnnotatedDataFrame varMetadata\",\n                          \"missing labelDescription column\"))\n    if (length(dimLabels(object))!=2)\n      msg <- c(msg, \"dimLabels must be a character vector of length 2\")\n    if (is.null(msg)) TRUE else msg\n}\n\nsetValidity(\"AnnotatedDataFrame\", validAnnotatedDataFrame)\n\nsetAs(\"AnnotatedDataFrame\", \"data.frame\", function(from) {\n    pData(from)\n})\n\nsetMethod(\"updateObject\", signature(object=\"AnnotatedDataFrame\"),\n          function(object, ..., verbose=FALSE) {\n              if (verbose) message(\"updateObject(object = 'AnnotatedDataFrame')\")\n              object <- asS4(object)\n              if (isVersioned(object) && isCurrent(object)[\"AnnotatedDataFrame\"])\n                callNextMethod()\n              else {\n                  ## version 1.0.0. -> 1.1.0 needs a new slot \"dimLabels\"\n                  to <- new(class(object))\n                  varMetadata(to) <- updateObject(varMetadata(object))\n                  pData(to) <- updateObject(pData(object))\n                  to\n              }\n          })\n\nannotatedDataFrameFromMatrix <- function(object, byrow=FALSE, ...) {\n    ## contract: 'object' is matrix-like, with dim, rownames, colnames\n    ## methods. Returns AnnotatedDataFrame with appropriate dimensions.\n    dims <- dim(object)\n    if (is.null(dims) || all(dims==0))\n        annotatedDataFrameFrom(NULL, byrow=byrow, ...)\n    else {\n        n <- if (byrow) dims[1] else dims[2]\n        nms <-\n            if(byrow) rownames(object)\n            else colnames(object)\n        data <- data.frame(numeric(n), row.names=nms)[,FALSE]\n        dimLabels <-\n            if (byrow) c(\"featureNames\", \"featureColumns\")\n            else c(\"sampleNames\", \"sampleColumns\")\n        AnnotatedDataFrame(data=data, dimLabels=dimLabels)\n    }\n}\n\nsetMethod(\"annotatedDataFrameFrom\",\n          signature(object=\"matrix\"),\n          annotatedDataFrameFromMatrix)\n\nannotatedDataFrameFromNull <- function(object, byrow=FALSE, ...) {\n    dimLabels <-\n        if (byrow) c(\"featureNames\", \"featureColumns\")\n        else c(\"sampleNames\", \"sampleColumns\")\n    AnnotatedDataFrame(data=data.frame(), dimLabels=dimLabels)\n}\n\nsetMethod(\"annotatedDataFrameFrom\",\n          signature(object=\"NULL\"),\n          annotatedDataFrameFromNull)\n\nannotatedDataFrameFromAssayData <- function(object, byrow=FALSE, ...) {\n    eltNames <-\n        if (is(object, \"environment\")) ls(object)\n        else names(object)\n    if (length(eltNames)==0)\n        annotatedDataFrameFrom(NULL, byrow=byrow, ...)\n    else\n        annotatedDataFrameFrom(object[[eltNames[1]]], byrow=byrow, ...)\n}\n\nsetMethod(\"annotatedDataFrameFrom\",\n          signature(object=\"AssayData\"),\n          annotatedDataFrameFromAssayData)\n\nhead.AnnotatedDataFrame <- function(x, n=6L, ...) {\n    ## essentially, utils:::head.data.frame\n    stopifnot(length(x) == 1L)\n    n <- if (n < 0L) {\n        max(nrow(x) + n, 0L)\n    } else min(n, nrow(x))\n    x[seq_len(n), ]\n}\n\ntail.AnnotatedDataFrame <- function(x, n=6L, ...) {\n    ## essentially, utils:::tail.data.frame\n    stopifnot(length(x) == 1L)\n    nrx <- nrow(x)\n    n <- if (n < 0L) \n        max(nrx + n, 0L)\n    else min(n, nrx)\n    x[seq.int(to = nrx, length.out = n), , drop = FALSE]\n}\n\nsetMethod(\"dimnames\", \"AnnotatedDataFrame\", function(x) {\n    dimnames(pData(x))\n})\n\nsetReplaceMethod(\"dimnames\", \"AnnotatedDataFrame\", function(x, value) {\n    sampleNames(x) <- value[[1]]\n    varLabels(x) <- value[[2]]\n    x\n})\n\nsetMethod(\"dim\", \"AnnotatedDataFrame\", function( x ) {\n  d <- dim(pData(x))\n  names(d) <- dimLabels(x)\n  d\n})\n\nsetMethod(\"dimLabels\", \"AnnotatedDataFrame\", function(object) {\n    object@dimLabels\n})\n\nsetReplaceMethod(\"dimLabels\",\n                 signature=signature(\n                   object=\"AnnotatedDataFrame\",\n                   value=\"character\"),\n                 function(object, value) {\n                     object@dimLabels <- value\n                     object\n                 })\n\nsetMethod(\"pData\", \"AnnotatedDataFrame\", function(object) object@data)\n\nsetReplaceMethod(\"pData\",\n                 signature=signature(\n                   object=\"AnnotatedDataFrame\",\n                   value=\"data.frame\"),\n                 function(object, value) {\n                     idx <- match(names(value), rownames(varMetadata(object)))\n                     varMetadata <- varMetadata(object)[idx,,drop=FALSE]\n                     row.names(varMetadata) <- names(value)\n                     initialize(object, data=value, varMetadata=varMetadata)\n                 })\n\nsetMethod(\"sampleNames\", \"AnnotatedDataFrame\",\n    function(object) row.names(object@data))\n\nsetReplaceMethod(\"sampleNames\",\n    signature(object=\"AnnotatedDataFrame\", value=\"ANY\"),\n    function(object, value) \n{\n    if (!is.null(value) && (length(value) != dim(object@data)[[1]]))\n        stop(\"number of new names (\", length(value), \") \",\n             \"should equal number of rows in AnnotatedDataFrame (\",\n             dim( object )[[1]], \")\")\n    row.names(object@data) <- value\n    object\n})\n\nsetMethod(\"featureNames\",\n          signature(object=\"AnnotatedDataFrame\"),\n          function(object) sampleNames(object))\n\nsetReplaceMethod(\"featureNames\",\n                 signature(object=\"AnnotatedDataFrame\", value=\"ANY\"),\n                 function(object, value) {\n                     sampleNames(object) <- value\n                     object\n                 })\n\nsetMethod(\"varLabels\", \"AnnotatedDataFrame\", function(object) colnames(object@data))\n\nsetReplaceMethod(\"varLabels\",\n    signature(\"AnnotatedDataFrame\", \"ANY\"),\n    function(object, value) \n{\n    if (!is.null(value) && (length(value) != dim(object@data)[[2]]))\n        stop(\"number of new varLabels (\", length(value), \") \",\n             \"should equal number of columns in AnnotatedDataFrame (\",\n             dim(object)[[2]], \")\")\n    if (!is.null(value)) {\n        ## silently ignore attempts to set colnames to NULL\n        colnames(object@data) <- value\n        row.names(object@varMetadata) <- value\n    }\n    object\n})\n\nsetMethod(\"varMetadata\", \"AnnotatedDataFrame\",\n          function(object) object@varMetadata )\n\nsetReplaceMethod(\"varMetadata\", c(\"AnnotatedDataFrame\", \"data.frame\"),\n                 function(object, value)\n{\n    if (!(\"labelDescription\" %in% colnames(value)))\n        warning(\"'varMetadata' must have column 'labelDescription'\")\n    rinfo <- .row_names_info(value)\n    if (0L != length(varLabels(object))) {\n        if (0L <= rinfo) {\n            ## not 'automatic'\n            bad <- setdiff(row.names(value), varLabels(object))\n            if (0L != length(bad)) {\n                fmt <- \"'%s' not in 'varLabels(<AnnotatedDataFrame>)'\"\n                nms <- paste(selectSome(bad), collapse=\"', '\")\n                stop(sprintf(fmt, nms))\n            }\n        }\n        if (ncol(object) != abs(rinfo)) {\n            fmt <- \"varMetadata has %d row(s), 'value' has %d\"\n            stop(sprintf(fmt, ncol(object), nrow(value)))\n        }\n        if (0 < ncol(pData(object)))\n            row.names(value) <- names(pData(object))\n    }\n    object@varMetadata <- value\n    object\n})\n\nsetMethod(\"[\",\n          signature(x=\"AnnotatedDataFrame\"),\n          function(x, i, j, ..., drop) {\n              if (missing(drop)) drop = FALSE\n              else if (drop)\n                stop(\"'AnnotatedDataFrame' does not support drop = TRUE\")\n              if(missing(j)) {\n                  mD <- x@varMetadata\n                  pD <- x@data[i,,drop = drop]\n              } else {\n                  mD <- x@varMetadata[j,,drop = drop]\n                  if( missing( i ))\n                    pD <- x@data[,j,drop = drop]\n                  else\n                    pD <- x@data[i,j,drop = drop]\n              }\n              initialize(x, data=pD, varMetadata=mD)\n          })\n\n##setMethod(\"$\", \"AnnotatedDataFrame\", function(x, name) `$`(pData(x), name))\nsetMethod(\"$\", \"AnnotatedDataFrame\", function(x, name) {\n    eval(substitute(pData(x)$NAME_ARG, list(NAME_ARG=name)))\n})\n\nsetReplaceMethod(\"$\", \"AnnotatedDataFrame\", function(x, name, value) {\n    x[[name]] <- value\n    x\n})\n\nsetMethod(\"[[\", \"AnnotatedDataFrame\", function(x, i, j, ...) pData(x)[[i]] )\n\nsetReplaceMethod(\"[[\",\n                 signature=signature(x=\"AnnotatedDataFrame\"),\n                 function(x, i, j, ..., value) {\n                     pData(x)[[i]] <- value\n                     for (metadata in names(list(...)))\n                       varMetadata(x)[i, metadata] <- list(...)[[metadata]]\n                     x\n                 })\n\nsetAs(\"phenoData\", \"AnnotatedDataFrame\", function(from) {\n  from <- asS4(from)\n  ## data\n  data <- from@pData\n  ## varMetadata\n  cnames <- colnames(data)\n  varMetadata <- from@varMetadata\n  if (all(dim(varMetadata)==0)) {\n    varMetadata <- data.frame(numeric(length(cnames)),row.names=cnames)[,FALSE]\n  }\n  ## varLabels -- as column in varMetadata,or warn\n  varLabels <- from@varLabels\n  if (length(varLabels)>0 && !(\"labelDescription\" %in% colnames(varMetadata)))\n    varMetadata[[\"labelDescription\"]] <- as.character(varLabels[cnames])\n  else if (length(varLabels)>0)\n    warning(\"contents of varLabels ignored\\n\", call.=FALSE)\n  else\n    varMetadata[[\"labelDescription\"]] <- rep.int(NA_character_, nrow(varLabels))\n  AnnotatedDataFrame(\n      data=data,\n      varMetadata=varMetadata,\n      dimLabels=c(\"sampleNames\", \"sampleColumns\"))\n})\n\nsetAs(\"data.frame\", \"AnnotatedDataFrame\",\n      function(from) AnnotatedDataFrame(data=from))\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nselectSome <- function(obj, maxToShow=5) {\n  len <- length(obj)\n  if (maxToShow<3) maxToShow <- 3\n  if (len > maxToShow) {\n      maxToShow <- maxToShow-1\n      bot <- ceiling(maxToShow/2)\n      top <- len-(maxToShow-bot-1)\n      nms <- obj[c(1:bot, top:len)]\n      c(as.character(nms[1:bot]), \"...\", as.character(nms[-c(1:bot)]))\n  }\n  else if (is.factor(obj))\n      as.character(obj)\n  else obj\n}\n\nsetMethod(\"selectSomeIndex\",\n          signature(object=\"data.frame\"),\n          function(object, maxToShow=5, byrow=TRUE, ...) {\n              len <-\n                if (byrow) dim(object)[[1]]\n                else dim(object)[[2]]\n              if (maxToShow < 3) maxToShow <- 3\n              if (len > maxToShow) {\n                  maxToShow <- maxToShow - 1\n                  bot <- ceiling(maxToShow/2)\n                  top <- len-(maxToShow-bot-1)\n                  list(1:bot, \"...\", top:len)\n              } else if (len >= 1) list(1:len, NULL, NULL)\n              else list(NULL, NULL, NULL)\n          })\n\n\n.wrapcat <-\n    function(lbl, nms, total, ..., indent=2, exdent=4)\n{\n    lbl <- sprintf(\"%s:\", lbl)\n    txt <- paste(c(lbl,  nms), collapse=\" \")\n    ext <-\n        if (length(nms) < total) sprintf(\"(%d total)\", total)\n        else character()\n    txt <- paste(c(lbl,  nms, ext), collapse=\" \")\n    cat(strwrap(txt, ..., indent=indent, exdent=exdent), sep=\"\\n\")\n}\n\n.showAnnotatedDataFrame <-\n    function(object, labels=list(0)) \n{\n    lbls <- list(object=paste0(\"An object of class '\", class(object), \"'\"),\n                 sampleNames=dimLabels(object)[[1]],\n                 varMetadata=\"varMetadata\",\n                 varLabels=\"varLabels\")\n    lbls[names(labels)] <- labels\n    if (ncol(object) == 0) {            # early exit for empty objects\n        cat(lbls[[\"object\"]], \": none\\n\", sep=\"\")\n        return()\n    }\n    ## create a simplified object for extracting names\n    idx <- selectSomeIndex(pData(object), maxToShow=4)\n    idy <- selectSomeIndex(pData(object), byrow=FALSE, maxToShow=4)\n    pData <- pData(object)[c(idx[[1]], idx[[3]]), c(idy[[1]], idy[[3]]),\n                           drop=FALSE]\n    rnms <- rownames(pData)\n    nms <- c(rnms[idx[[1]]], idx[[2]],\n             if (!is.null(idx[[1]])) rnms[-idx[[1]]] else NULL)\n\n    cat(lbls$object, \"\\n\", sep=\"\")\n    .wrapcat(lbls$sampleNames, nms, nrow(object))\n\n    cnms <- colnames(pData)\n    if (length(cnms) > 0) {\n        vars <- c(cnms[idy[[1]]], idy[[2]], cnms[-idy[[1]]])\n        .wrapcat(lbls$varLabels, vars, ncol(object))\n\n        mnms <- selectSome(colnames(varMetadata(object)), maxToShow=4)\n        .wrapcat(lbls$varMetadata, mnms, length(mnms))\n    } else cat(\"\\n  \", lbls$varLabels, \": none\", sep=\"\")\n}\n\nsetMethod(\"show\",\n          signature=signature(object=\"AnnotatedDataFrame\"),\n          function(object) .showAnnotatedDataFrame(object))\n\nsetMethod(\"combine\",\n          signature(x=\"AnnotatedDataFrame\", y=\"AnnotatedDataFrame\"),\n          function(x, y) {\n              if (class(x) != class(y)) {\n                  fmt <- \"'%s' objects have diffrenent classes '%s', '%s'\"\n                  txt0 <- \"combine,AnnotatedDataFrame,AnnotatedDataFrame-method\"\n                  stop(sprintf(fmt, txt0, class(x), class(y)))\n              }\n              if (!identical(dimLabels(x),dimLabels(y))) {\n                  fmt <- paste(\"AnnotatedDataFrame dimLabels differ:\\n\",\n                               \"    %s\\n\",\n                               \"    %s\\n  try 'updateObject'?\")\n                  stop(sprintf(fmt, paste(dimLabels(x), collapse=\", \"),\n                               paste(dimLabels(y), collapse=\", \")))\n              }\n\n              pDataX <- pData(x)\n              pDataY <- pData(y)\n              pData <- combine(pDataX, pDataY)\n\n              varMetadataX <- varMetadata(x)\n              varMetadataY <- varMetadata(y)\n              ## labelDescription is required, likely a factor with\n              ## conflicting levels\n              if (is.factor(varMetadataX$labelDescription) &&\n                  is.factor(varMetadataY$labelDescription)) {\n                  f <- factor(c(as.character(varMetadataX$labelDescription),\n                                as.character(varMetadataY$labelDescription)))\n                  varMetadataX$labelDescription <-\n                    factor(as.character(varMetadataX$labelDescription), levels=levels(f))\n                  varMetadataY$labelDescription <-\n                    factor(as.character(varMetadataY$labelDescription), levels=levels(f))\n                }\n              vM <- combine(varMetadataX, varMetadataY)\n\n              initialize(x, data=pData, varMetadata=vM)\n          })\n\n\nread.AnnotatedDataFrame <-\n    function(filename, path, sep = \"\\t\", header = TRUE, quote = \"\",\n             stringsAsFactors = FALSE, row.names = 1L,\n             varMetadata.char=\"#\", widget =\n             getOption(\"BioC\")$Base$use.widgets, sampleNames =\n             character(0), ...)\n{\n    \n    if(!(is.character(varMetadata.char) &&\n         (identical(nchar(varMetadata.char), 1L))))\n        stop(\"Invalid  'varMetadata.char'\")\n\n    ## For backward (or forward?) compatibility:\n    if(widget)\n        stop(\"Sorry: tkWidgets is not available for read.AnnotatedDataFrame\")\n\n    if(length(sampleNames)>0)\n        stop(\"'sampleNames' argument is not supported, provide the sample\",\n             \"names in the input file and use the option 'row.names'.\")\n\n    if(!missing(path))\n        filename = file.path(path, filename)\n    pData = read.table(filename, sep=sep, header=header, quote=quote,\n      stringsAsFactors=stringsAsFactors, \n      row.names=row.names, comment.char=varMetadata.char, ...)\n    \n    ## read varMetadata section (the lines with leading \"#\")\n    vmd = grep(paste0(\"^\",  varMetadata.char),\n      readLines(filename), value=TRUE)\n    svmd = strsplit(vmd, \": *\")\n    varNames = sub(\"^# *\", \"\", sapply(svmd, \"[\", 1L))\n    varMetad = sapply(svmd, \"[\", 2L)\n\n    ## link varMetadata names with pData colnames\n    mt = match(colnames(pData), varNames)\n    varMetad = ifelse(!is.na(mt), varMetad[mt], \"\")\n\n    vmd = data.frame(labelDescription=varMetad, row.names=colnames(pData))\n\n    ## add provenance information. Alapping it on as an attribute is a\n    ## bit tacky, if Martin likes the idea at all, maybe this can be\n    ## made a proper slot...\n    provenance = sprintf(\"Read from file %s on %s at %s.\",\n      filename, Sys.info()[\"nodename\"], date())\n    attr(vmd, \"provenance\") = provenance\n    \n    AnnotatedDataFrame(data=pData, varMetadata=vmd)\n    \n}\n\nwrite.AnnotatedDataFrame <-\n    function(x, file=\"\", varMetadata.char=\"#\", ..., append=FALSE,\n             fileEncoding=\"\")\n{\n    ## file handling from write.table\n    if (file == \"\") \n        file <- stdout()\n    else if (is.character(file)) {\n        file <- if (nzchar(fileEncoding)) \n            file(file, ifelse(append, \"a\", \"w\"), encoding = fileEncoding)\n        else file(file, ifelse(append, \"a\", \"w\"))\n        on.exit(close(file))\n    } else if (!isOpen(file, \"w\")) {\n        open(file, \"w\")\n        on.exit(close(file))\n    }\n    if (!inherits(file, \"connection\")) \n        stop(\"'file' must be a character string or connection\")\n\n    writeLines(sprintf(\"%s %s: %s\", varMetadata.char, varLabels(x),\n                       varMetadata(x)$labelDescription),\n               file)\n    write.table(pData(x), file, append=append, fileEncoding=fileEncoding,\n                ...)\n}\n\nsetMethod(\"AnnotatedDataFrame\",\n          signature(data=\"missing\", varMetadata=\"missing\"),\n\n    function(data, varMetadata, dimLabels=c(\"rowNames\", \"columnNames\"), ...)\n{\n    .AnnotatedDataFrame(data=data.frame(), varMetadata=data.frame(),\n                        dimLabels=dimLabels, ...)\n})\n\nsetMethod(\"AnnotatedDataFrame\",\n          signature(data=\"data.frame\", varMetadata=\"missing\"),\n    function(data, varMetadata,\n             dimLabels=c(\"rowNames\", \"columnNames\"), ...)\n{\n    varMetadata <- data.frame(\n        labelDescription = rep.int(NA_character_, ncol(data)),\n        stringsAsFactors = FALSE\n    )\n    row.names(varMetadata) <- names(data)\n    .AnnotatedDataFrame(data=data, varMetadata=varMetadata,\n                        dimLabels=dimLabels, ...)\n})\n\nsetMethod(\"AnnotatedDataFrame\",\n           signature(data=\"data.frame\", varMetadata=\"data.frame\"),\n    function(data, varMetadata,\n             dimLabels=c(\"rowNames\", \"columnNames\"), ...)\n{\n    if (!\"labelDescription\" %in% colnames(varMetadata))\n        varMetadata[[\"labelDescription\"]] <-\n            rep.int(NA_character_, nrow(varMetadata))\n    row.names(varMetadata) <- names(data)\n    varMetadata[[\"labelDescription\"]] <-\n        as.character(varMetadata[[\"labelDescription\"]])\n    .AnnotatedDataFrame(data=data, varMetadata=varMetadata,\n                        dimLabels=dimLabels, ...)\n})\n\n\n\n\n",
        "methods-AssayData.R": "assayDataNew <-\n    function(storage.mode = c(\"lockedEnvironment\", \"environment\", \"list\"),\n             ...)\n{\n    storage.mode <- match.arg(storage.mode) ## defaults to \"lockedEnvironment\"\n    assayData <- switch(storage.mode,\n                        lockedEnvironment =,\n                        environment = new.env(parent=emptyenv()),\n                        list = list())\n    \n    arglist <- list(...)\n    if((length(arglist)>0L) &&\n       ((is.null(names(arglist))) || any(names(arglist)==\"\")))\n        stop(\"all arguments must be named\")\n\n    for (nm in names(arglist)) {\n        elt <- arglist[[nm]]\n        if (!is.null(dimnames(elt)))\n            dimnames(elt) <- lapply(dimnames(elt), unname)\n        assayData[[nm]] <- elt\n    }\n    if (storage.mode == \"lockedEnvironment\")\n        assayDataEnvLock(assayData)\n    msg <- assayDataValidMembers(assayData)\n    if (!is.logical(msg)) stop(msg)\n    assayData\n}\n\nassayDataValidMembers <- function(assayData, required) {\n    msg <- NULL\n    eltNames <-\n      if (\"list\" == assayDataStorageMode(assayData)) names(assayData)\n      else ls(assayData)\n    if (!missing(required)) {\n        absent <- required[!required %in% eltNames]\n        if (length(absent) != 0)\n          msg <- c(msg, paste0(\"'AssayData' missing '\", absent ,\"'\" ,\n                               collapse = \"\\n\\t\"))\n    }\n    dimsOk <-\n      sapply(eltNames, function(elt)\n             tryCatch(length(dim(assayData[[elt]]))>1,\n                      error=function(err) FALSE))\n    if (!all(dimsOk)) \n      msg <- c(msg, paste0(\"'AssayData' elements with invalid dimensions: '\",\n                           paste(eltNames[!dimsOk], collapse=\"' '\"), \"'\"))\n    if (length(assayData)>1) {\n        eltRowNames <- rownames(assayData[[eltNames[[1]]]])\n        rowNamesOk <- \n          all(sapply(eltNames[-1], function(elt)\n                     all(eltRowNames == rownames(assayData[[elt]]))))\n        if (!rowNamesOk)\n          msg <- c(msg, \"'AssayData' elements with different rowNames\")\n    }\n    if (is.null(msg)) TRUE else msg\n}\n\nassayDataStorageMode <- function(object) {\n  if (is(object, \"list\"))\n    \"list\"\n  else if (environmentIsLocked(object))\n    \"lockedEnvironment\"\n  else\n    \"environment\"\n}\n\nsetMethod(\"storageMode\", \"AssayData\", assayDataStorageMode)\n\nassayDataStorageModeReplace <- function(object, value) {\n    storageMode <- assayDataStorageMode(object)\n    if (storageMode == value) return(object)\n    names <- if (storageMode == \"list\") names(object) else ls(object)\n    switch(value,\n           lockedEnvironment = {\n               assayData <- new.env(parent=emptyenv())\n               for (nm in names) assayData[[nm]] <- object[[nm]]\n               assayDataEnvLock(assayData)\n               assayData\n           }, environment = {\n               assayData <- new.env(parent=emptyenv())\n               for (nm in names) assayData[[nm]] <- object[[nm]]\n               assayData\n           }, list = as.list(object))\n}\n\nsetReplaceMethod(\"storageMode\",\n                 signature=c(object=\"AssayData\", value=\"character\"),\n                 assayDataStorageModeReplace)\n\nassayDataEnvLock <- function(assayData)\n  lockEnvironment(assayData, bindings=TRUE)\n\nassayDataSubsetElements <-\n  function(object, elts, storageMode = assayDataStorageMode(object)) {\n    if (any(duplicated(elts)))\n      stop(\"'AssayData' element names must be unique\")\n    names <-\n        if (storageMode(object)==\"list\") names(object)\n        else ls(object)\n    if (!all(elts %in% names))\n      stop(\"'AssayData' missing elements: '\",\n           paste0(elts[!elts %in% names], collapse=\"', '\"), \"'\")\n    switch(storageMode,\n           lockedEnvironment = {\n               assayData <- new.env(parent = emptyenv())\n               for (nm in elts) assayData[[nm]] <- object[[nm]]\n               assayDataEnvLock(assayData)\n               assayData\n           },\n           environment = {\n               assayData <- new.env(parent = emptyenv())\n               for (nm in elts) assayData[[nm]] <- object[[nm]]\n               assayData\n           },\n           list = {\n               object[elts]\n           })\n}\n\nsetMethod(\"assayData\",\n          signature=signature(object=\"AssayData\"),\n          function(object) object)\n\n.assayDataDimnames <- function(assayData) {\n    switch(storageMode(assayData), lockedEnvironment=, environment = {\n        result <- vector(\"list\", length(assayData))\n        names(result) <- ls(assayData)\n        for (nm in ls(assayData))\n            result[[nm]] <- dimnames(assayData[[nm]])\n        result\n    }, list=lapply(assayData, dimnames))\n}\n\nsetMethod(\"sampleNames\", signature(object=\"AssayData\"),\n          function(object) {\n              if (!length(object))\n                return(character(0))\n              safe.colnames <-\n                function(x) if (ncol(x) == 0) character(0) else colnames(x)\n              switch(assayDataStorageMode(object),\n                     list=safe.colnames(object[[1]]),\n                     safe.colnames(object[[ls(object)[1]]]))\n          })\n\nsetReplaceMethod(\"sampleNames\", signature(object=\"AssayData\", value=\"list\"),\n    function(object, value) \n{\n    .names_found_unique <- function(names, table)\n    {\n        ok <- !is.null(names) && all(names %in% table) && \n              !any(duplicated(names))\n        if (!ok) {\n            txt <- \"'sampleNames' replacement list must have unique named elements\n                    corresponding to assayData element names\"\n            stop(paste(strwrap(txt, exdent=2), colapse=\"\\n\"))\n        }\n    }\n    mode <- assayDataStorageMode(object)\n    switch(mode, lockedEnvironment = {\n        .names_found_unique(names(value), ls(object))\n        object <- copyEnv(object)\n    }, environment = {\n        .names_found_unique(names(value), ls(object))\n    }, list= {\n        .names_found_unique(names(value), names(object))\n    })\n    for (nm in names(value)) {\n        dn <- dimnames(object[[nm]])\n        if (is.null(dn))\n            dn <- vector(\"list\", length(dim(object[[nm]])))\n        dn[[2]] <- value[[nm]]\n        dimnames(object[[nm]]) <- dn\n    }\n    if (mode == \"lockedEnvironment\")\n        assayDataEnvLock(object)\n    object\n})\n\nsetReplaceMethod(\"sampleNames\", signature(object=\"AssayData\", value=\"ANY\"),\n    function(object, value)\n{\n    mode <- assayDataStorageMode(object)\n    dims <- switch(mode, lockedEnvironment=, environment = {\n        result <- vector(\"list\", length(object))\n        names(result) <- ls(object)\n        for (nm in ls(object))\n            result[[nm]] <- ncol(object[[nm]])\n        result\n    }, list = {\n        lapply(object, ncol)\n    })\n    \n    if (length(dims)==0 && length(value) !=0)\n        return(object)                    # early exit; no samples to name\n    if (!all(dims==length(value))) {\n        txt <- sprintf(\"'value' length (%d) must equal sample number in AssayData (%d)\",\n                       length(value), dims[[1]])\n        stop(paste(strwrap(txt, exdent=2), collapse=\"\\n\"))\n    }\n\n    nms <- switch(mode, lockedEnvironment = {\n        object <- copyEnv(object)\n        ls(object)\n    }, environment = ls(object), list = names(object))\n\n    for (nm in nms) {\n        dn <- dimnames(object[[nm]])\n        if (is.null(dn))\n            dn <- vector(\"list\", length(dim(object[[nm]])))\n        dn[[2]] <- value\n        dimnames(object[[nm]]) <- dn\n    }\n\n    if (mode == \"lockedEnvironment\")\n        assayDataEnvLock(object)\n    object\n})\n\nsetMethod(\"featureNames\", signature(object=\"AssayData\"),\n          function(object) {\n              if (!length(object))\n                return(character(0))\n              safe.rownames <-\n                function(x) if (nrow(x) == 0) character(0) else rownames(x)\n              switch(assayDataStorageMode(object),\n                     list=safe.rownames(object[[1]]),\n                     safe.rownames(object[[ls(object)[1]]]))\n          })\n\nsetReplaceMethod(\"featureNames\", signature(object=\"AssayData\", value=\"ANY\"),\n    function(object, value) \n{\n    mode <- assayDataStorageMode(object)\n    dims <- switch(mode, lockedEnvironment=, environment = {\n        result <- vector(\"list\", length(object))\n        names(result) <- ls(object)\n        for (nm in ls(object)) result[[nm]] <- nrow(object[[nm]])\n        result\n    }, list = lapply(object, nrow))\n    if (length(dims)==0 && length(value) !=0)\n        return(object)                    # early exit; no features to name\n    if (!all(dims==length(value))) {\n        txt <- sprintf(\"'value' length (%d) must equal feature number in AssayData (%d)\",\n                       length(value), dims[[1]])\n        stop(paste(strwrap(txt, exdent=2), collapse=\"\\n\"))\n    }\n\n    nms <- switch(mode, lockedEnvironment = {\n        object <- copyEnv(object)\n        ls(object)\n    }, environment = ls(object), list=names(object))\n\n    for (nm in nms) {\n        dn <- dimnames(object[[nm]])\n        if (is.null(dn))\n            dn <- vector(\"list\", length(dim(object[[nm]])))\n        dn[[1]] <- value\n        dimnames(object[[nm]]) <- dn\n    }\n\n    if (mode == \"lockedEnvironment\")\n        assayDataEnvLock(object)\n    object\n})\n\nsetMethod(\"combine\", c(\"AssayData\", \"AssayData\"), function(x, y, ...) {\n    storage.mode <- assayDataStorageMode(x)\n    nmfunc <- if (\"environment\"==class(x)) ls else names\n\n    if (assayDataStorageMode(y) != storage.mode)\n      stop(\"assayData must have same storage, but are '\",\n           storage.mode, \"', '\", assayDataStorageMode(y))\n    if (length(nmfunc(x)) != length(nmfunc(y)))\n      stop(\"assayData have different numbers of elements:\\n\\t\",\n           paste(nmfunc(x), collapse=\" \"), \"\\n\\t\",\n           paste(nmfunc(y), collapse=\" \"))\n    if (!all(nmfunc(x) == nmfunc(y)))\n      stop(paste(\"assayData have different element names:\",\n                 paste(nmfunc(x), collapse=\" \"),\n                 paste(nmfunc(y), collapse=\" \"), sep=\"\\n\\t\"))\n    if (\"list\" == storage.mode) {\n        aData <- lapply(names(x), function(nm) combine(x[[nm]],y[[nm]]))\n        names(aData) <- names(x)\n    } else {\n        aData <- new.env(parent=emptyenv())\n        for (nm in ls(x)) aData[[nm]] <- combine(x[[nm]], y[[nm]])\n        if (\"lockedEnvironment\" == storage.mode) assayDataEnvLock(aData)\n    }\n    aData\n})\n\nassayDataDim <- function(object) {\n  nms <- if (assayDataStorageMode(object) == \"list\") names(object) else ls(object)\n  if ( length( nms ) == 0 ) return( NA )\n  d <- dim( object[[ nms[[1]] ]])\n  names(d) <- c( \"Features\", \"Samples\", rep(\"...\", max(length(d)-2, 0)))\n  d\n}\n\n##FIXME: RG says I don't know if you should ignore non-matrix objects or\n## not -  for now I have put in an informative error message\nassayDataDims <- function(object) {\n  nms <- if (assayDataStorageMode(object) == \"list\") names(object) else ls(object)\n  if (length(nms) == 0)\n    return(matrix(integer(0), nrow = 2, ncol = 0, \n                  dimnames = list(c(\"Features\", \"Samples\"), character(0))))\n  d <- sapply(nms, function(i) dim(object[[i]]))\n  rownames(d) <- c(\"Features\", \"Samples\", rep(\"...\", nrow(d)-2))\n  colnames(d) <- nms\n  d[,order(colnames(d)), drop=FALSE]\n}\n",
        "methods-ExpressionSet.R": "setMethod(\"initialize\", \"ExpressionSet\",\n    function(.Object, assayData, phenoData, featureData,\n             exprs=new(\"matrix\"), ... )\n{\n    if (missing(assayData)) {\n        if (missing(phenoData))\n            phenoData <- annotatedDataFrameFrom(exprs, byrow=FALSE)\n        if (missing(featureData))\n            featureData <- annotatedDataFrameFrom(exprs, byrow=TRUE)\n        .Object <- callNextMethod(.Object,\n                                  phenoData = phenoData,\n                                  featureData = featureData,\n                                  exprs = exprs,\n                                  ...)\n    } else if (missing(exprs)) {\n        if (missing(phenoData))\n            phenoData <- annotatedDataFrameFrom(assayData, byrow=FALSE)\n        if (missing(featureData))\n            featureData <- annotatedDataFrameFrom(assayData, byrow=TRUE)\n        .Object <- callNextMethod(.Object,\n                                  assayData = assayData,\n                                  phenoData = phenoData,\n                                  featureData = featureData,\n                                  ...)\n    } else stop(\"provide at most one of 'assayData' or 'exprs' to initialize ExpressionSet\",\n                call.=FALSE)\n    .harmonizeDimnames(.Object)\n})\n\n.harmonizeDimnames <- function(object) {\n    err <- function(conflicts)\n        stop(\"assayData element dimnames conflict: \",\n             paste(names(conflicts), collapse=\", \"))\n    okNames <- list(featureNames(featureData(object)),\n                    sampleNames(phenoData(object)))\n    dimNames <- .assayDataDimnames(assayData(object))\n    dimConflict <- function(dimNames, okNames, dim) {\n        nm <- lapply(dimNames, \"[[\", dim)\n        isConflict <- !sapply(nm, function(x, y) {\n            is.null(x) || isTRUE(all.equal(x, y, check.attr=FALSE))\n        }, okNames[[dim]])\n        isNamed <- sapply(lapply(nm, names), length) > 0\n        isNull <- sapply(nm, is.null)\n        if (all(!isConflict & !isNamed & !isNull))\n            return (FALSE)\n        if (any(isConflict & !isNull))\n            err(isConflict[!isNull])\n        TRUE\n    }\n    if (dimConflict(dimNames, okNames, 1))\n        featureNames(assayData(object)) <- okNames[[1]]\n    if (dimConflict(dimNames, okNames, 2))\n        sampleNames(assayData(object)) <- okNames[[2]]\n    object\n}\n\nsetAs(\"exprSet\", \"ExpressionSet\", function(from) {\n  from <- asS4(from)\n  desc <- from@description\n  desc <- \n    if (class(desc)!=\"MIAME\") {\n        txt <- \"missing or mis-formed MIAME 'description' in original object;\n                creating new, empty description\"\n        warning(paste0(strwrap(txt, indent=2), collapse=\"\\n  \"))\n        MIAME()\n    } else updateObject(desc)\n  exprs <- from@exprs\n  phenoData <- as(from@phenoData, \"AnnotatedDataFrame\")\n  annotation <- from@annotation\n  dims <- dim(exprs)\n  if (all(dim(from@se.exprs) == dims)) {\n    se.exprs <- from@se.exprs\n    colnames(se.exprs) <- colnames(exprs)\n    .ExpressionSet(phenoData=phenoData, experimentData=desc,\n        annotation=annotation, exprs=exprs, se.exprs=se.exprs)\n  } else {\n    txt <- \"missing or mis-formed 'se.exprs' in original object;\n            creating ExpressionSet without se.exprs\"\n    warning(paste0(strwrap(txt, indent=2), collapse=\"\\n  \"))\n    .ExpressionSet(phenoData=phenoData, experimentData=desc,\n                   annotation=annotation, exprs=exprs)\n  }\n})\n\nsetValidity(\"ExpressionSet\", function(object) {\n    msg <- validMsg(NULL, isValidVersion(object, \"ExpressionSet\"))\n    msg <- validMsg(msg, assayDataValidMembers(assayData(object), c(\"exprs\")))\n    if(class(experimentData(object)) != \"MIAME\")\n        msg <- validMsg(msg, \n               \"experimentData slot in ExpressionSet must be 'MIAME' object\")\n    if (is.null(msg)) TRUE else msg\n})\n\nsetAs(\"ExpressionSet\", \"data.frame\",\n      function (from) data.frame(t(exprs(from)), pData(from)))\n\nas.data.frame.ExpressionSet <- function(x, row.names=NULL, optional=FALSE, ...)\n  as(x, \"data.frame\")\n\nsetMethod(\"exprs\", signature(object=\"ExpressionSet\"),\n          function(object) assayDataElement(object,\"exprs\"))\n\nsetReplaceMethod(\"exprs\", signature(object=\"ExpressionSet\",value=\"matrix\"),\n                 function(object, value) assayDataElementReplace(object, \"exprs\", value))\n\n\n.esApply <- function(X, MARGIN, FUN, ...) {\n    parent <- environment(FUN)\n    if (is.null(parent))\n        parent <- emptyenv()\n    e1 <- new.env(parent=parent)\n    multiassign(names(pData(X)), pData(X), envir=e1)\n    environment(FUN) <- e1\n    apply(exprs(X), MARGIN, FUN, ...)\n}\n\nsetMethod(\"esApply\",\n          signature=signature(X=\"ExpressionSet\"),\n          .esApply)\n\nsetMethod(\"makeDataPackage\",\n          signature(object=\"ExpressionSet\"),\n          function(object, author, email,\n                   packageName, packageVersion, license, biocViews, filePath,\n                   description=paste(abstract(object), collapse=\"\\n\\n\"), ...) {\n              if( missing(email) || !(is.character(email) && (length(email) == 1)\n                                      && grep(\"@\", email) == 1 ) )\n                stop(\"invalid email address\")\n\n              sym = list(\n                AUTHOR = author,\n                VERSION=as.character(package_version(packageVersion)),\n                LICENSE=license,\n                TITLE = paste(\"Experimental Data Package:\",packageName),\n                MAINTAINER = paste0(author, \", <\", email, \">\"),\n                BVIEWS = biocViews,\n                DESCRIPTION = description,\n                FORMAT = pD2Rd(phenoData(object)))\n\n              res = createPackage(packageName, destinationDir=filePath,\n                originDir = system.file(\"ExpressionSet\", package=\"Biobase\"),\n                symbolValues = sym, unlink=TRUE)\n\n              ##save the data file\n              datadir = file.path(res$pkgdir, \"data\")\n              dir.create(datadir, showWarnings=FALSE)\n              outfile = file.path(datadir, paste0(packageName, \".rda\"))\n              assign(packageName, object)\n              save(list=packageName, file = outfile)\n\n              return(res)\n          })\n\nsetMethod(\"write.exprs\",\n          signature(x=\"ExpressionSet\"),\n          function(x, file=\"tmp.txt\", quote=FALSE,\n                   sep=\"\\t\", col.names=NA, ...){\n            write.table(exprs(x), file=file, quote=quote, sep=sep,\n                        col.names=col.names, ...)\n          })\n\nreadExpressionSet <- function(exprsFile,\n                              phenoDataFile,\n                              experimentDataFile,\n                              notesFile,\n                              path,\n                              annotation,\n                              ## arguments to read.* methods \n                              exprsArgs=list(sep=sep, header=header, row.names=row.names, quote=quote, ...),\n                              phenoDataArgs=list(sep=sep, header=header, row.names=row.names, quote=quote, stringsAsFactors=stringsAsFactors, ...),\n                              experimentDataArgs=list(sep=sep, header=header, row.names=row.names, quote=quote, stringsAsFactors=stringsAsFactors, ...),\n                              sep = \"\\t\", header = TRUE, quote = \"\", stringsAsFactors = FALSE, row.names = 1L,\n                              ## widget\n                              widget = getOption(\"BioC\")$Base$use.widgets,\n                              ...) {\n    if (!missing(widget) && widget != FALSE)\n        stop(\"sorry, widgets not yet available\")\n\n    ## exprs\n    if (missing(exprsFile))\n        stop(\"exprs can not be missing!\")\n    exprsArgs$file=exprsFile\n    ex = as.matrix(do.call(read.table, exprsArgs))\n\n    ## phenoData\n    if (!missing(phenoDataFile)) {\n        phenoDataArgs$file=phenoDataFile\n        pd = do.call(read.AnnotatedDataFrame, phenoDataArgs)\n        if (!identical(sampleNames(pd), colnames(ex)))\n            stop(\"Column names of expression matrix must be identical to\\n\",\n                 \"the sample names of the phenodata table.\\n\",\n                 \"You could use 'options(error=recover)' to compare the\",\n                 \"values of 'sampleNames(pd)' and 'colnames(ex)'.\\n\")\n    } else {\n        pd = annotatedDataFrameFrom(ex, byrow=FALSE)\n    }\n\n    obj = ExpressionSet(ex, phenoData=pd)\n\n\n    ## FIXME: these should probably added to obj before, or simultaneously to, exprs;\n    ##   as is this can provoke a lot of copying\n    ## experimentData\n    if (!missing(experimentDataFile))\n        experimentDataArgs$file=experimentDataFile\n    if (!is.null(experimentDataArgs$file))\n        experimentData(obj) <- do.call(read.MIAME, experimentDataArgs)\n    ## annotation\n    if (!missing(annotation))\n        annotation(obj) <- annotation\n    ## notes\n    if (!missing(notesFile))\n        notes(obj) <- readLines(notesFile)\n\n    validObject(obj)\n    obj\n}\n\nsetMethod(ExpressionSet, \"missing\",\n    function(assayData,\n             phenoData=AnnotatedDataFrame(),\n             featureData=AnnotatedDataFrame(),\n             experimentData=MIAME(), annotation=character(),\n             protocolData=AnnotatedDataFrame(),\n             ...)\n{\n    .ExpressionSet(\n        assayData=assayDataNew(exprs=new(\"matrix\")),\n        phenoData=phenoData,\n        featureData=featureData, experimentData=experimentData,\n        annotation=annotation, protocolData=protocolData, ...)\n})\n\nsetMethod(ExpressionSet, \"environment\",\n    function(assayData,\n             phenoData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n             featureData=annotatedDataFrameFrom(assayData, byrow=TRUE),\n             experimentData=MIAME(), annotation=character(),\n             protocolData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n             ...)\n{\n    .ExpressionSet(assayData=assayData, phenoData=phenoData,\n        featureData=featureData, experimentData=experimentData,\n        annotation=annotation, protocolData=protocolData, ...)\n})\n\n\nsetMethod(ExpressionSet, \"matrix\",\n    function(assayData,\n             phenoData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n             featureData=annotatedDataFrameFrom(assayData, byrow=TRUE),\n             experimentData=MIAME(), annotation=character(),\n             protocolData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n             ...)\n{\n    assayData <- assayDataNew(exprs=assayData)\n    .ExpressionSet(assayData=assayData, phenoData=phenoData,\n        featureData=featureData, experimentData=experimentData,\n        annotation=annotation, protocolData=protocolData, ...)\n})\n\n.DollarNames.ExpressionSet <- .DollarNames.eSet\n",
        "methods-MIAME.R": "setMethod(\"isCurrent\", signature(object=\"MIAME\", value=\"missing\"),\n          function(object, value) {\n              cver <- callNextMethod()\n              MIAMEres <- all(c(cver, \"pubMedIds\" %in% names(getObjectSlots(object))))\n              if(\"MIAxE\" %in% names(cver)) {\n                  res <- c(cver[\"MIAxE\"], MIAMEres) \n                  names(res) <- c(\"MIAxE\", \"MIAME\")\n              } else {res <- MIAMEres; names(res) <- \"MIAME\"}\n              res\n      })\n\nsetMethod(\"updateObject\", signature(object=\"MIAME\"),\n          function(object, ..., verbose=FALSE) {\n              if (verbose) message(\"updateObject(object = 'MIAME')\")\n              object <- asS4(object)\n              if (isVersioned(object) && isCurrent(object)[\"MIAME\"])\n                callNextMethod()\n              else\n                object <- updateObjectFromSlots(object, ..., verbose=verbose)\n                classVersion(object) <- classVersion(class(object))\n                object\n          })\n\n# ==========================================================================\nsetMethod(\"show\", \"MIAME\",\n   function(object) {\n      tmp <- c(\"samples\",\"hybridizations\",\"normalization controls\",\"preprocessing\")\n      Index <-c(length(object@samples) > 0,\n                length(object@hybridizations) > 0,\n                length(object@normControls) > 0,\n                length(object@preprocessing) > 0)\n      cat(\"Experiment data\\n\")\n      cat(\"  Experimenter name:\",object@name,\"\\n\")\n      cat(\"  Laboratory:\",object@lab,\"\\n\")\n      cat(\"  Contact information:\",object@contact,\"\\n\")\n      cat(\"  Title:\",object@title,\"\\n\")\n      cat(\"  URL:\",object@url,\"\\n\")\n# deal with legacy MIAME objects!\n      pmids = try( pubMedIds(object), silent=TRUE )\n      if (!inherits(pmids, \"try-error\")) cat(\"  PMIDs:\",pmids,\"\\n\")\n# end of dealing!\n      if(length(object@abstract) > 0 && all(object@abstract!=\"\"))\n         cat(\"\\n  Abstract: A\",length(strsplit(object@abstract,\" \")[[1]]),\n             \"word abstract is available. Use 'abstract' method.\\n\")\n      else\n         cat(\"  No abstract available.\\n\")\n      if(any(Index))\n         cat(\"  Information is available on:\", paste(tmp[Index],collapse=\", \"),\"\\n\")\n      nO = notes(object)\n      if (length(nO) > 0) {\n        cat(\"  notes:\\n\" )\n        if( is.list(nO) ) {\n           nms = names(nO)\n           ##a print width for the values, so we stay inside the margins\n           pw = options(\"width\")[[1]] - 6\n           for(i in 1:length(nO) ) {\n              cat(\"   \", nms[i], \":\", sep=\"\")\n              cat(\"     \", strbreak(nO[[i]], width=pw, exdent=0), sep=\"\\n      \")\n           }\n        }\n      }\n}\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"abstract\",\"MIAME\",function(object) object@abstract)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"samples\",\"MIAME\",function(object) object@samples)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"hybridizations\",\"MIAME\",function(object) object@hybridizations)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"normControls\",\"MIAME\",function(object) object@normControls)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"preproc\",\"MIAME\",function(object) object@preprocessing)\nsetReplaceMethod(\"preproc\", \"MIAME\", function(object, value) {\n    object@preprocessing <- value\n    object\n})\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"pubMedIds\",\"MIAME\",function(object) object@pubMedIds)\n\nsetReplaceMethod(\"pubMedIds\",\"MIAME\",function(object,value){\n   object@pubMedIds = value\n   object\n})\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"otherInfo\",\"MIAME\",function(object) object@other)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"expinfo\",\"MIAME\",\n   function(object) {\n      tmp <- c(object@name, object@lab, object@contact, object@title, object@url)\n    names(tmp) <- c(\"name\",\"lab\",\"contact\",\"title\",\"url\")\n    return(tmp)\n   }\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"notes\", signature(object=\"MIAME\"),\n          function(object) object@other)\n\nsetReplaceMethod(\"notes\", signature(object=\"MIAME\", value=\"list\"),\n                 function(object, value) {\n                     object@other <- value\n                     object\n                 })\n\nsetReplaceMethod(\"notes\", signature(object=\"MIAME\", value=\"character\"),\n                 function(object, value) {\n                     object@other <- append(object@other, value)\n                     object\n                 })\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMIAME <- \n    function(name = \"\", lab = \"\", contact = \"\",\n             title = \"\", abstract = \"\", url = \"\",\n             pubMedIds = \"\", samples = list(),\n             hybridizations = list(), normControls = list(),\n             preprocessing = list(), other = list()) {\n        .MIAME(name=name, lab=lab, contact=contact, title=title,\n               abstract=abstract, url=url, pubMedIds=pubMedIds,\n               samples=samples, hybridizations=hybridizations,\n               normControls=normControls, preprocessing=preprocessing,\n               other=other)\n    }\n\n\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nread.MIAME <- function(filename=NULL,widget=getOption(\"BioC\")$Base$use.widgets,...) {\n   if(!is.null(filename)) {\n      miame <- scan(filename,what=\"c\",quiet=TRUE,sep=\"\\n\",...)\n      MIAME(name=miame[1], lab=miame[2], contact=miame[3],\n            title=miame[4], abstract=miame[5], url=miame[6])\n   }\n   else\n      if(widget) {\n         requireNamespace(\"tkWidgets\", quietly=TRUE) ||\n             stop(\"Requires tkWidgets\")\n         tmp <- tkWidgets::tkMIAME()\n         MIAME(name=tmp$ExperimentName, lab=tmp$LabName,\n               contact=tmp$ContactInfo, title=tmp$ExperimentTitle,\n               abstract=tmp$Description, url=tmp$URL)\n      }\n      else\n         MIAME()\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"combine\", c(\"MIAME\", \"MIAME\"), function(x, y, ...) {\n  if (identical(x,y)) return (x)\n  for (sl in names(getSlots(class(x)))) {\n    if (identical(slot(x,sl),slot(y,sl)))\n      next\n    slot(x,sl) <- \n      switch(sl,\n             ## multiple elements possible\n             name=,\n             lab=,\n             contact=,\n             title=,\n             url=,\n             pubMedIds=,\n             samples=,\n             hybridizations=,\n             normControls=,\n             preprocessing=,\n             other=\n             {\n               c(slot(x,sl),slot(y,sl))\n             },\n             ## just a single entry\n             abstract= {\n               paste(slot(x,sl), slot(y,sl), collapse=\"\\n\")\n             },\n             .__classVersion__= {\n                 stop(\"'MIAME' objects have different class version strings\")\n             },\n             ## unknown\n             {\n                 warning(\"\\n  unknown or conflicting information in MIAME field '\", sl,\"'; using information from object 'x'\")\n                 slot(x,sl)\n             })\n\n  }\n  x\n})\n",
        "methods-MIAxE.R": "# ==================================\n# MIAxE Class Methods \n# ----------------------------------\nsetMethod(\"show\",\n          signature=signature(object=\"MIAxE\"),\n          function(object) {\n              cat(class( object ), \"\\n\", sep=\"\")\n          })\n\n",
        "methods-MultiSet.R": "setMethod(\"initialize\",\n          signature(.Object=\"MultiSet\"),\n          function(.Object, ...) callNextMethod())\n",
        "methods-NChannelSet.R": "NChannelSet <- .NChannelSet\n\n.init_NChannelSet <-              # copy constructor, validation\n    selectMethod(initialize, \"ANY\")\n\nsetMethod(\"initialize\", \"NChannelSet\",\n    function(.Object, assayData, phenoData, ...)\n{\n    mySlots <- slotNames(.Object)\n    dotArgs <- list(...)\n    isSlot <- names(dotArgs) %in% mySlots\n    if (missing(assayData)) {\n        assayData <- do.call(assayDataNew, dotArgs[!isSlot],\n                             envir=parent.frame())\n    }\n    if (missing(phenoData)) {\n        phenoData <- annotatedDataFrameFrom(assayData, byrow=FALSE)\n    }\n    if (is.null(varMetadata(phenoData)[[\"channel\"]])) {\n        varMetadata(phenoData)[[\"channel\"]] <- \n            factor(rep(\"_ALL_\", nrow(varMetadata(phenoData))),\n                   levels=c(assayDataElementNames(assayData), \"_ALL_\"))\n    }\n    ## ensure sample names OK -- all assayData with names;\n    ## phenoData with correct names from assayData\n    nms <- if (storageMode(assayData) == \"list\")\n        names(assayData)\n    else\n        ls(assayData)\n    assaySampleNames <- vector(\"list\", length(nms))\n    names(assaySampleNames) <- nms\n    for (nm in nms) {\n        cnames <- colnames(assayData[[nm]])\n        assaySampleNames[[nm]] <- if (is.null(cnames)) {\n            sampleNames(phenoData)\n        } else cnames\n    }\n\n    sampleNames(assayData) <- assaySampleNames\n    sampleNames(phenoData) <- sampleNames(assayData)\n    do.call(callNextMethod,\n            c(.Object,\n              assayData = assayData, phenoData = phenoData,\n              dotArgs[isSlot]))\n})\n\n.invalid_NChannelAssayNames <- function(object)\n{\n    phenoChannels <- levels(varMetadata(object)[[\"channel\"]])\n    assayChannels <- c(\"_ALL_\", assayDataElementNames(object))\n    setdiff(union(assayChannels, phenoChannels),\n            intersect(assayChannels, phenoChannels))\n}\n\nsetValidity(\"NChannelSet\",\n    function(object) \n{\n    msg <- validMsg(NULL, isValidVersion(object, \"NChannelSet\"))\n    if (!\"channel\" %in% names(varMetadata(object))) {\n        txt <- \"\\n  'NChannelSet' varMetadata must have a 'channel' column\"\n        msg <- validMsg(msg, txt)\n    } else {\n        channel <-\n            varMetadata(object)[[\"channel\"]]\n        if (!is(channel, \"factor\")) {\n            txt <- paste(\"\\n  'NChannelSet' varMetadata column 'channel'\",\n                         \"must be class 'factor'\")\n            msg <- validMsg(msg, txt)\n        } else if (0 < length(levels(channel))) {\n            if (length(.invalid_NChannelAssayNames(object))) {\n                txt <- 'NChannelSet levels(varMetadata(object)$channel) /\n                        assayDataElementNames() mismatch; see\n                        ?\"channelNames<-,NChannelSet,character-method\"'\n                txt <- paste(strwrap(c(\"\\n\", txt), exdent=2), collapse=\"\\n  \")\n                msg <- validMsg(msg, txt)\n            }\n        }\n        if (!(\"_ALL_\" %in% levels(channel))) {\n            txt <- paste(\"\\n  'NChannelSet' varMetadata 'channel'\",\n                         \"requires '_ALL_' as a level\")\n            msg <- validMsg(msg, txt)\n        }\n    }\n    if (is.null(msg)) TRUE else msg\n})\n\n.assayDataGets_NChannelSet <-\n    function(object, value)\n{\n    phenoData <- phenoData(object)\n    ## update channel names, making some attempt to preserve order\n    from <- channelNames(object)\n    to <- assayDataElementNames(value)\n    lvls <- c(from[from %in% to], to[!to %in% from], \"_ALL_\")\n    varMetadata(phenoData)$channel <- \n        factor(as.character(varMetadata(phenoData)$channel), levels=lvls)\n\n    .init_NChannelSet(object, assayData=value, phenoData=phenoData)\n}\n\nsetReplaceMethod(\"assayData\", c(\"NChannelSet\", \"environment\"),\n    .assayDataGets_NChannelSet)\n\nsetReplaceMethod(\"assayData\", c(\"NChannelSet\", \"list\"),\n    .assayDataGets_NChannelSet)\n\nsetMethod(\"channelNames\", \"NChannelSet\", function(object, ...) {\n    nms <- assayDataElementNames(object)\n    lvls <- levels(varMetadata(object)$channel)\n    if (all(nms %in% lvls))\n        ## FIXME: this accomodates invalid (previous) NChannelSet instances\n        ## order to match channelNames\n        nms <- lvls[lvls %in% nms]\n    nms\n})\n\nsetGeneric(\"channelNames<-\",\n    function(object, ..., value) standardGeneric(\"channelNames<-\"))\n\nsetReplaceMethod(\"channelNames\", c(\"NChannelSet\", \"character\"),\n    function(object, ..., value)\n{\n    if (!is.null(names(value))) {\n        ## re-name & re-order\n        channelNames(object) <- as.list(value)\n    } else {\n        ## re-order\n        if (!all(sort(value) == sort(channelNames(object))))\n            stop(\"'value' elements must include all channelNames()\")\n        varMetadata(object)$channel <-\n            factor(varMetadata(object)$channel, levels=c(value, \"_ALL_\"))\n        validObject(object)\n    }\n    object\n})\n\nsetReplaceMethod(\"channelNames\", c(\"NChannelSet\", \"list\"),\n    function(object, ..., value)\n{\n    from <- unlist(value, use.names=FALSE)\n    if (!all(sort(from) == sort(channelNames(object))))\n       stop(\"'value' elements must include all channelNames()\")\n    to <- names(value)\n    if (any(duplicated(to)))\n        stop(\"duplicated channelNames are not allowed\")\n\n    assayData <- assayData(object)\n    levels(varMetadata(object)$channel) <- c(value, list(\"_ALL_\" = \"_ALL\"))\n    if (is.list(assayData)) {\n        idx <- match(from, names(assayData))\n        names(assayData)[idx] <- to\n    } else {\n        env <- new.env(parent=emptyenv())\n        for (i in seq_along(value))\n            env[[ to[i] ]] = assayData[[ from[i] ]]\n        if (storageMode(object) == \"lockedEnvironment\")\n            assayDataEnvLock(env)\n        assayData <- env\n    }\n    assayData(object) <- assayData\n    object\n})\n\nsetMethod(\"channel\",\n          signature = signature(\n            object = \"NChannelSet\",\n            name = \"character\"),\n          function(object, name, ...) {\n              if (length(name) != 1)\n                  stop(\"\\n  'NChannelSet' channel 'name' must be one element\",\n                       \"\\n    was: '\", paste0(name, collapse=\"', '\"), \"'\")\n              obj <- selectChannels(object, name) # subset phenoData appropriately\n              sampleNames(phenoData(obj)) <- sampleNames(assayData(obj))\n              ExpressionSet(assayData(obj)[[name]],\n                  phenoData = phenoData(obj),\n                  featureData = featureData(obj),\n                  experimentData = experimentData(obj),\n                  annotation=annotation(obj),\n                  protocolData=protocolData(obj),\n                  ...)\n          })\n\nsetMethod(\"selectChannels\",\n          signature = signature(\n            object = \"NChannelSet\",\n            names=\"character\"),\n          function(object, names, ...) {\n              if (any(duplicated(names)))\n                stop(\"NChannelSet' channels 'names' must be unique\")\n              channelNames <- channelNames(object)\n              badNames <- !names %in% channelNames\n              if (any(badNames))\n                stop(\"NChannelSet' channels 'names' must be channels\")\n              dropChannels <- channelNames[!channelNames %in% names]\n              if (0 == length(dropChannels))\n                return(object)\n              ## assayData\n              assayData <-\n                assayDataSubsetElements(assayData(object), names)\n              ## phenoData -- drop unneeded info\n              metadata <- varMetadata(object)[[\"channel\"]]\n              okMetadata <- !metadata %in% dropChannels\n              phenoData <- phenoData(object)[,okMetadata]\n              ## reduce factor levels\n              varMetadata(phenoData)[[\"channel\"]] <-\n                factor(metadata[okMetadata], levels=unique(c(names, \"_ALL_\")))\n              initialize(object,\n                         assayData = assayData,\n                         phenoData = phenoData,\n                         featureData = featureData(object),\n                         experimentData=experimentData(object),\n                         annotation=annotation(object),\n                         protocolData=protocolData(object),\n                         ...)\n          })\n\nsetMethod(\"sampleNames\",\n          signature=signature(object=\"NChannelSet\"),\n          function(object) {\n              assayData <- assayData(object)\n              nms <- if (storageMode(object) == \"list\")\n                  names(assayData)\n              else\n                  ls(assayData)\n              res <- vector(\"list\", length(nms))\n              names(res) <- nms\n              for (nm in nms)\n                  res[[nm]] <- colnames(assayData[[nm]])\n              ident <- sapply(res[-1], function(elt, ref) all(elt==ref),\n                              res[[1]])\n              if (all(ident)) res[[1]]\n              else res\n          })\n\nsetReplaceMethod(\"sampleNames\", c(\"NChannelSet\", \"list\"),\n    function(object, value)\n{\n    assayData <- assayData(object)\n    sampleNames(assayData) <- value\n    phenoData <- phenoData(object)\n    sampleNames(phenoData) <- sampleNames(assayData)\n    protocolData <- protocolData(object)\n    sampleNames(protocolData) <- sampleNames(assayData)\n\n    .init_NChannelSet(object, assayData=assayData,\n                      phenoData=phenoData, protocolData=protocolData)\n})\n",
        "methods-ScalarObject.R": "mkScalar <- function(obj) {\n    switch(typeof(obj),\n           character=.ScalarCharacter(obj),\n           logical=.ScalarLogical(obj),\n           integer=.ScalarInteger(obj),\n           double=.ScalarNumeric(obj),\n           stop(\"no scalar class implemented for type: \", typeof(obj)))\n}\n\nsetMethod(\"show\", \"ScalarObject\",\n          function(object) {\n              cat(object, \"\\n\")\n          })\n\nsetMethod(\"show\", \"ScalarCharacter\",\n          function(object) {\n              if (is.na(object))\n                  cat(NA, \"\\n\")\n              else\n                  cat(sprintf('\"%s\"\\n', object))\n          })\n",
        "methods-SnpSet.R": "setMethod(\"initialize\", \"SnpSet\",\n          function(.Object,\n                   assayData = assayDataNew(call = call,\n                                            callProbability = callProbability, ...),\n                   phenoData = annotatedDataFrameFrom(assayData, byrow=FALSE),\n                   featureData = annotatedDataFrameFrom(assayData, byrow=TRUE),\n                   experimentData = MIAME(),\n                   annotation = character(),\n                   protocolData = phenoData[,integer(0)],\n                   call = new(\"matrix\"),\n                   callProbability = matrix(numeric(),\n                                            nrow=nrow(call), ncol=ncol(call),\n                                            dimnames=dimnames(call)),\n                   ...) {\n            callNextMethod(.Object,\n                           assayData = assayData,\n                           phenoData = phenoData,\n                           featureData = featureData,\n                           experimentData = experimentData,\n                           annotation = annotation,\n                           protocolData = protocolData)\n          })\n\nsetValidity(\"SnpSet\", function(object) {\n  assayDataValidMembers(assayData(object), c(\"call\", \"callProbability\"))\n})\n\nsetMethod(\"exprs\", c(\"SnpSet\"), function(object) assayDataElement(object, \"call\"))\n\nsetReplaceMethod(\"exprs\", c(\"SnpSet\", \"matrix\"), function(object, value) {\n  assayDataElementReplace(object, \"call\", value)\n})\n\nsetMethod(snpCall, \"SnpSet\", function(object, ...) {\n    assayDataElement(object, \"call\")\n})\n\nsetMethod(snpCallProbability, \"SnpSet\", function(object, ...) {\n    assayDataElement(object, \"callProbability\")\n})\n\nsetReplaceMethod(\"snpCall\", c(\"SnpSet\", \"matrix\"),\n                 function(object, ..., value)\n{\n    assayDataElementReplace(object, \"call\", value)\n})\n\nsetReplaceMethod(\"snpCallProbability\", c(\"SnpSet\", \"matrix\"),\n                 function(object, ..., value)\n{\n    assayDataElementReplace(object, \"callProbability\", value)\n})\n",
        "methods-VersionedClass.R": "## ==========================================================================\n## Versioned: mix-in class to add version information\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n## initialize -- see VersionedClasses\n\nsetMethod(\"initialize\", signature(.Object=\"Versioned\"),\n          function(.Object, versions = list(), ...) {\n              .Object <- callNextMethod(.Object, ...)\n              classVersion(.Object)[names(versions)] <- versions\n              .Object\n          })\n\n## validity\n\nsetValidity(\"Versioned\", function(object) {\n    msg <- NULL\n    if (!isVersioned(object))\n      msg <- validMsg(msg, \"missing version string\")\n    if (is.null(msg)) TRUE else msg\n})\n\nisValidVersion <- function(object, nm) {# utility\n    msg <- NULL\n    if (!isS4(object))\n      msg <- validMsg(msg, \"not an S4 object\")\n    if (isVersioned(object) && !all(isCurrent(object)[nm])) {\n        vers <- isCurrent(object)[nm]\n        vers[is.na(vers)] <- FALSE\n        names(vers) <- nm\n        bad <- names(vers[vers==FALSE])\n        msg <- validMsg(msg, paste0(\"out-of-date class version '\", bad, \"'\"))\n    }\n    msg\n}\n\n##  isVersioned\n\nsetMethod(\"isVersioned\", signature(object=\"ANY\"),\n          function(object) FALSE)\n\nsetMethod(\"isVersioned\", signature(object=\"character\"),\n          function(object) {\n              ## need to check getNamespace(\"Biobase\") during Biobase installation\n              length(object) > 0 && nchar(object)>0 &&\n              (isClass(object) ||\n               isClass(object, where=getNamespace(\"Biobase\"))) &&\n              extends(getClass(object), \"Versioned\")\n      })\n\nsetMethod(\"isVersioned\", signature(object=\"Versioned\"),\n          function(object) \".__classVersion__\" %in% names(attributes(object)))\n\n## classVersion\n\nsetMethod(\"classVersion\", signature(object=\"ANY\"),\n          function(object) .VersionsNull())\n\nsetMethod(\"classVersion\", signature(object=\"character\"),\n          function(object) {\n              if (isVersioned(object))\n                attr(getClass(object)@prototype, \".__classVersion__\")\n              else callNextMethod()\n          })\n\nsetMethod(\"classVersion\", signature(object=\"Versioned\"),\n          function(object) {\n              if (isVersioned(object)) {\n                  if (isS4(object@.__classVersion__))\n                      object@.__classVersion__\n                  else\n                      ## force update to S4 instance\n                      ## user needs to recognize need for update\n                      updateObject(object@.__classVersion__)\n              }\n              else callNextMethod()\n          })\n\nsetReplaceMethod(\"classVersion\", signature(object=\"Versioned\", value=\"Versions\"),\n                 function(object, value) {\n                     object@.__classVersion__ <- value\n                     object\n                 })\n## isCurrent\n\nsetMethod(\"isCurrent\", signature(object=\"ANY\"), function(object, value) NA)\n\nsetMethod(\"isCurrent\", signature(object=\"Versioned\", value=\"missing\"),\n          function(object, value) isCurrent(object, class(object)))\n\nsetMethod(\"isCurrent\", signature(object=\"Versioned\", value=\"character\"),\n          function(object, value) {\n             # vers <- classVersion(value)\n             # if(!all(names(vers) %in% names(classVersion(object)))) {\n             #     res <- FALSE\n             #     names(res) <- value \n             #     return(res)\n             # }\n              vers <- classVersion(value)\n              if (extends(class(object),value) && \n                          isVersioned(object) &&\n                          all(names(vers) %in% names(classVersion(object)))) {\n                  res <- classVersion(object)[names(vers)] == vers\n                  names(res) <- names(vers)\n              } else {\n                  res <- FALSE\n                  names(res) <- value\n              }\n              res <- c(S4=isS4(object), res)\n              res\n          })\n\n## show\n\nsetMethod(\"show\", signature(object=\"Versioned\"),\n          function(object) callNextMethod())\n",
        "methods-VersionsNull.R": "## Unversioned\n##\n\nsetMethod(\"initialize\", signature(.Object=\"VersionsNull\"),\n          function(.Object, ...) {\n              if (!missing(...))\n                warning(\"ignoring arguments to '.VersionsNull()')\")\n              .Object\n          })\n\nsetMethod(\"show\", signature(object=\"VersionsNull\"),\n          function(object) print(\"No version\"))\n",
        "methods-aggregator.R": "setMethod(\"initialize\",\n          signature(.Object=\"aggregator\"),\n          function(.Object, aggenv=new.env(hash=TRUE), ...) {\n              callNextMethod(.Object, aggenv=aggenv, ...)\n          })\n# ==========================================================================\nsetMethod(\"aggenv\", \"aggregator\", function(object) object@aggenv)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"initfun\", \"aggregator\", function(object) object@initfun)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"aggfun\", \"aggregator\", function(object) object@aggfun)\n# ==========================================================================\nAggregate <- function(x, agg) {\n   if( !is(agg, \"aggregator\") )\n      stop(\"second argument must be an aggregator\")\n   if( is.null(x) || length(x) == 0 )\n      return()\n   if(is.character(x)) {\n      for( i in 1:length(x) ) {\n         nm <- x[i]\n         if( !exists(nm, envir=aggenv(agg), inherits=FALSE) )\n            assign(nm, envir=aggenv(agg), initfun(agg)(nm, x))\n         else {\n            v1 <- get(nm, envir=aggenv(agg))\n            assign(nm, aggfun(agg)(nm, v1), envir=aggenv(agg))\n         }\n      }\n   }\n   else\n      if(is.list(x)) {\n         nms <- names(x)\n         for( i in 1:length(x) ) {\n            nm <- nms[i]\n            if( !exists(nm, envir=aggenv(agg), inherits=FALSE) )\n               assign(nm, envir=aggenv(agg), initfun(agg)(nm, x[[i]]))\n            else {\n               v1 <- get(nm, envir=aggenv(agg))\n               assign(nm, envir=aggenv(agg), aggfun(agg)(nm, v1, x[[i]]))\n            }\n         }\n      }\n      else\n         stop(\"bad type for Aggregate\")\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n",
        "methods-container.R": "# ==========================================================================\nsetMethod(\"content\", \"container\", function(object) object@content)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"locked\", \"container\", function(object) object@locked)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"[\", \"container\",\n   function(x, i, j, ..., drop = FALSE) {\n      .container(content = content(x), x = x@x[i], locked = locked(x))\n   }\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"[[\", \"container\",\n   function(x, i, j, ...) {\n      x@x[[i]]\n   }\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetReplaceMethod(\"[[\", \"container\",\n   function(x, i, j,..., value) {\n      if( locked(x) )\n         stop(\"cannot assign into a locked container\")\n      cv <- class(value)\n      cont <- content(x)\n      if( !extends(cv, cont) )\n         stop(\"the container is class '\", cont,\n              \"' the object is class '\", cv, \"' cannot assign\")\n      x@x[[i]] <- value\n      x\n   }\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"length\", \"container\", function(x) length(x@x))\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"show\", \"container\",\n   function(object) {\n      cat(\"Container of \", content(object), \"\\n\", sep=\"\")\n      print(object@x)\n   }\n)\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n",
        "methods-eSet.R": "# ==========================================================================\n# eSet Class Validator\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"initialize\", signature(.Object=\"eSet\"),\n    function(.Object, assayData,\n        phenoData=annotatedDataFrameFrom(assayData, byrow=FALSE),\n        featureData=annotatedDataFrameFrom(assayData, byrow=TRUE),\n        experimentData=MIAME(), annotation=character(0),\n        protocolData=phenoData[,integer(0)], ...)\n{\n    ## NB: Arguments provided in '...' are used to initialize\n    ## slots if possible (when called from some subclass).\n    ## Otherwise, extra args in '...' are added as elements\n    ## to assayData.  We do this to allow subclasses to\n    ## rely on default contructor behavior for initializing\n    ## slots.\n    ##\n    ## NB2: Extra args to the assayData constructor will\n    ## be passed along as long as current class doesn't\n    ## have a slot with a matching name.\n    mySlots <- slotNames(.Object)\n    dotArgs <- list(...)\n    isSlot <- names(dotArgs) %in% mySlots\n    if (missing(assayData))\n        assayData <- do.call(assayDataNew, dotArgs[!isSlot], envir=parent.frame())\n    else {\n        checkClass(assayData, \"AssayData\", class(.Object))\n        nms <-\n            if (storageMode(assayData)==\"list\") names(assayData)\n            else ls(assayData)\n        dupNames <- nms %in% names(dotArgs[!isSlot])\n        if (any(dupNames))\n            warning(\"initialize argument(s) '\",\n                    paste(nms[dupNames], collapse=\"' '\"),\n                    \"' also present in 'assayData'; argument(s) ignored\")\n    }\n    if (!missing(phenoData))\n        checkClass(phenoData, \"AnnotatedDataFrame\", class(.Object))\n    dimLabels(phenoData) <- c(\"sampleNames\", \"sampleColumns\")\n    if (!missing(featureData))\n        checkClass(featureData, \"AnnotatedDataFrame\", class(.Object))\n    dimLabels(featureData) <- c(\"featureNames\", \"featureColumns\")\n    ## create the protocolData, if necessary\n    if (!missing(protocolData)) {\n        checkClass(protocolData, \"AnnotatedDataFrame\", class(.Object))\n        dimLabels(protocolData) <- c(\"sampleNames\", \"sampleColumns\")\n    }\n    ## coordinate sample names\n    adSampleNames <- sampleNames(assayData)\n    if (all(sapply(adSampleNames, is.null)))\n        sampleNames(assayData) <- sampleNames(phenoData)\n    pdSampleNames <- sampleNames(protocolData)\n    if (all(sapply(pdSampleNames, is.null)))\n        sampleNames(protocolData) <- sampleNames(phenoData)\n    ## where do feature names come from? assayData or featureData\n    adFeatureNames <- featureNames(assayData)\n    if (all(sapply(adFeatureNames, is.null)))\n        featureNames(assayData) <- featureNames(featureData)\n    ## create new instance from 'extra' dotArgs, and from instance\n    for (s in names(dotArgs)[isSlot])\n        slot(.Object, s) <- dotArgs[[s]]\n    callNextMethod(.Object, assayData=assayData, phenoData=phenoData,\n                   featureData=featureData, experimentData=experimentData,\n                   annotation=annotation, protocolData=protocolData)\n})\n\nupdateOldESet <- function(from, toClass, ...) {  # to MultiExpressionSet\n  from <- asS4(from)\n  ophenoData <- asS4(phenoData(from))\n  metadata <- ophenoData@varMetadata\n  if (all(dim(metadata)==0)) {\n    warning(\"replacing apparently empty varMetadata\")\n    metadata <- data.frame(numeric(ncol(ophenoData@pData)))[,FALSE]\n  }\n  if (!is.null(metadata[[\"varName\"]])) {\n    row.names(metadata) <- metadata[[\"varName\"]]\n    metadata[[\"varName\"]] <- NULL\n  } else if (!is.null(names(ophenoData@pData))) {\n    row.names(metadata) <- names(ophenoData@pData)\n  }\n  if (!is.null(metadata[[\"varLabels\"]])) {\n    names(metadata)[names(metadata)==\"varLabels\"] <- \"labelDescription\"\n    metadata[[\"labelDescription\"]] <- as.character(metadata[[\"labelDescription\"]])\n  }\n  ## phenoData\n  pData <- ophenoData@pData\n  phenoData <- AnnotatedDataFrame(data=pData, varMetadata=metadata)\n  ## sampleNames\n  if (any(sampleNames(assayData(from))!=sampleNames(phenoData))) {\n    warning(\"creating assayData colnames from phenoData sampleNames\")\n    sampleNames(assayData(from)) <- sampleNames(phenoData)\n  }\n  ## reporterNames\n  if (length(from@reporterNames) == dim(from)[[1]]) {\n      if (any(sapply(assayData(from),rownames)!=from@reporterNames))\n        warning(\"creating assayData featureNames from reporterNames\")\n      featureNames(assayData(from)) <- from@reporterNames\n  } else {\n      warning(\"creating numeric assayData featureNames\")\n      featureNames(assayData(from)) <- 1:dim(from)[[1]]\n  }\n  if (sum(dups <- duplicated(featureNames(assayData(from))))>0) {\n      warning(\"removing \", sum(dups), \" duplicated featureNames\")\n      from@assayData <- lapply(from@assayData, function(elt) elt[!dups,])\n  }\n  ## description\n  description <- from@description\n  if (is(description,\"MIAME\")) {\n    if (length(from@notes)!=0) {\n      warning(\"addding 'notes' to 'description'\")\n      description@other <- c(description@other,from@notes)\n    }\n    if (length(from@history)!=0) {\n      warning(\"adding 'history' to 'description'\")\n      description@other <- c(description@other,from@history)\n    }\n  } else {\n    warning(\"'description' is not of class MIAME; ignored\")\n    description <- NULL\n  }\n  ## reporterInfo\n  if (any(dim(from@reporterInfo)!=0))\n    warning(\"reporterInfo data not transfered to '\",toClass, \"' object\")\n  ## new object\n  object <- new(toClass,\n                assayData = from@assayData,\n                phenoData = phenoData,\n                featureData = annotatedDataFrameFrom(from@assayData, byrow=TRUE),\n                experimentData = updateObject(description),\n                annotation = from@annotation)\n  validObject(object)\n  object\n}\n\nsetAs(\"eSet\", \"ExpressionSet\", function(from, to) updateOldESet(from, \"ExpressionSet\"))\nsetAs(\"eSet\", \"MultiSet\", function(from, to) updateOldESet(from, \"MultiSet\"))\n\nupdateESetTo <- function(object, template, ..., verbose=FALSE) {\n    if (verbose) message(\"updateESetTo(object = 'eSet' template = '\", class(template), \"')\")\n    ## cannot instantiate a 'virtual' class, so use accessor functions\n    ## to update class components. Better than direct slot access?\n    funcs <- c(\"assayData\", \"phenoData\", \"experimentData\", \"annotation\")\n    eval(parse(text=paste(funcs,\"(template)<-\",\n                 \"updateObject(\", funcs, \"(object), ..., verbose=verbose)\")))\n    result <- try(featureData(template) <- featureData(object), silent=TRUE)\n    if (inherits(result, \"try-error\"))\n      featureData(template) <- annotatedDataFrameFrom(assayData(object), byrow=TRUE)\n    vers <- classVersion(\"eSet\")\n    classVersion(template)[names(vers)] <- vers # current class version, eSet & 'below' only\n    template\n}\n\nsetMethod(\"updateObject\", signature(object=\"eSet\"),\n          function(object, ..., verbose=FALSE) {\n              if (verbose) message(\"updateObject(object = 'eSet')\")\n              object <- asS4(object)\n              if (isVersioned(object) && isCurrent(object)[\"eSet\"])\n                return(callNextMethod())\n              ## storage.mode likely to be useful to update versioned classes, too\n              storage.mode.final <- storageMode(object)\n              storage.mode <-\n                if (storage.mode.final == \"lockedEnvironment\") \"environment\"\n                else storage.mode.final\n              additionalSlots <- setdiff(slotNames(class(object)), slotNames(\"eSet\"))\n              names(additionalSlots) <- additionalSlots\n              if (!isVersioned(object)) {\n                object <- updateESetTo(object, new(class(object), storage.mode=storage.mode), ..., verbose=verbose)\n                storageMode(object) <- storage.mode.final\n              } else if (classVersion(object)[\"eSet\"]==\"1.0.0\") {\n                ## added featureData slot; need to update phenoData\n                object <-\n                  do.call(new,\n                          c(list(class(object),\n                                 assayData = updateObject(assayData(object), ..., verbose=verbose),\n                                 phenoData = AnnotatedDataFrame(data=pData(object),\n                                                 varMetadata=varMetadata(object)),\n                                 featureData = annotatedDataFrameFrom(assayData(object), byrow=TRUE),\n                                 experimentData = updateObject(experimentData(object), ..., verbose=verbose),\n                                 annotation = annotation(object)),\n                            lapply(additionalSlots, function(x) slot(object, x))))\n              } else if (classVersion(object)[\"eSet\"]==\"1.1.0\") {\n                ## added scanDates slot\n                object <-\n                  do.call(new,\n                          c(list(class(object),\n                                 assayData = updateObject(assayData(object)),\n                                 phenoData = updateObject(phenoData(object)),\n                                 featureData = updateObject(featureData(object)),\n                                 experimentData = updateObject(experimentData(object)),\n                                 annotation = annotation(object)),\n                            lapply(additionalSlots, function(x) slot(object, x))))\n              } else if (classVersion(object)[\"eSet\"]==\"1.2.0\") {\n                ## added protocolData slot, removed scanDates slot\n                scanDates <- object@scanDates\n                protocolData <- phenoData(object)[,integer(0)]\n                if (length(scanDates) > 0) {\n                  protocolData[[\"ScanDate\"]] <- scanDates\n                }\n                object <-\n                  do.call(new,\n                          c(list(class(object),\n                                 assayData = updateObject(assayData(object)),\n                                 phenoData = updateObject(phenoData(object)),\n                                 featureData = updateObject(featureData(object)),\n                                 experimentData = updateObject(experimentData(object)),\n                                 annotation = annotation(object),\n                                 protocolData = protocolData),\n                            lapply(additionalSlots,\n                                   function(x) updateObject(slot(object, x)))))\n              } else {\n                stop(\"cannot update object of class '\", class(object),\n                     \"', claiming to be eSet version '\",\n                     as(classVersion(object)[\"eSet\"], \"character\"), \"'\")\n              }\n              object\n          })\n\nsetMethod(\"updateObjectTo\", signature(object=\"eSet\", template=\"eSet\"), updateESetTo)\n\nsetValidity(\"eSet\", function(object) {\n    msg <- validMsg(NULL, isValidVersion(object, \"eSet\"))\n    dims <- dims(object)\n    if (ncol(dims) > 0) {\n        ## assayData\n        msg <- validMsg(msg, assayDataValidMembers(assayData(object)))\n        if (any(dims[1,] != dims[1,1]))\n          msg <- validMsg(msg, \"row numbers differ for assayData members\")\n        if (any(dims[2,] != dims[2,1]))\n          msg <- validMsg(msg, \"sample numbers differ for assayData members\")\n        ## featureData\n        if (dims[1,1] != dim( featureData(object))[[1]])\n          msg <- validMsg(msg, \"feature numbers differ between assayData and featureData\")\n        if (!identical(featureNames(assayData(object)), featureNames(featureData(object))))\n          msg <- validMsg(msg, \"featureNames differ between assayData and featureData\")\n        ## phenoData\n        if (dims[2,1] != dim(phenoData(object))[[1]])\n          msg <- validMsg(msg, \"sample numbers differ between assayData and phenoData\")\n        if (!identical(sampleNames(assayData(object)), sampleNames(phenoData(object))))\n          msg <- validMsg(msg, \"sampleNames differ between assayData and phenoData\")\n        ## protocolData\n        if (dim(phenoData(object))[[1]] != dim(protocolData(object))[[1]])\n          msg <- validMsg(msg, \"sample numbers differ between phenoData and protocolData\")\n        if (!identical(sampleNames(phenoData(object)), sampleNames(protocolData(object))))\n          msg <- validMsg(msg, \"sampleNames differ between phenoData and protocolData\")\n    }\n    if (is.null(msg)) TRUE else msg\n})\n\nsetMethod(\"preproc\", \"eSet\", function(object) preproc(experimentData(object)))\n\nsetReplaceMethod(\"preproc\",\n                 signature=signature(object=\"eSet\"),\n                 function(object, value) {\n                     ed <- experimentData(object)\n                     preproc(ed) <- value\n                     object@experimentData <- ed\n                     object\n                 })\n\nsetMethod(\"show\",\n          signature=signature(object=\"eSet\"),\n          function(object) {\n              cat(class(object), \" (storageMode: \",\n                  storageMode(object), \")\\n\", sep=\"\")\n              adim <- dim(object)\n              if (length(adim)>1)\n                  cat(\"assayData:\",\n                      if (length(adim)>1)\n                      paste(adim[[1]], \"features,\",\n                            adim[[2]], \"samples\") else NULL,\n                      \"\\n\")\n              cat(\"  element names:\",\n                  paste(assayDataElementNames(object), collapse=\", \"), \"\\n\")\n              .showAnnotatedDataFrame(protocolData(object),\n                                      labels=list(object=\"protocolData\"))\n              .showAnnotatedDataFrame(phenoData(object),\n                                      labels=list(object=\"phenoData\"))\n              .showAnnotatedDataFrame(featureData(object),\n                                      labels=list(\n                                        object=\"featureData\",\n                                        sampleNames=\"featureNames\",\n                                        varLabels=\"fvarLabels\",\n                                        varMetadata=\"fvarMetadata\"))\n              cat(\"experimentData: use 'experimentData(object)'\\n\")\n              pmids <- pubMedIds(object)\n              if (length(pmids) > 0 && all(pmids != \"\"))\n                  cat(\"  pubMedIds:\", paste(pmids, sep=\", \"), \"\\n\")\n              cat(\"Annotation:\", annotation(object), \"\\n\")\n          })\n\nsetMethod(\"storageMode\", \"eSet\", function(object) storageMode(assayData(object)))\n\nsetReplaceMethod(\"storageMode\",\n                 signature=signature(\n                   object=\"eSet\", value=\"character\"),\n                 function(object, value) {\n                     ad <- assayData(object)\n                     storageMode(ad) <- value\n                     object@assayData <- ad\n                     object\n                 })\n\nsetMethod(\"sampleNames\",\n          signature(object=\"eSet\"),\n          function(object) sampleNames(phenoData(object)))\n\nsetReplaceMethod(\"sampleNames\",\n                 signature=signature(object=\"eSet\", value=\"ANY\"),\n                 function(object, value) {\n                     pd <- phenoData(object)\n                     sampleNames(pd) <- value\n                     ad <- assayData(object)\n                     sampleNames(ad) <- value\n                     prd <- protocolData(object)\n                     if (nrow(prd) == 0) {\n                         prd <- pd[,integer(0)]\n                     } else {\n                         sampleNames(prd) <- value\n                     }\n                     object@phenoData <- pd\n                     object@protocolData <- prd\n                     unsafeSetSlot(object, \"assayData\", ad)\n                 })\n\nsetMethod(\"featureNames\",\n          signature=signature(object=\"eSet\"),\n          function(object) featureNames(assayData(object)))\n\nsetReplaceMethod(\"featureNames\",\n                 signature=signature(object=\"eSet\", value=\"ANY\"),\n                 function(object, value) {\n                     fd <- featureData(object)\n                     featureNames(fd) <- value\n                     ad <- assayData(object)\n                     featureNames(ad) <- value\n                     object@featureData <- fd\n                     unsafeSetSlot(object, \"assayData\", ad)\n                 })\n\nsetMethod(\"dimnames\", \"eSet\", function(x) {\n    list(featureNames(x), sampleNames(x))\n})\n\nsetReplaceMethod(\"dimnames\", \"eSet\", function(x, value) {\n    featureNames(x) <- value[[1]]\n    sampleNames(x) <- value[[2]]\n    x\n})\n\nsetMethod(\"dim\", \"eSet\", function(x) assayDataDim(assayData(x)))\n\nsetMethod(\"dims\", \"eSet\", function(x) assayDataDims(assayData(x)))\n\nsetMethod(\"[\", \"eSet\", function(x, i, j, ..., drop = FALSE) {\n  if (missing(drop))\n    drop <- FALSE\n  if (missing(i) && missing(j)) {\n      if (!missing(...))\n        stop(\"specify genes or samples to subset; use '\",\n             substitute(x), \"$\", names(list(...))[[1]],\n             \"' to access phenoData variables\")\n      return(x)\n  }\n  if (!isVersioned(x) || !isCurrent(x)[\"eSet\"])\n    x <- updateObject(x)\n  if (!missing(j)) {\n    phenoData(x) <- phenoData(x)[j,, ..., drop = drop]\n    protocolData(x) <- protocolData(x)[j,, ..., drop = drop]\n  }\n  if (!missing(i))\n    featureData(x) <- featureData(x)[i,,..., drop=drop]\n  ## assayData; implemented here to avoid function call\n  orig <- assayData(x)\n  storage.mode <- assayDataStorageMode(orig)\n  assayData(x) <-\n    switch(storage.mode,\n           environment =,\n           lockedEnvironment = {\n             aData <- new.env(parent=emptyenv())\n             if (missing(i))                     # j must be present\n               for(nm in ls(orig)) aData[[nm]] <- orig[[nm]][, j, ..., drop = drop]\n             else {                              # j may or may not be present\n               if (missing(j))\n                 for(nm in ls(orig)) aData[[nm]] <- orig[[nm]][i,, ..., drop = drop]\n               else\n                 for(nm in ls(orig)) aData[[nm]] <- orig[[nm]][i, j, ..., drop = drop]\n             }\n             if (\"lockedEnvironment\" == storage.mode) assayDataEnvLock(aData)\n             aData\n           },\n           list = {\n             if (missing(i))                     # j must be present\n               lapply(orig, function(obj) obj[, j, ..., drop = drop])\n             else {                              # j may or may not be present\n               if (missing(j))\n                 lapply(orig, function(obj) obj[i,, ..., drop = drop])\n               else\n                 lapply(orig, function(obj) obj[i, j, ..., drop = drop])\n             }\n           })\n  x\n})\n\n## $ stops dispatching ?!\n##setMethod(\"$\", \"eSet\", function(x, name) `$`(phenoData(x), name))\nsetMethod(\"$\", \"eSet\", function(x, name) {\n    eval(substitute(phenoData(x)$NAME_ARG, list(NAME_ARG=name)))\n})\n\n.DollarNames.eSet <- function(x, pattern = \"\")\n    grep(pattern, names(pData(x)), value=TRUE)\n\nsetReplaceMethod(\"$\", \"eSet\", function(x, name, value) {\n  phenoData(x)[[name]] = value\n  x\n})\n\nsetMethod(\"[[\", \"eSet\", function(x, i, j, ...) phenoData(x)[[i]])\n\nsetReplaceMethod(\"[[\", \"eSet\",\n                 function(x, i, j, ..., value) {\n                     phenoData(x)[[i, ...]] <- value\n                     x\n                 })\n\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nsetMethod(\"assayData\", \"eSet\", function(object) object@assayData)\n\nsetReplaceMethod(\"assayData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"AssayData\"),\n                 function(object, value) {\n                     object@assayData <- value\n                     object\n                 })\n\nassayDataElementNames <- function(object) {\n    if (storageMode(object) == \"list\") names(assayData(object))\n    else ls(assayData(object))\n}\n\nassayDataElement <- function(object, elt) assayData(object)[[elt]]\n\n.validate_assayDataElementReplace <- function(obj, value) {\n    if (!is.null(value)) {\n        dimvalue <- dim(value)\n        dimobj <- dim(obj)[seq_along(dimvalue)]\n        if (!isTRUE(all.equal(unname(dimvalue), unname(dimobj))))\n            stop(\"object and replacement value have different dimensions\")\n    }\n    \n    if (!is.null(value)) {\n        if (!is.null(dimnames(value))) {\n            ## validate and harmonize dimnames\n            vd <- Map(function(od, vd) {\n                if (is.null(vd))\n                    ## update vd to contain indexes into matrix\n                    od <- seq_along(od)\n                else if (!setequal(od, vd))\n                    stop(\"object and replacement value dimnames differ\")\n                od\n            }, dimnames(obj), dimnames(value))\n            ## re-arrange value to have dimnames in same order as obj\n            value <- do.call(`[`, c(list(value), vd, drop=FALSE))\n        }\n        dimnames(value) <- dimnames(obj)\n    }\n    value\n}\n\nassayDataElementReplace <- function(obj, elt, value, validate=TRUE) {\n    ## 'validate' added later, needs to be last for position matching\n    if (validate)\n        value <- .validate_assayDataElementReplace(obj, value)\n\n    storage.mode <- storageMode(obj)\n    switch(storageMode(obj),\n           \"lockedEnvironment\" = {\n               aData <- copyEnv(assayData(obj))\n               if (is.null(value)) rm(list=elt, envir=aData)\n               else aData[[elt]] <- value\n               assayDataEnvLock(aData)\n               assayData(obj) <- aData\n           },\n           \"environment\" = {\n               if (is.null(value)) rm(list=elt, envir=assayData(obj))\n               else assayData(obj)[[elt]] <- value\n           },\n           list = assayData(obj)[[elt]] <- value)\n    obj\n}\n\n`assayDataElement<-` <- function(obj, elt, ..., value)\n    ## 'value' is always the last argument, but needs to be 3rd for\n    ## assayDataElementReplace\n    assayDataElementReplace(obj, elt, value, ...)\n\nsetMethod(\"phenoData\", \"eSet\", function(object) object@phenoData)\n\nsetReplaceMethod(\"phenoData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"AnnotatedDataFrame\"),\n                 function(object, value) {\n                     object@phenoData <- value\n                     if (nrow(protocolData(object)) == 0) {\n                         protocolData(object) <- value[,integer(0)]\n                     }\n                     object\n                 })\n\nsetMethod(\"pData\", \"eSet\", function(object) pData(phenoData(object)))\n\nsetReplaceMethod(\"pData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"data.frame\"),\n                 function(object, value) {\n                     pd <- phenoData(object)\n                     pData(pd) <- value\n                     phenoData(object) <- pd\n                     object\n                 })\n\nsetMethod(\"varMetadata\",\n          signature=signature(object=\"eSet\"),\n          function(object) varMetadata(phenoData(object)))\n\nsetReplaceMethod(\"varMetadata\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"data.frame\"),\n                 function(object, value) {\n                     pd <- phenoData(object)\n                     varMetadata(pd) <- value\n                     object@phenoData <- pd\n                     object\n                 })\n\nsetMethod(\"varLabels\",\n          signature=signature(object=\"eSet\"),\n          function(object) varLabels(phenoData(object)))\n\nsetReplaceMethod(\"varLabels\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"ANY\"),\n                 function(object, value) {\n                     pd <- phenoData(object)\n                     varLabels(pd) <- value\n                     object@phenoData <- pd\n                     object\n                 })\n\nsetMethod(\"featureData\",\n          signature(object=\"eSet\"),\n          function(object) object@featureData)\n\nsetReplaceMethod(\"featureData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"AnnotatedDataFrame\"),\n                 function(object, value) {\n                     object@featureData <- value\n                     object\n                 })\n\nsetMethod(\"fData\",\n          signature=signature(object=\"eSet\"),\n          function(object) pData(featureData(object)))\n\nsetReplaceMethod(\"fData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"data.frame\"),\n                 function(object, value) {\n                     fd <- featureData(object)\n                     pData(fd) <- value\n                     object@featureData <- fd\n                     object\n                 })\n\nsetMethod(\"fvarMetadata\",\n          signature=signature(object=\"eSet\"),\n          function(object) varMetadata(featureData(object)))\n\nsetReplaceMethod(\"fvarMetadata\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"data.frame\"),\n                 function(object, value) {\n                     fd <- featureData(object)\n                     varMetadata(fd) <- value\n                     object@featureData <- fd\n                     object\n                 })\n\nsetMethod(\"fvarLabels\",\n          signature=signature(object=\"eSet\"),\n          function(object) varLabels(featureData(object)))\n\nsetReplaceMethod(\"fvarLabels\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"ANY\"),\n                 function(object, value) {\n                     pd <- featureData(object)\n                     varLabels(pd) <- value\n                     object@featureData <- pd\n                     object\n                 })\n\nsetMethod(\"experimentData\", signature(object=\"eSet\"), function(object) object@experimentData)\n\nsetReplaceMethod(\"experimentData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"MIAME\"),\n                 function(object, value) {\n                     object@experimentData <- value\n                     object\n                 })\n\nsetMethod(\"description\", signature(object=\"eSet\"),\n          function(object, ...) {\n              experimentData(object)\n          })\n\nsetReplaceMethod(\"description\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"MIAME\"),\n                 function(object, value) {\n                     object@experimentData <- value\n                     object\n                 })\n\nsetMethod(\"notes\", signature(object=\"eSet\"),\n          function(object) otherInfo(experimentData(object)))\n\nsetReplaceMethod(\"notes\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"ANY\"),\n                 function(object, value) {\n                     ed <- experimentData(object)\n                     notes(ed) <- value\n                     object@experimentData <- ed\n                     object\n                 })\n\nsetMethod(\"pubMedIds\", signature(object=\"eSet\"),\n          function(object) pubMedIds(experimentData(object)))\n\nsetReplaceMethod(\"pubMedIds\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"character\"),\n                 function(object, value) {\n                     ed <- experimentData(object)\n                     pubMedIds(ed) <- value\n                     object@experimentData <- ed\n                     object\n                 })\n\nsetMethod(\"abstract\", \"eSet\", function(object) abstract(experimentData(object)))\n\nsetMethod(\"annotation\", \"eSet\", definition = function(object) object@annotation)\n\nsetReplaceMethod(\"annotation\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"character\"),\n                 function(object, value) {\n                     object@annotation <- value\n                     object\n                 })\n\nsetMethod(\"protocolData\", \"eSet\",\n          function(object) {\n              tryCatch(object@protocolData,\n                       error = function(x) {\n                         phenoData(object)[,integer(0)]\n                       })\n          })\n\nsetReplaceMethod(\"protocolData\",\n                 signature=signature(\n                   object=\"eSet\",\n                   value=\"AnnotatedDataFrame\"),\n                 function(object, value) {\n                     test <- try(object@protocolData, silent = TRUE)\n                     if (inherits(test, \"try-error\"))\n                       object <- updateObject(object)\n                     object@protocolData <- value\n                     object\n                 })\n\nsetMethod(\"combine\",\n          signature=signature(\n            x=\"eSet\", y=\"eSet\"),\n          function(x, y, ...) {\n              if (class(x) != class(y))\n                stop(\"objects must be the same class, but are '\",\n                     class(x), \"', '\", class(y), \"'\")\n              if (any(annotation(x) != annotation(y)))\n                stop(\"objects have different annotations: \",\n                     annotation(x), \", \", annotation(y))\n              if (!isCurrent(x)[[\"eSet\"]])\n                  x <- updateObject(x)\n              assayData(x) <- combine(assayData(x), assayData(y))\n              phenoData(x) <- combine(phenoData(x), phenoData(y))\n              featureData(x) <- combine(featureData(x), featureData(y))\n              experimentData(x) <- combine(experimentData(x),experimentData(y))\n              protocolData(x) <- combine(protocolData(x), protocolData(y))\n              ## annotation -- constant\n              x\n          })\n\n",
        "packages.R": "# ==========================================================================\n# Functions to operate with packages:\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# createPackage; package.version; dumpPackTxt\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# uses strings.R\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\ncreatePackage <- function(pkgname, destinationDir, originDir, symbolValues,\n                          unlink=FALSE, quiet=FALSE) {\n   ## check arguments\n   for (a in c(\"pkgname\", \"destinationDir\", \"originDir\"))\n      if (!is.character(get(a)) || length(get(a))!=1)\n         stop(\"'\", a, \"' must be character(1)\")\n   ## check whether destinationDir, originDir exist and are directories\n   for (a in c(\"destinationDir\", \"originDir\"))\n      if(!file.exists(get(a)) || !file.info(get(a))$isdir)\n         stop(\"'\", a, \"' must be a directory (\", get(a), \")\")\n   ## locate / remove / create destination directory\n   pkgdir = file.path(destinationDir, pkgname)\n   if (!quiet)\n      cat(\"Creating package in\", pkgdir, \"\\n\")\n   if (file.exists(pkgdir)) {\n      if (unlink) {\n         unlink(pkgdir, recursive=TRUE)\n         if (file.exists(pkgdir)) {\n            stop(\"directory '\", pkgdir, \"' exists and could not be removed; \",\n                 \"remove it manually or choose another destination directory\")\n         }\n         else {\n            if(!quiet)\n               cat(\"existing\", pkgdir, \"was removed.\\n\")\n         }\n      }\n      else\n         stop(\"directory '\", pkgdir, \"' exists; use unlink=TRUE \",\n              \"to remove it, or choose another destination directory\")\n   } ## if (file.exists)\n   ## predefined symbols\n   symbolValues = append(symbolValues, list(TODAY=date(), PKGNAME=pkgname))\n   ## copy (from strings.R)\n   copySubstitute(dir(originDir, full.names=TRUE), pkgdir, symbolValues, recursive=TRUE)\n   return(list(pkgdir=pkgdir))\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\npackage.version <- function(pkg, lib.loc = NULL) {\n   curWarn <- getOption(\"warn\")\n   on.exit(options(warn=curWarn),add=TRUE)\n   options(warn=-1)\n   desc <- packageDescription(pkg, lib.loc, \"Version\")\n   if (is.na(desc))\n      stop(\"package '\", pkg, \"' does not exist\")\n   desc\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\ndumpPackTxt <- function (package) {\n   # stolen from \"library\" to get descriptive info out on stdout\n   pkgpath <- find.package(package)\n#   outFile <- tempfile(\"Rlibrary\")\n#   outConn <- file(outFile, open = \"w\")\n   docFiles <- file.path(pkgpath, c(\"TITLE\", \"DESCRIPTION\", \"INDEX\"))\n   headers <- c(\"\", \"Description:\\n\\n\", \"Index:\\n\\n\")\n   footers <- c(\"\\n\", \"\\n\", \"\")\n   for (i in which(file.exists(docFiles))) {\n      writeLines(headers[i], sep = \"\")\n      writeLines(readLines(docFiles[i]) )\n      writeLines(footers[i], sep = \"\")\n   }\n#   close(outConn)\n#   file.show(outFile, delete.file = TRUE)\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n ##strictly internal, not for export\n ##take an AnnotatedDataFrame object and create a valid format\n ## section for a man page\n pD2Rd <- function(pD) {\n   if(!inherits(pD, \"AnnotatedDataFrame\") )\n     stop(\"only works for AnnotatedDataFrames\")\n\n   fmt = \"\\\\format{\\n  The format is:\\n  An \\\\code{ExpressionSetObject} with covariates:\\n\"\n   covs = \"\\\\itemize{\"\n   vMD = varMetadata(pD)\n   vL = varLabels(pD)\n   for(i in 1:length(vL) ) {\n     item = paste0(\"\\\\item \\\\code{\", vL[i], \"}: \", vMD[i,1])\n     covs = paste(covs, item, sep=\"\\n\")\n   }\n   paste0(fmt, covs, \"\\n}\\n}\\n\")\n }\n",
        "rowOp-methods.R": "setGeneric(\"rowMedians\", function(x, na.rm=FALSE, ...) {\n  # Backward compatibility for rowMedians(imat=...)\n  if (missing(x)) {\n    args <- list(...);\n    if (is.element(\"imat\", names(args))) {\n      x <- args$imat;\n      .Deprecated(msg=\"The name of the matrix argument for Biobase::rowMedians() has been changed from 'imat' to 'x'.\");\n    }\n  }\n  standardGeneric(\"rowMedians\")\n})\n\n\nsetMethod(\"rowMedians\", signature(x=\"matrix\"), function(x, na.rm=FALSE, ...) {\n  na.rm <- as.logical(na.rm);\n  hasNAs <- TRUE;  # Add as an argument? /2007-08-24\n  .Call(\"rowMedians\", x, na.rm, hasNAs, TRUE, PACKAGE=\"Biobase\");\n})\n\n\nsetMethod(\"rowMedians\", signature(x=\"ExpressionSet\"), function(x, na.rm=FALSE, ...) {\n  rowMedians(exprs(x), na.rm=na.rm, ...);\n})\n\n\nsetGeneric(\"rowQ\", function(imat, which) standardGeneric(\"rowQ\"))\n\n\nsetMethod(\"rowQ\", signature(imat=\"matrix\", which=\"numeric\"),\n          function(imat, which) {\n              if (any(is.na(imat)))\n                stop(\"cannot handle missing values.\")\n              if (length(which) != 1 || !is.finite(which))\n                stop(\"'which' must be length one and finite numeric\")\n              if(is.integer(imat))\n                  imat <- structure(as.numeric(imat), dim=dim(imat))\n              .Call(\"rowQ\", imat, which, PACKAGE=\"Biobase\")\n          })\n\n\nsetMethod(\"rowQ\", signature(imat=\"ExpressionSet\", which=\"numeric\"),\n          function(imat, which) rowQ(exprs(imat), which))\n\n\nrowMin <- function(imat)\n   rowQ(imat, 1)\n\n\nrowMax <- function(imat)\n   rowQ(imat, ncol(imat))\n",
        "strings.R": "# ==========================================================================\n# Functions to deal with strings:\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# strbreak\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nstrbreak <- function(x, width=getOption(\"width\"), exdent=2, collapse=\"\\n\") {\n   width <- as.integer(width)\n   if(is.na(width) || width<=1)\n      stop(\"invalid argument 'width'\")\n   exdent <- as.integer(exdent)\n   if(is.na(exdent) || exdent>width)\n      stop(\"invalid argument 'exdent'\")\n   ww <- width-exdent\n   lb <- paste0(collapse, paste(rep(\" \", exdent), collapse=\"\"))\n   rv <- character(length(x))\n   for(i in seq(along.with=x)) {\n      first <- 1\n      last  <- width\n      if(nchar(x[i])>width) {\n         f  <- seq(width+1, nchar(x[i]), ww)\n         first <- c(first, f)\n         last  <- c(last, f+ww-1)\n      }\n      rv[i] <-  paste(substring(x[i], first=first, last=last), collapse=lb)\n   }\n   return(rv)\n}\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nlcSuffix <- function(x, ignore.case = FALSE) {\n    x <- as.character(x)\n    if( ignore.case )   \n       x <- toupper(x)\n\n    nc <- nchar(x, type=\"char\")\n    for(i in 1:min(nc)) {\n        ## The +1 and +2 are because substr is funny\n       ss = substr(x, nc - i + 1, nc)\n       if( any(ss != ss[1] )) {\n           if (i == 1L)                 # trailing char mismatch\n             return(\"\")\n           return(substr(x[1], nc - i + 2, nc))\n       }\n    }\n    return(substr(x[1], nc - i + 1, nc))\n }\n\n\nlcPrefix <- function(x, ignore.case=FALSE) {\n    x <- as.character(x)\n    if (ignore.case)\n      x <- toupper(x)\n    nc <- nchar(x, type=\"char\")\n    for (i in 1:min(nc)) {\n        ss <- substr(x, 1, i)\n        if (any(ss != ss[1])) {\n            return(substr(x[1], 1, i-1))\n        }\n    }\n    substr(x[1], 1, i)\n}\n\n\nlcPrefixC <- function(x, ignore.case=FALSE) {\n    .Call(\"lc_prefix\", x, ignore.case)\n}\n",
        "tools.R": "# ==========================================================================\n# Uncategorized tools for Biobase\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n# testBioCConnection\n# openPDF\n# listLen; reverseSplit\n# rowQ; rowMedians; rowMin; rowMax\n# copySubstitute\n# isUnique\n# cache\n# userQuery\n# ==========================================================================\ntestBioCConnection <- function() {\n   ## Stifle the \"connected to www.... garbage output\n   curNetOpt <- getOption(\"internet.info\")\n   on.exit(options(internet.info=curNetOpt), add=TRUE)\n   options(internet.info=3)\n   ## First check to make sure they have HTTP capability.  If they do\n   ## not, there is no point to this exercise.\n   http <- as.logical(capabilities(what=\"http/ftp\"))\n   if (http == FALSE)\n      return(FALSE)\n   ## find out where we think that bioC is\n   bioCoption <- getOption(\"BIOC\")\n   if (is.null(bioCoption))\n      bioCoption <- \"http://www.bioconductor.org\"\n   ## Now check to see if we can connect to the BioC website\n   biocURL <- url(paste0(bioCoption,\"/main.html\"))\n   options(show.error.messages=FALSE)\n   test <- try(readLines(biocURL)[1])\n   options(show.error.messages=TRUE)\n   if (inherits(test,\"try-error\"))\n      return(FALSE)\n   else\n      close(biocURL)\n   return(TRUE)\n}\n# ==========================================================================\nopenPDF <- function(file, bg=TRUE) {\n   OST <- .Platform$OS.type\n   if (OST==\"windows\")\n      shell.exec(file)\n   else\n      if (OST == \"unix\") {\n         bioCOpt <- getOption(\"BioC\")\n         pdf <- getOption(\"pdfviewer\")\n         msg <- NULL\n         if (is.null(pdf))\n             msg <- \"getOption('pdfviewer') is NULL\"\n         else if (length(pdf)==1 && nchar(pdf[[1]])==0)\n             msg <- \"getOption('pdfviewer') is ''\"\n         if (!is.null(msg))\n             stop(msg, \"; please use 'options(pdfviewer=...)'\")\n         cmd <- paste(pdf,file)\n         if( bg )\n            cmd <- paste(cmd, \"&\")\n         system(cmd)\n      }\n    return(TRUE)\n}\n# ==========================================================================\nreverseSplit = function(inList) {\n   if (length(inList)==0) {\n       return(inList)\n   }\n   lens = sapply(inList, length)\n   nms = rep(names(inList), lens)\n   vals = unlist(inList)\n   split(nms, vals)\n}\n# ==========================================================================\ncopySubstitute = function(src, dest, symbolValues,\n                          symbolDelimiter = \"@\",\n                          allowUnresolvedSymbols = FALSE,\n                          recursive = FALSE,\n                          removeExtension = \"\\\\.in$\") {\n   ## Check integrity of arguments (...lots of bureaucracy)\n   mess = NULL\n   if (!is.list(symbolValues) && !is.vector(symbolValues))\n      mess = \"'symbolValues' must be a list or vector.\"\n   if (!all(sapply(symbolValues, is.character)))\n      mess = \"'symbolValues' must only contain characters.\"\n   if (is.null(names(symbolValues)) || any(names(symbolValues)==\"\"))\n      mess = \"'symbolValues' must have non-empty names.\"\n   if (!(is.character(symbolDelimiter) && length(symbolDelimiter)==1 && all(nchar(symbolDelimiter)==1)))\n      mess = \"'symbolDelimiter' must be a single character.\"\n   if (!is.logical(allowUnresolvedSymbols))\n      mess = \"'allowUnresolvedSymbols' must be of type logical.\"\n   if(!is.null(mess))\n      stop(mess)\n   ## Here the actual subsitution and copying work is done\n   ## cin and cout are single files or connections\n   cpSubsCon = function(cin, cout) {\n      txt = readLines(cin)\n      for (i in seq(along.with=symbolValues)) {\n          txt = gsub(nm[i], symbolValues[[i]], txt, fixed=TRUE)\n          if (any(is.na(txt)))\n              stop(\"trying to replace \", nm[i], \" by an NA\")\n      }\n      ## check for unresolved symbols\n      if(!allowUnresolvedSymbols) {\n         re = regexpr(paste0(symbolDelimiter, \".+\", symbolDelimiter), txt)\n         wh = which(re>0)\n         if(length(wh)>0) {\n            ml   = attr(re, \"match.length\")\n            mess = \"UNRESOLVED SYMBOLS:\\n\"\n            mess <- paste0(mess, paste(sapply(wh, function(i) {\n                paste(\"Line\", i, \":\", substr(txt[i], re[i], re[i] + ml[i]))\n            }), collapse=\"\\n\"))\n            stop(mess)\n         }\n      }\n      ## finito\n      writeLines(text=txt, con=cout)\n   }\n   ## Substitution on filenames\n   subsFileName = function(x) {\n      res = gsub(removeExtension, \"\", x)\n      for (i in seq(along.with=symbolValues)) {\n         res = gsub(nm[i], symbolValues[[i]], res)\n         if (any(is.na(res)))\n             stop(\"trying to replace \", nm[i], \" by an NA\")\n      }\n      return(res)\n   }\n   ## Iterate over character vectors of filenames and\n   ## recursively descend into directories\n   cpSubs = function(src, dest) {\n      usage = paste(\"\\n* Usage:\",\n         \"\\n* with recursive=FALSE:\",\n         \"\\n* 'src' a connection open for reading or a file name AND\",\n         \"\\n* 'dest' a connection open for writing or a file name\",\n         \"\\n* with recursive=TRUE:\",\n         \"\\n* 'src' a vector of file and directory names and 'dest' a directory name\\n\\n\")\n      if (!recursive) {\n         ## {file,connection} to {file,connection}\n         if (((\"connection\" %in% class(src) && isOpen(src, rw=\"r\")) ||\n             (is.character(src) && length(src)==1)) &&\n             ((\"connection\" %in% class(dest) && isOpen(dest, rw=\"w\")) ||\n             (is.character(dest) && length(dest)==1)))\n         {\n            if(is.character(dest))\n               dest = subsFileName(dest)\n            cpSubsCon(src, dest)\n            return(invisible(NULL))\n         }\n      }\n      else {\n         ## recursive: file(s) and/or directory(ies) to directory\n         if (is.character(src) && is.character(dest) && length(dest==1)) {\n            ## if 'dest' does not exist, create\n            if (file.access(dest) != 0) {\n               if (!dir.create(dest))\n                  stop(\"'dest' does not exist, and cannot be created: \", dest)\n            }\n            ## process src\n            isdir = file.info(src)$isdir\n            for (k in seq(along.with=src)) {\n               ## name of source file or directory (without path)\n               tmp  = unlist(strsplit(src[k], .Platform$file.sep))\n               tmp  = subsFileName(tmp[length(tmp)])\n               ## name of destination file or directory (with path)\n               destname = file.path(dest, tmp)\n               if (isdir[k]) {\n                  if(!dir.create(destname))\n                     stop(\"directory cannot be created: \", destname)\n                  cpSubs(dir(src[k], full.names=TRUE), destname)\n               }\n               else\n                  cpSubsCon(src[k], destname)\n            } ## for k\n            return(invisible(NULL))\n         } ## if(is.character...)\n      } ## if(recursive)else\n      stop(usage)\n   } ## cpSubs\n   ## DO IT!\n   nm  = paste0(symbolDelimiter, names(symbolValues), symbolDelimiter)\n   cpSubs(src, dest)\n}\n# ==========================================================================\nnote <- function(...) {\n    ## A \"less drastic\" version of warning()\n    if (nargs() > 0) {\n        message <- paste(\"Note:\",...,\"\\n\")\n        cat(message)\n    }\n}\n\n## ==================================================\nisUnique = function(x){\n\n  rv = rep(TRUE, length(x))\n\n  if(length(x)>=2) {\n    ord = order(x)\n    ox = x[ord]\n    ## compare consecutive values\n    neq = (ox[-length(ox)]!=ox[-1])\n    ## a value is unique if neither its predecessor nor successor\n    ## in the ordered vector are the same\n    rv[ord] = c(neq, TRUE) & c(TRUE, neq)\n  }\n\n  return(rv)\n}\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n## O.Sklyar, EBI, 2006\nmatchpt <- function(x, y) {\n  storage.mode(x)=\"double\"\n  if (is.vector(x))\n    x <- matrix(x, ncol = 1L, nrow = length(x))\n  if (!(is.matrix(x) && is.numeric(x)))\n    stop(\"'x' must be a numeric matrix.\")\n\n  if (!missing(y)) {\n    storage.mode(y)=\"double\"\n    if (is.vector(y))\n      y <- matrix(y, ncol = 1L, nrow = length(y))\n    if (!(is.matrix(y) && is.numeric(y)))\n      stop(\"y must be a numeric matrix.\")\n    if (ncol(x) != ncol(y))\n      stop(\"x and y must have the same number of columns.\")\n  } else {\n    y <- NULL\n  }\n  \n  res <- .Call(\"matchpt\", x, y, PACKAGE = \"Biobase\")\n  res <- as.data.frame(res)\n  rownames(res) <- rownames(x)\n  return(res)\n}\n\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\ncache <- function(expr, dir=\".\", prefix=\"tmp_R_cache_\") {\n    pexpr <- parse(text=deparse(substitute(expr)))\n    pexpr <- as.list(pexpr[[1]])\n    name <- as.character(pexpr[[2]])\n    RHS <- pexpr[[3]]\n    cachefile <- file.path(dir, paste0(prefix, name, \".RData\"))\n    if(file.exists(cachefile)) {\n        load(cachefile)\n        assign(name, get(name), envir=parent.frame())\n    } else {\n        dir.create(dir, recursive=TRUE, showWarnings=FALSE)\n        assign(name, eval(RHS, envir=parent.frame()), envir=parent.frame())\n        save(list=name, file=cachefile, envir=parent.frame())\n    }\n    invisible(get(name, envir=parent.frame()))\n}\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nvalidMsg <- function(msg, result) {\n    if (is.character(result)) {\n        append(msg, result)\n    } else msg\n}\n\ncheckClass <- function(object, expected, prefix=\"\", call.=FALSE, ...) {\n    if (!is(object, expected))\n      stop(prefix, \" '\", deparse(substitute(object)), \"' is class '\",\n           paste(class(object), collapse=\"', '\"),\n           \"' but should be or extend '\",\n           paste(expected, collapse=\"', '\"), \"'\", call.=call., ...)\n}\n\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nuserQuery <- function(msg, allowed=c(\"y\",\"n\"), default = \"n\",\n                      case.sensitive = FALSE) {\n    ## Prompts the user with a string and for an answer\n    ## repeats until it gets allowable input\n  if(interactive()){\n    repeat {\n      allowMsg <- paste0(\"[\", paste(allowed,collapse=\"/\"), \"] \")\n      outMsg <- paste(msg, allowMsg)\n      cat(outMsg)\n      if(case.sensitive)\n        ans <- readLines(n=1)\n      else\n        ans <- tolower(readLines(n=1))\n      if (ans %in% allowed)\n        break\n      else\n        cat(ans, \"is not a valid response, try again.\\n\")\n    }\n    return(ans)\n  }else{\n    return(default)\n  }\n}\n\nunsafeSetSlot <- function(obj, slot, value) {\n    \n    ## This function _assumes_ that there is exactly on references to\n    ## 'obj'; the number of references is not usually detectable from\n    ## casual perusal of the code, because R only maintains the\n    ## _illusion_ of pass by value. Use this with the greatest care,\n    ## if at all.\n\n    invisible(.Call(\"unsafe_set_slot\", obj, slot, value))\n}\n\nsubListExtract <- function(L, name, simplify=FALSE, keep.names=TRUE) {\n    ## Return a list or vector obtained by extracting the element named\n    ## 'name' from each inner list of L.\n    ##\n    ## L - list\n    ## name - character vector length 1, name of inner list element\n    ## simplify - return an atomic vector or error if TRUE\n    ## keep.names - if TRUE, keep names of L on result\n    ##\n    ## this is just a mockup, to play with the desired interface\n    ## and behavior.  will be replaced with a C version.\n    .Call(sublist_extract, L, name, simplify, keep.names)\n    \n##     f <- function(x) {\n##         wh <- match(name, names(x), 0)\n##         if (wh > 0)\n##           x[[wh]]\n##         else                            # would be nice to have index in msg\n##           stop(\"bad inner list, no element named \", name)\n##     }\n\n##     if (!simplify)\n##       ans <- lapply(L, f)\n##     else {\n##         ans <- sapply(L, f)\n##         if (is.list(ans))\n##           stop(\"unable to simplify\")\n##     }\n##     if (!keep.names)\n##       names(ans) <- NULL\n##     ans\n}\n",
        "updateObjectTo.R": "setMethod(\"updateObjectTo\", signature(object=\"ANY\", template=\"ANY\"),\n          function(object, template, ..., verbose=FALSE) {\n              if (verbose)\n                  message(\"updateObject(object = 'ANY', template = 'ANY') default for object = '\",\n                          class(object), \"' template = \", class(template), \"'\")\n              if (class(object)==class(template))\n                  object\n              else {\n                  tryCatch(as(object, class(template)),\n                           error=function(err) {\n                               stop(\"\\nupdateObjectTo:\\n    \",\n                                    \"cannot convert object of class '\", class(object), \"' \",\n                                    \"to template class '\", class(template), \"'\")})\n              }\n          })\n",
        "vignettes.R": "## Functions to detect and open vignettes:\n## uses tools.R\n\ngetPkgVigs = function(package=NULL) {\n  pkgs <- .packages()\n  if( !is.null(package) ) {\n    if( !is.character(package) )\n      stop(\"`package' must be a character vector of package names\")\n    rows <- match(package, pkgs)\n    if( all(is.na(rows)) )\n        stop(\"packages '\", paste(package, collapse=\"', '\"),\n             \"' are not loaded\")\n    if( any(is.na(rows)) )\n        warning(\"packages '\",\n                paste(package[is.na(rows)], collapse=\"', '\"),\n                \"' are not loaded\")\n    pkgs <- pkgs[rows[!is.na(rows)]]\n  }\n  vigrds = file.path(find.package(pkgs), \"Meta\", \"vignette.rds\")\n  \n  ## construct data frame with: package, path, title\n  pkgVigs = vector(mode=\"list\", length=length(vigrds))\n  for(j in seq(along.with=vigrds)) {\n    if (file.exists(vigrds[j])) {\n      v = readRDS(vigrds[j])\n      f = v[, \"PDF\"]\n      f = ifelse(f==\"\",\n        as.character(NA),\n        file.path(dirname(dirname(vigrds[j])), \"doc\", f))\n      tit = v[, \"Title\"]\n      tit[tit==\"\"] = as.character(NA)\n      rv= data.frame(package  = pkgs[j],\n                     filename = f,\n                     title    = tit,\n                     stringsAsFactors=FALSE)\n      pkgVigs[[j]] = rv\n    }\n  } ## for j\n  do.call(rbind, args=pkgVigs)\n}\n\n# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nopenVignette = function(package=NULL) {\n  vig = getPkgVigs(package)\n  if (is.null(vig)) {\n      txt <- \"\"\n      if (!is.null(package)) {\n          ss <- if (length(package)==1) \"\" else \"s\"\n          pkgs <- paste(package, collapse=\", \")\n          txt <- sprintf(\" for package%s %s\", ss, pkgs)\n      }\n      warning(\"no vignettes found\", txt)\n  } else {\n    hasnofile = is.na(vig$filename)\n    vig$title[hasnofile] = paste(vig$title[hasnofile], \"[-]\")\n    vig = vig[order(hasnofile, tolower(vig$package), tolower(vig$title)), ]\n    index = menu(paste(vig$package, \"-\", vig$tit),\n      title = paste(\"Please select a vignette:\",\n        if(any(hasnofile))\n          \"(entries marked by '[-]' have no PDF file)\"\n        else\n          \"\"\n        ))\n\n    if (index>0) {\n      vif = vig$filename[index]\n      if(!is.na(vif)) {\n        openPDF(vif)\n        cat(\"Opening\", vif, \"\\n\")\n        ## browseURL(paste0(\"file://\", vig[index]))\n      } else {\n        stop(\"Sorry, no PDF file could be found for this vignette.\\n\",\n             \"Please reinstall the package with built vignettes.\")\n      }\n    }\n  }\n}\n\n#-----------------------------------------------------------\n# add package vignettes to the menu bar of the Windows Rgui\n##----------------------------------------------------------\naddVigs2WinMenu = function(pkgName) {\n  if ((.Platform$OS.type == \"windows\") &&\n      (.Platform$GUI == \"Rgui\") &&\n      interactive()) {\n      \n    vigFile = system.file(\"Meta\", \"vignette.rds\", package=pkgName)\n    if (!file.exists(vigFile)) {\n      warning(sprintf(\"%s contains no vignette, nothing is added to the menu bar\", pkgName))\n    } else {\n      vigMtrx = readRDS(vigFile)\n      vigs = file.path(find.package(pkgName), \"doc\", vigMtrx[, \"PDF\"])\n      names(vigs) = vigMtrx[,\"Title\"]\n\n      if (!\"Vignettes\" %in% winMenuNames())\n        winMenuAdd(\"Vignettes\")\n      \n      pkgMenu = paste(\"Vignettes\", pkgName, sep=\"/\")\n      winMenuAdd(pkgMenu)\n\n      for (i in seq(along.with=vigs))\n        winMenuAddItem(pkgMenu, names(vigs)[i],\n                       paste0(\"shell.exec(\\\"\", vigs[i], \"\\\")\"))\n\n    } ## else\n    ans = TRUE\n\n  } else {\n    ans = FALSE\n  } ## else\n  ans\n}\n\n",
        "zzz.R": "# ==========================================================================\n# Biobase package initialization\n# ==========================================================================\n.onLoad <- function(libname, pkgname) {\n    ## need contents to load at library attach - not at build time\n    .initContents() ## in environment.R\n    .buildBiobaseOpts() ## in environment.R\n}\n\n.onAttach <- function(libname, pkgname) {\n    msg0 <- \"Vignettes contain introductory material; view with\n             'browseVignettes()'. To cite Bioconductor, see\n             'citation(\\\"Biobase\\\")', and for packages\n             'citation(\\\"pkgname\\\")'.\"\n    msg <- strwrap(paste(msg0, collapse=\"\"), exdent=4, indent=4)\n    packageStartupMessage(paste(c(\"Welcome to Bioconductor\\n\", msg),\n                                collapse=\"\\n\"), \"\\n\")\n    addVigs2WinMenu(\"Biobase\") \n}\n\n.onUnload <- function( libpath ) {\n  library.dynam.unload( \"Biobase\", libpath )\n}\n"
    },
    "Biostrings": {
        "AMINO_ACID_CODE.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The Single-Letter Amino Acid Code.\n###\n\nAMINO_ACID_CODE <- c(\n    A=\"Ala\", # Alanine\n    R=\"Arg\", # Arginine\n    N=\"Asn\", # Asparagine\n    D=\"Asp\", # Aspartic Acid\n    C=\"Cys\", # Cysteine\n    Q=\"Gln\", # Glutamine\n    E=\"Glu\", # Glutamic Acid\n    G=\"Gly\", # Glycine\n    H=\"His\", # Histidine\n    I=\"Ile\", # Isoleucine\n    L=\"Leu\", # Leucine\n    K=\"Lys\", # Lysine\n    M=\"Met\", # Methionine\n    F=\"Phe\", # Phenylalanine\n    P=\"Pro\", # Proline\n    S=\"Ser\", # Serine\n    T=\"Thr\", # Threonine\n    W=\"Trp\", # Tryptophan\n    Y=\"Tyr\", # Tyrosine\n    V=\"Val\", # Valine\n\n  ## 21st and 22nd proteinogenic amino acids. Not coded for directly in\n  ## the Standard Genetic Code:\n    U=\"Sec\", # Selenocysteine\n    O=\"Pyl\", # Pyrrolysine\n\n  ## Ambiguities:\n    B=\"Asx\", # Asparagine or Aspartic Acid\n    J=\"Xle\", # Leucine or Isoleucine\n    Z=\"Glx\", # Glutamine or Glutamic Acid\n    X=\"Xaa\"  # Any amino acid\n)\n\n.AMINO_ACID_CODE_names <- names(AMINO_ACID_CODE)\n\n### Amino Acid alphabet (\"*\" is a translation stop)\nAA_ALPHABET <- c(.AMINO_ACID_CODE_names, \"*\", \"-\", \"+\", \".\")\n\nAA_STANDARD <- .AMINO_ACID_CODE_names[1:20]\n\nAA_PROTEINOGENIC <- .AMINO_ACID_CODE_names[1:22]\n\n",
        "GENETIC_CODE.R": "### =========================================================================\n### The Standard Genetic Code and its known variants\n### -------------------------------------------------------------------------\n###\n### File: R/GENETIC_CODE.R\n### Last update: January 28, 2014\n###\n### Reference document (last updated April 30, 2013):\n###\n###   http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi\n###\n### The \"official names\" of the various codes (\"Standard\", \"SGC0\",\n### \"Vertebrate Mitochondrial\", \"SGC1\", etc..) and their ids (1, 2, etc...)\n### were taken from the print-form ASN.1 version of the above document\n### (version 3.9 at the time of this writing):\n###\n###   ftp://ftp.ncbi.nih.gov/entrez/misc/data/gc.prt\n###\n### By historical convention the codons (which are 3-nucleotide mRNA\n### subsequences) are represented using the DNA alphabet (i.e. using T\n### instead of U). Another way to look at this is to consider that the codons\n### are coming from the \"coding DNA strand\" (a.k.a. \"sense DNA strand\" or\n### \"non-template DNA strand\").\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The Standard Code\n###\n### Official names:\n###   - Standard\n###   - SGC0\n### Official id: 1\n###\n\nGENETIC_CODE <- c(\n    TTT=\"F\",\n    TTC=\"F\",\n    TTA=\"L\",\n    TTG=\"L\",\n\n    TCT=\"S\",\n    TCC=\"S\",\n    TCA=\"S\",\n    TCG=\"S\",\n\n    TAT=\"Y\",\n    TAC=\"Y\",\n    TAA=\"*\",\n    TAG=\"*\",\n\n    TGT=\"C\",\n    TGC=\"C\",\n    TGA=\"*\",\n    TGG=\"W\",\n\n    CTT=\"L\",\n    CTC=\"L\",\n    CTA=\"L\",\n    CTG=\"L\",\n\n    CCT=\"P\",\n    CCC=\"P\",\n    CCA=\"P\",\n    CCG=\"P\",\n\n    CAT=\"H\",\n    CAC=\"H\",\n    CAA=\"Q\",\n    CAG=\"Q\",\n\n    CGT=\"R\",\n    CGC=\"R\",\n    CGA=\"R\",\n    CGG=\"R\",\n\n    ATT=\"I\",\n    ATC=\"I\",\n    ATA=\"I\",\n    ATG=\"M\",\n\n    ACT=\"T\",\n    ACC=\"T\",\n    ACA=\"T\",\n    ACG=\"T\",\n\n    AAT=\"N\",\n    AAC=\"N\",\n    AAA=\"K\",\n    AAG=\"K\",\n\n    AGT=\"S\",\n    AGC=\"S\",\n    AGA=\"R\",\n    AGG=\"R\",\n\n    GTT=\"V\",\n    GTC=\"V\",\n    GTA=\"V\",\n    GTG=\"V\",\n\n    GCT=\"A\",\n    GCC=\"A\",\n    GCA=\"A\",\n    GCG=\"A\",\n\n    GAT=\"D\",\n    GAC=\"D\",\n    GAA=\"E\",\n    GAG=\"E\",\n\n    GGT=\"G\",\n    GGC=\"G\",\n    GGA=\"G\",\n    GGG=\"G\"\n)\n\nattr(GENETIC_CODE, \"alt_init_codons\") <- c(\"TTG\", \"CTG\")\n\n### From the \"RNA transcript\".\nRNA_GENETIC_CODE <- GENETIC_CODE\nnames(RNA_GENETIC_CODE) <-\n    chartr(\"T\", \"U\", names(GENETIC_CODE))\nattr(RNA_GENETIC_CODE, \"alt_init_codons\") <-\n    chartr(\"T\", \"U\", attr(GENETIC_CODE, \"alt_init_codons\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### All the known genetic codes\n###\n\n### All the known codes taken from\n###   ftp://ftp.ncbi.nih.gov/entrez/misc/data/gc.prt\n### on May 25, 2017 (Version 4.0), and stored in one big list.\n.genetic_code_table <- list(\n\n    list(name   = \"Standard\",\n         name2  = \"SGC0\",\n         id     = 1,\n         AAs    = c(\"FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"---M---------------M------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Vertebrate Mitochondrial\",\n         name2  = \"SGC1\",\n         id     = 2,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIMMTTTTNNKKSS**VVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"MMMM---------------M------------\")),\n\n    list(name   = \"Yeast Mitochondrial\",\n         name2  = \"SGC2\",\n         id     = 3,\n         AAs    = c(\"FFLLSSSSYY**CCWWTTTTPPPPHHQQRRRR\",\n                    \"IIMMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"--MM----------------------------\")),\n\n    list(name   = paste0(c(\"Mold Mitochondrial\",\n                           \"Protozoan Mitochondrial\",\n                           \"Coelenterate Mitochondrial\",\n                           \"Mycoplasma\",\n                           \"Spiroplasma\"), collapse=\"; \"),\n         name2  = \"SGC3\",\n         id     = 4,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--MM---------------M------------\",\n                    \"MMMM---------------M------------\")),\n\n    list(name   = \"Invertebrate Mitochondrial\",\n         name2  = \"SGC4\",\n         id     = 5,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIMMTTTTNNKKSSSSVVVVAAAADDEEGGGG\"),\n         Starts = c(\"---M----------------------------\",\n                    \"MMMM---------------M------------\")),\n\n    list(name   = \"Ciliate Nuclear; Dasycladacean Nuclear; Hexamita Nuclear\",\n         name2  = \"SGC5\",\n         id     = 6,\n         AAs    = c(\"FFLLSSSSYYQQCC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Echinoderm Mitochondrial; Flatworm Mitochondrial\",\n         name2  = \"SGC8\",\n         id     = 9,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNNKSSSSVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M---------------M------------\")),\n\n    list(name   = \"Euplotid Nuclear\",\n         name2  = \"SGC9\",\n         id     = 10,\n         AAs    = c(\"FFLLSSSSYY**CCCWLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Bacterial, Archaeal and Plant Plastid\",\n         name2  = NA,\n         id     = 11,\n         AAs    = c(\"FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"---M---------------M------------\",\n                    \"MMMM---------------M------------\")),\n\n    list(name   = \"Alternative Yeast Nuclear\",\n         name2  = NA,\n         id     = 12,\n         AAs    = c(\"FFLLSSSSYY**CC*WLLLSPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"-------------------M------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Ascidian Mitochondrial\",\n         name2  = NA,\n         id     = 13,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIMMTTTTNNKKSSGGVVVVAAAADDEEGGGG\"),\n         Starts = c(\"---M----------------------------\",\n                    \"--MM---------------M------------\")),\n\n    list(name   = \"Alternative Flatworm Mitochondrial\",\n         name2  = NA,\n         id     = 14,\n         AAs    = c(\"FFLLSSSSYYY*CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNNKSSSSVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Blepharisma Macronuclear\",\n         name2  = NA,\n         id     = 15,\n         AAs    = c(\"FFLLSSSSYY*QCC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Chlorophycean Mitochondrial\",\n         name2  = NA,\n         id     = 16,\n         AAs    = c(\"FFLLSSSSYY*LCC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Trematode Mitochondrial\",\n         name2  = NA,\n         id     = 21,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIMMTTTTNNNKSSSSVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M---------------M------------\")),\n\n    list(name   = \"Scenedesmus obliquus Mitochondrial\",\n         name2  = NA,\n         id     = 22,\n         AAs    = c(\"FFLLSS*SYY*LCC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"---M----------------------------\")),\n\n    list(name   = \"Thraustochytrium Mitochondrial\",\n         name2  = NA,\n         id     = 23,\n         AAs    = c(\"FF*LSSSSYY**CC*WLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"--------------------------------\",\n                    \"M--M---------------M------------\")),\n\n    list(name   = \"Pterobranchia Mitochondrial\",\n         name2  = NA,\n         id     = 24,\n         AAs    = c(\"FFLLSSSSYY**CCWWLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSSKVVVVAAAADDEEGGGG\"),\n         Starts = c(\"---M---------------M------------\",\n                    \"---M---------------M------------\")),\n\n    list(name   = \"Candidate Division SR1 and Gracilibacteria\",\n         name2  = NA,\n         id     = 25,\n         AAs    = c(\"FFLLSSSSYY**CCGWLLLLPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"---M----------------------------\",\n                    \"---M---------------M------------\")),\n\n    list(name   = \"Pachysolen tannophilus Nuclear\",\n         name2  = NA,\n         id     = 26,\n         AAs    = c(\"FFLLSSSSYY**CC*WLLLAPPPPHHQQRRRR\",\n                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n         Starts = c(\"-------------------M------------\",\n                    \"---M----------------------------\"))\n\n### The following genetic codes are listed on\n###   https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi\n### but not on\n###   ftp://ftp.ncbi.nih.gov/entrez/misc/data/gc.prt\n### They pose the problem that they use stop codons that are not always\n### translated as such. For example, in code 27 below, TGA can mean STOP\n### or be translated as Trp but I don't see any information on the\n### https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi page about\n### when one or the other occurs. So I've no idea how could one use these\n### codes to predict translation. More precisely, translate() needs to be\n### deterministic and I don't see how it could with these genetic codes.\n \n#    list(name   = \"Karyorelict Nuclear\",\n#         name2  = NA,\n#         id     = 27,\n#         AAs    = c(\"FFLLSSSSYYQQCCWWLLLAPPPPHHQQRRRR\",\n#                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n#         Starts = c(\"--------------------------------\",\n#                    \"---M----------------------------\")),\n\n#    list(name   = \"Condylostoma Nuclear\",\n#         name2  = NA,\n#         id     = 28,\n#         AAs    = c(\"FFLLSSSSYYQQCCWWLLLAPPPPHHQQRRRR\",\n#                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n#         Starts = c(\"--------------------------------\",\n#                    \"---M----------------------------\")),\n\n#    list(name   = \"Mesodinium Nuclear\",\n#         name2  = NA,\n#         id     = 29,\n#         AAs    = c(\"FFLLSSSSYYYYCC*WLLLAPPPPHHQQRRRR\",\n#                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n#         Starts = c(\"--------------------------------\",\n#                    \"---M----------------------------\")),\n\n#    list(name   = \"Peritrich Nuclear\",\n#         name2  = NA,\n#         id     = 30,\n#         AAs    = c(\"FFLLSSSSYYEECC*WLLLAPPPPHHQQRRRR\",\n#                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n#         Starts = c(\"--------------------------------\",\n#                    \"---M----------------------------\")),\n\n#    list(name   = \"Blastocrithidia Nuclear\",\n#         name2  = NA,\n#         id     = 31,\n#         AAs    = c(\"FFLLSSSSYYEECCWWLLLLPPPPHHQQRRRR\",\n#                    \"IIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\"),\n#         Starts = c(\"--------------------------------\",\n#                    \"---M----------------------------\"))\n)\n\n### All the known codes summarized in one big data.frame:\nGENETIC_CODE_TABLE <- do.call(rbind,\n    lapply(.genetic_code_table,\n        function(genetic_code) {\n            data.frame(name=genetic_code$name,\n                       name2=as.character(genetic_code$name2),\n                       id=as.character(genetic_code$id),\n                       AAs=paste0(genetic_code$AAs, collapse=\"\"),\n                       Starts=paste0(genetic_code$Starts, collapse=\"\"),\n                       stringsAsFactors=FALSE)\n        }))\n\n.solve_id_or_name2 <- function(id_or_name2, full.search=FALSE)\n{\n    if (!isSingleString(id_or_name2))\n        stop(\"'id_or_name2' must be a single string\")\n    if (id_or_name2 == \"\")\n        stop(\"'id_or_name2' must be a non empty string\")\n    if (!isTRUEorFALSE(full.search))\n        stop(\"'full.search' must be TRUE or FALSE\")\n    ## Search the 'id' col.\n    idx <- match(id_or_name2, GENETIC_CODE_TABLE$id)\n    if (!is.na(idx))\n        return(idx)\n    ## Search the 'name2' col.\n    idx <- match(id_or_name2, GENETIC_CODE_TABLE$name2)\n    if (!is.na(idx))\n        return(idx)\n    if (!full.search)\n        stop(\"Genetic code not found for 'id_or_name2=\\\"\",\n             id_or_name2, \"\\\"'.\\n  \",\n             \"Maybe try again with 'full.search=TRUE'.\")\n    ## Search the 'name' col.\n    idx <- grep(id_or_name2, GENETIC_CODE_TABLE$name, ignore.case=TRUE)\n    if (length(idx) == 0L)\n        stop(\"Genetic code not found for 'id_or_name2=\\\"\",\n             id_or_name2, \"\\\"'.\")\n    if (length(idx) >= 2L)\n        stop(\"More than one genetic code found for 'id_or_name2=\\\"\",\n             id_or_name2, \"\\\"'.\\n  \",\n             \"Try to be more specific.\")\n    idx\n}\n\ngetGeneticCode <- function(id_or_name2=\"1\", full.search=FALSE,\n                           as.data.frame=FALSE)\n{\n    if (!isTRUEorFALSE(as.data.frame))\n        stop(\"'as.data.frame' must be TRUE or FALSE\")\n    idx <- .solve_id_or_name2(id_or_name2, full.search=full.search)\n    ans <- safeExplode(GENETIC_CODE_TABLE[idx, \"AAs\"])\n    Start <- safeExplode(GENETIC_CODE_TABLE[idx, \"Starts\"])\n    if (as.data.frame) {\n        ans <- data.frame(AA=ans, Start=Start, stringsAsFactors=FALSE)\n        rownames(ans) <- names(GENETIC_CODE)\n        return(ans)\n    }\n    names(ans) <- names(GENETIC_CODE)\n    idx <- which(Start != \"-\" & Start != ans)\n    stopifnot(all(Start[idx] == \"M\"))  # should never happen\n    attr(ans, \"alt_init_codons\") <- names(ans)[idx]\n    ans\n}\n\n",
        "IUPAC_CODE_MAP.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The IUPAC extended genetic alphabet.\n###\n\nIUPAC_CODE_MAP <- c(\n    A=\"A\",\n    C=\"C\",\n    G=\"G\",\n    T=\"T\",\n    M=\"AC\",\n    R=\"AG\",\n    W=\"AT\",\n    S=\"CG\",\n    Y=\"CT\",\n    K=\"GT\",\n    V=\"ACG\",\n    H=\"ACT\",\n    D=\"AGT\",\n    B=\"CGT\",\n    N=\"ACGT\"\n)\n\nmergeIUPACLetters <- function(x)\n{\n    if (!is.character(x) || any(is.na(x)) || any(nchar(x) == 0))\n        stop(\"'x' must be a vector of non-empty character strings\")\n    x <- CharacterList(strsplit(toupper(x), \"\", fixed=TRUE))\n    yy <- unname(IUPAC_CODE_MAP[unlist(x, use.names=FALSE)])\n    if (any(is.na(yy)))\n        stop(\"some strings in 'x' contain non IUPAC letters\")\n    yy <- CharacterList(strsplit(yy, \"\", fixed=TRUE))\n    y <- unstrsplit(sort(unique(IRanges:::regroupBySupergroup(yy, x))))\n    names(IUPAC_CODE_MAP)[match(y, IUPAC_CODE_MAP)]\n}\n\n",
        "MIndex-class.R": "### =========================================================================\n### MIndex objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"MIndex\" VIRTUAL class.\n###\n### This class serves as a base class for a family of match containers that\n### can be manipulated thru a common API. This common API is the MIndex API\n### defined in this section.\n### Note that, in normal operations, the user should never need to create\n### MIndex objects directly or to modify existing ones. Those objects are\n### typically returned by a sequence matching/alignment function like\n### vmatchPattern() or matchPDict().\n###\n\nsetClass(\"MIndex\",\n    contains=\"IRangesList\",\n    representation(\n        \"VIRTUAL\",\n        width0=\"integer\",\n        NAMES=\"character_OR_NULL\"\n    )\n)\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"MIndex\",\n    function(x) c(\"width0\", \"NAMES\", callNextMethod())\n)\n\nsetMethod(\"length\", \"MIndex\", function(x) length(x@width0))\n\nsetGeneric(\"width0\", function(x) standardGeneric(\"width0\"))\n\nsetMethod(\"width0\", \"MIndex\", function(x) x@width0)\n\nsetMethod(\"names\", \"MIndex\", function(x) x@NAMES)\n\nsetReplaceMethod(\"names\", \"MIndex\",\n    function(x, value)\n        stop(\"attempt to modify the names of a \", class(x), \" instance\")\n)\n\nsetGeneric(\"startIndex\", function(x) standardGeneric(\"startIndex\"))\n\nsetGeneric(\"endIndex\", function(x) standardGeneric(\"endIndex\"))\n\nsetMethod(\"elementNROWS\", \"MIndex\",\n    function(x) elementNROWS(endIndex(x))\n)\n\nsetMethod(\"unlist\", \"MIndex\",\n    function(x, recursive=TRUE, use.names=TRUE)\n    {\n        use.names <- normargUseNames(use.names)\n        start_index <- startIndex(x)\n        ans_start <- unlist(start_index, recursive=FALSE, use.names=FALSE)\n        if (is.null(ans_start))\n            ans_start <- integer(0)\n        end_index <- endIndex(x)\n        ans_end <- unlist(end_index, recursive=FALSE, use.names=FALSE)\n        if (is.null(ans_end))\n            ans_end <- integer(0)\n        if (use.names) {\n            ans_names <- names(x)\n            if (!is.null(ans_names))\n                ans_names <- rep.int(ans_names, times=sapply(end_index, length))\n        } else {\n            ans_names <- NULL\n        }\n        ans_width <- ans_end - ans_start + 1L\n        ans <- new2(\"IRanges\", start=ans_start, width=ans_width, check=FALSE)\n        names(ans) <- ans_names\n        ans\n    }\n)\n\n.from_MIndex_to_CompressedIRangesList <- function(from)\n{\n    ans <- relist(unlist(from, use.names=FALSE), from)\n    names(ans) <- names(from)\n    ans\n}\n\nsetAs(\"MIndex\", \"CompressedIRangesList\", .from_MIndex_to_CompressedIRangesList)\n\nextractAllMatches <- function(subject, mindex)\n{\n    if (is(subject, \"MaskedXString\"))\n        subject <- unmasked(subject)\n    else if (!is(subject, \"XString\"))\n        stop(\"'subject' must be an XString or MaskedXString object\")\n    if (!is(mindex, \"MIndex\"))\n        stop(\"'mindex' must be an MIndex object\")\n    allviews <- unlist(mindex)\n    ans <- unsafe.newXStringViews(subject, start(allviews), width(allviews))\n    names(ans) <- names(allviews)\n    ans\n}\n\nsetMethod(\"show\", \"MIndex\",\n    function(object)\n    {\n        cat(\"MIndex object of length \", length(object), \"\\n\", sep=\"\")\n        irl <- as(object, \"CompressedIRangesList\")\n        IRanges:::show_IntegerRangesList(irl, with.header=FALSE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"ByPos_MIndex\" class.\n### \n\nsetClassUnion(\"Dups_OR_NULL\", c(\"Dups\", \"NULL\"))\n\nsetClass(\"ByPos_MIndex\",\n    contains=\"MIndex\",\n    representation(\n        dups0=\"Dups_OR_NULL\",  # NULL or same length as the \"width0\" slot\n        ends=\"list\"            # same length as the \"width0\" slot\n    )\n)\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/bindROWS.R file in\n### the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"ByPos_MIndex\",\n    function(x) c(\"dups0\", \"ends\", callNextMethod())\n)\n\n### Only reason for defining this method is to catch the situation where\n### x@dups0 is not NULL.\nsetMethod(\"extractROWS\", \"ByPos_MIndex\",\n    function(x, i)\n    {\n        if (!is.null(x@dups0))\n            stop(wmsg(\"subsetting a ByPos_MIndex object that has a non-null \",\n                      \"'dups0' slot is not ready yet, sorry\"))\n        callNextMethod()\n    }\n)\n\nsetMethod(\"[[\", \"ByPos_MIndex\",\n    function(x, i, j, ...)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x)\n        if (!is.null(x@dups0) && !is.na(i2 <- high2low(x@dups0)[i]))\n            i <- i2\n        ans_end <- x@ends[[i]]\n        if (is.null(ans_end))\n            ans_end <- integer(0)\n        ans_width <- rep.int(x@width0[i], length(ans_end))\n        ans_start <- ans_end - x@width0[i] + 1L\n        new2(\"IRanges\", start=ans_start, width=ans_width, check=FALSE)\n    }\n)\n\n### An example of a ByPos_MIndex object of length 5 where only the\n### 2nd and 5th pattern have matches:\n###   > width0 <- c(9L, 10L, 8L, 4L, 10L)\n###   > dups0 <- Dups(c(NA, NA, NA, NA, 2))\n###   > ends <- vector(mode=\"list\", length=5)\n###   > ends[[2]] <- c(199L, 402L)\n###   > mindex <- new(\"ByPos_MIndex\", width0=width0, NAMES=letters[1:5], dups0=dups0, ends=ends)\n###   > mindex[[1]]\n###   > mindex[[2]]\n###   > mindex[[6]] # Error in mindex[[6]] : subscript out of bounds\n###   > startIndex(mindex)\n###   > endIndex(mindex)\n###   > elementNROWS(mindex)\n###\nsetMethod(\"startIndex\", \"ByPos_MIndex\",\n    function(x)\n    {\n        .Call2(\"ByPos_MIndex_endIndex\",\n              high2low(x@dups0), x@ends, x@width0,\n              PACKAGE=\"Biostrings\")\n    }\n)\nsetMethod(\"endIndex\", \"ByPos_MIndex\",\n    function(x)\n    {\n        .Call2(\"ByPos_MIndex_endIndex\",\n              high2low(x@dups0), x@ends, NULL,\n              PACKAGE=\"Biostrings\")\n    }\n)\n\nByPos_MIndex.combine <- function(mi_list)\n{\n    if (length(mi_list) == 0)\n        stop(\"cannot combine an empty list of MIndex objects\")\n    ## 'mi_list[[i]]@width0' should be identical for any 'i'. We don't check\n    ## this!\n    ans_width0 <- mi_list[[1L]]@width0\n    ## 'names(mi_list[[i]])' should be identical for any 'i'. We don't check\n    ## this!\n    ans_names <- names(mi_list[[1L]])\n    ends_listlist <- lapply(mi_list, function(mi) mi@ends)\n    #mergeEnds <- function(...)\n    #{\n    #    ans <- unlist(list(...), recursive=FALSE, use.names=FALSE)\n    #    if (is.null(ans))\n    #        return(NULL)\n    #    sort(unique(ans))\n    #}\n    #args <- c(list(FUN=mergeEnds), ends_listlist, list(SIMPLIFY=FALSE))\n    #ans_ends <- do.call(mapply, args)\n    ans_ends <- .Call2(\"ByPos_MIndex_combine\",\n                      ends_listlist,\n                      PACKAGE=\"Biostrings\")\n    new(\"ByPos_MIndex\", width0=ans_width0, NAMES=ans_names, ends=ans_ends)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"SparseMIndex\" class (DISABLED FOR NOW).\n### \n### Slot description:\n###\n###   ends_envir: a key-value list (environment) where the values are integer\n###       vectors containing the ending positions of the pattern whose\n###       position in the original dictionary is given by the key (the keys are\n###       strings representing positive integers).\n### \n\nif (FALSE) {\n\n  setClass(\"SparseMIndex\",\n    contains=\"MIndex\",\n    representation(\n        ends_envir=\"environment\"\n    )\n  )\n\n  setMethod(\"show\", \"SparseMIndex\",\n    function(object)\n    {\n        cat(\"Sparse MIndex object of length \", length(object), \"\\n\", sep=\"\")\n    }\n  )\n\n  setMethod(\"[[\", \"SparseMIndex\",\n    function(x, i, j, ...)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x)\n        ans_end <- x@ends_envir[[formatC(i, width=10, format=\"d\", flag=\"0\")]]\n        if (is.null(ans_end))\n            ans_end <- integer(0)\n        ans_width <- rep.int(x@width0[i], length(ans_end))\n        ans_start <- ans_end - x@width0[i] + 1L\n        new2(\"IRanges\", start=ans_start, width=ans_width, check=FALSE)\n    }\n  )\n\n  ### An example of a SparseMIndex object of length 5 where only the\n  ### 2nd pattern has matches:\n  ###   > width0 <- c(9L, 10L, 8L, 4L, 10L)\n  ###   > ends_envir <- new.env(hash=TRUE, parent=emptyenv())\n  ###   > ends_envir[['0000000002']] <- c(199L, 402L)\n  ###   > mindex <- new(\"SparseMIndex\", width0=width0, NAMES=letters[1:5], ends_envir=ends_envir)\n  ###   > mindex[[1]]\n  ###   > mindex[[2]]\n  ###   > mindex[[6]] # Error in mindex[[6]] : subscript out of bounds\n  ###   > names(mindex)\n  ###   > mindex[[\"a\"]]\n  ###   > mindex[[\"b\"]]\n  ###   > mindex[[\"aa\"]] # Error in mindex[[\"aa\"]] : pattern name ‘aa’ not found\n  ###   > startIndex(mindex)\n  ###   > endIndex(mindex)\n  ###   > elementNROWS(mindex)\n  ###\n  setMethod(\"startIndex\", \"SparseMIndex\",\n    function(x)\n    {\n        all.names <- TRUE\n        .Call2(\"SparseMIndex_endIndex\",\n              x@ends_envir, x@width0, x@NAMES, all.names,\n              PACKAGE=\"Biostrings\")\n    }\n  )\n  setMethod(\"endIndex\", \"SparseMIndex\",\n    function(x)\n    {\n        all.names <- TRUE\n        .Call2(\"SparseMIndex_endIndex\",\n              x@ends_envir, NULL, x@NAMES, all.names,\n              PACKAGE=\"Biostrings\")\n    }\n  )\n\n}\n\n",
        "MaskedXString-class.R": "### =========================================================================\n### MaskedXString objects\n### -------------------------------------------------------------------------\n###\n### Note that thinking of MaskedXString objects as particular XString objects\n### might seem natural and therefore making the MaskedXString class an\n### extension of the XString class is tempting... But in the end there would\n### be no benefit in doing so because inheritance would not give us\n### anything good out-of-the-box. This is because almost all XString methods\n### are doing the wrong thing for MaskedXString objects and hence would need\n### to be overwritten so it would not save us any work. Furthermore, some of\n### the XString methods should be disabled for MaskedXString objects. But if\n### MaskedXString objects are considered XString objects, then these methods\n### need to be overwritten and call stop() so that they fail on MaskedXString\n### objects. By not making the MaskedXString class an extension of the XString\n### class, we avoid all this mess.\n###\n\n### Not good (MaskedXString extends XString).\n#setClass(\"MaskedXString\",\n#    contains=\"XString\",\n#    representation(\n#        \"VIRTUAL\",\n#        masks=\"MaskCollection\"\n#    )\n#)\n### 4 direct \"MaskedXString\" derivations (no additional slot)\n#setClass(\"MaskedBString\", contains=c(\"MaskedXString\", \"BString\"))\n#setClass(\"MaskedDNAString\", contains=c(\"MaskedXString\", \"DNAString\"))\n#setClass(\"MaskedRNAString\", contains=c(\"MaskedXString\", \"RNAString\"))\n#setClass(\"MaskedAAString\", contains=c(\"MaskedXString\", \"AAString\"))\n\n### Better (MaskedXString does NOT extend XString).\nsetClass(\"MaskedXString\",\n    representation(\n        \"VIRTUAL\",\n        unmasked=\"XString\",\n        masks=\"MaskCollection\"\n    )\n)\n\nsetClass(\"MaskedBString\",\n    contains=\"MaskedXString\",\n    representation(\n        unmasked=\"BString\"\n    )\n)\nsetClass(\"MaskedDNAString\",\n    contains=\"MaskedXString\",\n    representation(\n        unmasked=\"DNAString\"\n    )\n)\nsetClass(\"MaskedRNAString\",\n    contains=\"MaskedXString\",\n    representation(\n        unmasked=\"RNAString\"\n    )\n)\nsetClass(\"MaskedAAString\",\n    contains=\"MaskedXString\",\n    representation(\n        unmasked=\"AAString\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor-like methods.\n###\n\nsetGeneric(\"unmasked\", function(x) standardGeneric(\"unmasked\"))\nsetMethod(\"unmasked\", \"MaskedXString\", function(x) x@unmasked)\nsetMethod(\"unmasked\", \"XString\", function(x) x)  # no-op\n\nsetGeneric(\"masks\", function(x) standardGeneric(\"masks\"))\nsetMethod(\"masks\", \"XString\", function(x) NULL)\nsetMethod(\"masks\", \"MaskedXString\", function(x) x@masks)\n\nsetMethod(\"length\", \"MaskedXString\", function(x) length(unmasked(x)))\n\nsetMethod(\"maskedwidth\", \"MaskedXString\", function(x) maskedwidth(collapse(masks(x))))\n\nsetMethod(\"maskedratio\", \"MaskedXString\", function(x) maskedratio(collapse(masks(x))))\n\nsetMethod(\"nchar\", \"MaskedXString\",\n    function(x, type=\"chars\", allowNA=FALSE)\n    {\n        length(x) - maskedwidth(x)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.MaskedXString.unmasked <- function(object)\n{\n    if (!is(unmasked(object), \"XString\"))\n        return(\"the 'unmasked' slot must contain an XString object\")\n    if (!is(object, paste(\"Masked\", xsbaseclass(object), sep=\"\")))\n        return(\"bad XString base type for the unmasked sequence\")\n    if (length(object) != width(masks(object)))\n        return(\"the length of the object and the width of the mask collection differ\")\n    NULL\n}\n\n.valid.MaskedXString.masks <- function(object)\n{\n    masks <- masks(object)\n    if (!is(masks, \"MaskCollection\"))\n        return(\"the 'masks' slot must contain a MaskCollection object\")\n    if (width(masks) != length(object))\n        return(\"the length of the object and the width of the mask collection differ\")\n    NULL\n}\n\n.valid.MaskedXString <- function(object)\n{\n    c(.valid.MaskedXString.unmasked(object),\n      .valid.MaskedXString.masks(object))\n}\n\nsetValidity(\"MaskedXString\",\n    function(object)\n    {\n        problems <- .valid.MaskedXString(object)\n        if (is.null(problems)) TRUE else problems\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"seqtype\" and \"seqtype<-\" methods.\n###\n\nsetMethod(\"seqtype\", \"MaskedXString\", function(x) seqtype(unmasked(x)))\n\n### Downgrades 'x' to a MaskedB/DNA/RNA/AAString instance!\nsetReplaceMethod(\"seqtype\", \"MaskedXString\",\n    function(x, value)\n    {\n        ## could be done with 'seqtype(unmasked(x)) <- value'\n        ## if `unmasked<-` was available\n        unmasked <- unmasked(x)\n        seqtype(unmasked) <- value\n        ans_class <- paste(\"Masked\", value, \"String\", sep=\"\")\n        new(ans_class, unmasked=unmasked, masks=masks(x))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### From MaskedXString objects to MaskedXString objects.\nsetAs(\"MaskedXString\", \"MaskedBString\",\n    function(from) {seqtype(from) <- \"B\"; from}\n)\nsetAs(\"MaskedXString\", \"MaskedDNAString\",\n    function(from) {seqtype(from) <- \"DNA\"; from}\n)\nsetAs(\"MaskedXString\", \"MaskedRNAString\",\n    function(from) {seqtype(from) <- \"RNA\"; from}\n)\nsetAs(\"MaskedXString\", \"MaskedAAString\",\n    function(from) {seqtype(from) <- \"AA\"; from}\n)\n\n### From XString objects to MaskedXString objects.\nsetAs(\"BString\", \"MaskedBString\",\n    function(from)\n    {\n        masks <- new(\"MaskCollection\", width=length(from))\n        new(\"MaskedBString\", unmasked=from, masks=masks)\n    }\n)\nsetAs(\"DNAString\", \"MaskedDNAString\",\n    function(from)\n    {\n        masks <- new(\"MaskCollection\", width=length(from))\n        new(\"MaskedDNAString\", unmasked=from, masks=masks)\n    }\n)\nsetAs(\"RNAString\", \"MaskedRNAString\",\n    function(from)\n    {\n        masks <- new(\"MaskCollection\", width=length(from))\n        new(\"MaskedRNAString\", unmasked=from, masks=masks)\n    }\n)\nsetAs(\"AAString\", \"MaskedAAString\",\n    function(from)\n    {\n        masks <- new(\"MaskCollection\", width=length(from))\n        new(\"MaskedAAString\", unmasked=from, masks=masks)\n    }\n)\n\n### From MaskedXString objects to XString objects.\nsetAs(\"MaskedBString\", \"BString\",\n    function(from) unmasked(from)\n)\nsetAs(\"MaskedDNAString\", \"DNAString\",\n    function(from) unmasked(from)\n)\nsetAs(\"MaskedRNAString\", \"RNAString\",\n    function(from) unmasked(from)\n)\nsetAs(\"MaskedAAString\", \"AAString\",\n    function(from) unmasked(from)\n)\n\n### Dispatch on 'x' (see generic in XString-class.R).\nsetMethod(\"XString\", \"MaskedXString\",\n    function(seqtype, x, start=NA, end=NA, width=NA)\n        XString(seqtype, unmasked(x), start=start, end=end, width=width)\n)\n\n### From a MaskedXString object to a MaskCollection object.\nsetAs(\"MaskedXString\", \"MaskCollection\",\n    function(from) masks(from)\n)\n\n### From a MaskedXString object to a NormalIRanges object.\nsetAs(\"MaskedXString\", \"NormalIRanges\",\n    function(from) as(masks(from), \"NormalIRanges\")\n)\n\n### From a MaskedXString object to an XStringViews object.\nsetAs(\"MaskedXString\", \"XStringViews\",\n    function(from)\n    {\n        views <- gaps(collapse(masks(from)))[[1]]\n        unsafe.newXStringViews(unmasked(from), start(views), width(views))\n    }\n)\n\nsetAs(\"MaskedXString\", \"Views\", function(from) as(from, \"XStringViews\"))\n\n### NOT exported.\ntoXStringViewsOrXString <- function(x)\n{\n    x0 <- unmasked(x)\n    mask1 <- collapse(masks(x))\n    if (isEmpty(mask1))\n        return(x0)\n    views <- gaps(mask1)[[1]]\n    unsafe.newXStringViews(x0, start(views), width(views))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The transformation methods (endomorphisms) \"collapse\" and \"gaps\".\n###\n\nsetMethod(\"collapse\", \"MaskedXString\",\n    function(x)\n    {\n        x@masks <- collapse(masks(x))\n        x\n    }\n)\n\n### 'start' and 'end' are ignored.\nsetMethod(\"gaps\", \"MaskedXString\",\n    function(x, start=NA, end=NA)\n    {\n        x@masks <- gaps(collapse(masks(x)))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"subseq\" method for MaskedXString objects.\n###\n### This method is used by the toSeqSnippet() function when called\n### on a MaskedXString object.\n###\n\nsetMethod(\"subseq\", \"MaskedXString\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        x@unmasked <- subseq(unmasked(x), start=start, end=end, width=width)\n        x@masks <- narrow(masks(x), start=start, end=end, width=width)\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"as.character\" and \"toString\" methods.\n###\n\n### This method is used by the toSeqSnippet() function when called\n### on a MaskedXString object.\nsetMethod(\"as.character\", \"MaskedXString\",\n    function(x)\n    {\n        ans <- as.character(unmasked(x))\n        nir0 <- as(x, \"NormalIRanges\")\n        for (i in seq_len(length(nir0))) {\n            strip <- paste(rep.int(\"#\", width(nir0)[i]), collapse=\"\")\n            substr(ans,  start(nir0)[i], end(nir0)[i]) <- strip\n        }\n        ans\n    }\n)\n\nsetMethod(\"toString\", \"MaskedXString\", function(x, ...) as.character(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\nsetMethod(\"show\", \"MaskedXString\",\n    function(object)\n    {\n        object_len <- length(object)\n        cat(object_len, \"-letter \", class(object), \" object \",\n            \"(# for masking)\\n\", sep=\"\")\n        snippet <- toSeqSnippet(object, getOption(\"width\") - 5L)\n        cat(\"seq: \", add_colors(snippet), \"\\n\", sep=\"\")\n        MaskCollection.show_frame(masks(object))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"masks<-\" replacement methods.\n###\n\nsetGeneric(\"masks<-\", function(x, value) standardGeneric(\"masks<-\"))\n\n### Setting the masks of a MaskedXString object...\nsetReplaceMethod(\"masks\", signature(x=\"MaskedXString\", value=\"NULL\"),\n    function(x, value) unmasked(x)\n)\nsetReplaceMethod(\"masks\", signature(x=\"MaskedXString\", value=\"MaskCollection\"),\n    function(x, value)\n    {\n        if (width(value) != length(x))\n            stop(\"the width of the mask collection must be equal \",\n                 \"to the length of the sequence\")\n        x@masks <- value\n        x\n    }\n)\n\n### Setting the masks of an XString object...\nsetReplaceMethod(\"masks\", signature(x=\"XString\", value=\"NULL\"),\n    function(x, value) x\n)\nsetReplaceMethod(\"masks\", signature(x=\"XString\", value=\"ANY\"),\n    function(x, value)\n    {\n        x <- as(x, paste(\"Masked\", xsbaseclass(x), sep=\"\"))\n        masks(x) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"Views\" method.\n###\n\nsetMethod(\"Views\", \"MaskedXString\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n    {\n        if (any(active(masks(subject))))\n            warning(\"masks were dropped\")\n        Views(unmasked(subject), start=start, end=end, width=width, names=names)\n    }\n)\n\n",
        "MultipleAlignment.R": "### =========================================================================\n### MultipleAlignment objects\n### -------------------------------------------------------------------------\n###\n\n## virtual class for multiple alignments\nsetClass(\"MultipleAlignment\",\n    representation(\"VIRTUAL\",\n                   unmasked=\"XStringSet\",\n                   rowmask=\"NormalIRanges\",\n                   colmask=\"NormalIRanges\")\n)\n\n## concrete classes for multiple alignments\nsetClass(\"DNAMultipleAlignment\",\n    contains=\"MultipleAlignment\",\n    representation=representation(unmasked=\"DNAStringSet\")\n)\nsetClass(\"RNAMultipleAlignment\",\n    contains=\"MultipleAlignment\",\n    representation=representation(unmasked=\"RNAStringSet\")\n)\nsetClass(\"AAMultipleAlignment\",\n    contains=\"MultipleAlignment\",\n    representation=representation(unmasked=\"AAStringSet\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n\n.valid.MultipleAlignment.unmasked <- function(object)\n{\n    if (length(unique(nchar(object@unmasked))) > 1)\n        \"alignments have an unequal number of characters\"\n    else\n        NULL\n}\n\n.valid.MultipleAlignment.rowmask <- function(object)\n{\n    rng <- range(object@rowmask)\n    if (length(rng) > 0 &&\n        (start(rng) < 1 || end(rng) > length(object@unmasked)))\n        \"'rowmask' contains values outside of [1, nrow]\"\n    else\n        NULL\n}\n\n.valid.MultipleAlignment.colmask <- function(object)\n{\n    rng <- range(object@colmask)\n    if (length(rng) > 0 &&\n        (start(rng) < 1 || end(rng) > nchar(object@unmasked)[1L]))\n        \"'colmask' contains values outside of [1, ncol]\"\n    else\n        NULL\n}\n\nsetValidity(\"MultipleAlignment\",\n    function(object)\n    {\n        problems <-\n          c(.valid.MultipleAlignment.unmasked(object),\n            .valid.MultipleAlignment.rowmask(object),\n            .valid.MultipleAlignment.colmask(object))\n        if (is.null(problems)) TRUE else problems\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor-like methods.\n###\n\nsetMethod(\"unmasked\", \"MultipleAlignment\", function(x) x@unmasked)\n\nsetMethod(\"rownames\",\"MultipleAlignment\", function(x) names(x@unmasked))\nsetReplaceMethod(\"rownames\", \"MultipleAlignment\",\n    function(x,value)\n    {\n        names(x@unmasked) <- value\n        x\n    }\n)\n\nsetGeneric(\"rowmask\", signature=\"x\", function(x) standardGeneric(\"rowmask\"))\nsetMethod(\"rowmask\", \"MultipleAlignment\", function(x) x@rowmask)\n\n.setMask <- function(mask, append, invert, length, value){\n  if (!isTRUEorFALSE(invert))\n    stop(\"'invert' must be TRUE or FALSE\")\n  if (invert)\n    value <- gaps(value, start=1L, end=length)     \n  append <- match.arg(append, choices=c(\"union\", \"replace\", \"intersect\"))\n  value <- switch(append,\n                  \"union\"=union(mask, value),\n                  \"replace\"=value,\n                  \"intersect\"=intersect(mask, value))\n  as(value, \"NormalIRanges\")\n}\nsetGeneric(\"rowmask<-\", signature=c(\"x\", \"value\"),\n    function(x, append=\"union\", invert=FALSE, value)\n           standardGeneric(\"rowmask<-\")\n)\n\nsetReplaceMethod(\"rowmask\", signature(x=\"MultipleAlignment\", value=\"NULL\"),\n    function(x, append=\"replace\", invert=FALSE, value)\n        callGeneric(x, append=append, invert=invert,\n                    value=new(\"NormalIRanges\"))\n)\nsetReplaceMethod(\"rowmask\",\n    signature(x=\"MultipleAlignment\", value=\"ANY\"),\n    function(x, append=\"union\", invert=FALSE, value)\n    {\n      if (!is(value, \"IRanges\"))\n        value <- as(value, \"IRanges\")\n      value <- .setMask(mask=rowmask(x), append=append, invert=invert,\n                        length=dim(x)[1], value=value)\n      initialize(x, rowmask = value)\n    }\n)\n\nsetGeneric(\"colmask\", signature=\"x\", function(x) standardGeneric(\"colmask\"))\nsetMethod(\"colmask\", \"MultipleAlignment\", function(x) x@colmask)\n\nsetGeneric(\"colmask<-\", signature=c(\"x\", \"value\"),\n    function(x, append=\"union\", invert=FALSE, value)\n           standardGeneric(\"colmask<-\")\n)\nsetReplaceMethod(\"colmask\", signature(x=\"MultipleAlignment\", value=\"NULL\"),\n    function(x, append=\"replace\", invert=FALSE, value)\n        callGeneric(x, append=append, invert=invert,\n                    value=new(\"NormalIRanges\"))\n)\nsetReplaceMethod(\"colmask\",\n    signature(x=\"MultipleAlignment\", value=\"ANY\"),\n    function(x, append=\"union\", invert=FALSE, value)\n    {\n      if (!is(value, \"IRanges\"))\n        value <- as(value, \"IRanges\")\n      value <- .setMask(mask=colmask(x), append=append, invert=invert,\n                        length=dim(x)[2], value=value)\n      initialize(x, colmask = value)\n    }\n)\n\nsetMethod(\"maskMotif\", signature(x=\"MultipleAlignment\", motif=\"ANY\"),\n    function(x, motif, min.block.width=1, ...)\n    {\n        cmask <- colmask(x)\n        if (length(colmask(x)) > 0)\n            colmask(x) <- NULL\n        string <- consensusString(x)\n        if (length(string) == 1) {\n            string <- gsub(\"#\", \"+\", string)\n            string <- as(string, xsbaseclass(unmasked(x)))\n            maskedString <-\n              callGeneric(string, motif, min.block.width=min.block.width, ...)\n            newmask <- nir_list(masks(maskedString))[[1L]]\n            colmask(x) <- union(newmask, cmask)\n        }\n        x\n    }\n)\n\nsetGeneric(\"maskGaps\", signature=\"x\",\n    function(x, ...) standardGeneric(\"maskGaps\")\n)\nsetMethod(\"maskGaps\", \"MultipleAlignment\",\n    function(x, min.fraction=0.5, min.block.width=3)\n    {\n        if (!isSingleNumber(min.fraction) || min.fraction < 0 ||\n            min.fraction > 1)\n            stop(\"'min.fraction' must be a number in [0, 1]\")\n        if (!isSingleNumber(min.block.width) || min.block.width <= 0)\n            stop(\"'min.block.width' must be a positive integer\")\n        if (!is.integer(min.block.width))\n            min.block.width <- as.integer(min.block.width)\n\n        cmask <- colmask(x)\n        if (length(colmask(x)) > 0)\n            colmask(x) <- NULL\n        m <- consensusMatrix(x)\n        newmask <- (m[\"-\",] / colSums(m)) >= min.fraction\n        newmask[is.na(newmask)] <- FALSE\n        newmask <- as(newmask, \"NormalIRanges\")\n        newmask <- newmask[width(newmask) >= min.block.width]\n        colmask(x) <- union(newmask, cmask)\n        x\n    }\n)\n\nsetMethod(\"nrow\",\"MultipleAlignment\", function(x) length(x@unmasked))\nsetMethod(\"ncol\",\"MultipleAlignment\",\n    function(x) {if (nrow(x) == 0L) 0L else nchar(x@unmasked[[1L]])}\n)\nsetMethod(\"dim\",\"MultipleAlignment\", function(x) c(nrow(x), ncol(x)))\n\nsetGeneric(\"maskednrow\", signature=\"x\",\n    function(x) standardGeneric(\"maskednrow\")\n)\nsetMethod(\"maskednrow\", \"MultipleAlignment\",\n    function(x) sum(width(rowmask(x)))\n)\n\nsetGeneric(\"maskedncol\", signature=\"x\",\n    function(x) standardGeneric(\"maskedncol\")\n)\nsetMethod(\"maskedncol\", \"MultipleAlignment\",\n    function(x) sum(width(colmask(x)))\n)\n\nsetGeneric(\"maskeddim\", signature=\"x\",\n    function(x) standardGeneric(\"maskeddim\")\n)\nsetMethod(\"maskeddim\", \"MultipleAlignment\",\n    function(x) c(maskednrow(x), c(maskedncol(x)))\n)\n\nsetMethod(\"maskedratio\", \"MultipleAlignment\",\n    function(x) maskeddim(x) / dim(x)\n)\n\nsetMethod(\"nchar\", \"MultipleAlignment\",\n    function(x) ncol(x) - maskedncol(x)\n)\n\nsetMethod(\"seqtype\", \"MultipleAlignment\",\n    function(x) seqtype(unmasked(x))\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructors.\n###\n\n.new_MultipleAlignment <- function(seqtype, x, start, end, width, use.names,\n                                   rowmask, colmask)\n{\n    ans_class <- paste0(seqtype, \"MultipleAlignment\")\n    unmasked <- get(paste0(seqtype, \"StringSet\"))(x=x,\n                                                  start=start,\n                                                  end=end,\n                                                  width=width,\n                                                  use.names=use.names)\n    if (is.null(rowmask))\n        rowmask <- new(\"NormalIRanges\")\n    if (is.null(colmask))\n        colmask <- new(\"NormalIRanges\")\n    new(ans_class, unmasked=unmasked, rowmask=rowmask, colmask=colmask)\n}\n\nDNAMultipleAlignment <- function(x=character(),\n                                 start=NA, end=NA, width=NA, use.names=TRUE,\n                                 rowmask=NULL, colmask=NULL)\n{\n    .new_MultipleAlignment(\"DNA\", x, start, end, width, use.names,\n                           rowmask, colmask)\n}\n\nRNAMultipleAlignment <- function(x=character(),\n                                 start=NA, end=NA, width=NA, use.names=TRUE,\n                                 rowmask=NULL, colmask=NULL)\n{\n    .new_MultipleAlignment(\"RNA\", x, start, end, width, use.names,\n                           rowmask, colmask)\n}\n\nAAMultipleAlignment <- function(x=character(),\n                                start=NA, end=NA, width=NA, use.names=TRUE,\n                                rowmask=NULL, colmask=NULL)\n{\n    .new_MultipleAlignment(\"AA\", x, start, end, width, use.names,\n                           rowmask, colmask)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Read function.\n###\n\n## markupPattern specifies which lines to skip\n.read.MultipleAlignment.splitRows <-\nfunction(rows, markupPattern)\n{\n    markupLines <- grep(markupPattern, rows, perl=TRUE)\n    alnLines <- gaps(as(markupLines, \"IRanges\"), start=1, end=length(rows))\n    nseq <- unique(width(alnLines))\n    if (length(nseq) != 1)\n        stop(\"missing alignment rows\")\n    rows <- extractROWS(rows, alnLines)\n    spaces <- regexpr(\"\\\\s+\", rows)\n    ids <- substr(rows, 1L, spaces - 1L)\n    nsplits <- length(rows) %/% nseq\n    if (!identical(ids, rep.int(head(ids, nseq), nsplits)))\n        stop(\"alignment rows out of order\")\n    alns <- substr(rows, spaces + attr(spaces, \"match.length\"), nchar(rows))\n    structure(do.call(paste,\n                      c(split(alns, rep(seq_len(nsplits), each=nseq)), sep=\"\")),\n              names = head(ids, nseq))\n}\n\n.read.Stockholm <-\nfunction(filepath)\n{\n    rows <- scan(filepath, what = \"\", sep = \"\\n\", strip.white = TRUE,\n                 quiet = TRUE, blank.lines.skip = FALSE)\n    if (length(rows) < 3 ||\n        !identical(grep(\"^# STOCKHOLM\", rows[1L]), 1L))\n        stop(\"invalid Stockholm file\")\n    chartr(\".\", \"-\",\n           .read.MultipleAlignment.splitRows(rows, \"(^\\\\s*|^#.*|^//\\\\s*)$\"))\n}\n\n.read.ClustalAln <-\nfunction(filepath)\n{\n    rows <- scan(filepath, what = \"\", sep = \"\\n\", strip.white = TRUE,\n                 quiet = TRUE, blank.lines.skip = FALSE)\n    if (length(rows) < 3 ||\n        !identical(grep(\"^CLUSTAL\", rows[1L]), 1L) ||\n        !identical(rows[2:3], c(\"\",\"\")))\n        stop(\"invalid Clustal aln file\")\n    rows <- tail(rows, -3)\n    rows <- sub(\"^(\\\\S+\\\\s+\\\\S+)\\\\s*\\\\d*$\", \"\\\\1\", rows)\n    .read.MultipleAlignment.splitRows(rows, \"^(\\\\s|\\\\*|:|\\\\.)*$\")\n}\n\n## In order to recycle .read.MultipleAlignment.splitRows().\n## I need to have the names on each row.\n.read.PhylipAln <- \nfunction(filepath, maskGen=FALSE)\n{\n    rows <- scan(filepath, what = \"\", sep = \"\\n\", strip.white = TRUE,\n                 quiet = TRUE, blank.lines.skip = FALSE)\n    if (length(rows) < 1 ||\n        !identical(grep(\"^\\\\d+?\\\\s\\\\d+?\", rows[1L]), 1L))\n        stop(\"invalid Phylip file\")\n    ##(mask+num rows + blank line) \n    nameLength <- as.numeric(sub(\"(\\\\d+).*$\",\"\\\\1\", rows[1])) +1 \n    rows <- tail(rows, -1)\n    names <- character()\n    names[nameLength] <- \"\" ## an empty string is ALWAYS the last \"name\"\n    offset <- 0L\n    for(i in seq_len(length(rows))){\n      if(i<nameLength){\n        rows[i] <- sub(\"(^\\\\S+)\\\\s+(\\\\S+)\", \"\\\\1\\\\|\\\\2\", rows[i])\n        rows[i] <- gsub(\"\\\\s\", \"\", rows[i])\n        rows[i] <- sub(\"\\\\|\", \" \", rows[i])\n        names[i] <- sub(\"(\\\\S+).*$\",\"\\\\1\",rows[i])\n      }else{        \n        rows[i] <- gsub(\"\\\\s\", \"\", rows[i])\n        rows[i] <- paste(names[i %% nameLength], rows[i])\n      }\n    }\n    rows <- c(\" \",rows)\n    if(maskGen==FALSE){ ## filter out the Mask values OR blank lines\n       .read.MultipleAlignment.splitRows(rows, \"^(Mask|\\\\s)\")\n    }else{## only retrieve the Mask values\n      if(length(grep(\"^(?!Mask)\",rows, perl=TRUE))==length(rows)){\n        return(as(IRanges(),\"NormalIRanges\"))\n      }else{\n        msk <- .read.MultipleAlignment.splitRows(rows, \"^(?!Mask)\")\n        ## THEN cast them to be a NormalIRanges object.\n        splt <- strsplit(msk,\"\") ## split up all chars\n        names(splt) <- NULL ## drop the name\n        splt <- unlist(splt) ## THEN unlist\n        lsplt <- as.logical(as.numeric(splt)) ## NOW you can get a logical\n        return(gaps(as(lsplt,\"NormalIRanges\"))) ## gaps() inverts mask\n      }\n    }\n}\n\n.checkFormat <- function(filepath, format){\n    if (missing(format)) {\n        ext <- tolower(sub(\".*\\\\.([^.]*)$\", \"\\\\1\", filepath))\n        format <- switch(ext, \"sto\" = \"stockholm\", \"aln\" = \"clustal\", \"fasta\")\n    } else {\n        format <- match.arg(tolower(format), c(\"fasta\", \"stockholm\", \"clustal\",\n                                               \"phylip\"))\n    }\n    format\n}\n\n.read.MultipleAlignment <-\nfunction(filepath, format, seqtype, ...)\n{\n    format <- .checkFormat(filepath, format)\n    switch(format,\n           \"stockholm\" = .read.Stockholm(filepath),\n           \"clustal\" = .read.ClustalAln(filepath),\n           \"phylip\" = .read.PhylipAln(filepath),\n           .read_XStringSet(filepath, format,\n                            nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                            use.names=TRUE, seqtype=seqtype))\n    ##TODO: BUGs with stockholm??\n}\n\n.read.MultipleMask <-\nfunction(filepath, format)\n{\n    format <- .checkFormat(filepath, format)\n    switch(format,\n           \"stockholm\" = as(IRanges(),\"NormalIRanges\"),\n           \"clustal\" = as(IRanges(),\"NormalIRanges\"),\n           \"phylip\" = .read.PhylipAln(filepath, maskGen=TRUE),\n           as(IRanges(),\"NormalIRanges\"))\n}\n\n\nreadDNAMultipleAlignment <-\nfunction(filepath, format)\n{\n    DNAMultipleAlignment(.read.MultipleAlignment(filepath, format, \"DNA\"),\n                         rowmask=as(IRanges(),\"NormalIRanges\"),\n                         colmask=.read.MultipleMask(filepath,format))\n}\n\nreadRNAMultipleAlignment <-\nfunction(filepath, format)\n{\n    RNAMultipleAlignment(.read.MultipleAlignment(filepath, format, \"RNA\"),\n                         rowmask=as(IRanges(),\"NormalIRanges\"),\n                         colmask=.read.MultipleMask(filepath,format))\n}\n\nreadAAMultipleAlignment <-\nfunction(filepath, format)\n{\n    AAMultipleAlignment(.read.MultipleAlignment(filepath, format, \"AA\"),\n                        rowmask=as(IRanges(),\"NormalIRanges\"),\n                        colmask=.read.MultipleMask(filepath,format))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Write functions.\n###\n\n## helper to chop up strings into pieces.\n.strChop <- function(x, chopsize=10, simplify = TRUE)\n{\n  chunks <- breakInChunks(nchar(x), chunksize=chopsize)\n  if(simplify==TRUE){\n    sapply(seq_len(length(chunks)),\n           function(i)\n           substr(x, start=start(chunks)[i], stop=end(chunks)[i]))\n  }else{\n    lapply(seq_len(length(chunks)),\n           function(i)\n           substr(x, start=start(chunks)[i], stop=end(chunks)[i]))\n  }\n}\n\n## We just have to just insert line spaces\n.insertSpaces <- function(str){\n  str = .strChop(str)\n  paste(str, collapse=\" \")\n}\n\n.write.MultAlign <- function(x,filepath,invertColMask, showRowNames,\n                             hideMaskedCols){\n  if(inherits(x, \"MultipleAlignment\")){\n    ## 1st, we need to capture the colmask as a vector that can be included\n    msk <- colmask(x)\n    dims <- dim(x)    \n    if(invertColMask==FALSE){\n      msk<-gaps(msk, start=1, end=dims[2])\n    }\n    ##If we are hiding the masked cols, then we don't care about the mask\n    if(hideMaskedCols){\n      hasMask <- FALSE\n    }else{## If we show masked cols, drop mask before as.character()\n      colmask(x) <- NULL\n      if(length(msk) > 0){hasMask<-TRUE}else{hasMask <- FALSE}\n    }\n    if(hasMask){dims[1] <- dims[1]+1}\n    ## Massage to character vector\n    ch <- as.character(x)\n    ch <- unlist(lapply(ch, .insertSpaces))\n    ## Convert mask to string format\n    if(hasMask){\n      mskInd <- as.integer(msk) ## index that should be masked\n      mskCh <- paste(as.character(replace(rep(1,dim(x)[2]), mskInd, 0)),\n        collapse=\"\")\n      mskCh <- .insertSpaces(mskCh)\n    }\n    ## Split up the output into lines, but grouped into a list object\n    names <- names(ch)\n    ch <- sapply(ch, .strChop, chopsize=55, simplify=FALSE)\n    ## Again consider mask, split, name & cat on (if needed)\n    if(hasMask){\n      mskCh <- .strChop(mskCh, chopsize=55)\n      ch <- c(list(Mask = mskCh), ch)\n    }\n    ## 1) precalculate the max length of the names and then\n    maxLen <- max(nchar(names(ch)))\n    ## 2) make a string of that many spaces into a row\n    stockSpc <- paste(rep(\" \", maxLen), collapse=\"\")\n    ## 3) will need to buffer all names() to be that length.\n    bufferSpacing<-function(name){\n        spc <- paste(rep(\" \", maxLen - nchar(name)), collapse=\"\")\n        paste(name, spc, sep=\"\")\n    }\n    ## 4) append set of blank strings to list for \"gapped-rows\" later\n    ch <- c(ch, list(rep(\"\",length(ch[[1]]))))\n    ## 5) Iterate so that all the rows are interleaved together\n    output <- character(length(ch[[1]])*length(ch))\n    for(i in seq_len(length(ch[[1]]))){\n      for(j in seq_len(length(ch))){\n        if(i==1){\n          output[j] <- paste(unlist(lapply(names(ch[j]), bufferSpacing)),\n                             \"   \",ch[[j]][i],sep=\"\")\n        }else{\n          if(showRowNames){\n            output[(length(ch)*(i-1)) + j] <-\n              paste(unlist(lapply(names(ch[j]), bufferSpacing)),\n                    \"   \",ch[[j]][i],sep=\"\")\n          }else{\n            output[(length(ch)*(i-1)) + j] <- paste(stockSpc,\n                                                    \"   \",ch[[j]][i],sep=\"\")\n          }\n        }\n      }\n    }\n    ## drop trailing spaces\n    output <-  gsub(\"\\\\s+$\",\"\", output)\n    ## remove the extra end line\n    output <- output[1:length(output)-1]\n    ## finally attach the dims\n    if(hasMask){\n      ##Honestly not sure if I need a \"W\" here or what it means?\n      output <- c(paste(\"\",paste(c(dims,\"\"),collapse=\" \"),collapse=\" \"),output)\n    }else{\n      output <- c(paste(\"\",paste(dims,collapse=\" \"),collapse=\" \"),output)\n    }\n    writeLines(output, filepath)\n  }\n}\n\nwrite.phylip <- function(x, filepath){\n  .write.MultAlign(x, filepath, invertColMask=TRUE, showRowNames=FALSE,\n                   hideMaskedCols=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show detailed pager view of unmasked sequences.\n###\n\ndetail <- function(x, ...) show(x)\nsetGeneric(\"detail\")\nsetMethod(\"detail\", \"MultipleAlignment\",\n          function(x,invertColMask=FALSE,hideMaskedCols=TRUE){\n            ## We don't want a permanent file for this\n            FH <- tempfile(pattern = \"tmpFile\", tmpdir = tempdir())\n            ## Then write out a temp file with the correct stuff in it\n            .write.MultAlign(x, FH, invertColMask=invertColMask,\n                             showRowNames=TRUE,\n                             hideMaskedCols=hideMaskedCols)\n            ## use file.show() to display\n            file.show(FH)\n          })\n\n\n## TODO: explore if we can make a textConnection() to save time writing to disk.\n## page() allows this, but seems to be actually slower than what we do here,\n## also, it looks considerably less nice than when it comes from a file...\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"MultipleAlignment\", \"DNAStringSet\",\n    function(from) DNAStringSet(as.character(from))\n)\nsetAs(\"MultipleAlignment\", \"RNAStringSet\",\n    function(from) RNAStringSet(as.character(from))\n)\nsetAs(\"MultipleAlignment\", \"AAStringSet\",\n    function(from) AAStringSet(as.character(from))\n)\nsetAs(\"MultipleAlignment\", \"BStringSet\",\n    function(from) BStringSet(as.character(from))\n)\n\nsetAs(\"character\", \"DNAMultipleAlignment\",\n      function(from) DNAMultipleAlignment(from)\n)\nsetAs(\"character\", \"RNAMultipleAlignment\",\n      function(from) RNAMultipleAlignment(from)\n)\nsetAs(\"character\", \"AAMultipleAlignment\",\n      function(from) AAMultipleAlignment(from)\n)\n\nsetMethod(\"as.character\", \"MultipleAlignment\",\n    function(x, use.names=TRUE)\n        apply(as.matrix(x, use.names=use.names), 1, paste, collapse=\"\")\n)\n\nsetMethod(\"as.matrix\", \"MultipleAlignment\",\n    function(x, use.names=TRUE)\n    {\n        if (nrow(x) == 0) {\n            m <- matrix(character(0), nrow=0, ncol=0)\n        } else {\n            m <- as.matrix(unmasked(x), use.names=use.names)\n            if (maskednrow(x) > 0)\n                m <- m[- as.integer(rowmask(x)), , drop=FALSE]\n            if (maskedncol(x) > 0)\n                m <- m[, - as.integer(colmask(x)), drop=FALSE]\n        }\n        m\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Utilities.\n###\n\nsetMethod(\"consensusMatrix\",\"MultipleAlignment\",\n    function(x, as.prob=FALSE, baseOnly=FALSE)\n    {\n        strings <- unmasked(x)\n        if (maskednrow(x) > 0)\n            strings <- strings[- as.integer(rowmask(x))]\n        m <- callGeneric(strings, as.prob=as.prob, baseOnly=baseOnly,\n                         width=ncol(x))\n        if (maskedncol(x) > 0)\n            m[, as.integer(colmask(x))] <- NA\n        m\n    }\n)\n\nsetMethod(\"consensusString\",\"MultipleAlignment\",\n    function(x, ambiguityMap, threshold, codes)\n    {\n        consensus <- rep.int(\"#\", ncol(x))\n        if (ncol(x) > 0) {\n            cmat <- consensusMatrix(x, width=ncol(x))\n            ngaps <- cmat[\"-\",]\n            cmat <- cmat[codes, , drop=FALSE]\n            colsums <- colSums(cmat, na.rm=TRUE)\n            nzsum <- which(colsums > 1e-6)\n            if (length(nzsum) > 0) {\n                colsums[- nzsum] <- 1  # to avoid division by 0\n                gaplocs <- which(as.logical(ngaps > colsums))\n                nzsum <- setdiff(nzsum, gaplocs)\n                cmat <- cmat / rep(colsums, each=nrow(cmat))\n                consensus[gaplocs] <- \"-\"\n                consensus[nzsum] <-\n                  safeExplode(consensusString(cmat[, nzsum, drop=FALSE],\n                                              ambiguityMap=ambiguityMap,\n                                              threshold=threshold))\n            }\n            consensus <- paste(consensus, collapse=\"\")\n        }\n        consensus\n    }\n)\n\nsetMethod(\"consensusString\",\"DNAMultipleAlignment\",\n    function(x, ambiguityMap=IUPAC_CODE_MAP, threshold=0.25)\n    {\n        callNextMethod(x, ambiguityMap=ambiguityMap, threshold=threshold,\n                       codes=names(IUPAC_CODE_MAP))\n    }\n)\n\nsetMethod(\"consensusString\",\"RNAMultipleAlignment\",\n    function(x,\n            ambiguityMap=\n            structure(as.character(RNAStringSet(DNAStringSet(IUPAC_CODE_MAP))),\n                      names=\n                      as.character(RNAStringSet(DNAStringSet(names(IUPAC_CODE_MAP))))),\n            threshold=0.25)\n    {\n        callNextMethod(x, ambiguityMap=ambiguityMap, threshold=threshold,\n                       codes=\n                       as.character(RNAStringSet(DNAStringSet(names(IUPAC_CODE_MAP)))))\n    }\n)\n\nsetMethod(\"consensusString\",\"AAMultipleAlignment\",\n    function(x, ambiguityMap=\"?\", threshold=0.5)\n    {\n        callNextMethod(x, ambiguityMap=ambiguityMap, threshold=threshold,\n                       codes=names(AMINO_ACID_CODE))\n    }\n)\n\nsetGeneric(\"consensusViews\", signature=\"x\",\n    function(x, ...) standardGeneric(\"consensusViews\")\n)\n\nsetMethod(\"consensusViews\",\"MultipleAlignment\",\n    function(x, ambiguityMap, threshold)\n    {\n        cmask <- colmask(x)\n        if (length(cmask) > 0)\n            colmask(x) <- NULL\n        consensus <-\n          consensusString(x, ambiguityMap=ambiguityMap, threshold=threshold)\n        if (length(consensus) == 0)\n            consensus <- \"\"\n        Views(BString(consensus), gaps(cmask, start=1, end=ncol(x)))\n    }\n)\n\nsetMethod(\"consensusViews\",\"DNAMultipleAlignment\",\n    function(x, ambiguityMap=IUPAC_CODE_MAP, threshold=0.25)\n    {\n        callNextMethod(x, ambiguityMap=ambiguityMap, threshold=threshold)\n    }\n)\n\nsetMethod(\"consensusViews\",\"RNAMultipleAlignment\",\n    function(x,\n             ambiguityMap=as.character(RNAStringSet(DNAStringSet(IUPAC_CODE_MAP))),\n             threshold=0.25)\n    {\n        callNextMethod(x, ambiguityMap=ambiguityMap, threshold=threshold)\n    }\n)\n\nsetMethod(\"consensusViews\",\"AAMultipleAlignment\",\n    function(x, ambiguityMap=\"?\", threshold=0.5)\n    {\n        callNextMethod(x, ambiguityMap=ambiguityMap, threshold=threshold)\n    }\n)\n\nsetMethod(\"alphabetFrequency\",\"MultipleAlignment\",\n    function(x, as.prob=FALSE, collapse=FALSE)\n    {\n        if (collapse) {\n            strings <- as(x, sprintf(\"%sStringSet\", seqtype(x)))\n            m <- callGeneric(strings, as.prob=as.prob, collapse=TRUE)\n        } else {\n            rmask <- rowmask(x)\n            if (length(rmask) > 0)\n                rowmask(x) <- NULL\n            strings <- as(x, sprintf(\"%sStringSet\", seqtype(x)))\n            m <- callGeneric(strings, as.prob=as.prob)\n            if (length(rmask) > 0)\n                m[as.integer(rmask),] <- NA\n        }\n        m\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\n.MultipleAlignment.show_frame_header <-\nfunction (iW, with.names) \n{\n    cat(format(\"\", width = iW + 1), sep=\"\")\n    if (with.names) {\n        cat(format(\" aln\", width = getOption(\"width\") - iW - .namesW - 1),\n            format(\"names\", width=.namesW, justify=\"left\"), sep=\"\")\n    } else {\n        cat(\" aln\")\n    }\n    cat(\"\\n\")\n}\n\n.MultipleAlignment.show_frame_line <-\nfunction (x, i, iW)\n{\n    snippetWidth <- getOption(\"width\") - 2L - iW\n    if (!is.null(names(x))) \n        snippetWidth <- snippetWidth - .namesW - 1L\n    snippet <- toSeqSnippet(x[[i]], snippetWidth)\n    if (!is.null(names(x))) {\n        snippet_class <- class(snippet)\n        snippet <- format(snippet, width=snippetWidth)\n        class(snippet) <- snippet_class\n    }\n    cat(format(paste(\"[\", i, \"]\", sep=\"\"), width=iW, justify=\"right\"), \" \",\n        add_colors(snippet), sep=\"\")\n    if (!is.null(names(x))) {\n        snippet_name <- names(x)[i]\n        if (is.na(snippet_name))\n            snippet_name <- \"<NA>\"\n        else if (nchar(snippet_name) > .namesW)\n            snippet_name <- paste0(substr(snippet_name, 1L, .namesW - 3L),\n                                   #compact_ellipsis)\n                                   \"...\")\n        cat(\" \", snippet_name, sep=\"\")\n    }\n    cat(\"\\n\")\n}\n\n.MultipleAlignment.show_frame <-\nfunction (x, half_nrow=9L)\n{\n    lx <- length(x)\n    iW <- nchar(as.character(lx)) + 2\n    .MultipleAlignment.show_frame_header(iW, !is.null(names(x)))\n    if (lx <= 2 * half_nrow + 1) {\n        for (i in seq_len(lx))\n            .MultipleAlignment.show_frame_line(x, i, iW)\n    } else {\n        for (i in 1:half_nrow)\n            .MultipleAlignment.show_frame_line(x, i, iW)\n        cat(format(\"...\", width=iW, justify=\"right\"), \"...\\n\")\n        for (i in (lx - half_nrow + 1L):lx)\n            .MultipleAlignment.show_frame_line(x, i, iW)\n    }\n}\n\nsetMethod(\"show\", \"MultipleAlignment\",\n    function(object)\n    {\n        nr <- nrow(object)\n        nc <- ncol(object)\n        cat(class(object), \" with \", nr, ifelse(nr == 1, \" row and \", \n            \" rows and \"), nc, ifelse(nc == 1, \" column\\n\", \" columns\\n\"), \n            sep = \"\")\n        if (nr != 0) {\n            strings <- unmasked(object)\n            mdim <- maskeddim(object)\n            if (sum(mdim) > 0) {\n                if (mdim[1] > 0) {\n                    strings <- BStringSet(strings)\n                    maskStrings <-\n                      rep(BStringSet(paste(rep.int(\"#\", ncol(object)),\n                                           collapse=\"\")), mdim[1])\n                    i <- as.integer(rowmask(object))\n                    if (!is.null(rownames(object)))\n                        names(maskStrings) <- rownames(object)[i]\n                    strings[i] <- maskStrings\n                }\n                if (mdim[2] > 0) {\n                    strings <- as.matrix(strings)\n                    strings[, as.integer(colmask(object))] <- \"#\"\n                    strings <- BStringSet(apply(strings, 1, paste, collapse=\"\"))\n                }\n            }\n            .MultipleAlignment.show_frame(strings)\n        }\n    }\n)\n\n",
        "PDict-class.R": "### =========================================================================\n### PDict objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"PreprocessedTB\" VIRTUAL class.\n###\n\nsetClass(\"PreprocessedTB\",\n    representation(\n        \"VIRTUAL\",\n        tb=\"DNAStringSet\",  # always constant width\n        exclude_dups0=\"logical\",\n        dups=\"Dups\",\n        base_codes=\"integer\"\n    )\n)\n\nsetMethod(\"length\", \"PreprocessedTB\", function(x) length(x@tb))\n\nsetMethod(\"width\", \"PreprocessedTB\", function(x) width(x@tb))\n\nsetGeneric(\"tb\", function(x) standardGeneric(\"tb\"))\nsetMethod(\"tb\", \"PreprocessedTB\", function(x) x@tb)\n\nsetGeneric(\"tb.width\", function(x) standardGeneric(\"tb.width\"))\nsetMethod(\"tb.width\", \"PreprocessedTB\", function(x) width(x@tb)[1])\n\nsetGeneric(\"dups\", function(x) standardGeneric(\"dups\"))\nsetMethod(\"dups\", \"PreprocessedTB\", function(x) x@dups)\n\nsetGeneric(\"nnodes\", function(x) standardGeneric(\"nnodes\"))\n\nsetGeneric(\"hasAllFlinks\", function(x) standardGeneric(\"hasAllFlinks\"))\n\nsetGeneric(\"computeAllFlinks\",\n    function(x, ...) standardGeneric(\"computeAllFlinks\"))\n\nsetMethod(\"initialize\", \"PreprocessedTB\",\n    function(.Object, tb, pp_exclude, high2low, base_codes)\n    {\n        .Object@tb <- tb\n        .Object@exclude_dups0 <- !is.null(pp_exclude)\n        .Object@dups <- Dups(high2low)\n        .Object@base_codes <- base_codes  # should be 'xscodes(tb, baseOnly=TRUE)'\n        .Object\n    }\n)\n\n.PreprocessedTB.showFirstLine <- function(x)\n{\n    cat(\"Preprocessed Trusted Band\\n\")\n    cat(\"| length x width = \", length(x), \" x \", tb.width(x), \"\\n\", sep=\"\")\n    cat(\"| algorithm = \\\"\", class(x), \"\\\"\\n\", sep=\"\")\n}\n\nsetMethod(\"togrouplength\", \"PreprocessedTB\",\n    function(x, j=NULL) togrouplength(dups(x), j=j)\n)\n\nsetMethod(\"duplicated\", \"PreprocessedTB\",\n    function(x, incomparables=FALSE, ...) duplicated(dups(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"Twobit\" class.\n###\n### A low-level container for storing the PreprocessedTB object (preprocessed\n### Trusted Band) obtained with the \"Twobit\" algo.\n### With this algo, the 2-bit-per-letter signatures of all\n### the oligonucleotides in the Trusted Band are computed and the mapping\n### from these signatures to the 1-based position of the corresponding\n### oligonucleotide in the Trusted Band is stored in a way that allows very\n### fast lookup.\n###\n\nsetClass(\"Twobit\",\n    contains=\"PreprocessedTB\",\n    representation(\n        sign2pos=\"XInteger\"  # length(x@sign2pos) is tb.width(x)^4\n    )\n)\n\nsetMethod(\"show\", \"Twobit\",\n    function(object)\n    {\n        .PreprocessedTB.showFirstLine(object)\n        cat(\"| length of sign2pos lookup table = \",\n            length(object@sign2pos), \"\\n\", sep=\"\")\n    }\n)\n\nsetMethod(\"initialize\", \"Twobit\",\n    function(.Object, tb, pp_exclude)\n    {\n        base_codes <- xscodes(tb, baseOnly=TRUE)\n        C_ans <- .Call2(\"build_Twobit\", tb, pp_exclude, base_codes,\n                       PACKAGE=\"Biostrings\")\n        .Object <- callNextMethod(.Object, tb, pp_exclude, C_ans$high2low, base_codes)\n        .Object@sign2pos <- C_ans$sign2pos\n        .Object\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"ACtree2\" class.\n###\n### A low-level container for storing the PreprocessedTB object (preprocessed\n### Trusted Band) obtained with the \"ACtree2\" algo.\n###\n\n### Big Atomic Buffer of integers.\nsetClass(\"IntegerBAB\", representation(xp=\"externalptr\"))\n\nsetClass(\"ACtree2\",\n    contains=\"PreprocessedTB\",\n    representation(\n        nodebuf_ptr=\"IntegerBAB\",\n        nodeextbuf_ptr=\"IntegerBAB\"\n    )\n)\n\nsetMethod(\"nnodes\", \"ACtree2\",\n    function(x) .Call2(\"ACtree2_nnodes\", x, PACKAGE=\"Biostrings\")\n)\n\nsetMethod(\"hasAllFlinks\", \"ACtree2\",\n    function(x) .Call2(\"ACtree2_has_all_flinks\", x, PACKAGE=\"Biostrings\")\n)\n\nsetMethod(\"computeAllFlinks\", \"ACtree2\",\n    function(x) .Call2(\"ACtree2_compute_all_flinks\", x, PACKAGE=\"Biostrings\")\n)\n\nsetMethod(\"show\", \"ACtree2\",\n    function(object)\n    {\n        .PreprocessedTB.showFirstLine(object)\n        invisible(.Call2(\"ACtree2_summary\", object, PACKAGE=\"Biostrings\"))\n    }\n)\n\nsetMethod(\"initialize\", \"ACtree2\",\n    function(.Object, tb, pp_exclude)\n    {\n        nodebuf_max_nblock <- .Call2(\"ACtree2_nodebuf_max_nblock\",\n                                    PACKAGE=\"Biostrings\")\n        nodebuf_ptr <- .Call2(\"IntegerBAB_new\", nodebuf_max_nblock,\n                             PACKAGE=\"Biostrings\")\n        nodeextbuf_max_nblock <- .Call2(\"ACtree2_nodeextbuf_max_nblock\",\n                                       PACKAGE=\"Biostrings\")\n        nodeextbuf_ptr <- .Call2(\"IntegerBAB_new\", nodeextbuf_max_nblock,\n                                PACKAGE=\"Biostrings\")\n        base_codes <- xscodes(tb, baseOnly=TRUE)\n        C_ans <- .Call2(\"ACtree2_build\",\n                       tb, pp_exclude, base_codes,\n                       nodebuf_ptr, nodeextbuf_ptr,\n                       PACKAGE=\"Biostrings\")\n        .Object <- callNextMethod(.Object, tb, pp_exclude, C_ans$high2low, base_codes)\n        .Object@nodebuf_ptr <- nodebuf_ptr\n        .Object@nodeextbuf_ptr <- nodeextbuf_ptr\n        .Object\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"PDict3Parts\" class.\n###\n\nsetClass(\"PDict3Parts\",\n    representation(\n        head=\"DNAStringSet\",\n        pptb=\"PreprocessedTB\",\n        tail=\"DNAStringSet\"\n    )\n)\n\nsetMethod(\"length\", \"PDict3Parts\", function(x) length(x@pptb))\n\nsetMethod(\"width\", \"PDict3Parts\",\n    function(x) { width(x@head) + width(x@pptb) + width(x@tail) }\n)\n\nsetMethod(\"head\", \"PDict3Parts\",\n    function(x, ...)\n    {\n        if (all(width(x@head) == 0L))\n            return(NULL)\n        x@head\n    }\n)\n\nsetMethod(\"tb\", \"PDict3Parts\", function(x) tb(x@pptb))\n\nsetMethod(\"tb.width\", \"PDict3Parts\", function(x) tb.width(x@pptb))\n\nsetMethod(\"tail\", \"PDict3Parts\",\n    function(x, ...)\n    {\n        if (all(width(x@tail) == 0L))\n            return(NULL)\n        x@tail\n    }\n)\n\n.PDict3Parts <- function(x, tb.start, tb.end, tb.width, algo, pptb0)\n{\n    threeparts <- threebands(x, start=tb.start, end=tb.end, width=tb.width)\n    head <- threeparts$left\n    tb <- threeparts$middle\n    tail <- threeparts$right\n    if (is.null(pptb0)) {\n        pptb <- new(algo, tb, NULL)\n    } else {\n        use_pptb0 <- algo == class(pptb0) &&\n                     all(width(head) == 0L) && all(width(tail) == 0L)\n        if (use_pptb0) {\n            ## We can avoid doing the expensive preprocessing again by\n            ## making the 'pptb' that would be returned by\n            ## 'new(algo, tb, high2low(dups(pptb0)))':\n            pptb <- pptb0\n            pptb@dups <- Dups(rep.int(as.integer(NA), length(pptb)))\n            pptb@exclude_dups0 <- TRUE\n        } else {\n            pptb <- new(algo, tb, high2low(dups(pptb0)))\n        }\n    }\n    new(\"PDict3Parts\", head=head, pptb=pptb, tail=tail)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"PDict\" VIRTUAL class (top level).\n###\n### A (virtual) container for storing a preprocessed dictionary of DNA\n### patterns that can later be passed to the matchPDict() function for fast\n### matching.\n###\n\n### TODO: Use dups0=\"Dups_OR_NULL\" below like for the ByPos_MIndex class (see\n### MIndex-class.R).\nsetClass(\"PDict\",\n    contains=\"List\",\n    representation(\n        \"VIRTUAL\",\n        dict0=\"DNAStringSet\",\n        constant_width=\"logical\",\n        dups0=\"Dups\"  # TODO: use Dups_OR_NULL instead!\n    ),\n    prototype(\n        elementType=\"DNAString\"\n    )\n)\n\nsetMethod(\"length\", \"PDict\", function(x) length(x@dict0))\n\nsetMethod(\"width\", \"PDict\", function(x) width(x@dict0))\n\nsetMethod(\"names\", \"PDict\", function(x) names(x@dict0))\n\nsetReplaceMethod(\"names\", \"PDict\",\n    function(x, value)\n        stop(\"attempt to modify the names of a \", class(x), \" instance\")\n)\n\nsetMethod(\"dups\", \"PDict\",\n    function(x) if (length(x@dups0) == 0) NULL else x@dups0\n)\n\n### Extract the i-th element of a PDict object as DNAString object.\n### Note that only the \"[[\" operator is provided for now. Providing \"[\" sounds\n### like a nice feature too but 'x[i]' would have to return a PDict object of\n### the same PDict subtype as 'x' i.e. a preprocessed dictionary where the\n### preprocessed data structure reflects the subsetted dictionary.\n### For example if the preprocessed data structure is an Aho-Corasick tree,\n### then this tree needs to be updated so that it stays in sync with\n### 'x@dict0[i]'. This updating operation might be complex and expensive in\n### terms of CPU cycles and/or memory usage. It could even be that its cost is\n### in fact greater than preprocessing again 'x@dict0[i]' from scratch!\n### So in the end, \"[\" would not have much value (other than providing some\n### convenience) over the approach that consists to ask the user to do the\n### subsetting upstream i.e. to subset the original dictionary before s/he\n### passes it to PDict() again.\nsetMethod(\"[[\", \"PDict\",\n    function(x, i, j, ...)\n    {\n        i <- normalizeDoubleBracketSubscript(i, x)\n        x@dict0[[i]]\n    }\n)\n\nsetMethod(\"togrouplength\", \"PDict\",\n    function(x, j=NULL)\n    {\n        if (is.null(dups(x)))\n            stop(\"duplicates information not available for this object\")\n        togrouplength(dups(x), j=j)\n    }\n)\n\nsetMethod(\"duplicated\", \"PDict\",\n    function(x, incomparables=FALSE, ...)\n    {\n        if (is.null(dups(x)))\n            stop(\"duplicates information not available for this object\")\n        duplicated(dups(x))\n    }\n)\n\n### Just an alias for \"togrouplength\".\nsetGeneric(\"patternFrequency\", function(x) standardGeneric(\"patternFrequency\"))\nsetMethod(\"patternFrequency\", \"PDict\", function(x) togrouplength(x))\n\n.PDict.showFirstLine <- function(x, algo)\n{\n    cat(class(x), \" object of length \", length(x), sep=\"\")\n    if (x@constant_width) {\n        width <- width(x@dict0)[1]\n        width_info <- paste(\"width \", width, sep=\"\")\n    } else {\n        width_info <- \"variable width\"\n    }\n    cat(\" and \", width_info, sep=\"\")\n    if (!is.null(algo))\n        cat(\" (preprocessing algo=\\\"\", algo, \"\\\")\", sep=\"\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"TB_PDict\" class.\n###\n### A container for storing a Trusted Band PDict object.\n###\n\nsetClass(\"TB_PDict\",\n    contains=\"PDict\",\n    representation(\n        threeparts=\"PDict3Parts\"\n    )\n)\n\nsetMethod(\"head\", \"TB_PDict\", function(x, ...) head(x@threeparts))\nsetMethod(\"tb\", \"TB_PDict\", function(x) tb(x@threeparts))\nsetMethod(\"tb.width\", \"TB_PDict\", function(x) tb.width(x@threeparts))\nsetMethod(\"tail\", \"TB_PDict\", function(x, ...) tail(x@threeparts))\n\nsetMethod(\"show\", \"TB_PDict\",\n    function(object)\n    {\n        algo <- class(object@threeparts@pptb)\n        .PDict.showFirstLine(object, algo)\n        head <- head(object)\n        tail <- tail(object)\n        if (is.null(head) && is.null(tail))\n             return(cat(\"\\n\", sep=\"\"))\n        cat(\":\\n\")\n        if (is.null(head)) {\n            cat(\"  - with NO head\")\n        } else {\n            cat(\"  - with a head of \")\n            min_width <- min(width(head))\n            max_width <- max(width(head))\n            if (min_width == max_width)\n                cat(\"width \", min_width, sep=\"\")\n            else\n                cat(\"variable width (min=\", min_width,\n                    \" / max=\", max_width, \")\", sep=\"\")\n        }\n        cat(\"\\n\")\n        cat(\"  - with a Trusted Band of width \", tb.width(object), sep=\"\")\n        cat(\"\\n\")\n        if (is.null(tail)) {\n            cat(\"  - with NO tail\")\n        } else {\n            cat(\"  - with a tail of \")\n            min_width <- min(width(tail))\n            max_width <- max(width(tail))\n            if (min_width == max_width)\n                cat(\"width \", min_width, sep=\"\")\n            else\n                cat(\"variable width (min=\", min_width,\n                    \" / max=\", max_width, \")\", sep=\"\")\n        }\n        cat(\"\\n\")\n    }\n)\n\n.TB_PDict <- function(x, tb.start, tb.end, tb.width, algo)\n{\n    constant_width <- isConstant(width(x))\n    if (constant_width && hasOnlyBaseLetters(x))\n        pptb0 <- new(\"ACtree2\", x, NULL)  # because ACtree2 supports big input\n    else\n        pptb0 <- NULL\n    threeparts <- .PDict3Parts(x, tb.start, tb.end, tb.width, algo, pptb0)\n    ans <- new(\"TB_PDict\", dict0=x,\n                           constant_width=constant_width,\n                           threeparts=threeparts)\n    ## '!is.null(pptb0)' should be the same as 'threeparts@pptb@exclude_dups0'\n    if (!is.null(pptb0))\n        ans@dups0 <- dups(pptb0)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"MTB_PDict\" class.\n###\n### A container for storing a Multiple Trusted Band PDict object.\n###\n\nsetClass(\"MTB_PDict\",\n    contains=\"PDict\",\n    representation(\n        threeparts_list=\"list\"\n    )\n)\n\nsetMethod(\"as.list\", \"MTB_PDict\",\n    function(x, ...)\n    {\n        lapply(x@threeparts_list,\n          function(threeparts)\n              new(\"TB_PDict\", dict0=x@dict0,\n                              constant_width=x@constant_width,\n                              dups0=x@dups0,\n                              threeparts=threeparts)\n        )\n    }\n)\n\nsetMethod(\"show\", \"MTB_PDict\",\n    function(object)\n    {\n        cat(\"  \")\n        .PDict.showFirstLine(object, NULL)\n        cat(\"\\nComponents:\\n\")\n        show(as.list(object))\n    }\n)\n\n### 'max.mismatch' is assumed to be an integer >= 1\n.MTB_PDict <- function(x, max.mismatch, algo)\n{\n    min.TBW <- 3L\n    min_width <- min(width(x))\n    if (min_width < 2L * min.TBW)\n        stop(\"'max.mismatch >= 1' is supported only if the width \",\n             \"of dictionary 'x' is >= \", 2L * min.TBW)\n    constant_width <- isConstant(width(x))\n    NTB <- max.mismatch + 1L # nb of Trusted Bands\n    TBW0 <- min_width %/% NTB\n    if (TBW0 < min.TBW) {\n        max.max.mismatch <- min_width %/% min.TBW - 1L\n        stop(\"'max.mismatch' must be <= \", max.max.mismatch,\n             \" given the width of dictionary 'x'\")\n    }\n    all_tbw0 <- rep.int(TBW0, NTB - min_width %% NTB)\n    all_tbw1 <- rep.int(TBW0 + 1L, min_width %% NTB)\n    all_tbw <- c(all_tbw0, all_tbw1)\n    ## R1 is the average number of (perfect) matches that is expected\n    ## to be found during stage1 each time the sliding window is moved\n    ## to the next position.\n    R1 <- length(x) * sum(1/4^all_tbw)\n    if (R1 > 10)\n        warning(\"given the characteristics of dictionary 'x', \",\n                \"this value of 'max.mismatch' will\\n\",\n                \"  give poor performance when you call \",\n                \"matchPDict() on this MTB_PDict object\\n\",\n                \"  (it will of course depend ultimately on the \",\n                \"length of the subject)\")\n    all_headw <- diffinv(all_tbw)\n    if (constant_width)\n        pptb0 <- new(\"ACtree2\", x, NULL)  # because ACtree2 supports big input\n    else\n        pptb0 <- NULL\n    threeparts_list <- lapply(seq_len(NTB),\n                         function(i)\n                           .PDict3Parts(x, all_headw[i]+1L, all_headw[i+1L], NA, algo, pptb0)\n                       )\n    ans <- new(\"MTB_PDict\", dict0=x,\n                            constant_width=constant_width,\n                            threeparts_list=threeparts_list)\n    if (!is.null(pptb0))\n        ans@dups0 <- dups(pptb0)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"Expanded_TB_PDict\" class.\n###\n\nsetClass(\"Expanded_TB_PDict\",\n    contains=\"TB_PDict\",\n    representation(\n        expanded_dict0=\"DNAStringSetList\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The PDict() constructor (user-friendly).\n###\n\n.PDict <- function(x, max.mismatch, tb.start, tb.end, tb.width,\n                      algo, skip.invalid.patterns)\n{\n    if (!is(x, \"DNAStringSet\"))\n        x <- DNAStringSet(x)\n    if (length(x) == 0)\n        stop(\"'x' must contain at least one pattern\")\n    names <- names(x)\n    if (!is.null(names)) {\n        if (any(names %in% c(\"\", NA)))\n            stop(\"'x' has invalid names\")\n        if (any(duplicated(names)))\n            stop(\"'x' has duplicated names\")\n    }\n    if (!isSingleNumberOrNA(max.mismatch))\n        stop(\"'max.mismatch' must be a single integer or 'NA'\")\n    if (!is.integer(max.mismatch))\n        max.mismatch <- as.integer(max.mismatch)\n    if (!isSingleNumberOrNA(tb.start))\n        stop(\"'tb.start' must be a single integer or 'NA'\")\n    if (!isSingleNumberOrNA(tb.end))\n        stop(\"'tb.end' must be a single integer or 'NA'\")\n    if (!isSingleNumberOrNA(tb.width))\n        stop(\"'tb.width' must be a single integer or 'NA'\")\n    if (!is.character(algo))\n        stop(\"'algorithm' must be a character vector\")\n    if (\"ACtree\" %in% algo) {\n        warning(\"support for ACtree preprocessing algo has been \",\n                \"dropped, using ACtree2 algo\")\n        algo[!is.na(match(algo, \"ACtree\"))] <- \"ACtree2\"\n    }\n    if (!identical(skip.invalid.patterns, FALSE))\n        stop(\"'skip.invalid.patterns' must be FALSE for now, sorry\")\n    is_default_TB <- is.na(tb.start) && is.na(tb.end) && is.na(tb.width)\n    if (!is.na(max.mismatch) && !is_default_TB)\n            stop(\"'tb.start', 'tb.end' and 'tb.width' must be NAs \",\n                 \"when 'max.mismatch' is not NA\")\n    if (is.na(max.mismatch) || max.mismatch == 0) {\n        .TB_PDict(x, tb.start, tb.end, tb.width, algo)\n    } else {\n        if (max.mismatch < 0)\n            stop(\"'max.mismatch' must be 'NA' or >= 0\")\n        .MTB_PDict(x, max.mismatch, algo)\n    }\n}\n\nsetGeneric(\"PDict\", signature=\"x\",\n    function(x, max.mismatch=NA, tb.start=NA, tb.end=NA, tb.width=NA,\n                algorithm=\"ACtree2\", skip.invalid.patterns=FALSE)\n        standardGeneric(\"PDict\")\n)\n\nsetMethod(\"PDict\", \"character\",\n    function(x, max.mismatch=NA, tb.start=NA, tb.end=NA, tb.width=NA,\n                algorithm=\"ACtree2\", skip.invalid.patterns=FALSE)\n        .PDict(x, max.mismatch, tb.start, tb.end, tb.width,\n                  algorithm, skip.invalid.patterns)\n)\n\nsetMethod(\"PDict\", \"DNAStringSet\",\n    function(x, max.mismatch=NA, tb.start=NA, tb.end=NA, tb.width=NA,\n                algorithm=\"ACtree2\", skip.invalid.patterns=FALSE)\n        .PDict(x, max.mismatch, tb.start, tb.end, tb.width,\n                  algorithm, skip.invalid.patterns)\n)\n\nsetMethod(\"PDict\", \"XStringViews\",\n    function(x, max.mismatch=NA, tb.start=NA, tb.end=NA, tb.width=NA,\n                algorithm=\"ACtree2\", skip.invalid.patterns=FALSE)\n    {\n        if (!is(subject(x), \"DNAString\"))\n            stop(\"'subject(x)' must be a DNAString object\")\n        .PDict(x, max.mismatch, tb.start, tb.end, tb.width,\n                  algorithm, skip.invalid.patterns)\n    }\n)\n\n### 2 extra \"PDict\" methods to deal with the probe sequences stored\n### in the *probe annotation packages (e.g. drosophila2probe).\nsetMethod(\"PDict\", \"AsIs\",\n    function(x, max.mismatch=NA, tb.start=NA, tb.end=NA, tb.width=NA,\n                algorithm=\"ACtree2\", skip.invalid.patterns=FALSE)\n        .PDict(x, max.mismatch, tb.start, tb.end, tb.width,\n                  algorithm, skip.invalid.patterns)\n)\nsetMethod(\"PDict\", \"probetable\",\n    function(x, max.mismatch=NA, tb.start=NA, tb.end=NA, tb.width=NA,\n                algorithm=\"ACtree2\", skip.invalid.patterns=FALSE)\n        PDict(x$sequence, max.mismatch=max.mismatch,\n              tb.start=tb.start, tb.end=tb.end, tb.width=tb.width,\n              algorithm=algorithm, skip.invalid.patterns=skip.invalid.patterns)\n)\n\n",
        "QualityScaledXStringSet.R": "### =========================================================================\n### QualityScaledXStringSet objects\n### -------------------------------------------------------------------------\n###\n\n\nsetClass(\"QualityScaledXStringSet\",\n    contains=\"XStringSet\",\n    representation(\n        \"VIRTUAL\",\n        quality=\"XStringQuality\"\n    )\n)\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"QualityScaledXStringSet\",\n    function(x) c(\"quality\", callNextMethod())\n)\n\n### QualityScaledXStringSet subclasses\nsetClass(\"QualityScaledBStringSet\",\n    contains=c(\"BStringSet\", \"QualityScaledXStringSet\")\n)\nsetClass(\"QualityScaledDNAStringSet\",\n    contains=c(\"DNAStringSet\", \"QualityScaledXStringSet\")\n)\nsetClass(\"QualityScaledRNAStringSet\",\n    contains=c(\"RNAStringSet\", \"QualityScaledXStringSet\")\n)\nsetClass(\"QualityScaledAAStringSet\",\n    contains=c(\"AAStringSet\", \"QualityScaledXStringSet\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid.QualityScaledXStringSet <- function(object)\n{\n    message <- NULL\n    if (!all(nchar(object@quality) == 1 | nchar(object@quality) == nchar(object)))\n        message <- c(message, \"'nchar(quality)' must equal 1 or nchar of 'XStringSet'\")\n    message\n}\n\nsetValidity(\"QualityScaledXStringSet\",\n    function(object)\n    {\n        problems <- .valid.QualityScaledXStringSet(object)\n        if (is.null(problems)) TRUE else problems\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods\n###\n\nsetGeneric(\"quality\", function(x) standardGeneric(\"quality\"), useAsDefault = function(x) x@quality)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The user-friendly versatile constructors\n###\n\n### The returned 'quality' is guaranteed to have the shape of 'x' (i.e. same\n### length() and width()).\n.normarg_quality <- function(quality, x)\n{\n    if (!is(quality, \"XStringQuality\"))\n        stop(\"'quality' must be of class 'XStringQuality'\")\n    quality_width <- width(quality)\n    x_width <- width(x)\n    if (length(quality) == length(x)) {\n        recycle_me <- quality_width != x_width\n        if (any(recycle_me & quality_width != 1L))\n            stop(wmsg(\"the quality strings must be of length 1 or have the \",\n                      \"same length as their corresponding string in 'x'\"))\n        recycle_idx <- which(recycle_me)\n        width2 <- x_width[recycle_idx]\n        idx <- relist(rep.int(1L, sum(width2)), PartitioningByWidth(width2))\n        quality[recycle_idx] <- quality[recycle_idx][idx]\n        return(quality)\n    }\n    if (length(quality) == 1L) {\n        if (all(x_width == quality_width))\n            return(rep.int(quality, length(x)))\n        if (quality_width != 1L)\n            stop(wmsg(\"when 'quality' is a single string it must be \",\n                      \"a single letter or have the same width as all \",\n                      \"the strings in 'x'\"))\n        quality <- PhredQuality(BStringSet(rep.int(quality[[1L]], max(x_width)),\n                                           start=1L, end=x_width))\n        return(quality)\n    }\n    stop(\"'length(quality)' must equal 'length(x)' or 1\")\n}\n\nQualityScaledXStringSet <- function(x, quality) {\n    if (!is(x, \"XStringSet\"))\n        stop(\"'x' must be of class 'XStringSet'\")\n    quality <- .normarg_quality(quality, x)\n    output <- as(x, paste0(\"QualityScaled\", class(x)))\n    slot(output, \"quality\", check=FALSE) <- quality\n    output\n}\n\nQualityScaledBStringSet <- function(x, quality) QualityScaledXStringSet(BStringSet(x), quality)\nQualityScaledDNAStringSet <- function(x, quality) QualityScaledXStringSet(DNAStringSet(x), quality)\nQualityScaledRNAStringSet <- function(x, quality) QualityScaledXStringSet(RNAStringSet(x), quality)\nQualityScaledAAStringSet <- function(x, quality) QualityScaledXStringSet(AAStringSet(x), quality)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Overwrite some endomorphic methods for XStringSet objects\n###\n\n### The default \"narrow\" method calls windows() so we only need to implement\n### a \"windows\" method for QualityScaledXStringSet objects to make narrow()\n### work on these objects.\nsetMethod(\"windows\", \"QualityScaledXStringSet\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        x@quality <- windows(x@quality, start=start, end=end, width=width)\n        callNextMethod()\n    }\n)\n\nsetMethod(\"reverse\", \"QualityScaledXStringSet\",\n    function(x)\n    {\n        x@quality <- reverse(x@quality)\n        callNextMethod()\n    }\n)\n\nsetMethod(\"reverseComplement\", \"QualityScaledDNAStringSet\",\n    function(x)\n    {\n        x@quality <- reverse(x@quality)\n        callNextMethod()\n    }\n)\n\nsetMethod(\"reverseComplement\", \"QualityScaledRNAStringSet\",\n    function(x)\n    {\n        x@quality <- reverse(x@quality)\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### show()\n###\n\nsetMethod(\"show\", \"QualityScaledXStringSet\",\n    function(object)\n    {\n        cat(\"  A \", class(object), \" instance containing:\\n\", sep=\"\")\n        cat(\"\\n\")\n        selectMethod(\"show\", \"XStringSet\")(as(object, \"XStringSet\"))\n        cat(\"\\n\")\n        show(quality(object))\n        cat(\"\\n\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### readQualityScaledDNAStringSet() / writeQualityScaledXStringSet()\n###\n\nreadQualityScaledDNAStringSet <- function(filepath,\n                       quality.scoring=c(\"phred\", \"solexa\", \"illumina\"),\n                       nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                       use.names=TRUE)\n{\n    quality.scoring <- match.arg(quality.scoring)\n    x <- readDNAStringSet(filepath, format=\"fastq\",\n                          nrec, skip, seek.first.rec,\n                          use.names, with.qualities=TRUE)\n    qualities <- mcols(x)[ , \"qualities\"]\n    ## Drop the 'qualities' metadata column from the DNAStringSet\n    ## object, since it gets passed into the QualityScaledDNAStringSet\n    ## constructor via the 'quals' argument anyway (otherwise we get a\n    ## warning that doesn't make sense).\n    mcols(x)[ , \"qualities\"] <- NULL\n    if (ncol(mcols(x)) == 0L)\n        mcols(x) <- NULL\n    quals <- switch(quality.scoring,\n                    phred=PhredQuality(qualities),\n                    solexa=SolexaQuality(qualities),\n                    illumina=IlluminaQuality(qualities))\n    QualityScaledDNAStringSet(x, quals)\n}\n\nwriteQualityScaledXStringSet <- function(x, filepath,\n                       append=FALSE, compress=FALSE, compression_level=NA)\n{\n    if (!is(x, \"QualityScaledXStringSet\"))\n        stop(wmsg(\"'x' must be a QualityScaledXStringSet object\"))\n    writeXStringSet(x, filepath, append, compress, compression_level,\n                       format=\"fastq\", qualities=quality(x))\n}\n",
        "SparseList-class.R": "### =========================================================================\n### SparseList objects\n### -------------------------------------------------------------------------\n###\n\nsetClass(\"SparseList\",\n    representation(\n        length=\"integer\",\n        env=\"environment\"\n    )\n)\n\n### Typical use:\n###   env <- new.env(hash=TRUE, parent=emptyenv())\n###   key <- formatC(98L, width=10, format=\"d\", flag=\"0\")\n###   value <- 3:-2\n###   assign(key, value, envir=env)\n###   x <- new(\"SparseList\", length=100L, env=env)\n###   length(x)\n###   ls(x)\n###   ls(x, all.names=TRUE)\n###   as.list(x)\n###   as.list(x, all.names=TRUE)\n###   x[[1]]\n###   x[[98]\n###   x[[101]]]\n###\n\nsetMethod(\"length\", \"SparseList\", function(x) x@length)\n\n### 'pos', 'envir' and 'pattern' args are ignored\nsetMethod(\"ls\", signature(name=\"SparseList\"),\n    function(name, pos, envir, all.names=FALSE, pattern)\n    {\n        if (!all.names)\n            return(ls(name@env, all.names=TRUE))\n        seq_len(length(name))\n    }\n)\n\nsetMethod(\"as.list\", \"SparseList\",\n    function(x, all.names=FALSE, ...)\n    {\n        if (!all.names)\n            return(as.list(x@env, all.names=TRUE))\n        ans <- vector(mode=\"list\", length=length(x))\n        symbols <- ls(x)\n        for (symb in symbols)\n            ans[[as.integer(symb)]] <- get(symb, envir=x@env)\n        ans\n    }\n)\n\n### Supported 'i' types: character or numeric vector of length 1.\nsetMethod(\"[[\", \"SparseList\",\n    function(x, i, j, ...)\n    {\n        if (!missing(j) || length(list(...)) > 0)\n            stop(\"invalid subsetting\")\n        if (missing(i))\n            stop(\"subscript is missing\")\n        if (!is.character(i) && !is.numeric(i))\n            stop(\"invalid subscript type\")\n        if (length(i) < 1L)\n            stop(\"attempt to select less than one element\")\n        if (length(i) > 1L)\n            stop(\"attempt to select more than one element\")\n        if (is.na(i))\n            stop(\"subscript cannot be NA\")\n        if (is.character(i))\n            return(get(i, envir=x@env))\n        if (!is.integer(i))\n            i <- as.integer(i)\n        if (i < 1L || i > length(x))\n            stop(\"subscript out of bounds\")\n        i <- formatC(i, width=10, format=\"d\", flag=\"0\")\n        get(i, envir=x@env)\n    }\n)\n\n",
        "XString-class.R": "### =========================================================================\n### XString objects\n### -------------------------------------------------------------------------\n###\n### The XString virtual class is a general container for storing an \"external\n### string\".\n###\n\nsetClass(\"XString\", contains=\"XRaw\", representation(\"VIRTUAL\"))\n\n### XString subclasses (no additional slots)\nsetClass(\"BString\", contains=\"XString\")\nsetClass(\"DNAString\", contains=\"XString\")\nsetClass(\"RNAString\", contains=\"XString\")\nsetClass(\"AAString\", contains=\"XString\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor-like methods.\n###\n\nsetMethod(\"nchar\", \"XString\", function(x, type=\"chars\", allowNA=FALSE) length(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"seqtype\" and \"seqtype<-\" methods.\n###\n\nsetMethod(\"seqtype\", \"BString\", function(x) \"B\")\nsetMethod(\"seqtype\", \"DNAString\", function(x) \"DNA\")\nsetMethod(\"seqtype\", \"RNAString\", function(x) \"RNA\")\nsetMethod(\"seqtype\", \"AAString\", function(x) \"AA\")\n\n.copySubSharedRaw <- function(x, start=1, nchar=NA, lkup=NULL)\n{\n    ans <- SharedRaw(nchar)\n    SharedVector.copy(ans, start, start + nchar - 1L, src=x, lkup=lkup)\n}\n\n### Downgrades 'x' to a B/DNA/RNA/AAString instance!\nsetReplaceMethod(\"seqtype\", \"XString\",\n    function(x, value)\n    {\n        from_seqtype <- seqtype(x)\n        to_seqtype <- value\n        ans_class <- paste(to_seqtype, \"String\", sep=\"\")\n        lkup <- get_seqtype_conversion_lookup(from_seqtype, to_seqtype)\n        if (is.null(lkup))\n            return(new(ans_class, shared=x@shared, offset=x@offset, length=x@length))\n        shared <- .copySubSharedRaw(x@shared, start=x@offset+1L, nchar=x@length, lkup=lkup)\n        new(ans_class, shared=shared, length=length(shared))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### XString.readCodes()\n###\n\nXString.readCodes <- function(x, i, imax=integer(0))\n{\n    SharedRaw.readInts(x@shared, x@offset + i, x@offset + imax)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_character_from_XString_by_positions() and\n### extract_character_from_XString_by_ranges()\n###\n### Low-level generics called by the as.character(), show(), and letter()\n### methods for XString and XStringViews objects. Not intended to be called\n### directly by the end user.\n### Purpose is to facilitate support for XString derivatives defined in\n### other packages. For example, defining the following methods in the\n### Modstrings package will make as.character(), show(), and letter()\n### work as expected on ModString and ModStringViews objects (granted\n### that seqtype() works properly on ModString derivatives via appropriate\n### methods):\n###\n###   setMethod(\"extract_character_from_XString_by_positions\", \"ModString\",\n###       function(x, pos, collapse=FALSE)\n###       {\n###           ans <- callNextMethod()\n###           codec <- modscodec(seqtype(x))\n###           .convert_one_byte_codes_to_letters(ans, codec)\n###       }\n###   )\n###   setMethod(\"extract_character_from_XString_by_ranges\", \"ModString\",\n###       function(x, start, width, collapse=FALSE)\n###       {\n###           ans <- callNextMethod()\n###           codec <- modscodec(seqtype(x))\n###           .convert_one_byte_codes_to_letters(ans, codec)\n###       }\n###   )\n###\n\nsetGeneric(\"extract_character_from_XString_by_positions\", signature=\"x\",\n    function(x, pos, collapse=FALSE)\n    {\n        ## Only light checking of 'pos' (i.e. we don't check that it contains\n        ## valid positions on 'x').\n        stopifnot(is(x, \"XString\"), is.integer(pos))\n        ans <- standardGeneric(\"extract_character_from_XString_by_positions\")\n        stopifnot(is.character(ans))\n        ans\n    }\n)\n\n### Default method.\nsetMethod(\"extract_character_from_XString_by_positions\", \"XString\",\n    function(x, pos, collapse=FALSE)\n    {\n        XVector:::extract_character_from_XRaw_by_positions(x, pos,\n                                                           collapse=collapse,\n                                                           lkup=xs_dec_lkup(x))\n    }\n)\n\nsetGeneric(\"extract_character_from_XString_by_ranges\", signature=\"x\",\n    function(x, start, width, collapse=FALSE)\n    {\n        ## Only light checking of 'start' and 'width' (i.e. we don't check\n        ## that they have the same length and define valid ranges on 'x').\n        stopifnot(is(x, \"XString\"), is.integer(start), is.integer(width))\n        ans <- standardGeneric(\"extract_character_from_XString_by_ranges\")\n        stopifnot(is.character(ans))\n        ans\n    }\n)\n\n### Default method.\nsetMethod(\"extract_character_from_XString_by_ranges\", \"XString\",\n    function(x, start, width, collapse=FALSE)\n    {\n        XVector:::extract_character_from_XRaw_by_ranges(x, start, width,\n                                                        collapse=collapse,\n                                                        lkup=xs_dec_lkup(x))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### make_XString_from_string()\n###\n### Low-level generic called by XString() constructor. Not intended to be\n### called directly by the end user.\n### Purpose is to make it easy to extend the XString() constructor to\n### support XString derivatives defined in other packages. For example,\n### defining the following method in the Modstrings package will make calls\n### of the form 'XString(\"ModDNA\", ...)' work (granted that seqtype() works\n### properly on ModDNAString objects via appropriate methods):\n###\n###   setMethod(\"make_XString_from_string\", \"ModString\",\n###       function(x0, string, start, width)\n###       {\n###           codec <- modscodec(seqtype(x0))\n###           string <- .convert_letters_to_one_byte_codes(string, codec)\n###           callNextMethod()\n###       }\n###   )\n###\n\nsetGeneric(\"make_XString_from_string\", signature=\"x0\",\n    function(x0, string, start, width)\n    {\n        ## Only light checking of 'start' and 'width' (i.e. we don't check\n        ## that they define a valid range on 'string').\n        stopifnot(is(x0, \"XString\"),\n                  isSingleInteger(start),\n                  isSingleInteger(width))\n        if (!isSingleString(string))\n            stop(wmsg(\"input must be a single non-NA string\"))\n        ans <- standardGeneric(\"make_XString_from_string\")\n        stopifnot(class(ans) == class(x0))\n        ans\n    }\n)\n\n### Default method.\nsetMethod(\"make_XString_from_string\", \"XString\",\n    function(x0, string, start, width)\n    {\n        lkup <- get_seqtype_conversion_lookup(\"B\", seqtype(x0))\n        .Call2(\"new_XString_from_CHARACTER\",\n               class(x0), string, start, width, lkup,\n               PACKAGE=\"Biostrings\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The XString() constructor. NOT exported.\n###\n### This constructor and its helper functions use the uSEW (user-specified\n### Start/End/Width) interface.\n###\n\nsetGeneric(\"XString\", signature=\"x\",\n    function(seqtype, x, start=NA, end=NA, width=NA)\n        standardGeneric(\"XString\")\n)\n\n.charToXString <- function(seqtype, string, start, end, width)\n{\n    if (!isSingleString(string))\n        stop(wmsg(\"input must be a single non-NA string\"))\n    x0 <- new2(paste0(seqtype, \"String\"), check=FALSE)\n    solved_SEW <- solveUserSEW(width(string),\n                               start=start, end=end, width=width)\n    make_XString_from_string(x0, string, start(solved_SEW), width(solved_SEW))\n}\n\nsetMethod(\"XString\", \"character\",\n    function(seqtype, x, start=NA, end=NA, width=NA)\n    {\n        if (is.null(seqtype))\n            seqtype <- \"B\"\n        .charToXString(seqtype, x, start, end, width)\n    }\n)\n\nsetMethod(\"XString\", \"factor\",\n    function(seqtype, x, start=NA, end=NA, width=NA)\n    {\n        if (is.null(seqtype))\n            seqtype <- \"B\"\n        .charToXString(seqtype, as.character(x), start, end, width)\n    }\n)\n\nsetMethod(\"XString\", \"XString\",\n    function(seqtype, x, start=NA, end=NA, width=NA)\n    {\n        ans <- subseq(x, start=start, end=end, width=width)\n        ## `seqtype<-` must be called even when user supplied 'seqtype' is\n        ## NULL because we want to enforce downgrade to a B/DNA/RNA/AAString\n        ## instance\n        if (is.null(seqtype))\n            seqtype <- seqtype(x)\n        seqtype(ans) <- seqtype\n        ans\n    }\n)\n\n### Just because of the silly \"AsIs\" objects found in the probe packages\n### (e.g. drosophila2probe$sequence)\nsetMethod(\"XString\", \"AsIs\",\n    function(seqtype, x, start=NA, end=NA, width=NA)\n    {\n        if (!is.character(x))\n            stop(\"unsupported input type\")\n        class(x) <- \"character\" # keeps the names (unlike as.character())\n        XString(seqtype, x, start=start, end=end, width=width)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The user interfaces to the XString() constructor.\n###\n\nBString <- function(x=\"\", start=1, nchar=NA)\n    XString(\"B\", x, start=start, width=nchar)\n\nDNAString <- function(x=\"\", start=1, nchar=NA)\n    XString(\"DNA\", x, start=start, width=nchar)\n\nRNAString <- function(x=\"\", start=1, nchar=NA)\n    XString(\"RNA\", x, start=start, width=nchar)\n\nAAString <- function(x=\"\", start=1, nchar=NA)\n    XString(\"AA\", x, start=start, width=nchar)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"XString\", \"BString\",\n    function(from) {seqtype(from) <- \"B\"; from}\n)\nsetAs(\"XString\", \"DNAString\",\n    function(from) {seqtype(from) <- \"DNA\"; from}\n)\nsetAs(\"XString\", \"RNAString\",\n    function(from) {seqtype(from) <- \"RNA\"; from}\n)\nsetAs(\"XString\", \"AAString\",\n    function(from) {seqtype(from) <- \"AA\"; from}\n)\n\nsetAs(\"character\", \"BString\", function(from) BString(from))\nsetAs(\"character\", \"DNAString\", function(from) DNAString(from))\nsetAs(\"character\", \"RNAString\", function(from) RNAString(from))\nsetAs(\"character\", \"AAString\", function(from) AAString(from))\nsetAs(\"character\", \"XString\", function(from) BString(from))\n\nsetMethod(\"as.character\", \"XString\",\n    function(x)\n        extract_character_from_XString_by_ranges(x, 1L, length(x))\n)\n\nsetMethod(\"toString\", \"XString\", function(x, ...) as.character(x))\n\n### FIXME: Sometimes returns a vector sometimes a factor. This needs to be\n### sorted out. The use case is that as.data.frame() relies on this.\nsetMethod(\"as.vector\", \"XString\",\n    function(x)\n    {\n        codes <- xscodes(x)\n        x_alphabet <- names(codes)\n        if (is.null(x_alphabet)) {\n            ans <- rawToChar(as.raw(x), multiple=TRUE)\n            x_alphabet <- alphabet(x)\n            if (!is.null(x_alphabet))\n                ans <- factor(ans, levels=x_alphabet)\n            return(ans)\n        }\n        code2pos <- integer(length(codes))\n        code2pos[codes] <- seq_along(codes)\n        ans <- code2pos[as.integer(x)]\n        attributes(ans) <- list(levels=x_alphabet, class=\"factor\")\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\ncompact_ellipsis <- rawToChar(as.raw(c(0xe2, 0x80, 0xa6)))\n\n### NOT exported but used in the BSgenome package.\n### 'x' must be a single character string, or an XString or\n### MaskedXString object.\n### Return a character vector possibly with a class attribute on it for\n### later S3 dispatch in add_colors().\ntoSeqSnippet <- function(x, width)\n{\n    if (width < 7L)\n        width <- 7L\n    ## Do NOT use nchar() here as it wouldn't do the right thing on a\n    ## MaskedXString object!\n    x_len <- length(x)\n    if (x_len <= width) {\n        ans <- as.character(x)\n    } else {\n        w1 <- (width - 2L) %/% 2L\n        w2 <- (width - 3L) %/% 2L\n        ans <- paste0(as.character(subseq(x, start=1, width=w1)),\n                      #compact_ellipsis,\n                      \"...\",\n                      as.character(subseq(x, end=x_len, width=w2)))\n    }\n    if (is(x, \"XString\") || is(x, \"MaskedXString\"))\n        class(ans) <- c(seqtype(x), class(ans))  # for S3 dispatch\n                                                 # in add_colors()\n    ans\n}\n\nsetMethod(\"show\", \"XString\",\n    function(object)\n    {\n        object_len <- object@length\n        cat(object_len, \"-letter \", class(object), \" object\\n\", sep=\"\")\n        snippet <- toSeqSnippet(object, getOption(\"width\") - 5L)\n        cat(\"seq: \", add_colors(snippet), \"\\n\", sep=\"\")\n    }\n)\n\nsetMethod(\"showAsCell\", \"XString\",\n    function(object)\n    {\n        ans <- safeExplode(as.character(object))\n        class(ans) <- c(seqtype(object), class(ans))\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Equality.\n###\n### We want:\n###   BString(\"ab\") == \"ab\" # TRUE\n###   DNAString(\"TG\") == RNAString(\"UG\") # TRUE!!!\n###   library(BSgenome.Hsapiens.UCSC.hg18)\n###   dna <- Hsapiens$chr1\n###   dna != Hsapiens$chr1 # FALSE\n###   dnav <- Views(dna, start=1:7, end=101:107)\n###   dnav[[1]] == dnav[[7]] # TRUE\n###   dnav <- Views(dna, start=1:7, end=(length(dna)-6):length(dna))\n### This is fast:\n###   dnav[[1]] == dnav[[7]] # FALSE\n### But this would have killed your machine:\n###   s1 <- toString(dnav[[1]])\n###   s7 <- toString(dnav[[7]])\n###   s1 == s7\n\n### 'x' and 'y' must be XString objects\n.XString.equal <- function(x, y)\n{\n    if (x@length != y@length)\n        return(FALSE)\n    ans <- !SharedVector.compare(x@shared, x@offset + 1L, y@shared, y@offset + 1L, x@length)\n    as.logical(ans)\n}\n\nsetMethod(\"==\", signature(e1=\"XString\", e2=\"XString\"),\n    function(e1, e2)\n    {\n        if (!comparable_seqtypes(seqtype(e1), seqtype(e2))) {\n            class1 <- class(e1)\n            class2 <- class(e2)\n            stop(\"comparison between a \\\"\", class1, \"\\\" instance \",\n                 \"and a \\\"\", class2, \"\\\" instance \",\n                 \"is not supported\")\n        }\n        .XString.equal(e1, e2)\n    }\n)\nsetMethod(\"==\", signature(e1=\"BString\", e2=\"character\"),\n    function(e1, e2)\n    {\n        if (length(e2) != 1 || e2 %in% c(\"\", NA))\n            stop(\"comparison between a \\\"BString\\\" object and a character vector \",\n                 \"of length != 1 or an empty string or an NA \",\n                 \"is not supported\")\n        .XString.equal(e1, BString(e2))\n    }\n)\nsetMethod(\"==\", signature(e1=\"character\", e2=\"BString\"),\n    function(e1, e2) e2 == e1\n)\n\nsetMethod(\"!=\", signature(e1=\"XString\", e2=\"XString\"),\n    function(e1, e2) !(e1 == e2)\n)\nsetMethod(\"!=\", signature(e1=\"BString\", e2=\"character\"),\n    function(e1, e2) !(e1 == e2)\n)\nsetMethod(\"!=\", signature(e1=\"character\", e2=\"BString\"),\n    function(e1, e2) !(e1 == e2)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"substr\" and \"substring\" methods.\n###\n\nsetMethod(\"substr\", \"XString\",\n    function(x, start, stop) subseq(x, start=start, end=stop)\n)\n\nsetMethod(\"substring\", \"XString\",\n    function(text, first, last=1000000L) subseq(text, start=first, end=last)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### Update XString objects created before the big internal renaming I made\n### in IRanges 1.3.76.\nsetMethod(\"updateObject\", \"XString\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (!is(try(object@shared, silent=TRUE), \"try-error\"))\n            return(object)\n        xdata <- object@xdata\n        ans_shared <- new(\"SharedRaw\")\n        ans_shared@xp <- xdata@xp\n        ans_shared@.link_to_cached_object=xdata@.link_to_cached_object\n        new2(class(object),\n             shared=ans_shared,\n             offset=object@offset,\n             length=object@length,\n             check=FALSE)\n    }\n)\n\n### Update AAString objects created before AA_ALPHABET was enforced\nsetMethod(\"updateObject\", \"AAString\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## Start by calling the updateObject() method for XString objects.\n        object <- callNextMethod()\n\n        codec <- xscodec(AAString())\n        class(object) <- \"BString\"\n        mapping <- vapply(uniqueLetters(object), utf8ToInt, integer(1L))\n        missingVals <- is.na(codec@enc_lkup[mapping+1L])\n        if(any(missingVals)){\n            errorChars <- paste(names(mapping)[which(missingVals)],\n                                collapse=', ')\n            stop(\"Cannot decode, AAString contains invalid character(s): \",\n                  errorChars)\n        }\n        AAString(object)\n    }\n)\n",
        "XStringCodec-class.R": "### =========================================================================\n### XStringCodec objects\n### --------------------\n###\n### A XStringCodec object allows fast mapping between letters and codes.\n###\n### In addition to the slots 'letters' and 'codes', it has 2 extra slots\n### 'enc_lkup' and 'dec_lkup' that are lookup tables. They allow fast\n### translation from letters to codes and from codes to letters.\n### Those lookup tables are used at the C level for fast encoding/decoding\n### of the sequence contained in a DNAString or RNAString object.\n### See the buildLookupTable() function for more details about lookup tables.\n###\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions.\n###\n\n### Could not find a simpler way to get the vector of ascii codes :-/\n.letterAsByteVal <- function(letters)\n{\n    if (!all(nchar(letters) == 1))\n        stop(\"strings in 'letters' must have one single letter\")\n    as.integer(charToRaw(paste(letters, collapse=\"\")))\n}\n\n### Builds a lookup table that can be used for fast mapping from 'keys'\n### (unique integers >= 0) to 'vals'.\n### The returned value is a vector 'lkup' such that:\n###   lkup[keys + 1] is identical to vals\n### Note that if 'x' and 'y' are both integer vectors of the same length,\n### then lkupx2y <- buildLookupTable(x, y) and lkupy2x <- buildLookupTable(y, x)\n### are reverse lookup tables.\n### The key property of reverse lookup tables is:\n###   lkupy2x[lkupx2y[x + 1]] + 1 is identical to x\n### More generally, if 'x', 'y1', 'y2', and 'z' verify:\n###   a) 'x' is a vector of unique non-negative integers\n###   b) 'y1' is a vector of non-negative integers with same length as 'x'\n###   c) 'y2' is a vector of unique non-negative integers\n###   d) 'z' is a vector of same length as 'y2'\n### and if 'lkupx2y' and 'lkupy2z' are the lookup tables from 'x' to 'y1'\n### and from 'y2' to 'z' (respectively), then this table:\n###   lkupx2z <- lkupy2z[lkupx2y + 1]\n### is the lookup table from 'x' to the subset of 'z' defined by\n###   lkupx2z[x + 1]\n### Note that 'lkupx2z[x + 1]' is exactly the same as 'lkupy2z[y1 + 1]'.\nbuildLookupTable <- function(keys, vals)\n{\n    ## Checking 'keys'.\n    if (!is.integer(keys))\n        stop(\"'keys' must be a an integer vector\")\n    if (any(is.na(keys)))\n        stop(\"'keys' cannot contain NAs\")\n    keys_len <- length(keys)\n    if (keys_len != 0L && min(keys) < 0L)\n        stop(\"'keys' cannot contain negative integers\")\n    if (any(duplicated(keys)))\n        stop(\"'keys' cannot contain duplicates\")\n\n    ## Checking 'vals'.\n    if (!is.atomic(vals) || length(vals) != keys_len)\n        stop(\"'vals' must be a vector of the length of 'keys'\")\n\n    ## Build the lookup table ('ans') and return it.\n    if (keys_len == 0L) {\n        ans_len <- 0L  # but could be anything as long as we fill with NAs\n    } else {\n        ans_len <- max(keys) + 1L\n    }\n    ans <- vector(mode=typeof(vals), length=ans_len)\n    ans[] <- NA\n    ans[keys + 1L] <- vals\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The XStringCodec class.\n###\n\nsetClass(\"XStringCodec\",\n    representation(\n        letters=\"character\",\n        codes=\"integer\",\n        enc_lkup=\"integer\",    # Lookup table for fast encoding\n        dec_lkup=\"integer\"     # Lookup table for fast decoding\n    )\n)\n\nsetMethod(\"initialize\", \"XStringCodec\",\n    function(.Object, letters, codes, extra_letters=NULL, extra_codes=NULL)\n    {\n        letter_byte_vals <- .letterAsByteVal(letters)\n        codes <- as.integer(codes)\n        .Object@letters <- letters\n        .Object@codes <- codes\n        .Object@dec_lkup <- buildLookupTable(codes, letter_byte_vals)\n        if (!is.null(extra_letters)) {\n            letter_byte_vals <- c(letter_byte_vals, .letterAsByteVal(extra_letters))\n            codes <- c(codes, as.integer(extra_codes))\n        }\n        .Object@enc_lkup <- buildLookupTable(letter_byte_vals, codes)\n        .Object\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The DNA and RNA alphabets and codecs.\n###\n\nDNA_BASE_CODES <- c(A=1L, C=2L, G=4L, T=8L)\nRNA_BASE_CODES <- c(A=1L, C=2L, G=4L, U=8L)\n\n.IUPACcodes <- function(baseCodes)\n{\n    baseIsU <- names(baseCodes) == \"U\"\n    if (any(baseIsU))\n        names(baseCodes)[baseIsU] <- \"T\"\n    code_list <- strsplit(IUPAC_CODE_MAP, \"\", fixed=TRUE)\n    codes <- sapply(code_list, function(x) sum(baseCodes[x]))\n    if (any(baseIsU))\n        names(codes)[names(codes) == \"T\"] <- \"U\"\n    codes\n}\n\n.DNAorRNAcodes <- function(baseCodes, baseOnly)\n{\n    if (!isTRUEorFALSE(baseOnly))\n        stop(\"'baseOnly' must be TRUE or FALSE\")\n    codes <- .IUPACcodes(baseCodes)\n    if (baseOnly) {\n        codes[names(codes) %in% names(baseCodes)]\n    } else {\n        c(codes, `-`=16L, `+`=32L, `.`=64L)\n    }\n}\n\nDNAcodes <- function(baseOnly) .DNAorRNAcodes(DNA_BASE_CODES, baseOnly)\nRNAcodes <- function(baseOnly) .DNAorRNAcodes(RNA_BASE_CODES, baseOnly)\n\n### DNA and RNA alphabets.\nDNA_CODES <- DNAcodes(FALSE)\nRNA_CODES <- RNAcodes(FALSE)\nDNA_ALPHABET <- names(DNA_CODES)\nRNA_ALPHABET <- names(RNA_CODES)\n\n### DNA_BASES could be defined more simply as being 'names(DNA_BASE_CODES)'\n### but calling DNAcodes() gives us the guarantee that the order of the\n### bases will be consistent with DNA_ALPHABET.\nDNA_BASES <- names(DNAcodes(TRUE))\nRNA_BASES <- names(RNAcodes(TRUE))\n\n### DNA and RNA codecs.\n.XStringCodec.DNAorRNA <- function(codes)\n{\n    letters <- names(codes)\n    extra_letters <- setdiff(tolower(letters), letters)\n    extra_codes <- codes[toupper(extra_letters)]\n    new(\"XStringCodec\", letters, codes, extra_letters, extra_codes)\n}\n\nDNA_STRING_CODEC <- .XStringCodec.DNAorRNA(DNA_CODES)\nRNA_STRING_CODEC <- .XStringCodec.DNAorRNA(RNA_CODES)\n\n### Return the lookup table that transforms a DNA sequence into its\n### complementary sequence.\ngetDNAComplementLookup <- function()\n{\n    complement_base_codes <- c(A=DNA_BASE_CODES[\"T\"][[1]],\n                               C=DNA_BASE_CODES[\"G\"][[1]],\n                               G=DNA_BASE_CODES[\"C\"][[1]],\n                               T=DNA_BASE_CODES[\"A\"][[1]])\n    complement_codes <- .DNAorRNAcodes(complement_base_codes, FALSE)\n    complement_codec <- .XStringCodec.DNAorRNA(complement_codes)\n    complement_codec@enc_lkup[DNA_STRING_CODEC@dec_lkup + 1]\n}\n\n### Return the lookup table that transforms an RNA sequence into its\n### complementary sequence.\ngetRNAComplementLookup <- function()\n{\n    complement_base_codes <- c(A=RNA_BASE_CODES[\"U\"][[1]],\n                               C=RNA_BASE_CODES[\"G\"][[1]],\n                               G=RNA_BASE_CODES[\"C\"][[1]],\n                               U=RNA_BASE_CODES[\"A\"][[1]])\n    complement_codes <- .DNAorRNAcodes(complement_base_codes, FALSE)\n    complement_codec <- .XStringCodec.DNAorRNA(complement_codes)\n    complement_codec@enc_lkup[RNA_STRING_CODEC@dec_lkup + 1]\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The AA alphabet and codec.\n###\n\n### AAStrings don't need to support DNA/RNA or complementation,\n### so the code to generate the codec can be a lot simpler.\nAAcodes <- function(baseOnly)\n{\n    if (!isTRUEorFALSE(baseOnly))\n        stop(\"'baseOnly' must be TRUE or FALSE\")\n    letters <- AA_ALPHABET\n    if (baseOnly)\n        letters <- head(letters, n=20L)\n    setNames(.letterAsByteVal(letters), letters)\n}\n\n### AA codec.\n.XStringCodec.AA <- function(codes)\n{\n    letters <- names(codes)\n    extra_letters <- setdiff(tolower(letters), letters)\n    extra_codes <- .letterAsByteVal(toupper(extra_letters))\n    new(\"XStringCodec\", letters, codes, extra_letters, extra_codes)\n}\n\nAA_CODES <- AAcodes(FALSE)\nAA_STRING_CODEC <- .XStringCodec.AA(AA_CODES)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Add extra codecs below...\n",
        "XStringPartialMatches-class.R": "### =========================================================================\n### XStringPartialMatches objects\n### -------------------------------------------------------------------------\n### A XStringPartialMatches object contains a set of partial matches\n### on the same XString object, the subject string.\n\nsetClass(\"XStringPartialMatches\",\n    contains=\"XStringViews\",\n    representation(\n        subpatterns=\"XStringViews\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor methods\n\nsetGeneric(\"subpatterns\",\n    function(x)\n    {\n        .Deprecated()\n        standardGeneric(\"subpatterns\")\n    }\n)\n\nsetMethod(\"subpatterns\", \"XStringPartialMatches\", function(x) x@subpatterns)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method\n###\n\nsetMethod(\"show\", \"XStringPartialMatches\",\n    function(object)\n    {\n        msg <- \"XStringPartialMatches objects are deprecated\"\n        .Deprecated(msg=wmsg(msg))\n        subject <- subject(object)\n        lsub <- length(subject)\n        cat(\"  Views on a \", lsub, \"-letter \",\n            class(subject), \" subject\", sep=\"\")\n        #if (!is.null(subject@codec))\n        #    cat(\" with alphabet:\", toString(subject@codec@letters))\n        cat(\"\\nSubject:\", toSeqSnippet(subject, 70))\n        XStringViews.show_vframe(object)\n\n        pattern <- pattern(object)\n        lpat <- length(pattern)\n        cat(\"  Views on a \", lpat, \"-letter \",\n            class(pattern), \" pattern\", sep=\"\")\n        #if (!is.null(pattern@codec))\n        #    cat(\" with alphabet:\", toString(pattern@codec@letters))\n        cat(\"\\nPattern:\", toSeqSnippet(pattern, 70))\n        XStringViews.show_vframe(subpatterns(object))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"[\", \"XStringPartialMatches\",\n    function(x, i, j, ..., drop)\n    {\n        msg <- \"XStringPartialMatches objects are deprecated\"\n        .Deprecated(msg=wmsg(msg))\n        ans <- callNextMethod()\n        ans@subpatterns <- ans@subpatterns[i]\n        ans\n    }\n)\n\n",
        "XStringQuality-class.R": "### =========================================================================\n### XStringQuality objects\n### -------------------------------------------------------------------------\n### An XStringQuality object contains quality information for an XString.\n\nsetClass(\"XStringQuality\",\n    contains=\"BStringSet\",\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"PhredQuality\", contains=\"XStringQuality\")\n\nsetClass(\"SolexaQuality\", contains=\"XStringQuality\")\n\nsetClass(\"IlluminaQuality\", contains=\"XStringQuality\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Create a methodology for managing quality conversions.\n###\n\nsetGeneric(\"offset\", function(x) standardGeneric(\"offset\"))\nsetMethod(\"offset\", \"PhredQuality\", function(x) 33L)\nsetMethod(\"offset\", \"SolexaQuality\", function(x) 64L)\nsetMethod(\"offset\", \"IlluminaQuality\", function(x) 64L)\n\nsetGeneric(\"minQuality\", function(x) standardGeneric(\"minQuality\"))\nsetMethod(\"minQuality\", \"PhredQuality\", function(x) 0L)\nsetMethod(\"minQuality\", \"SolexaQuality\", function(x) -5L)\nsetMethod(\"minQuality\", \"IlluminaQuality\", function(x) 0L)\n\nsetGeneric(\"maxQuality\", function(x) standardGeneric(\"maxQuality\"))\nsetMethod(\"maxQuality\", \"PhredQuality\", function(x) 93L) # 126 - 33; valid printable ASCII\nsetMethod(\"maxQuality\", \"SolexaQuality\", function(x) 99L)\nsetMethod(\"maxQuality\", \"IlluminaQuality\", function(x) 99L)\n\nsetGeneric(\"q2p\", function(x) standardGeneric(\"q2p\"))\nsetMethod(\"q2p\", \"PhredQuality\", function(x) function(q) 10^(-q/10))\nsetMethod(\"q2p\", \"SolexaQuality\",\n          function(x) function(q) 1 - 1/(1 + 10^(-q/10)))\nsetMethod(\"q2p\", \"IlluminaQuality\", function(x) function(q) 10^(-q/10))\n\nsetGeneric(\"p2q\", function(x) standardGeneric(\"p2q\"))\nsetMethod(\"p2q\", \"PhredQuality\", function(x) function(p) -10 * log10(p))\nsetMethod(\"p2q\", \"SolexaQuality\",\n          function(x) function(p) -10 * (log10(p) - log10(1 - p)))\nsetMethod(\"p2q\", \"IlluminaQuality\", function(x) function(p) -10 * log10(p))\n\nqualityConverter <- function(x, qualityClass, outputType) {\n    .BStringSet2integer <- function(x, scale) {\n        if (length(x) != 1L)\n            stop(wmsg(\"as.integer()/as.numeric() can be used on a \",\n                      qualityClass, \" object of length 1 only. \",\n                      \"Coerce to IntegerList or NumericList (with \",\n                      \"'as( , \\\"IntegerList\\\")' or 'as( , \\\"NumericList\\\")') \",\n                      \"when the object is of arbitrary length.\"))\n        as.integer(charToRaw(as.character(x))) - offset(scale)\n    }\n    .integer2BStringSet <- function(x, scale) {\n        if (length(x) == 0)\n            value <- BStringSet()\n        else\n            value <-\n              BStringSet(rawToChar(as.raw(pmax.int(minQuality(scale),\n                                          pmin.int(maxQuality(scale), x)) +\n                                          offset(scale))))\n        value\n    }\n    .numeric2BStringSet <- function(x, scale) {\n        if (length(x) == 0) {\n            value <- BStringSet()\n        } else if (any(is.na(x)) || any(x < 0) || any(x > 1)) {\n            stop(\"'x' must be numbers between 0 and 1 inclusive\")\n        } else {\n            x <- pmax.int(x, 1e-16)\n            x <- pmin.int(x, 1 - 1e-16)\n            value <- .integer2BStringSet(as.integer(round(p2q(scale)(x))), scale)\n        }\n        value\n    }\n    scale <- new(qualityClass)\n    outputType <- match.arg(outputType, c(\"BStringSet\", \"integer\", \"numeric\"))\n    transform <- paste(class(x), \"2\", outputType, sep = \"\")\n    switch(transform,\n           \"BStringSet2BStringSet\" =, \"character2BStringSet\" =,\n           \"integer2integer\" =, \"numeric2numeric\" = x,\n           \"BStringSet2integer\" =, \"character2integer\" =\n           .BStringSet2integer(x, scale),\n           \"BStringSet2numeric\" =, \"character2numeric\" =\n           q2p(scale)(.BStringSet2integer(x, scale)),\n           \"integer2BStringSet\" = .integer2BStringSet(x, scale),\n           \"numeric2BStringSet\" = .numeric2BStringSet(x, scale),\n           \"integer2numeric\" = q2p(scale)(x),\n           \"numeric2integer\" = as.integer(p2q(scale)(x)))\n}\n\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n.characterToXStringQuality <- function(from, qualityClass)\n    as(BStringSet(from), qualityClass)\n.BStringToXStringQuality <- function(from, qualityClass)\n    as(BStringSet(from), qualityClass)\n.BStringSetToXStringQuality <-\nfunction(from, qualityClass)\n{\n    ans <- new2(qualityClass, pool=from@pool, ranges=from@ranges, check=FALSE)\n    names(ans) <- names(from)\n    ans\n}\n.integerToXStringQuality <- function(from, qualityClass)\n    as(qualityConverter(from, qualityClass, \"BStringSet\"), qualityClass)\n.numericToXStringQuality <- function(from, qualityClass)\n    as(qualityConverter(from, qualityClass, \"BStringSet\"), qualityClass)\n\n.IntegerOrNumericListToXStringQuality <- function(from, qualityClass)\n    as(relist(as(unlist(from, use.names=FALSE), qualityClass)[[1L]], from),\n       qualityClass)\n\n.XStringQualityToInteger <- function(from, qualityClass)\n    qualityConverter(BStringSet(from), qualityClass, \"integer\")\n.XStringQualityToNumeric <- function(from, qualityClass)\n    qualityConverter(BStringSet(from), qualityClass, \"numeric\")\n\n.XStringQualityToIntegerMatrix <- function(x)\n{\n    if (!isConstant(width(x)))\n        stop(\"'x' must be rectangular (i.e. have a constant width)\")\n    ans <- matrix(as.integer(unlist(x)) - offset(x),\n                  nrow=length(x), byrow=TRUE)\n    rownames(ans) <- names(x)\n    ans\n}\n\nsetAs(\"character\", \"PhredQuality\",\n      function(from) .characterToXStringQuality(from, \"PhredQuality\"))\nsetAs(\"BString\", \"PhredQuality\",\n      function(from) .BStringToXStringQuality(from, \"PhredQuality\"))\nsetAs(\"BStringSet\", \"PhredQuality\",\n      function(from) .BStringSetToXStringQuality(from, \"PhredQuality\"))\nsetAs(\"integer\", \"PhredQuality\",\n      function(from) .integerToXStringQuality(from, \"PhredQuality\"))\nsetAs(\"numeric\", \"PhredQuality\",\n      function(from) .numericToXStringQuality(from, \"PhredQuality\"))\nsetAs(\"IntegerList\", \"PhredQuality\",\n    function(from) .IntegerOrNumericListToXStringQuality(from, \"PhredQuality\"))\nsetAs(\"NumericList\", \"PhredQuality\",\n    function(from) .IntegerOrNumericListToXStringQuality(from, \"PhredQuality\"))\n\nsetAs(\"character\", \"SolexaQuality\",\n      function(from) .characterToXStringQuality(from, \"SolexaQuality\"))\nsetAs(\"BString\", \"SolexaQuality\",\n      function(from) .BStringToXStringQuality(from, \"SolexaQuality\"))\nsetAs(\"BStringSet\", \"SolexaQuality\",\n      function(from) .BStringSetToXStringQuality(from, \"SolexaQuality\"))\nsetAs(\"integer\", \"SolexaQuality\",\n      function(from) .integerToXStringQuality(from, \"SolexaQuality\"))\nsetAs(\"numeric\", \"SolexaQuality\",\n      function(from) .numericToXStringQuality(from, \"SolexaQuality\"))\nsetAs(\"IntegerList\", \"SolexaQuality\",\n    function(from) .IntegerOrNumericListToXStringQuality(from, \"SolexaQuality\"))\nsetAs(\"NumericList\", \"SolexaQuality\",\n    function(from) .IntegerOrNumericListToXStringQuality(from, \"SolexaQuality\"))\n\nsetAs(\"character\", \"IlluminaQuality\",\n      function(from) .characterToXStringQuality(from, \"IlluminaQuality\"))\nsetAs(\"BString\", \"IlluminaQuality\",\n      function(from) .BStringToXStringQuality(from, \"IlluminaQuality\"))\nsetAs(\"BStringSet\", \"IlluminaQuality\",\n      function(from) .BStringSetToXStringQuality(from, \"IlluminaQuality\"))\nsetAs(\"integer\", \"IlluminaQuality\",\n      function(from) .integerToXStringQuality(from, \"IlluminaQuality\"))\nsetAs(\"numeric\", \"IlluminaQuality\",\n      function(from) .numericToXStringQuality(from, \"IlluminaQuality\"))\nsetAs(\"IntegerList\", \"IlluminaQuality\",\n    function(from) .IntegerOrNumericListToXStringQuality(from, \"IlluminaQuality\"))\nsetAs(\"NumericList\", \"IlluminaQuality\",\n    function(from) .IntegerOrNumericListToXStringQuality(from, \"IlluminaQuality\"))\n\nsetMethod(\"as.vector\", \"XStringQuality\",\n    function(x, mode=\"any\")\n    {\n        if (!isSingleString(mode))\n            stop(\"'mode' must be a single string\")\n        if (mode %in% \"integer\")  # return the quality scores\n            return(.XStringQualityToInteger(x, class(x)))\n        if (mode %in% \"numeric\")  # return the probabilities\n            return(.XStringQualityToNumeric(x, class(x)))\n        if (mode %in% c(\"any\", \"character\"))\n            return(as.character(x))\n        stop(\"'mode' can be \\\"integer\\\", \\\"numeric\\\", \\\"character\\\" \",\n             \"or \\\"any\\\" when 'x' is an XStringQuality object\")\n    }\n)\n\n### Return the quality scores.\n.from_XStringQuality_to_CompressedIntegerList <- function(from)\n    relist(as.integer(as(unlist(from, use.names=FALSE), class(from))), from)\n\nsetAs(\"XStringQuality\", \"CompressedIntegerList\",\n    .from_XStringQuality_to_CompressedIntegerList\n)\nsetAs(\"XStringQuality\", \"IntegerList\",\n    .from_XStringQuality_to_CompressedIntegerList\n)\n\n### Return the probabilities.\n.from_XStringQuality_to_CompressedNumericList <- function(from)\n    relist(as.numeric(as(unlist(from, use.names=FALSE), class(from))), from)\n\nsetAs(\"XStringQuality\", \"CompressedNumericList\",\n    .from_XStringQuality_to_CompressedNumericList\n)\nsetAs(\"XStringQuality\", \"NumericList\",\n    .from_XStringQuality_to_CompressedNumericList\n)\n\n### Return the quality scores.\nsetMethod(\"as.matrix\", \"XStringQuality\",\n    function(x, ...) .XStringQualityToIntegerMatrix(x)\n)\nsetAs(\"XStringQuality\", \"matrix\", function(from) as.matrix(from))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The user-friendly versatile constructors.\n\nPhredQuality <- function(x) as(x, \"PhredQuality\")\nSolexaQuality <- function(x) as(x, \"SolexaQuality\")\nIlluminaQuality <- function(x) as(x, \"IlluminaQuality\")\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### alphabet and encoding\n###\n\nsetMethod(\"alphabet\", \"XStringQuality\",\n    function(x)\n{\n    alf <- strsplit(rawToChar(as.raw(33:126)), \"\")[[1]]\n    len <- maxQuality(x) - minQuality(x) + 1L\n    alf[seq(offset(x) + minQuality(x) - 32L, length.out=len)]\n})\n\nsetGeneric(\"encoding\", function(x) standardGeneric(\"encoding\"))\n\nsetMethod(\"encoding\", \"XStringQuality\",\n    function(x)\n{\n    alf <- alphabet(x)\n    setNames(seq(minQuality(x), length.out=length(alf)), alf)\n})\n\n",
        "XStringSet-class.R": "### =========================================================================\n### XStringSet objects\n### -------------------------------------------------------------------------\n###\n\nsetClass(\"XStringSet\",\n    contains=\"XRawList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"XString\")\n)\n\n### This tells some operations (e.g. pcompare() and narrow()) to ignore the\n### list-like nature of XStringSet derivatives i.e. to treat their list\n### elements as atoms.\nsetMethod(\"pcompareRecursively\", \"XStringSet\", function(x) FALSE)\n\n### The concrete XStringSet subclasses below have no additional slots.\nsetClass(\"BStringSet\",\n    contains=\"XStringSet\",\n    representation(),\n    prototype(elementType=\"BString\")\n)\nsetClass(\"DNAStringSet\",\n    contains=\"XStringSet\",\n    representation(),\n    prototype(elementType=\"DNAString\")\n)\nsetClass(\"RNAStringSet\",\n    contains=\"XStringSet\",\n    representation(),\n    prototype(elementType=\"RNAString\")\n)\nsetClass(\"AAStringSet\",\n    contains=\"XStringSet\",\n    representation(),\n    prototype(elementType=\"AAString\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"seqtype\" and \"seqtype<-\" methods.\n###\n\nsetMethod(\"seqtype\", \"XStringSet\",\n    function(x) seqtype(new(elementType(x)))\n)\n\n### NOT an endomorphism in general! (Because it downgrades 'x' to a\n### B/DNA/RNA/AAStringSet instance.)\n### Also, does NOT preserve the metadata or metadata columns.\n### For the 2 reasons above, seqtype(x) <- seqtype(x) is NOT guaranteed\n### to be a no-op!\nsetReplaceMethod(\"seqtype\", \"XStringSet\",\n    function(x, value)\n    {\n        ans_class <- paste(value, \"StringSet\", sep=\"\")\n        ## Don't try to replace the code below with 'as(x, ans_class)' because\n        ## that would introduce a chicken-egg situation ('as(x, ans_class)'\n        ## actually calls the seqtype() setter when 'x' is an XStringSet\n        ## object).\n        lkup <- get_seqtype_conversion_lookup(seqtype(x), value)\n        if (!is.null(lkup))\n            x <- xvcopy(x, lkup=lkup)  # temporarily breaks 'x'!\n        new2(ans_class, pool=x@pool, ranges=x@ranges, check=FALSE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going from XString to XStringSet with extractList() and family.\n###\n\nsetMethod(\"relistToClass\", \"XString\",\n    function(x) paste0(class(x), \"Set\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor-like methods.\n###\n\nsetMethod(\"width\", \"character\",\n    function(x)\n    {\n        if (anyNA(x))\n            stop(\"NAs in 'x' are not supported\")\n\n        ## Bytes with values > 127 in 'x' break 'nchar(x, type=\"chars\")'\n        ## on some systems, depending on how LC_CTYPE is set. For example\n        ## on my Linux laptop where LC_CTYPE is set to en_US.UTF-8:\n        ##   Sys.getlocale(\"LC_CTYPE\")  # en_US.UTF-8\n        ##   x <- rawToChar(as.raw(135L))\n        ##   nchar(x, type=\"chars\")  # invalid multibyte string, element 1\n        ## These byte values are legit e.g. they occur when doing things\n        ## like 'SolexaQuality(99L)' or 'BString(rawToChar(as.raw(135L)))'.\n        ## The purpose of temporarily setting LC_CTYPE to C below is to\n        ## make sure that the call to 'nchar(x, type=\"chars\")' will always\n        ## succeed and do the right thing. A simple test is:\n        ##   x <- safeExplode(rawToChar(as.raw(1:255)))\n        ##   stopifnot(identical(width(x), rep.int(1L, 255)))\n        ## Note that using 'nchar(x, type=\"bytes\")' wouldn't be an option\n        ## because it breaks the Modstrings package (which uses multibyte\n        ## characters).\n\n        prev_LC_CTYPE <- Sys.getlocale(\"LC_CTYPE\")\n        Sys.setlocale(\"LC_CTYPE\", \"C\")\n        on.exit(Sys.setlocale(\"LC_CTYPE\", prev_LC_CTYPE))\n\n        nchar(x, type=\"chars\")\n    }\n)\n\nsetMethod(\"nchar\", \"XStringSet\",\n    function(x, type=\"chars\", allowNA=FALSE) width(x)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"subseq\" endomorphism and related transformations.\n###\n### Methods for XStringSet objects are inherited from the XVectorList class.\n###\n\n### The default \"narrow\" method calls windows() so we only need to implement\n### a \"windows\" method for character vectors to make narrow() also work on\n### them.\nsetMethod(\"windows\", \"character\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        x_width <- width(x)\n        ir <- solveUserSEW(x_width, start=start, end=end, width=width)\n        substr(x, start=start(ir), stop=end(ir))\n    }\n)\n\nsetMethod(\"subseq\", \"character\",\n    function(x, start=NA, end=NA, width=NA)\n        narrow(x, start=start, end=end, width=width)\n)\n\nsetMethod(\"threebands\", \"character\",\n    function(x, start=NA, end=NA, width=NA)\n    {\n        names(x) <- NULL\n        x_width <- width(x)\n        solved_SEW <- solveUserSEW(x_width, start=start, end=end, width=width)\n        left <- substr(x, start=1L, stop=start(solved_SEW)-1L)\n        middle <- substr(x, start=start(solved_SEW), stop=end(solved_SEW))\n        right <- substr(x, start=end(solved_SEW)+1L, stop=x_width)\n        list(left=left, middle=middle, right=right)\n    }\n)\n\nsetReplaceMethod(\"subseq\", \"character\",\n    function(x, start=NA, end=NA, width=NA, value)\n    {\n        bands <- threebands(x, start=start, end=end, width=width)\n        ## Use x[] <- ... to preserve names and any other attribute.\n        x[] <- paste(bands$left, value, bands$right, sep=\"\")\n        x\n    }\n)\n\n### TODO: Make this a method for XVectorList objects and move it to the\n### IRanges package (this means the implementation cannot use xscat() anymore).\nsetReplaceMethod(\"subseq\", \"XStringSet\",\n    function(x, start=NA, end=NA, width=NA, value)\n    {\n        bands <- threebands(x, start=start, end=end, width=width)\n        ## Use x[] <- ... to preserve class (endomorphism), names, metadata\n        ## columns, and any other attribute.\n        if (is.null(value)) {\n            x[] <- xscat(bands$left, bands$right)\n        } else {\n            x[] <- xscat(bands$left, value, bands$right)\n        }\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### make_XStringSet_from_strings()\n###\n### Low-level generic called by XStringSet() constructor. Not intended to be\n### called directly by the end user.\n### Purpose is to make it easy to extend the XStringSet() constructor to\n### support XStringSet derivatives defined in other packages. For example,\n### defining the following method in the Modstrings package will make calls\n### of the form 'XStringSet(\"ModDNA\", ...)' work (granted that seqtype()\n### works properly on ModDNAStringSet objects via appropriate methods):\n###\n###   setMethod(\"make_XStringSet_from_strings\", \"ModStringSet\",\n###       function(x0, strings, start, width)\n###       {\n###           codec <- modscodec(seqtype(x0))\n###           strings <- vapply(strings,\n###               function(string)\n###                   .convert_letters_to_one_byte_codes(string, codec),\n###               character(1),\n###               USE.NAMES=FALSE)\n###           callNextMethod()\n###       }\n###   )\n###\n\nsetGeneric(\"make_XStringSet_from_strings\", signature=\"x0\",\n    function(x0, strings, start, width)\n    {\n        ## Only light checking of 'start' and 'width' (i.e. we don't check\n        ## that they have the same length as 'strings' and define valid\n        ## ranges on its elements).\n        stopifnot(is(x0, \"XStringSet\"), is.integer(start), is.integer(width))\n        if (!is.character(strings))\n            stop(wmsg(\"input must be a character vector\"))\n        ans <- standardGeneric(\"make_XStringSet_from_strings\")\n        stopifnot(class(ans) == class(x0))\n        ans\n    }\n)\n\n### Default method.\nsetMethod(\"make_XStringSet_from_strings\", \"XStringSet\",\n    function(x0, strings, start, width)\n    {\n        lkup <- get_seqtype_conversion_lookup(\"B\", seqtype(x0))\n        .Call2(\"new_XStringSet_from_CHARACTER\",\n               class(x0), elementType(x0), strings, start, width, lkup,\n               PACKAGE=\"Biostrings\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The XStringSet() constructor. NOT exported.\n###\n### This constructor and its helper functions use the uSEW (user-specified\n### Start/End/Width) interface.\n###\n\nsetGeneric(\"XStringSet\", signature=\"x\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n        standardGeneric(\"XStringSet\")\n)\n\n### 'x' must be a character string or an XString object.\n.oneSeqToXStringSet <- function(seqtype, x, start, end, width, use.names)\n{\n    ans_xvector <- XString(seqtype, x)\n    ans_ranges <- solveUserSEW(length(ans_xvector),\n                               start=start, end=end, width=width,\n                               rep.refwidths=TRUE)\n    ## We mimic how substring() replicates the name of a single string (try\n    ## 'substring(c(A=\"abcdefghij\"), 2, 6:2)').\n    if (!is(x, \"XString\") && normargUseNames(use.names)) {\n        x_names <- names(x)\n        if (!is.null(x_names)) {\n            ans_names <- rep.int(x_names, length(ans_ranges))\n            names(ans_ranges) <- ans_names\n        }\n    }\n    extractList(ans_xvector, ans_ranges)\n}\n\n.charToXStringSet <- function(seqtype, strings, start, end, width, use.names)\n{\n    if (length(strings) == 1L) {\n        ans <- .oneSeqToXStringSet(seqtype, strings,\n                                   start, end, width, use.names)\n    } else {\n        use.names <- normargUseNames(use.names)\n        x0 <- new2(paste0(seqtype, \"StringSet\"), check=FALSE)\n        solved_SEW <- solveUserSEW(width(strings),\n                                   start=start, end=end, width=width)\n        ans <- make_XStringSet_from_strings(x0, strings,\n                                            start(solved_SEW),\n                                            width(solved_SEW))\n        if (use.names)\n            names(ans) <- names(strings)\n    }\n    ans\n}\n\nsetMethod(\"XStringSet\", \"character\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        if (is.null(seqtype))\n            seqtype <- \"B\"\n        .charToXStringSet(seqtype, x, start, end, width, use.names)\n    }\n)\n\nsetMethod(\"XStringSet\", \"factor\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        if (is.null(seqtype))\n            seqtype <- \"B\"\n        if (length(x) < nlevels(x)) {\n            ans <- .charToXStringSet(seqtype, as.character(x),\n                                     start, end, width, use.names)\n            return(ans)\n        }\n        ## If 'x' has less levels than elements, then it's cheaper to\n        ## operate on its levels. In case of equality (i.e. if\n        ## length(x) == nlevels(x)), the price is the same but the final\n        ## XStringSet object obtained by operating on the levels might use\n        ## less memory (if 'x' contains duplicated values).\n        ans <- .charToXStringSet(seqtype, levels(x),\n                                 start, end, width, use.names)\n        ans[as.integer(x)]\n    }\n)\n\nsetMethod(\"XStringSet\", \"XString\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n        .oneSeqToXStringSet(seqtype, x, start, end, width, use.names)\n)\n\nsetMethod(\"XStringSet\", \"XStringSet\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        ans <- narrow(x, start=start, end=end, width=width, use.names=use.names)\n        ## `seqtype<-` must be called even when 'seqtype' is NULL\n        ## because we want to enforce downgrade to a B/DNA/RNA/AAStringSet\n        ## instance.\n        if (is.null(seqtype))\n            seqtype <- seqtype(x)\n        ## Downgrade to a B/DNA/RNA/AAStringSet **instance** and drop the\n        ## metadata and metadata columns.\n        seqtype(ans) <- seqtype\n        if (!is.null(mcols(x)))\n            warning(wmsg(\"metadata columns on input \", class(x), \" object \",\n                         \"were dropped\"))\n        ans\n    }\n)\n\nsetMethod(\"XStringSet\", \"list\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        x_len <- length(x)\n        if (x_len == 0L) {\n            tmp_elementType <- \"BString\"\n        } else {\n            tmp_elementType <- paste(seqtype(x[[1L]]), \"String\", sep=\"\")\n        }\n        tmp_class <- paste(tmp_elementType, \"Set\", sep=\"\")\n        tmp <- XVector:::new_XVectorList_from_list_of_XVector(tmp_class, x)\n        XStringSet(seqtype, tmp,\n                   start=start, end=end, width=width, use.names=use.names)\n    }\n)\n\n### 2 extra \"XStringSet\" methods to deal with the probe sequences stored\n### in the *probe annotation packages (e.g. drosophila2probe).\n\nsetMethod(\"XStringSet\", \"AsIs\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        if (!is.character(x))\n            stop(\"unsupported input type\")\n        class(x) <- \"character\" # keeps the names (unlike as.character())\n        .charToXStringSet(seqtype, x, start, end, width, use.names)\n    }\n)\n\nsetMethod(\"XStringSet\", \"probetable\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n        XStringSet(seqtype, x$sequence,\n                   start=start, end=end, width=width, use.names=use.names)\n)\n\n### Default method.\nsetMethod(\"XStringSet\", \"ANY\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n        XStringSet(seqtype, as.character(x),\n                   start=start, end=end, width=width, use.names=use.names)\n)\n\nsetMethod(\"XStringSet\", \"missing\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n        XStringSet(seqtype, NULL)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The user interfaces to the XStringSet() constructor.\n###\n\nBStringSet <- function(x=character(), start=NA, end=NA, width=NA,\n                       use.names=TRUE)\n    XStringSet(\"B\", x, start=start, end=end, width=width,\n                    use.names=use.names)\n\nDNAStringSet <- function(x=character(), start=NA, end=NA, width=NA,\n                         use.names=TRUE)\n    XStringSet(\"DNA\", x, start=start, end=end, width=width,\n                      use.names=use.names)\n\nRNAStringSet <- function(x=character(), start=NA, end=NA, width=NA,\n                         use.names=TRUE)\n    XStringSet(\"RNA\", x, start=start, end=end, width=width,\n                      use.names=use.names)\n\nAAStringSet <- function(x=character(), start=NA, end=NA, width=NA,\n                        use.names=TRUE)\n    XStringSet(\"AA\", x, start=start, end=end, width=width,\n                     use.names=use.names)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\nsetAs(\"ANY\", \"BStringSet\", function(from) BStringSet(from))\n\nsetAs(\"ANY\", \"DNAStringSet\", function(from) DNAStringSet(from))\n\nsetAs(\"ANY\", \"RNAStringSet\", function(from) RNAStringSet(from))\n\nsetAs(\"ANY\", \"AAStringSet\", function(from) AAStringSet(from))\n\nsetAs(\"ANY\", \"XStringSet\",\n    function(from)\n    {\n        from_seqtype <- try(seqtype(from), silent=TRUE)\n        if (is(from_seqtype, \"try-error\"))\n            from_seqtype <- \"B\"\n        XStringSet(from_seqtype, from)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" and \"showAsCell\" methods.\n###\n\n.namesW <- 20\n\n.XStringSet.show_frame_header <- function(iW, widthW, with.names)\n{\n    cat(format(\"\", width=iW+1),\n        format(\"width\", width=widthW, justify=\"right\"),\n        sep=\"\")\n    if (with.names) {\n        cat(format(\" seq\", width=getOption(\"width\")-iW-widthW-.namesW-1),\n            format(\"names\", width=.namesW, justify=\"left\"),\n            sep=\"\")\n    } else {\n        cat(\" seq\")\n    }\n    cat(\"\\n\")\n}\n\n.XStringSet.show_frame_line <- function(x, i, iW, widthW)\n{\n    width <- nchar(x)[i]\n    snippet_width <- getOption(\"width\") - 2L - iW - widthW\n    if (!is.null(names(x)))\n        snippet_width <- snippet_width - .namesW - 1L\n    snippet <- toSeqSnippet(x[[i]], snippet_width)\n    if (!is.null(names(x))) {\n        snippet_class <- class(snippet)\n        snippet <- format(snippet, width=snippet_width)\n        class(snippet) <- snippet_class\n    }\n    cat(format(paste(\"[\", i,\"]\", sep=\"\"), width=iW, justify=\"right\"), \" \",\n        format(width, width=widthW, justify=\"right\"), \" \",\n        add_colors(snippet),\n        sep=\"\")\n    if (!is.null(names(x))) {\n        snippet_name <- names(x)[i]\n        if (is.na(snippet_name))\n            snippet_name <- \"<NA>\"\n        else if (nchar(snippet_name) > .namesW)\n            snippet_name <- paste0(substr(snippet_name, 1L, .namesW - 3L),\n                                   #compact_ellipsis)\n                                   \"...\")\n        cat(\" \", snippet_name, sep=\"\")\n    }\n    cat(\"\\n\")\n}\n\n### 'half_nrow' must be >= 1\n.XStringSet.show_frame <- function(x, half_nrow=5L)\n{\n    if (is.null(head_nrow <- getOption(\"showHeadLines\")))\n        head_nrow <- half_nrow\n    if (is.null(tail_nrow <- getOption(\"showTailLines\")))\n        tail_nrow <- half_nrow\n\n    lx <- length(x)\n    iW <- nchar(as.character(lx)) + 2 # 2 for the brackets\n    ncharMax <- max(nchar(x))\n    widthW <- max(nchar(ncharMax), nchar(\"width\"))\n    .XStringSet.show_frame_header(iW, widthW, !is.null(names(x)))\n    if (lx < (2*half_nrow+1L) | (lx < (head_nrow+tail_nrow+1L))) {\n        for (i in seq_len(lx))\n            .XStringSet.show_frame_line(x, i, iW, widthW)\n    } else {\n        if (head_nrow > 0)\n            for (i in 1:head_nrow)\n                .XStringSet.show_frame_line(x, i, iW, widthW)\n        cat(format(\"...\", width=iW, justify=\"right\"),\n            format(\"...\", width=widthW, justify=\"right\"),\n            \"...\\n\")\n        if (tail_nrow > 0)\n            for (i in (lx-tail_nrow+1L):lx)\n                .XStringSet.show_frame_line(x, i, iW, widthW)\n    }\n}\n\nsetMethod(\"show\", \"XStringSet\",\n    function(object)\n    {\n        object_len <- length(object)\n        cat(class(object), \" object of length \", length(object), sep=\"\")\n        if (object_len != 0L)\n            cat(\":\")\n        cat(\"\\n\")\n        if (object_len != 0L)\n            .XStringSet.show_frame(object)\n    }\n)\n\nsetMethod(\"showAsCell\", \"XStringSet\",\n    function(object)\n        vapply(object, toSeqSnippet, character(1), width=23L)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other coercion methods.\n###\n\n### 'unlist(x)' turns XStringSet object 'x' into an XString object.\nsetMethod(\"unlist\", \"XStringSet\",\n    function(x, recursive=TRUE, use.names=TRUE)\n        .Call2(\"XStringSet_unlist\", x, PACKAGE=\"Biostrings\")\n)\n\nsetMethod(\"as.character\", \"XStringSet\",\n    function(x, use.names=TRUE)\n    {\n        use.names <- normargUseNames(use.names)\n        ans <- .Call2(\"new_CHARACTER_from_XStringSet\",\n                     x, xs_dec_lkup(x),\n                     PACKAGE=\"Biostrings\")\n        if (use.names)\n            names(ans) <- names(x)\n        ans\n    }\n)\n\nsetMethod(\"as.factor\", \"XStringSet\",\n    function(x)\n    {\n        as.factor(as.character(x))\n    })\n\n### TODO: Turn this into an S3/S4 combo for as.data.frame.XStringSet\nsetMethod(\"as.data.frame\", \"XStringSet\",\n    function(x, row.names=NULL, optional=FALSE)\n    {\n        x <- as.character(x)\n        as.data.frame(x, row.names=NULL, optional=optional,\n                         stringsAsFactors=FALSE)\n    }\n)\n\nsetMethod(\"as.vector\", \"XStringSet\",\n    function(x, mode=\"any\")\n    {\n        if (!isSingleString(mode))\n            stop(\"'mode' must be a single string\")\n        if (!(mode %in% c(\"any\", \"character\")))\n            stop(\"'mode' can only be \\\"any\\\" or \\\"character\\\" \",\n                 \"when 'x' is an XStringSet object\")\n        as.character(x)\n    }\n)\n\nsetMethod(\"toString\", \"XStringSet\",\n    function(x, ...) toString(as.character(x), ...)\n)\n\nsetMethod(\"as.matrix\", \"XStringSet\",\n    function(x, use.names=TRUE)\n    {\n        use.names <- normargUseNames(use.names)\n        nrow <- length(x)\n        if (nrow == 0)\n            stop(\"'x' must contain at least 1 string\")\n        widths <- width(x)\n        ncol <- widths[1]\n        if (!all(widths == ncol))\n            stop(\"'x' strings are not equal-width\")\n        y <- as.character(x, use.names=FALSE)\n        y <- unlist(strsplit(y, NULL), recursive=FALSE, use.names=FALSE)\n        m <- matrix(y, nrow=nrow, byrow=TRUE)\n        if (use.names)\n            rownames(m) <- names(x)\n        m\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### Update XStringSet objects created before the big change to the XStringSet\n### internals (\"super\" slot replaced by \"pool\" slot).\n### This change happened in Biostrings 2.13.43.\nsetMethod(\"updateObject\", \"XStringSet\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (!is(try(object@pool, silent=TRUE), \"try-error\"))\n            return(object)\n        ans_xvector <- updateObject(object@super)\n        ans_ranges <- updateObject(object@ranges)\n        names(ans_ranges) <- names(object)\n        extractList(ans_xvector, ans_ranges)\n    }\n)\n\n### Update the elements in XStringSet object but without using the naive\n### approach that consists in calling updateObject() on each of them, which\n### would be very inefficient for objects that contain more than a few hundred\n### sequences. More generally speaking, using the following idiom:\n###\n###     for (i in seq_along(object))\n###         object[[i]] <- someTransformation(object[[i]])\n###\n### for element-wise transformation of an XStringSet object should be avoided\n### at all cost! It is **much** more efficient to apply the transformation\n### to the SharedRaw objects stored in 'object@pool', because the number of\n### SharedRaw objects is typically **very** small compared to the length of\n### the XStringSet object. This is typically thousand of times faster than\n### the naive approach. However, note that this trick only works if the\n### tranformation operates on the individual letters without moving them\n### around, which is the case for updateObject().\n.updateObject_XStringSet <- function(object, ..., verbose=FALSE)\n{\n    baseclass <- xsbaseclass(object)\n    ## Update SharedRaw elements directly (significantly fewer SharedRaw\n    ## objects than XStrings).\n    for (i in seq_along(object@pool)) {\n        shared <- object@pool[[i]] # SharedRaw object\n        ## Turn SharedRaw object into an XString object.\n        xs <- new2(baseclass, shared=shared, length=length(shared), check=FALSE)\n        ## Update XString object.\n        xs <- updateObject(xs, ..., verbose=verbose)\n        object@pool[[i]] <- xs@shared\n    }\n    object\n}\n\n### Update AAStringSet objects created before AA_ALPHABET was enforced\n### for AAString objects\nsetMethod(\"updateObject\", \"AAStringSet\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## Start by calling the updateObject() method for XStringSet objects.\n        object <- callNextMethod()\n        object <- compact(object)\n        .updateObject_XStringSet(object, ..., verbose=verbose)\n    }\n)\n\n",
        "XStringSet-comparison.R": "### =========================================================================\n### Comparing and ordering the elements in one or more XStringSet objects\n### -------------------------------------------------------------------------\n###\n\n\n### Returns a character vector of length 2 containing the 2 XStringSet direct\n### concrete subclasses that 'x' and 'y' need to be coerced to before they can\n### actually be compared.\n.coerce_to <- function(x, y)\n{\n    seqtype1 <- try(seqtype(x), silent=TRUE)\n    if (is(seqtype1, \"try-error\"))\n        seqtype1 <- \"B\"\n    seqtype2 <- try(seqtype(y), silent=TRUE)\n    if (is(seqtype2, \"try-error\"))\n        seqtype2 <- \"B\"\n    if (seqtype1 != seqtype2) {\n        if ((seqtype1 != \"B\" && seqtype2 == \"AA\")\n         || (seqtype2 != \"B\" && seqtype1 == \"AA\"))\n            stop(\"comparison between a \\\"\", class(x), \"\\\" instance \",\n                 \"and a \\\"\", class(y), \"\\\" instance\\n\",\n                 \"  is not supported\")\n        if (seqtype1 == \"B\" && seqtype2 != \"AA\")\n            seqtype1 <- seqtype2\n        if (seqtype2 == \"B\" && seqtype1 != \"AA\")\n            seqtype2 <- seqtype1\n    }\n    class1 <- paste0(seqtype1, \"StringSet\")\n    class2 <- paste0(seqtype2, \"StringSet\")\n    c(class1, class2)\n}\n\n.coerce_and_call_next_method <- function(f, x, y, ...)\n{\n    classes <- .coerce_to(x, y)\n    class1 <- classes[[1L]]\n    class2 <- classes[[2L]]\n    if (!is(x, class1))\n        x <- as(x, class1)\n    if (!is(y, class2))\n        y <- as(y, class2)\n    ## We cannot use callNextMethod() in this context (only from within the\n    ## body of a method definition), so we use getMethod() instead.\n    XRawList_method <- getMethod(f, c(\"XRawList\", \"XRawList\"))\n    XRawList_method(x, y, ...)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompare().\n###\n\n### Method signatures for binary comparison operators.\n.OP2_SIGNATURES <- list(\n    c(\"XStringSet\", \"XStringSet\"),\n    c(\"XStringSet\", \"Vector\"),\n    c(\"XStringSet\", \"vector\"),\n    c(\"Vector\", \"XStringSet\"),\n    c(\"vector\", \"XStringSet\")\n)\n\n.pcompare_XStringSet <- function(x, y)\n    .coerce_and_call_next_method(\"pcompare\", x, y)\n\nsetMethods(\"pcompare\", .OP2_SIGNATURES, .pcompare_XStringSet)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match().\n###\n\n.XStringSet.match <- function(x, table,\n                              nomatch=NA_integer_, incomparables=NULL)\n{\n    .coerce_and_call_next_method(\"match\", x, table,\n                                 nomatch=nomatch, incomparables=incomparables)\n}\n\nsetMethods(\"match\", .OP2_SIGNATURES, .XStringSet.match)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is.na() and related methods\n###\n\nsetMethod(\"is.na\", \"XStringSet\", function(x) rep(FALSE, length(x)))\n\nsetMethod(\"anyNA\", \"XStringSet\", function(x, recursive=FALSE) FALSE)\n",
        "XStringSet-io.R": "### =========================================================================\n### Input/output of XStringSet objects\n### -------------------------------------------------------------------------\n\n\n### 'filexp_list' must be a list of \"file external pointers\" returned by\n### XVector::open_input_files() or XVector:::open_output_file().\n.close_filexp_list <- function(filexp_list)\n{\n    for (filexp in filexp_list) XVector:::close_filexp(filexp)\n}\n\n.normarg_nrec <- function(nrec)\n{\n    if (!isSingleNumber(nrec))\n        stop(wmsg(\"'nrec' must be a single integer value\"))\n    if (!is.integer(nrec))\n        nrec <- as.integer(nrec)\n    nrec\n}\n\n.normarg_skip <- function(skip)\n{\n    if (!isSingleNumber(skip))\n        stop(wmsg(\"'skip' must be a single integer value\"))\n    if (!is.integer(skip))\n        skip <- as.integer(skip)\n    if (skip < 0L)\n        stop(wmsg(\"'skip' cannot be negative\"))\n    skip\n}\n\n.is_filexp_list <- function(filepath)\n{\n    ## We only check the first list element.\n    is.list(filepath) && length(filepath) != 0L &&\n                         is(filepath[[1L]], \"externalptr\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### FASTA\n###\n\n.read_fasta_files <- function(filexp_list, nrec, skip, seek.first.rec,\n                              use.names, elementType, lkup)\n{\n    nrec <- .normarg_nrec(nrec)\n    skip <- .normarg_skip(skip)\n    if (!isTRUEorFALSE(seek.first.rec))\n        stop(wmsg(\"'seek.first.rec' must be TRUE or FALSE\"))\n    .Call2(\"read_fasta_files\", filexp_list, nrec, skip, seek.first.rec,\n                               use.names, elementType, lkup,\n                               PACKAGE=\"Biostrings\")\n}\n\nfasta.index <- function(filepath, nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                        seqtype=\"B\")\n{\n    filexp_list <- open_input_files(filepath)\n    on.exit(.close_filexp_list(filexp_list))\n    nrec <- .normarg_nrec(nrec)\n    skip <- .normarg_skip(skip)\n    if (!isTRUEorFALSE(seek.first.rec))\n        stop(wmsg(\"'seek.first.rec' must be TRUE or FALSE\"))\n    seqtype <- match.arg(seqtype, c(\"B\", \"DNA\", \"RNA\", \"AA\"))\n    lkup <- get_seqtype_conversion_lookup(\"B\", seqtype)\n    ans <- .Call2(\"fasta_index\",\n                  filexp_list, nrec, skip, seek.first.rec, lkup,\n                  PACKAGE=\"Biostrings\")\n    ## 'expath' will usually be the same as 'filepath', except when 'filepath'\n    ## contains URLs which will be replaced by the path to the downloaded file.\n    expath <- vapply(filexp_list, attr, character(1), \"expath\", USE.NAMES=FALSE)\n    ans$filepath <- expath[ans[ , \"fileno\"]]\n    ans\n}\n\nfasta.seqlengths <- function(filepath, nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                             seqtype=\"B\", use.names=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n    fai <- fasta.index(filepath, nrec=nrec, skip=skip,\n                       seek.first.rec=seek.first.rec,\n                       seqtype=seqtype)\n    ans <- fai[ , \"seqlength\"]\n    if (use.names)\n        names(ans) <- fai[ , \"desc\"]\n    ans\n}\n\n.check_fasta_index <- function(fai)\n{\n    .REQUIRED_COLS <- c(\"recno\", \"fileno\", \"offset\",\n                        \"desc\", \"seqlength\", \"filepath\")\n    if (!all(.REQUIRED_COLS %in% colnames(fai)))\n        stop(wmsg(\"invalid FASTA index: a FASTA index must be a data frame \",\n                  \"with columns: \", paste0(.REQUIRED_COLS, collapse=\", \")))\n\n    recno <- fai[ , \"recno\"]\n    if (!is.integer(recno)\n     || S4Vectors:::anyMissingOrOutside(recno, lower=1L))\n        stop(wmsg(\"invalid FASTA index: the \\\"recno\\\" column must be \",\n                  \"an integer vector with no NAs and with positive values\"))\n\n    fileno <- fai[ , \"fileno\"]\n    if (!is.integer(fileno)\n     || S4Vectors:::anyMissingOrOutside(fileno, lower=1L))\n        stop(wmsg(\"invalid FASTA index: the \\\"fileno\\\" column must be \",\n                  \"an integer vector with no NAs and with positive values\"))\n\n    offset <- fai[ , \"offset\"]\n    if (!is.numeric(offset) || any(is.na(offset)) || any(offset < 0))\n        stop(wmsg(\"invalid FASTA index: the \\\"offset\\\" column must be \",\n                  \"a numeric vector with no NAs and no negative values\"))\n\n    desc <- fai[ , \"desc\"]\n    if (!is.character(desc) || any(is.na(desc)))\n        stop(wmsg(\"invalid FASTA index: the \\\"desc\\\" column must be \",\n                  \"a character vector with no NAs\"))\n\n    seqlength <- fai[ , \"seqlength\"]\n    if (!is.integer(seqlength)\n     || S4Vectors:::anyMissingOrOutside(seqlength, lower=0L))\n        stop(wmsg(\"invalid FASTA index: the \\\"seqlength\\\" column must be \",\n                  \"an integer vector with no NAs and no negative values\"))\n\n    filepath <- fai[ , \"filepath\"]\n    if (!is.character(filepath) || any(is.na(filepath)))\n        stop(wmsg(\"invalid FASTA index: the \\\"filepath\\\" column must be \",\n                  \"a character vector with no NAs\"))\n}\n\n### \"FASTA blocks\" are groups of consecutive FASTA records.\n### Fasta index 'ssorted_fai' must be strictly sorted by \"recno\". This is NOT\n### checked!\n.compute_sorted_fasta_blocks_from_ssorted_fasta_index <- function(ssorted_fai)\n{\n    recno <- ssorted_fai[ , \"recno\"]\n    fileno <- ssorted_fai[ , \"fileno\"]\n    offset <- ssorted_fai[ , \"offset\"]\n    blockid <- recno - seq_along(recno)  # this block id is unique only within\n                                         # a given file\n    is_first_in_block <- !duplicatedIntegerPairs(blockid, fileno)\n    first_in_block_idx <- which(is_first_in_block)\n    data.frame(fileno=fileno[first_in_block_idx],\n               nrec=diff(c(first_in_block_idx, nrow(ssorted_fai) + 1L)),\n               offset=offset[first_in_block_idx])\n}\n\n### Fasta index 'ssorted_fai' must be strictly sorted by \"recno\". This is NOT\n### checked!\n.read_XStringSet_from_ssorted_fasta_index <- function(ssorted_fai,\n                                                      elementType, lkup)\n{\n    ## Prepare 'nrec_list' and 'offset_list'.\n    fasta_blocks <-\n        .compute_sorted_fasta_blocks_from_ssorted_fasta_index(ssorted_fai)\n    nrec_list <- split(fasta_blocks[ , \"nrec\"], fasta_blocks[ , \"fileno\"],\n                       drop=TRUE)\n    offset_list <- split(fasta_blocks[ , \"offset\"], fasta_blocks[ , \"fileno\"],\n                         drop=TRUE)\n\n    ## Prepare 'filexp_list'.\n    filepath <- ssorted_fai[ , \"filepath\"]\n    fileno <- ssorted_fai[ , \"fileno\"]\n    used_fileno <- as.integer(names(nrec_list))\n    used_filepath <- filepath[match(used_fileno, fileno)]\n    filexp_list <- open_input_files(used_filepath)\n    on.exit(.close_filexp_list(filexp_list))\n\n    ## Prepare 'seqlengths'.\n    seqlengths <- ssorted_fai[ , \"seqlength\"]\n\n    .Call2(\"read_fasta_blocks\",\n           seqlengths, filexp_list, nrec_list, offset_list,\n           elementType, lkup,\n           PACKAGE=\"Biostrings\")\n}\n\n.read_XStringSet_from_fasta_index <- function(fai, use.names, elementType, lkup)\n{\n    .check_fasta_index(fai)\n\n    ## Create a \"strictly sorted\" version of 'fai' by removing duplicated rows\n    ## and sorting the remaining rows by ascending \"recno\".\n    recno <- fai[ , \"recno\"]\n    ssorted_recno <- sort(unique(recno))\n    ssorted_fai <- fai[match(ssorted_recno, recno), , drop=FALSE]\n\n    C_ans <- .read_XStringSet_from_ssorted_fasta_index(ssorted_fai,\n                                                       elementType, lkup)\n\n    ## Re-order XStringSet object to make it parallel to 'recno'.\n    ans <- C_ans[match(recno, ssorted_recno)]\n\n    ## Set names on XStringSet object.\n    if (use.names)\n        names(ans) <- fai[ , \"desc\"]\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### FASTQ\n###\n\n.read_fastq_files <- function(filexp_list, nrec, skip, seek.first.rec,\n                              use.names, elementType, lkup, with.qualities)\n{\n    nrec <- .normarg_nrec(nrec)\n    skip <- .normarg_skip(skip)\n    if (!isTRUEorFALSE(seek.first.rec))\n        stop(wmsg(\"'seek.first.rec' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(with.qualities))\n        stop(wmsg(\"'with.qualities' must be TRUE or FALSE\"))\n    C_ans <- .Call2(\"read_fastq_files\",\n                    filexp_list, nrec, skip, seek.first.rec,\n                    use.names, elementType, lkup, with.qualities,\n                    PACKAGE=\"Biostrings\")\n    if (!with.qualities)\n        return(C_ans)\n    ans <- C_ans[[1L]]\n    mcols(ans)$qualities <- C_ans[[2L]]\n    ans\n}\n\nfastq.seqlengths <- function(filepath, nrec=-1L, skip=0L, seek.first.rec=FALSE)\n{\n    filexp_list <- open_input_files(filepath)\n    on.exit(.close_filexp_list(filexp_list))\n    nrec <- .normarg_nrec(nrec)\n    skip <- .normarg_skip(skip)\n    if (!isTRUEorFALSE(seek.first.rec))\n        stop(wmsg(\"'seek.first.rec' must be TRUE or FALSE\"))\n    .Call2(\"fastq_seqlengths\",\n           filexp_list, nrec, skip, seek.first.rec,\n           PACKAGE=\"Biostrings\")\n}\n\nfastq.geometry <- function(filepath, nrec=-1L, skip=0L, seek.first.rec=FALSE)\n{\n    seqlengths <- fastq.seqlengths(filepath, nrec, skip, seek.first.rec)\n    common_seqlength <- runValue(Rle(seqlengths))\n    if (length(common_seqlength) != 1L)\n        common_seqlength <- NA_integer_\n    c(length(seqlengths), common_seqlength)\n}\n\n.read_XStringSet_from_fastq <- function(filepath, nrec, skip, seek.first.rec,\n                                        use.names, elementType, lkup,\n                                        with.qualities)\n{\n    filexp_list <- open_input_files(filepath)\n    on.exit(.close_filexp_list(filexp_list))\n    nrec <- .normarg_nrec(nrec)\n    skip <- .normarg_skip(skip)\n    if (!isTRUEorFALSE(seek.first.rec))\n        stop(wmsg(\"'seek.first.rec' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(with.qualities))\n        stop(wmsg(\"'with.qualities' must be TRUE or FALSE\"))\n    C_ans <- .Call2(\"read_fastq_files\",\n                    filexp_list, nrec, skip, seek.first.rec,\n                    use.names, elementType, lkup, with.qualities,\n                    PACKAGE=\"Biostrings\")\n    if (!with.qualities)\n        return(C_ans)\n    ans <- C_ans[[1L]]\n    mcols(ans)$qualities <- C_ans[[2L]]\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The readBStringSet(), readDNAStringSet(), readRNAStringSet(), and\n### readAAStringSet() functions.\n###\n\n.read_XStringSet <- function(filepath, format,\n                             nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                             use.names=TRUE, seqtype=\"B\",\n                             with.qualities=FALSE)\n{\n    if (!isSingleString(format))\n        stop(wmsg(\"'format' must be a single string\"))\n    format <- match.arg(tolower(format), c(\"fasta\", \"fastq\"))\n    if (!isTRUEorFALSE(use.names))\n        stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n    elementType <- paste(seqtype, \"String\", sep=\"\")\n    lkup <- get_seqtype_conversion_lookup(\"B\", seqtype)\n\n    ## Read FASTQ.\n    if (format == \"fastq\") {\n        if (!.is_filexp_list(filepath)) {\n            filepath <- open_input_files(filepath)\n            on.exit(.close_filexp_list(filepath))\n        }\n        ans <- .read_fastq_files(filepath,\n                                 nrec, skip, seek.first.rec,\n                                 use.names, elementType, lkup,\n                                 with.qualities)\n        return(ans)\n    }\n\n    ## Read FASTA.\n    if (!identical(with.qualities, FALSE))\n        stop(wmsg(\"The 'with.qualities' argument is only supported \",\n                  \"when reading a FASTQ file.\"))\n    if (.is_filexp_list(filepath)) {\n        ans <- .read_fasta_files(filepath,\n                                 nrec, skip, seek.first.rec,\n                                 use.names, elementType, lkup)\n        return(ans)\n    }\n    if (is.data.frame(filepath)) {\n        if (!(identical(nrec, -1L) &&\n              identical(skip, 0L) &&\n              identical(seek.first.rec, FALSE)))\n            warning(wmsg(\"'nrec', 'skip', and 'seek.first.rec' are \",\n                         \"ignored when 'filepath' is a data frame\"))\n        fai <- filepath\n    } else {\n        fai <- fasta.index(filepath, nrec=nrec, skip=skip,\n                           seek.first.rec=seek.first.rec,\n                           seqtype=seqtype)\n    }\n    .read_XStringSet_from_fasta_index(fai, use.names, elementType, lkup)\n}\n\nreadBStringSet <- function(filepath, format=\"fasta\",\n                           nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                           use.names=TRUE, with.qualities=FALSE)\n    .read_XStringSet(filepath, format, nrec, skip, seek.first.rec,\n                     use.names, \"B\", with.qualities)\n\nreadDNAStringSet <- function(filepath, format=\"fasta\",\n                             nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                             use.names=TRUE, with.qualities=FALSE)\n    .read_XStringSet(filepath, format, nrec, skip, seek.first.rec,\n                     use.names, \"DNA\", with.qualities)\n\nreadRNAStringSet <- function(filepath, format=\"fasta\",\n                             nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                             use.names=TRUE, with.qualities=FALSE)\n    .read_XStringSet(filepath, format, nrec, skip, seek.first.rec,\n                     use.names, \"RNA\", with.qualities)\n\nreadAAStringSet <- function(filepath, format=\"fasta\",\n                            nrec=-1L, skip=0L, seek.first.rec=FALSE,\n                            use.names=TRUE, with.qualities=FALSE)\n    .read_XStringSet(filepath, format, nrec, skip, seek.first.rec,\n                     use.names, \"AA\", with.qualities)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### writeXStringSet()\n###\n\n.write_XStringSet_to_fasta <- function(x, filexp_list, width=80L)\n{\n    if (!isSingleNumber(width))\n        stop(wmsg(\"'width' must be a single integer\"))\n    if (!is.integer(width))\n        width <- as.integer(width)\n    if (width < 1L)\n        stop(wmsg(\"'width' must be an integer >= 1\"))\n    lkup <- get_seqtype_conversion_lookup(seqtype(x), \"B\")\n    .Call2(\"write_XStringSet_to_fasta\",\n          x, filexp_list, width, lkup,\n          PACKAGE=\"Biostrings\")\n}\n\n.write_XStringSet_to_fastq <- function(x, filexp_list, qualities=NULL)\n{\n    if (is.null(qualities)){\n        if (is(x, \"QualityScaledXStringSet\"))\n            qualities <- quality(x)\n        else\n            qualities <- mcols(x)$qualities\n    }\n    if (!is.null(qualities)) {\n        if (!is(qualities, \"BStringSet\"))\n            stop(wmsg(\"'qualities' must be NULL or a BStringSet object\"))\n        if (length(qualities) != length(x))\n            stop(wmsg(\"'x' and 'qualities' must have the same length\"))\n    }\n    lkup <- get_seqtype_conversion_lookup(seqtype(x), \"B\")\n    .Call2(\"write_XStringSet_to_fastq\",\n           x, filexp_list, qualities, lkup,\n           PACKAGE=\"Biostrings\")\n}\n\nwriteXStringSet <- function(x, filepath, append=FALSE,\n                            compress=FALSE, compression_level=NA,\n                            format=\"fasta\", ...)\n{\n    if (!is(x, \"XStringSet\"))\n        stop(wmsg(\"'x' must be an XStringSet object\"))\n    if (!isSingleString(format))\n        stop(wmsg(\"'format' must be a single string\"))\n    format <- match.arg(tolower(format), c(\"fasta\", \"fastq\"))\n    filexp_list <- XVector:::open_output_file(filepath, append,\n                                              compress, compression_level)\n    on.exit(.close_filexp_list(filexp_list))\n    res <- try(switch(format,\n                   \"fasta\"=.write_XStringSet_to_fasta(x, filexp_list, ...),\n                   \"fastq\"=.write_XStringSet_to_fastq(x, filexp_list, ...)\n               ),\n               silent=FALSE)\n    if (is(res, \"try-error\") && !append) {\n        ## Get the expanded path and remove the file.\n        expath <- attr(filexp_list[[1L]], \"expath\")\n        if (!file.remove(expath))\n            warning(wmsg(\"cannot remove file '\", expath, \"'\"))\n    }\n    invisible(NULL)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Serialization of XStringSet objects.\n###\n\nsaveXStringSet <- function(x, objname, dirpath=\".\",\n                           save.dups=FALSE, verbose=TRUE)\n{\n    if (!is(x, \"XStringSet\"))\n        stop(wmsg(\"'x' must be an XStringSet object\"))\n    if (!isSingleString(objname))\n        stop(wmsg(\"'objname' must be a single string\"))\n    if (!isSingleString(dirpath))\n        stop(wmsg(\"'dirpath' must be a single string\"))\n    if (!isTRUEorFALSE(save.dups))\n        stop(wmsg(\"'save.dups' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(verbose))\n        stop(wmsg(\"'verbose' must be TRUE or FALSE\"))\n    x_dups <- NULL\n    ## Don't use 'is(x, \"DNAStringSet\")' here since we only want to use the\n    ## \"pre-compression trick\" on a DNAStringSet *instance*. There is no\n    ## guarantee that using this trick on an object deriving from the\n    ## DNAStringSet class won't corrupt the data stored in the extra slots!\n    if (class(x) == \"DNAStringSet\") {\n        ## The \"pre-compression trick\" is based on the following property.\n        ## If 'x_dup2unq' is an integer vector (of the same length as 'x')\n        ## that maps from duplicated to unique elements in 'x', then\n        ## 'x' and 'x[x_dup2unq]' contain exactly the same *values* i.e.\n        ## 'all(x == x[x_dup2unq])' is TRUE. Note that other metadata\n        ## attached to 'x' like the names etc could differ though!\n        ## So by replacing 'x' with 'x[x_dup2unq]' below , we actually don't\n        ## modify the sequences in 'x', but the internal representation of 'x'\n        ## has changed. What has changed is that duplicated elements are not\n        ## duplicated in memory anymore (i.e. they all point to the same place\n        ## in memory) so calling compact() on 'x' will be much more efficient.\n        ## Note that, for efficiency reasons, we use PDict() to extract the\n        ## 'x_dup2unq' mapping. This means that the \"pre-compression trick\"\n        ## works only if 'x' is a rectangular DNAStringSet instance with no\n        ## IUPAC ambiguity codes.\n        pdict <- try(PDict(x), silent=TRUE)\n        if (!is(pdict, \"try-error\") && !is.null(pdict@dups0)) {\n            x_dups <- pdict@dups0\n            x_names <- names(x)\n            x_dup2unq <- togroup(x_dups)\n            x <- x[x_dup2unq]\n            names(x) <- x_names\n        }\n    }\n    x <- compact(x)\n    assign(objname, x)\n    objfile <- paste(objname, \".rda\", sep=\"\")\n    filepath <- file.path(dirpath, objfile)\n    if (save.dups) {\n        if (is.null(x_dups))\n            stop(wmsg(\"could not determine 'x_dups'\"))\n        objname2 <- paste(objname, \"_dups\", sep=\"\")\n        assign(objname2, x_dups)\n        objname <- c(objname, objname2)\n    }\n    if (verbose)\n        cat(\"Saving \", filepath, \" ... \", sep=\"\")\n    save(list=objname, file=filepath)\n    if (verbose)\n        cat(\"OK\\n\")\n}\n\n",
        "XStringSetList-class.R": "### =========================================================================\n### XStringSetList objects\n### -------------------------------------------------------------------------\n###\n\nsetClass(\"XStringSetList\",\n    contains=\"CompressedList\",\n    representation(\n        \"VIRTUAL\",\n        unlistData=\"XStringSet\"\n    ),\n    prototype(\n        elementType=\"XStringSet\"\n    )\n)\n\nsetClass(\"BStringSetList\",\n    contains=\"XStringSetList\",\n    representation(\n        unlistData=\"BStringSet\"\n    ),\n    prototype(\n        elementType=\"BStringSet\"\n    )\n)\nsetClass(\"DNAStringSetList\",\n    contains=\"XStringSetList\",\n    representation(\n        unlistData=\"DNAStringSet\"\n    ),\n    prototype(\n        elementType=\"DNAStringSet\"\n    )\n)\nsetClass(\"RNAStringSetList\",\n    contains=\"XStringSetList\",\n    representation(\n        unlistData=\"RNAStringSet\"\n    ),\n    prototype(\n        elementType=\"RNAStringSet\"\n    )\n)\nsetClass(\"AAStringSetList\",\n    contains=\"XStringSetList\",\n    representation(\n        unlistData=\"AAStringSet\"\n    ),\n    prototype(\n        elementType=\"AAStringSet\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Link XStringSet subclasses to corresponding XStringSetList subclasses\n###\n### Used by splitAsList() and family (e.g. relist(), extractList(), etc...)\n### to infer the class of the output when the input is an XStringSet\n### derivative.\n###\n\nsetMethod(\"relistToClass\", \"XStringSet\",\n    function(x) paste0(seqtype(x), \"StringSetList\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The XStringSetList() constructor. NOT exported.\n###\n\n.new_XStringSetList_from_list <- function(seqtype, x)\n{\n    x_eltNROWS <- elementNROWS(x)\n    empty_idx <- which(x_eltNROWS == 0L)\n    if (length(empty_idx) != 0L) {\n        y <- x[-empty_idx]\n    } else {\n        y <- x\n    }\n    unlisted_y <- unlist(y, use.names=FALSE, recursive=FALSE)\n    if (!is.list(unlisted_y) && length(unlisted_y) == sum(x_eltNROWS)) {\n        unlisted_ans <- XStringSet(seqtype, unlisted_y)\n    } else {\n        ## In that case 'length(unlisted_y)' should be < 'sum(x_eltNROWS)'\n        ## which means unlist() was not able to fully unlist 'y'. So let's\n        ## try to turn each list element into an XStringSet object and then\n        ## combine them together. This is of course much slower than if\n        ## unlist() had succeeded.\n        y <- lapply(unname(y), XStringSet, seqtype=seqtype)\n        unlisted_ans <- do.call(c, y)\n    }\n    relist(unlisted_ans, x)\n}\n\n.new_XStringSetList_from_List <- function(seqtype, x)\n{\n    unlisted_x <- unlist(x, use.names=FALSE)\n    unlisted_ans <- XStringSet(seqtype, unlisted_x)\n    ans <- relist(unlisted_ans, x)\n    ## relist() puts the names back but not the metadata columns.\n    mcols(ans) <- mcols(x, use.names=FALSE)\n    ans\n}\n\nXStringSetList <- function(seqtype, ..., use.names=TRUE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    x <- list(...)\n    if (length(x) == 1L) {\n        x1 <- x[[1L]]\n        if (is.list(x1) || (is(x1, \"List\") && !is(x1, \"XStringSet\"))) {\n            x <- x1\n            if (is(x, \"List\")) {\n                if (!use.names)\n                    names(x) <- NULL\n                return(.new_XStringSetList_from_List(seqtype, x))\n            }\n        }\n    }\n    if (!use.names)\n        names(x) <- NULL\n    .new_XStringSetList_from_list(seqtype, x)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"seqtype\" and \"seqtype<-\" methods.\n###\n\nsetMethod(\"seqtype\", \"XStringSetList\",\n    function(x) seqtype(unlist(x, use.names=FALSE))\n)\n\n### Downgrades 'x' to a B/DNA/RNA/AAStringSetList instance!\nsetReplaceMethod(\"seqtype\", \"XStringSetList\",\n    function(x, value)\n    {\n        ## Could be done elegantly with 'seqtype(unlisted(x)) <- value'\n        ## if `unlisted<-` was available.\n        unlisted_ans <- unlist(x, use.names=FALSE)\n        seqtype(unlisted_ans) <- value\n        ans <- relist(unlisted_ans, x)\n        ## relist() puts the names back but not the metadata columns.\n        mcols(ans) <- mcols(x, use.names=FALSE)\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### User interface to the XStringSetList() constructor\n###\n\nBStringSetList <- function(..., use.names=TRUE)\n    XStringSetList(\"B\", ..., use.names=use.names)\n\nDNAStringSetList <- function(..., use.names=TRUE)\n    XStringSetList(\"DNA\", ..., use.names=use.names)\n\nRNAStringSetList <- function(..., use.names=TRUE)\n    XStringSetList(\"RNA\", ..., use.names=use.names)\n\nAAStringSetList <- function(..., use.names=TRUE)\n    XStringSetList(\"AA\", ..., use.names=use.names)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\nsetMethod(\"show\", \"XStringSetList\",\n    function(object)\n    {\n        cat(class(object), \" of length \", length(object), \"\\n\", sep = \"\")\n        IRanges:::.showAtomicList(object, minLines=10)\n    }\n)\n\nsetMethod(\"showAsCell\", \"XStringSetList\",\n     function(object) showAsCell(CharacterList(object))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from list-like object to XStringSetList\n###\n\n### Try to turn an arbitrary **list-like** object into an ordinary list of\n### XStringSet objects.\n.as_list_of_XStringSet <- function(from, seqtype=NULL)\n{\n    prefix <- if (is.null(seqtype)) \"X\" else seqtype\n    Class <- paste0(prefix, \"StringSet\")\n    lapply(from, as, Class, strict=FALSE)\n}\n\n### --- From ordinary list to XStringSetList ---\n### Note that being able to coerce a length-one ordinary list to an\n### XStringSetList derivative will automatically make [[<- work on\n### XStringSetList derivatives.\n\n.from_list_to_XStringSetList <- function(from, seqtype=NULL)\n{\n    x <- .as_list_of_XStringSet(from, seqtype=seqtype)\n    if (is.null(seqtype)) {\n        if (length(x) != 0L) {\n            seqtype <- seqtype(x[[1L]])\n        } else {\n            seqtype <- \"B\"\n        }\n    }\n    ans_class <- paste0(seqtype, \"StringSetList\")\n    IRanges:::new_CompressedList_from_list(ans_class, x)\n}\n\n### --- From List derivative to XStringSetList ---\n\n.from_List_to_XStringSetList <- function(from, seqtype=NULL)\n{\n    if (is(from, \"XStringSet\")) {\n        ## Perform a \"dumb split\".\n        if (!is.null(seqtype))\n            seqtype(from) <- seqtype\n        ## We call IRanges:::from_Vector_to_CompressedList() to perform\n        ## the \"dumb split\". This is **very** efficient!\n        return(IRanges:::from_Vector_to_CompressedList(from))\n    }\n\n    x <- .as_list_of_XStringSet(from, seqtype=seqtype)\n    if (is.null(seqtype)) {\n        if (length(x) != 0L) {\n            seqtype <- seqtype(x[[1L]])\n        } else {\n            seqtype <- try(seqtype(from), silent=TRUE)\n            if (inherits(seqtype, \"try-error\"))\n                seqtype <- \"B\"\n        }\n    }\n    ans_class <- paste0(seqtype, \"StringSetList\")\n    IRanges:::new_CompressedList_from_list(ans_class, x,\n                                 metadata=metadata(from),\n                                 mcols=mcols(from, use.names=FALSE))\n}\n\n### --- Actually set the coercion methods (10 methods) ---\n\n.set_coercions_to_XStringSetList <- function(seqtype=NULL)\n{\n    prefix <- if (is.null(seqtype)) \"X\" else seqtype\n    to <- paste0(prefix, \"StringSetList\")\n    setAs(\"list\", to,\n        function(from) .from_list_to_XStringSetList(from, seqtype)\n    )\n    setAs(\"List\", to,\n        function(from) .from_List_to_XStringSetList(from, seqtype)\n    )\n}\n\n.set_coercions_to_XStringSetList()\n.set_coercions_to_XStringSetList(\"B\")\n.set_coercions_to_XStringSetList(\"DNA\")\n.set_coercions_to_XStringSetList(\"RNA\")\n.set_coercions_to_XStringSetList(\"AA\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other methods\n###\n\nsetMethod(\"nchar\", \"XStringSetList\", IRanges:::nchar_CompressedList)\n",
        "XStringViews-class.R": "### =========================================================================\n### XStringViews objects\n### -------------------------------------------------------------------------\n###\n### The XStringViews class is the basic container for storing a set of views\n### (start/end locations) on the same XString object, called the \"subject\"\n### string.\n###\n\nsetClass(\"XStringViews\",\n    contains=\"Views\",\n    representation(\n        subject=\"XString\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Unsafe constructor (not exported). Use only when 'start' and 'width' are\n### guaranteed to be valid.\n###\n\nunsafe.newXStringViews <- function(subject, start, width)\n    new2(\"XStringViews\", subject=subject,\n                         ranges=IRanges(start=start, width=width),\n                         check=FALSE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### User-friendly constructor.\n###\n\nsetMethod(\"Views\", \"XString\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n        IRanges:::new_Views(subject, start=start,\n                                     end=end,\n                                     width=width,\n                                     names=names,\n                                     Class=\"XStringViews\")\n)\n\nsetMethod(\"Views\", \"character\",\n    function(subject, start=NULL, end=NULL, width=NULL, names=NULL)\n    {\n        xsubject <- XString(NULL, subject)\n        Views(xsubject, start=start, end=end, width=width, names=names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessor-like methods.\n###\n\nsetMethod(\"nchar\", \"XStringViews\",\n    function(x, type=\"chars\", allowNA=FALSE)\n    {\n        if (length(x) == 0)\n            return(integer(0))\n        start0 <- pmax.int(start(x), 1L)\n        end0 <- pmin.int(end(x), nchar(subject(x)))\n        ans <- end0 - start0 + 1L\n        ans[ans < 0L] <- 0L\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"seqtype\" and \"seqtype<-\" methods.\n###\n\nsetMethod(\"seqtype\", \"XStringViews\", function(x) seqtype(subject(x)))\n\n### Does NOT downgrade 'x' to an XStringViews instance! (endomorphism)\nsetReplaceMethod(\"seqtype\", \"XStringViews\",\n    function(x, value)\n    {\n        ## could be done with 'seqtype(subject(x)) <- value'\n        ## if `subject<-` was available\n        subject <- subject(x)\n        seqtype(subject) <- value\n        x@subject <- subject\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion.\n###\n\n### From XStringViews to XStringSet.\nfromXStringViewsToStringSet <- function(x,\n                                 out.of.limits=c(\"ok\", \"warning\", \"error\"),\n                                 use.names=FALSE)\n{\n    out.of.limits <- match.arg(out.of.limits)\n    ans_ranges <- restrict(as(x, \"IRanges\"), start=1L, end=nchar(subject(x)),\n                           keep.all.ranges=TRUE,\n                           use.names=use.names)\n    if (out.of.limits != \"ok\" && any(width(ans_ranges) < width(x))) {\n        if (out.of.limits == \"warning\")\n            warning(\"trimming \\\"out of limits\\\" views\")\n        else\n            stop(\"'x' has \\\"out of limits\\\" views\")\n    }\n    extractList(subject(x), ans_ranges)\n}\n\n### We need this so that B/DNA/RNA/AAStringSet() used below work on an\n### XStringViews object.\nsetMethod(\"XStringSet\", \"XStringViews\",\n    function(seqtype, x, start=NA, end=NA, width=NA, use.names=TRUE)\n    {\n        y <- fromXStringViewsToStringSet(x, out.of.limits=\"warning\",\n                                         use.names=use.names)\n        XStringSet(seqtype, y,\n                   start=start, end=end, width=width, use.names=TRUE)\n    }\n)\n\nsetAs(\"XStringViews\", \"XStringSet\",\n    function(from) fromXStringViewsToStringSet(from, out.of.limits=\"warning\",\n                                               use.names=TRUE))\n\nsetAs(\"XStringViews\", \"BStringSet\", function(from) BStringSet(from))\nsetAs(\"XStringViews\", \"DNAStringSet\", function(from) DNAStringSet(from))\nsetAs(\"XStringViews\", \"RNAStringSet\", function(from) RNAStringSet(from))\nsetAs(\"XStringViews\", \"AAStringSet\", function(from) AAStringSet(from))\n\n### From XStringSet to XStringViews.\n\n.XStringSetAsViews <- function(from) successiveViews(unlist(from), width(from))\n\nsetAs(\"XStringSet\", \"Views\", .XStringSetAsViews)\nsetAs(\"XStringSet\", \"XStringViews\", .XStringSetAsViews)\n\nsetMethod(\"as.data.frame\", \"XStringViews\",\n    function(x, row.names=NULL, optional= FALSE)\n    {\n        ans1 <- as.data.frame(as(x, \"IRanges\"), row.names=row.names, optional=optional)\n        ans2 <- as.data.frame(as(x, \"XStringSet\"), row.names=row.names, optional=optional)\n        stopifnot(ncol(ans2) == 1L)  # should never happen\n        colnames(ans2)[[1L]] <- \"seq\"\n        cbind(ans1, ans2)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"show\" method.\n###\n\nXStringViews.show_vframe_header <- function(iW, startW, endW, widthW)\n{\n    cat(\"  \",\n        format(\"\", width=iW+1),\n        format(\"start\", width=startW, justify=\"right\"), \" \",\n        format(\"end\", width=endW, justify=\"right\"), \" \",\n        format(\"width\", width=widthW, justify=\"right\"), \"\\n\",\n        sep=\"\")\n}\n\n### The 2 helper functions below convert a given view on an XString object\n### into a character-string.\n### Both assume that 'start' <= 'end' (so they don't check it) and\n### padd the result with spaces to produce the \"margin effect\"\n### if 'start' or 'end' are out of limits.\n\n### nchar(XStringViews.get_view(x, start, end)) is always end-start+1\nXStringViews.get_view <- function(x, start, end)\n{\n    start <- as.integer(start)\n    end <- as.integer(end)\n    lx <- length(x)\n    if (end < 1L || start > lx)\n            return(format(\"\", width=end-start+1L))\n    Lmargin <- \"\"\n    if (start < 1L) {\n        Lmargin <- format(\"\", width=1L-start)\n        start <- 1L\n    }\n    Rmargin <- \"\"\n    if (end > lx) {\n        Rmargin <- format(\"\", width=end-lx)\n        end <- lx\n    }\n    s <- extract_character_from_XString_by_ranges(x, start, end - start + 1L)\n    paste0(Lmargin, s, Rmargin)\n}\n\n### 'nchar(XStringViews.get_snippet(x, start, end, snippetWidth))' is\n### <= 'snippetWidth'.\nXStringViews.get_snippet <- function(x, start, end, snippetWidth)\n{\n    if (snippetWidth < 7L)\n        snippetWidth <- 7L\n    width <- end - start + 1L\n    if (width <= snippetWidth) {\n        ans <- XStringViews.get_view(x, start, end)\n    } else {\n        w1 <- (snippetWidth - 2L) %/% 2L\n        w2 <- (snippetWidth - 3L) %/% 2L\n        ans <- paste0(XStringViews.get_view(x, start, start+w1-1L),\n                      #compact_ellipsis,\n                      \"...\",\n                      XStringViews.get_view(x, end-w2+1L, end))\n    }\n    class(ans) <- c(seqtype(x), class(ans))  # for S3 dispatch in add_colors()\n    ans\n}\n\nXStringViews.show_vframe_line <- function(x, i, iW, startW, endW, widthW)\n{\n    start <- start(x)[i]\n    end <- end(x)[i]\n    width <- end - start + 1L\n    snippetWidth <- getOption(\"width\") - 8L - iW - startW - endW - widthW\n    snippet <- XStringViews.get_snippet(subject(x), start, end, snippetWidth)\n    cat(\"  \",\n        format(paste(\"[\", i,\"]\", sep=\"\"), width=iW, justify=\"right\"), \" \",\n        format(start, width=startW, justify=\"right\"), \" \",\n        format(end, width=endW, justify=\"right\"), \" \",\n        format(width, width=widthW, justify=\"right\"), \" \",\n        \"[\", add_colors(snippet), \"]\\n\",\n        sep=\"\")\n}\n\nXStringViews.show_vframe <- function(x)\n{\n    nhead <- get_showHeadLines()\n    ntail <- get_showTailLines()\n    cat(\"\\nviews:\")\n    x_len <- length(x)\n    if (x_len == 0L) {\n        cat(\" NONE\\n\")\n    } else {\n        cat(\"\\n\")\n        iW <- nchar(as.character(x_len)) + 2L  # 2 for the brackets\n        startMax <- max(start(x))\n        startW <- max(nchar(startMax), nchar(\"start\"))\n        endMax <- max(end(x))\n        endW <- max(nchar(endMax), nchar(\"end\"))\n        widthMax <- max(width(x))\n        widthW <- max(nchar(widthMax), nchar(\"width\"))\n        XStringViews.show_vframe_header(iW, startW, endW, widthW)\n        if (x_len <= nhead + ntail + 1L) {\n            for (i in seq_len(x_len))\n                XStringViews.show_vframe_line(x, i, iW, startW, endW, widthW)\n        } else {\n            if (nhead > 0L)\n                for (i in seq_len(nhead))\n                    XStringViews.show_vframe_line(x, i, iW, startW, endW,\n                                                  widthW)\n            cat(\"  \",\n                format(\"...\", width=iW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=startW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=endW, justify=\"right\"),\n                \" \",\n                format(\"...\", width=widthW, justify=\"right\"),\n                \" ...\\n\", sep=\"\")\n            if (ntail > 0L)\n                for (i in (x_len-ntail+1L):x_len)\n                    XStringViews.show_vframe_line(x, i, iW, startW, endW,\n                                                  widthW)\n        }\n    }\n}\n\nsetMethod(\"show\", \"XStringViews\",\n    function(object)\n    {\n        subject <- subject(object)\n        subject_len <- length(subject)\n        cat(\"Views on a \", subject_len, \"-letter \",\n            class(subject), \" subject\", sep=\"\")\n        snippet <- toSeqSnippet(subject, getOption(\"width\") - 9L)\n        cat(\"\\nsubject: \", add_colors(snippet), sep=\"\")\n        XStringViews.show_vframe(object)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Equality.\n###\n\n### Assume that 'start1', 'end1', 'start2', 'end2' are single integers\n### and that start1 <= end1 and start2 <= end2.\nXStringViews.view1_equal_view2 <- function(x1, start1, end1, x2, start2, end2)\n{\n    one <- as.integer(1)\n    w1 <- end1 - start1 + one\n    w2 <- end2 - start2 + one\n    if (w1 != w2)\n        return(FALSE)\n\n    lx1 <- length(x1)\n    isBlank1 <- end1 < one || start1 > lx1\n    lx2 <- length(x2)\n    isBlank2 <- end2 < one || start2 > lx2\n    if (isBlank1 && isBlank2)\n        return(TRUE)\n    if (isBlank1 || isBlank2)\n        return(FALSE)\n\n    # Left margin\n    LmarginSize1 <- start1 < one\n    LmarginSize2 <- start2 < one\n    if (LmarginSize1 != LmarginSize2)\n        return(FALSE)\n    if (LmarginSize1) {\n        # Both views have a left margin\n        if (start1 != start2)\n            return(FALSE)\n        start1 <- one\n        start2 <- one\n    }\n\n    # Right margin\n    RmarginSize1 <- end1 > lx1\n    RmarginSize2 <- end2 > lx2\n    if (RmarginSize1 != RmarginSize2)\n        return(FALSE)\n    if (RmarginSize1) {\n        # Both views have a right margin\n        if (end1 - lx1 != end2 - lx2)\n            return(FALSE)\n        end1 <- lx1\n        end2 <- lx2\n    }\n\n    # At this point, we can trust that 1 <= start1 <= end1 <= lx1\n    # and that 1 <= start2 <= end2 <= lx2.\n    subseq(x1, start=start1, end=end1) == subseq(x2, start=start2, end=end2)\n}\n\n### 'x' and 'y' must be XStringViews objects.\n### Returns a logical vector of length max(length(x), length(y)).\n### Recycle its arguments.\nXStringViews.equal <- function(x, y)\n{\n    lx <- length(x)\n    ly <- length(y)\n    if (lx < ly) {\n        tmp <- x\n        x <- y\n        y <- tmp\n        tmp <- lx\n        lx <- ly\n        ly <- tmp\n    }\n    if (ly == 0)\n        return(logical(0))\n    # Now we are sure that lx >= ly >= 1\n    ans <- logical(lx)\n    j <- 1\n    for (i in seq_len(lx)) {\n        ans[i] <- XStringViews.view1_equal_view2(\n                      subject(x), start(x)[i], end(x)[i],\n                      subject(y), start(y)[j], end(y)[j])\n        # Recycle\n        if (j < ly) j <- j + 1 else j <- 1\n    }\n    if (j != 1)\n        warning(paste(\"longer object length\",\n                      \"is not a multiple of shorter object length\"))\n    ans\n}\n\n### These methods are called if at least one side of the \"==\" (or \"!=\")\n### operator is an XStringViews object. They have precedence over the\n### corresponding methods defined for XString objects, i.e. they will\n### be called if one side is an XStringViews object and the other side\n### is an XString object.\n### Typical use:\n###   v <- Views(DNAString(\"TAATAATG\"), start=-2:9, end=0:11)\n###   v == v[4]\n###   v == v[1]\n###   v2 <- Views(DNAString(\"G\"), start=1, end=3)\n###   v == v2\n### Also works if one side is an XString object:\n###   v == DNAString(\"ATG\")\n###   RNAString(\"AUG\") == v\n### Whitespace matters:\n###   v == \"TG\"\n### But this doesn't work neither (\"TG \" can't be converted to a DNAString\n### object):\n###   v == \"TG \"\n\nsetMethod(\"==\", signature(e1=\"XStringViews\", e2=\"XStringViews\"),\n    function(e1, e2)\n    {\n        if (!comparable_seqtypes(seqtype(e1), seqtype(e2))) {\n            class1 <- class(subject(e1))\n            class2 <- class(subject(e2))\n            stop(\"comparison between XStringViews objects with subjects of \",\n                 \"class \\\"\", class1, \"\\\" and \\\"\", class2, \"\\\" \",\n                 \"is not supported\")\n        }\n        XStringViews.equal(e1, e2)\n    }\n)\nsetMethod(\"==\", signature(e1=\"XStringViews\", e2=\"XString\"),\n    function(e1, e2)\n    {\n        if (!comparable_seqtypes(seqtype(e1), seqtype(e2))) {\n            class1 <- class(subject(e1))\n            class2 <- class(e2)\n            stop(\"comparison between an XStringViews object with a subject of \",\n                 \"class \\\"\", class1, \"\\\" and a \\\"\", class2, \"\\\" instance \",\n                 \"is not supported\")\n        }\n        XStringViews.equal(e1, as(e2, \"Views\"))\n    }\n)\nsetMethod(\"==\", signature(e1=\"XStringViews\", e2=\"character\"),\n    function(e1, e2)\n    {\n        if (!is(subject(e1), \"BString\"))\n            stop(\"comparison between an XStringViews object with a subject of \",\n                 \"class \\\"\", class(subject(e1)), \"\\\" and a character vector \",\n                 \"is not supported\")\n        if (length(e2) == 0 || any(e2 %in% c(\"\", NA)))\n            stop(\"comparison between an XStringViews object and a character \",\n                 \"vector of length 0 or with empty strings or NAs \",\n                 \"is not supported\")\n        XStringViews.equal(e1, as(BStringSet(e2), \"Views\"))\n    }\n)\nsetMethod(\"==\", signature(e1=\"XString\", e2=\"XStringViews\"),\n    function(e1, e2) e2 == e1\n)\nsetMethod(\"==\", signature(e1=\"character\", e2=\"XStringViews\"),\n    function(e1, e2) e2 == e1\n)\n\nsetMethod(\"!=\", signature(e1=\"XStringViews\", e2=\"XStringViews\"),\n    function(e1, e2) !(e1 == e2)\n)\nsetMethod(\"!=\", signature(e1=\"XStringViews\", e2=\"XString\"),\n    function(e1, e2) !(e1 == e2)\n)\nsetMethod(\"!=\", signature(e1=\"XStringViews\", e2=\"character\"),\n    function(e1, e2) !(e1 == e2)\n)\nsetMethod(\"!=\", signature(e1=\"XString\", e2=\"XStringViews\"),\n    function(e1, e2) !(e1 == e2)\n)\nsetMethod(\"!=\", signature(e1=\"character\", e2=\"XStringViews\"),\n    function(e1, e2) !(e1 == e2)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other methods.\n###\n\nsetMethod(\"as.character\", \"XStringViews\",\n    function(x, use.names=TRUE, check.limits=TRUE)\n    {\n        if (!isTRUEorFALSE(check.limits))\n            stop(\"'check.limits' must be TRUE or FALSE\")\n        if (check.limits)\n            out.of.limits <- \"error\"\n        else\n            out.of.limits <- \"warning\"\n        y <- fromXStringViewsToStringSet(x, out.of.limits=out.of.limits,\n                                         use.names=use.names)\n        as.character(y)\n    }\n)\n\nsetMethod(\"as.matrix\", \"XStringViews\",\n    function(x, use.names=TRUE)\n    {\n        ## TODO: Supress this warning in BioC 2.12.\n        # msg <- c(\"as.matrix() on an XStringViews object 'x' has changed \",\n        #          \"behavior: now the\\n  views in 'x' must be of equal width \",\n        #          \"and each view is converted into a row of\\n\",\n        #          \"  single characters. To achieve the old behavior, \",\n        #          \"do 'as.matrix(ranges(x))'.\\n  To supress this warning, do \",\n        #          \"'suppressWarnings(as.matrix(x))'.\\n  This warning will be \",\n        #          \"removed in BioC 2.12.\")\n        # warning(msg)\n        y <- fromXStringViewsToStringSet(x, out.of.limits=\"error\",\n                                         use.names=use.names)\n        as.matrix(y)\n    }\n)\n\nsetMethod(\"toString\", \"XStringViews\",\n    function(x, ...)\n    {\n        toString(as.character(x), ...)\n    }\n)\n\n",
        "chartr.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"chartr\" generic function and methods.\n###\n\n.mkOldToNewLkup <- function(old, new, x)\n{\n    x_seqtype <- seqtype(x)\n    if (!is(old, \"XString\") || seqtype(old) != x_seqtype)\n        old <- XString(x_seqtype, old)\n    if (!is(new, \"XString\") || seqtype(new) != x_seqtype)\n        new <- XString(x_seqtype, new)\n    if (nchar(old) != nchar(new))\n        stop(\"'old' and 'new' must have the same length\")\n    old_codes <- XString.readCodes(old, 1, nchar(old))\n    new_codes <- XString.readCodes(new, 1, nchar(new))\n    lkup <- buildLookupTable(xscodes(x), xscodes(x))\n    lkup[1 + old_codes] <- new_codes\n    lkup\n}\n\nsetMethod(\"chartr\", c(old=\"ANY\", new=\"ANY\", x=\"XString\"),\n    function(old, new, x) xvcopy(x, lkup=.mkOldToNewLkup(old, new, x))\n)\n\nsetMethod(\"chartr\", c(old=\"ANY\", new=\"ANY\", x=\"XStringSet\"),\n    function(old, new, x) xvcopy(x, lkup=.mkOldToNewLkup(old, new, x))\n)\n\nsetMethod(\"chartr\", c(old=\"ANY\", new=\"ANY\", x=\"XStringViews\"),\n    function(old, new, x)\n    {\n        x@subject <- chartr(old, new, subject(x))\n        x\n    }\n)\n\nsetMethod(\"chartr\", c(old=\"ANY\", new=\"ANY\", x=\"MaskedXString\"),\n    function(old, new, x)\n    {\n        if (any(active(masks(x))))\n            stop(\"\\\"chartr\\\" method for MaskedXString objects \",\n                 \"with active masks not ready yet\\n  Please complain!\")\n        ans <- chartr(old, new, unmasked(x))\n        masks(ans) <- masks(x)\n        ans\n    }\n)\n\n### A simple wrapper to chartr().\nreplaceAmbiguities <- function(x, new=\"N\")\n{\n    if(!(inherits(x, c(\"XString\", \"XStringSet\", \"XStringViews\"))) ||\n       !(seqtype(x) %in% c(\"DNA\", \"RNA\")))\n      stop(\"replaceAmbiguities is only supported for DNA and RNA\")\n    if (!(isSingleString(new) && nchar(new) == 1L))\n        stop(\"'new' must be a single letter\")\n    old <- paste(setdiff(names(IUPAC_CODE_MAP), DNA_BASES), collapse=\"\")\n    new <- strrep(new, nchar(old))\n    chartr(old, new, x)\n}\n\n",
        "coloring.R": "### =========================================================================\n### XString Display Colors\n### -------------------------------------------------------------------------\n\n### Return a named character vector where all the names are single letters.\n### Colors for A, C, G, and T were inspired by\n###   https://en.wikipedia.org/wiki/Nucleotide#Structure\n### Called in .onLoad() to initialize DNA_AND_RNA_COLORED_LETTERS.\nmake_DNA_AND_RNA_COLORED_LETTERS <- function()\n{\n    ## Not sure why but the built-in white() style in the crayon package\n    ## produces some kind of light grey text color. So we define a style\n    ## that produces a text color that is 100% white.\n    whiter <- make_style(rgb(1, 1, 1))\n    dark_grey_bg <- make_style(rgb(0.5,0.5,0.5), bg=TRUE)\n\n    ## All the IUPAC ambiguity letters minus N.\n    dark_grey_bg_letters <- c(\"M\", \"R\", \"W\", \"S\", \"Y\", \"K\", \"V\", \"H\", \"D\", \"B\")\n\n    c(\n        A=make_style(rgb(1, 0.5, 0.5), bg=TRUE)(black(\"A\")),\n        C=make_style(rgb(0.5, 1, 0.5), bg=TRUE)(black(\"C\")),\n        G=make_style(rgb(0.5, 1, 1), bg=TRUE)(black(\"G\")),\n        T=make_style(rgb(1, 0.8, 0.5), bg=TRUE)(black(\"T\")),\n        U=make_style(rgb(1, 1, 0.5), bg=TRUE)(black(\"U\")),\n        setNames(sprintf(dark_grey_bg(whiter(\"%s\")), dark_grey_bg_letters),\n                 dark_grey_bg_letters),\n        N=make_style(\"grey\", bg=TRUE)(whiter(\"N\"))\n    )\n}\n\n### Return a named character vector where all the names are single letters.\n### Colors amino acids by similarity\n### Colors groupins by\n###   https://www.jalview.org/help/html/colourSchemes/zappo.html\n### Called in .onLoad() to initialize AA_COLORED_LETTERS.\nmake_AA_COLORED_LETTERS <- function(){\n    whiter <- make_style(rgb(1, 1, 1))\n    dark_grey_bg <- make_style(rgb(0.5,0.5,0.5), bg=TRUE)\n\n    ## All the IUPAC ambiguity letters minus X.\n    dark_grey_bg_letters <- c(\"U\",\"O\",\"B\",\"J\",\"Z\")\n\n    cp <- c(\"#fbf8cc\", \"#ffcfd2\", \"#cfbaf0\",\n            \"#a3c4f3\", \"#8eecf5\", \"#b9fbc0\", \"#f1c0e8\")\n\n    c(\n        # Cysteine\n        C=make_style(cp[1], bg=TRUE)(black(\"C\")),\n\n        # Aliphatic/hydrophobic\n        A=make_style(cp[2], bg=TRUE)(black(\"A\")),\n        V=make_style(cp[2], bg=TRUE)(black(\"V\")),\n        M=make_style(cp[2], bg=TRUE)(black(\"M\")),\n        L=make_style(cp[2], bg=TRUE)(black(\"L\")),\n        I=make_style(cp[2], bg=TRUE)(black(\"I\")),\n\n        # Conformationally Special\n        P=make_style(cp[3], bg=TRUE)(black(\"P\")),\n        G=make_style(cp[3], bg=TRUE)(black(\"G\")),\n\n        # Positive\n        K=make_style(cp[4], bg=TRUE)(black(\"K\")),\n        R=make_style(cp[4], bg=TRUE)(black(\"R\")),\n        H=make_style(cp[4], bg=TRUE)(black(\"H\")),\n\n        # Hydrophilic\n        N=make_style(cp[5], bg=TRUE)(black(\"N\")),\n        T=make_style(cp[5], bg=TRUE)(black(\"T\")),\n        Q=make_style(cp[5], bg=TRUE)(black(\"Q\")),\n        S=make_style(cp[5], bg=TRUE)(black(\"S\")),\n\n        # Aromatic\n        F=make_style(cp[6], bg=TRUE)(black(\"F\")),\n        Y=make_style(cp[6], bg=TRUE)(black(\"Y\")),\n        W=make_style(cp[6], bg=TRUE)(black(\"W\")),\n\n        # Negative\n        E=make_style(cp[7], bg=TRUE)(black(\"E\")),\n        D=make_style(cp[7], bg=TRUE)(black(\"D\")),\n\n        # Ambiguity\n        setNames(sprintf(dark_grey_bg(whiter(\"%s\")), dark_grey_bg_letters),\n                 dark_grey_bg_letters),\n\n        # Any code\n        X=make_style(\"grey\", bg=TRUE)(whiter(\"X\"))\n    )\n}\n\n### 'x' must be a character vector.\n## env_var_name is the name of the corresponding palette in .pkgenv\n.add_xstring_colors <- function(x, env_var_name)\n{\n    if (!isTRUE(getOption(\"Biostrings.coloring\", default=FALSE)))\n        return(x)\n    color_palette <- get(env_var_name, envir=.pkgenv)\n    ans <- vapply(x,\n        function(xi) {\n            xi <- safeExplode(xi)\n            m <- match(xi, names(color_palette))\n            match_idx <- which(!is.na(m))\n            xi[match_idx] <- color_palette[m[match_idx]]\n            paste0(xi, collapse=\"\")\n        },\n        character(1),\n        USE.NAMES=FALSE\n    )\n    x_names <- names(x)\n    if (!is.null(x_names))\n        names(ans) <- x_names\n    ans\n}\n\n.update_X_palette <- function(colors=NULL, env_var_name,\n                                alphabet, default_palette_function){\n    ## passing default_palette_function as a function pointer so we don't\n    ## have to evaluate it unless necessary\n    palette <- get(env_var_name, envir=.pkgenv)\n    if(is.null(colors))\n        palette <- default_palette_function()\n    if(!is.null(colors)){\n        if(!is.list(colors)){\n            stop(\"'colors' should be NULL or a named list of entries with 'bg' \",\n                    \"and optionally 'fg' values.\")\n        }\n\n        n <- names(colors)\n        if(!is.null(alphabet) && length(setdiff(n, alphabet)) != 0){\n            ## non-BStrings: checking if the characters are valid\n            stop(\"Invalid codes specified.\")\n        } else if(is.null(alphabet)){\n            ## BStrings: checking for single characters (0:255 in raw)\n            name_nchars <- vapply(n, \\(x) length(charToRaw(x)), integer(1L))\n            if(!all(name_nchars == 1L))\n                stop(\"Invalid codes specified.\")\n        }\n\n        for(i in seq_along(colors)){\n            fg <- colors[[i]]$fg\n            bg <- colors[[i]]$bg\n            if(is.null(fg) && is.null(bg)){\n                palette[n[i]] <- n[i]\n            } else if(is.null(bg)) {\n                palette[n[i]] <- make_style(fg)(n[i])\n            } else {\n                if(is.null(fg)) fg <- rgb(1,1,1)\n                palette[n[i]] <- make_style(bg, bg=TRUE)(make_style(fg)(n[i]))\n            }\n        }\n    }\n\n    assign(env_var_name, palette, envir=.pkgenv)\n}\n\nupdate_DNA_palette <- function(colors=NULL){\n    .update_X_palette(colors, \"DNA_AND_RNA_COLORED_LETTERS\",\n                        union(DNA_ALPHABET, RNA_ALPHABET),\n                        make_DNA_AND_RNA_COLORED_LETTERS)\n}\n\nupdate_RNA_palette <- update_DNA_palette\n\nupdate_AA_palette <- function(colors=NULL){\n    .update_X_palette(colors, \"AA_COLORED_LETTERS\",\n                        AA_ALPHABET,\n                        make_AA_COLORED_LETTERS)\n}\n\nupdate_B_palette <- function(colors=NULL){\n    ## BStrings don't have a default palette\n    ## thus their default palette function is just \\() return(character(0L))\n    .update_X_palette(colors, \"B_COLORED_LETTERS\",\n                        NULL,\n                        \\(){ character(0L) })\n}\n\nadd_colors <- function(x) UseMethod(\"add_colors\")\nadd_colors.default <- identity\nadd_colors.DNA <- add_colors.RNA <- function(x){ .add_xstring_colors(x, \"DNA_AND_RNA_COLORED_LETTERS\") }\nadd_colors.AA <- function(x){ .add_xstring_colors(x, \"AA_COLORED_LETTERS\") }\nadd_colors.B <- function(x) { .add_xstring_colors(x, \"B_COLORED_LETTERS\") }\n",
        "dinucleotideFrequencyTest.R": "# Log-likelihood tests of independence & goodness of fit\n# Does Williams' and Yates' correction\n# does Monte Carlo simulation of p-values, via gtestsim.c\n#\n# G & q calculation from Sokal & Rohlf (1995) Biometry 3rd ed.\n# TOI Yates' correction taken from Mike Camann's 2x2 G-test fn.\n# GOF Yates' correction as described in Zar (2000)\n# more stuff taken from ctest's chisq.test()\n#\n# ToDo:\n# 1) Beautify\n# 2) Add warnings for violations\n# 3) Make appropriate corrections happen by default\n#\n# V3.3 Pete Hurd Sept 29 2001. phurd@ualberta.ca\n\ng.test <- function(x, y = NULL, correct=\"none\",\n  p = rep(1/length(x), length(x)), simulate.p.value = FALSE, B = 2000)\n{\n  DNAME <- deparse(substitute(x))\n  if (is.data.frame(x)) x <- as.matrix(x)\n  if (is.matrix(x)) {\n    if (min(dim(x)) == 1) \n      x <- as.vector(x)\n  }\n  if (!is.matrix(x) && !is.null(y)) {\n    if (length(x) != length(y)) \n      stop(\"x and y must have the same length\")\n    DNAME <- paste(DNAME, \"and\", deparse(substitute(y)))\n    OK <- complete.cases(x, y)\n    x <- as.factor(x[OK])\n    y <- as.factor(y[OK])\n    if ((nlevels(x) < 2) || (nlevels(y) < 2)) \n      stop(\"x and y must have at least 2 levels\")\n    x <- table(x, y)\n  }\n  if (any(x < 0) || any(is.na(x))) \n    stop(\"all entries of x must be nonnegative and finite\")\n  if ((n <- sum(x)) == 0) \n    stop(\"at least one entry of x must be positive\")\n  #If x is matrix, do test of independence\n  if (is.matrix(x)) {\n    #Test of Independence\n    nrows<-nrow(x)\n    ncols<-ncol(x)\n    if (correct==\"yates\"){ # Do Yates' correction?\n      if(dim(x)[1]!=2 || dim(x)[2]!=2) # check for 2x2 matrix\n        stop(\"Yates' correction requires a 2 x 2 matrix\")\n      if((x[1,1]*x[2,2])-(x[1,2]*x[2,1]) > 0)\n        {\n          x[1,1] <- x[1,1] - 0.5\n          x[2,2] <- x[2,2] - 0.5\n          x[1,2] <- x[1,2] + 0.5\n          x[2,1] <- x[2,1] + 0.5\n        }\n      else\n        {\n          x[1,1] <- x[1,1] + 0.5\n          x[2,2] <- x[2,2] + 0.5\n          x[1,2] <- x[1,2] - 0.5\n          x[2,1] <- x[2,1] - 0.5\n        }\n    }\n\n    sr <- apply(x,1,sum)\n    sc <- apply(x,2,sum)\n    E <- outer(sr,sc, \"*\")/n\n    # are we doing a monte-carlo?\n    # no monte carlo GOF?\n    if (simulate.p.value){\n      METHOD <- paste(\"Log likelihood ratio (G-test) test of independence\\n\\t with simulated p-value based on\", B, \"replicates\")\n      tmp <- .C(\"gtestsim\", as.integer(nrows), as.integer(ncols),\n                as.integer(sr), as.integer(sc), as.integer(n), as.integer(B),\n                as.double(E), integer(nrows * ncols), double(n+1),\n                integer(ncols), results=double(B), PACKAGE= \"Biostrings\")\n      g <- 0\n      for (i in 1:nrows){\n        for (j in 1:ncols){\n          if (x[i,j] != 0) g <- g + x[i,j] * log(x[i,j]/E[i,j])\n        }\n      }\n      STATISTIC <- G <- 2 * g\n      PARAMETER <- NA\n      PVAL <- sum(tmp$results >= STATISTIC)/B\n    }\n    else {\n      # no monte-carlo\n      # calculate G\n      g <- 0\n      for (i in 1:nrows){\n        for (j in 1:ncols){\n          if (x[i,j] != 0) g <- g + x[i,j] * log(x[i,j]/E[i,j])\n        }\n      }\n      q <- 1\n      if (correct==\"williams\"){ # Do Williams' correction\n        row.tot <- col.tot <- 0    \n        for (i in 1:nrows){ row.tot <- row.tot + 1/(sum(x[i,])) }\n        for (j in 1:ncols){ col.tot <- col.tot + 1/(sum(x[,j])) }\n        q <- 1+ ((n*row.tot-1)*(n*col.tot-1))/(6*n*(ncols-1)*(nrows-1))\n      }\n      STATISTIC <- G <- 2 * g / q\n      PARAMETER <- (nrow(x)-1)*(ncol(x)-1)\n      PVAL <- 1-pchisq(STATISTIC,df=PARAMETER)\n      if(correct==\"none\")\n        METHOD <- \"Log likelihood ratio (G-test) test of independence without correction\"\n      if(correct==\"williams\")\n        METHOD <- \"Log likelihood ratio (G-test) test of independence with Williams' correction\"\n      if(correct==\"yates\")\n        METHOD <- \"Log likelihood ratio (G-test) test of independence with Yates' correction\"\n    }\n  }\n  else {\n    # x is not a matrix, so we do Goodness of Fit\n    METHOD <- \"Log likelihood ratio (G-test) goodness of fit test\"\n    if (length(x) == 1)\n      stop(\"x must at least have 2 elements\")\n    if (length(x) != length(p))\n      stop(\"x and p must have the same number of elements\")\n    E <- n * p\n\n    if (correct==\"yates\"){ # Do Yates' correction\n      if(length(x)!=2)\n        stop(\"Yates' correction requires 2 data values\")\n      if ( (x[1]-E[1]) > 0.25) {\n        x[1] <- x[1]-0.5\n        x[2] <- x[2]+0.5\n      }\n      else if ( (E[1]-x[1]) > 0.25){\n        x[1] <- x[1]+0.5\n        x[2] <- x[2]-0.5\n      }\n    }\n    names(E) <- names(x)\n    g <- 0\n    for (i in 1:length(x)){\n      if (x[i] != 0) g <- g + x[i] * log(x[i]/E[i])\n    }\n    q <- 1\n    if (correct==\"williams\"){ # Do Williams' correction\n      q <- 1+(length(x)+1)/(6*n)\n    }\n    STATISTIC <- G <- 2*g/q\n    PARAMETER <- length(x) - 1\n    PVAL <- pchisq(STATISTIC, PARAMETER, lower.tail = FALSE)\n  }\n  names(STATISTIC) <- \"Log likelihood ratio statistic (G)\"\n  names(PARAMETER) <- \"X-squared df\"\n  names(PVAL) <- \"p.value\"\n  structure(list(statistic=STATISTIC,parameter=PARAMETER,p.value=PVAL,\n            method=METHOD,data.name=DNAME, observed=x, expected=E),\n            class=\"htest\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"dinucleotideFrequencyTest\" generic and methods.\n###\n\n.dinucleotideFrequencyTest.XStringSet <-\nfunction(x, i, j, test = c(\"chisq\", \"G\", \"adjG\"), simulate.p.value = FALSE,\n         B = 2000)\n{\n    freqTable <- nucleotideFrequencyAt(x, c(i,j))\n    okRows <- rowSums(freqTable) > 0\n    okCols <- colSums(freqTable) > 0\n    freqTable <- freqTable[okRows, okCols]\n    test <- match.arg(test)\n    switch(test,\n            chisq = {\n                ans <-\n                  suppressWarnings(chisq.test(freqTable,\n                                              correct = FALSE,\n                                              simulate.p.value = simulate.p.value,\n                                              B = B))\n                ans$method <-\n                  paste(ans$method, \" of independence\", sep = \"\")\n            },\n            G = {\n                ans <-\n                  suppressWarnings(g.test(freqTable,\n                                          correct = \"none\",\n                                          simulate.p.value = simulate.p.value,\n                                          B = B))\n            },\n            adjG = {\n                ans <-\n                  suppressWarnings(g.test(freqTable,\n                                          correct = \"williams\",\n                                          simulate.p.value = simulate.p.value,\n                                          B = B))\n            })\n    ans$data.name <-\n      paste(\"nucleotideFrequencyAt(\", deparse(substitute(x)),\n            \", c(\", i, \", \", j, \"))\", sep = \"\")\n    ans\n}\n\nsetGeneric(\"dinucleotideFrequencyTest\", signature=\"x\",\n    function(x, i, j, test = c(\"chisq\", \"G\", \"adjG\"), simulate.p.value = FALSE,\n             B = 2000)\n        standardGeneric(\"dinucleotideFrequencyTest\")\n)\n\nsetMethod(\"dinucleotideFrequencyTest\", \"DNAStringSet\",\n    .dinucleotideFrequencyTest.XStringSet\n)\n\nsetMethod(\"dinucleotideFrequencyTest\", \"RNAStringSet\",\n    .dinucleotideFrequencyTest.XStringSet\n)\n",
        "findPalindromes.R": "### =========================================================================\n### findPalindromes() and family\n### -------------------------------------------------------------------------\n\n\n.get_DNAorRNA_palindrome_L2R_lkup <- function()\n{\n    keys <- unname(DNA_CODES[c(DNA_BASES, \"-\")])\n    vals <- unname(DNA_CODES[c(rev(DNA_BASES), \"-\")])\n    buildLookupTable(keys, vals)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The findPalindromes() generic and methods\n###\n\n### Return an IRanges object.\n.find_palindromes <- function(subject, min.armlength,\n                              max.looplength, min.looplength,\n                              max.mismatch, allow.wobble, L2R_lkup)\n{\n    ## check min.armlength\n    if (!isSingleNumber(min.armlength))\n        stop(\"'min.armlength' must be a single integer\")\n    min.armlength <- as.integer(min.armlength)\n    if (min.armlength < 2)\n        stop(\"'min.armlength' must be >= 2\")\n    ## check max.looplength\n    if (!isSingleNumber(max.looplength))\n        stop(\"'max.looplength' must be a single integer\")\n    max.looplength <- as.integer(max.looplength)\n    if (max.looplength < 0)\n        stop(\"'max.looplength' must be a non-negative integer\")\n    ## check min.looplength\n    if (!isSingleNumber(min.looplength))\n        stop(\"'min.looplength' must be a single integer\")\n    min.looplength <- as.integer(min.looplength)\n    if (min.looplength > max.looplength)\n        stop(\"'min.looplength' must be <= 'max.looplength'\")\n    if (min.looplength < 0)\n        stop(\"'min.looplength' must be a non-negative integer\")\n    if (!isTRUEorFALSE(allow.wobble))\n        stop(\"'allow.wobble' must be a logical\")\n    if (allow.wobble && !(seqtype(subject) %in% c(\"DNA\", \"RNA\")))\n        stop(\"subject must be DNA or RNA if 'allow.wobble' is TRUE\")\n    ## check max.mismatch\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    C_ans <- .Call2(\"find_palindromes\",\n                    subject,\n                    min.armlength, max.looplength, max.mismatch,\n                    min.looplength, allow.wobble, L2R_lkup,\n                    PACKAGE=\"Biostrings\")\n    unsafe.newXStringViews(subject, start(C_ans), width(C_ans))\n}\n\nsetGeneric(\"findPalindromes\", signature=\"subject\",\n    function(subject, min.armlength=4,\n                      max.looplength=1, min.looplength=0,\n                      max.mismatch=0, allow.wobble=FALSE)\n        standardGeneric(\"findPalindromes\")\n)\n\nsetMethod(\"findPalindromes\", \"XString\",\n    function(subject, min.armlength=4,\n                      max.looplength=1, min.looplength=0,\n                      max.mismatch=0, allow.wobble=FALSE)\n    {\n        .find_palindromes(subject, min.armlength,\n                          max.looplength, min.looplength,\n                          max.mismatch, allow.wobble,\n                          NULL)\n    }\n)\n\nsetMethod(\"findPalindromes\", \"DNAString\",\n    function(subject, min.armlength=4,\n                      max.looplength=1, min.looplength=0,\n                      max.mismatch=0, allow.wobble=FALSE)\n    {\n        L2R_lkup <- .get_DNAorRNA_palindrome_L2R_lkup()\n        .find_palindromes(subject, min.armlength,\n                          max.looplength, min.looplength,\n                          max.mismatch, allow.wobble,\n                          L2R_lkup)\n    }\n)\n\nsetMethod(\"findPalindromes\", \"RNAString\",\n    function(subject, min.armlength=4,\n                      max.looplength=1, min.looplength=0,\n                      max.mismatch=0, allow.wobble=FALSE)\n    {\n        L2R_lkup <- .get_DNAorRNA_palindrome_L2R_lkup()\n        .find_palindromes(subject, min.armlength,\n                          max.looplength, min.looplength,\n                          max.mismatch, allow.wobble,\n                          L2R_lkup)\n    }\n)\n\nsetMethod(\"findPalindromes\", \"XStringViews\",\n    function(subject, min.armlength=4,\n                      max.looplength=1, min.looplength=0,\n                      max.mismatch=0, allow.wobble=FALSE)\n    {\n        tmp <- vector(mode=\"list\", length=length(subject))\n        offsets <- start(subject) - 1L\n        for (i in seq_along(subject)) {\n            pals <- findPalindromes(subject[[i]],\n                                    min.armlength=min.armlength,\n                                    max.looplength=max.looplength,\n                                    min.looplength=min.looplength,\n                                    max.mismatch=max.mismatch,\n                                    allow.wobble=allow.wobble)\n            tmp[[i]] <- shift(ranges(pals), shift=offsets[i])\n        }\n        ans_ranges <- do.call(\"c\", tmp)\n        unsafe.newXStringViews(subject(subject),\n                               start(ans_ranges), width(ans_ranges))\n    }\n)\n\nsetMethod(\"findPalindromes\", \"MaskedXString\",\n    function(subject, min.armlength=4,\n                      max.looplength=1, min.looplength=0,\n                      max.mismatch=0, allow.wobble=FALSE)\n    {\n        findPalindromes(toXStringViewsOrXString(subject),\n                        min.armlength=min.armlength,\n                        max.looplength=max.looplength,\n                        min.looplength=min.looplength,\n                        max.mismatch=max.mismatch,\n                        allow.wobble=allow.wobble)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The palindromeArmLength() generic and methods\n###\n\n.palindrome_arm_length <- function(x, max.mismatch, allow.wobble, L2R_lkup)\n{\n    if (!isTRUEorFALSE(allow.wobble))\n        stop(\"'allow.wobble' must be a logical\")\n    if (allow.wobble && !(seqtype(x) %in% c(\"DNA\", \"RNA\")))\n        stop(\"x must be DNA or RNA if 'allow.wobble' is TRUE\")\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    .Call2(\"palindrome_arm_length\",\n           x, max.mismatch, allow.wobble, L2R_lkup,\n           PACKAGE=\"Biostrings\")\n}\n\nsetGeneric(\"palindromeArmLength\", signature=\"x\",\n    function(x, max.mismatch=0, allow.wobble=FALSE) standardGeneric(\"palindromeArmLength\")\n)\n\nsetMethod(\"palindromeArmLength\", \"XString\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        x <- as(x, \"XStringSet\")\n        .palindrome_arm_length(x, max.mismatch, allow.wobble, NULL)\n    }\n)\n\nsetMethod(\"palindromeArmLength\", \"DNAString\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        L2R_lkup <- .get_DNAorRNA_palindrome_L2R_lkup()\n        x <- as(x, \"DNAStringSet\")\n        .palindrome_arm_length(x, max.mismatch, allow.wobble, L2R_lkup)\n    }\n)\n\nsetMethod(\"palindromeArmLength\", \"RNAString\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        L2R_lkup <- .get_DNAorRNA_palindrome_L2R_lkup()\n        x <- as(x, \"RNAStringSet\")\n        .palindrome_arm_length(x, max.mismatch, allow.wobble, L2R_lkup)\n    }\n)\n\nsetMethod(\"palindromeArmLength\", \"XStringViews\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        if (length(x) == 0)\n            return(integer(0))\n        if (seqtype(x) %in% c(\"DNA\", \"RNA\")) {\n            L2R_lkup <- .get_DNAorRNA_palindrome_L2R_lkup()\n        } else {\n            L2R_lkup <- NULL\n        }\n        max.mismatch <- normargMaxMismatch(max.mismatch)\n        x <- fromXStringViewsToStringSet(x, out.of.limits=\"error\")\n        .palindrome_arm_length(x, max.mismatch, allow.wobble, L2R_lkup)\n    }\n)\n\nsetMethod(\"palindromeArmLength\", \"XStringSet\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        if (length(x) == 0)\n            return(integer(0))\n        if (seqtype(x) %in% c(\"DNA\", \"RNA\")) {\n            L2R_lkup <- .get_DNAorRNA_palindrome_L2R_lkup()\n        } else {\n            L2R_lkup <- NULL\n        }\n        max.mismatch <- normargMaxMismatch(max.mismatch)\n        .palindrome_arm_length(x, max.mismatch, allow.wobble, L2R_lkup)\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The palindromeLeftArm() and palindromeRightArm() generics and methods\n###\n\nsetGeneric(\"palindromeLeftArm\", signature=\"x\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n        standardGeneric(\"palindromeLeftArm\")\n)\n\nsetGeneric(\"palindromeRightArm\", signature=\"x\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n        standardGeneric(\"palindromeRightArm\")\n)\n\nsetMethod(\"palindromeLeftArm\", \"XString\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n        subseq(x,\n            start=1L,\n            end=palindromeArmLength(x, max.mismatch=max.mismatch, allow.wobble=allow.wobble)\n        )\n)\n\nsetMethod(\"palindromeRightArm\", \"XString\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        start <- nchar(x) -\n                 palindromeArmLength(x, max.mismatch=max.mismatch, allow.wobble=allow.wobble) +\n                 1L\n        subseq(x, start=start, end=nchar(x))\n    }\n)\n\nsetMethod(\"palindromeLeftArm\", \"XStringViews\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        ans_start <- start(x)\n        ans_width <- palindromeArmLength(x, max.mismatch=max.mismatch, allow.wobble=allow.wobble)\n        unsafe.newXStringViews(subject(x), ans_start, ans_width)\n    }\n)\n\nsetMethod(\"palindromeRightArm\", \"XStringViews\",\n    function(x, max.mismatch=0, allow.wobble=FALSE)\n    {\n        ans_width <- palindromeArmLength(x, max.mismatch=max.mismatch, allow.wobble=allow.wobble)\n        ans_start <- end(x) - ans_width + 1L\n        unsafe.newXStringViews(subject(x), ans_start, ans_width)\n    }\n)\n\n",
        "getSeq.R": "### =========================================================================\n### The getSeq() generic\n### -------------------------------------------------------------------------\n\n\nsetGeneric(\"getSeq\", function(x, ...) standardGeneric(\"getSeq\"))\n\n### Methods are defined in BSgenome and Rsamtools.\n\n",
        "injectHardMask.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"injectHardMask\" generic function and methods.\n###\n\nsetGeneric(\"injectHardMask\", signature=\"x\",\n    function(x, letter=\"+\") standardGeneric(\"injectHardMask\")\n)\n\nsetMethod(\"injectHardMask\", \"XStringViews\",\n    function(x, letter=\"+\")\n    {\n        x_seqtype <- seqtype(x)\n        if (is(letter, \"XString\") && seqtype(letter) == x_seqtype) {\n            if (length(letter) != 1)\n                stop(\"'letter' must be a single letter\")\n        } else {\n            if (!isSingleString(letter) || nchar(letter) != 1)\n                stop(\"'letter' must be a single letter\")\n            letter <- XString(x_seqtype, letter)\n        }\n        code <- XString.readCodes(letter, 1L)\n        y <- gaps(x)\n        ## Because y is obtained with the \"gaps\" method for XStringViews\n        ## objects, then the set of ranges defined by start(y) and width(y)\n        ## is normal and is guaranteed to be within the limits of y.\n        ## Hence start(y) and width(y) can be considered safe.\n        .Call2(\"XString_inject_code\",\n              subject(y), start(y), width(y), code,\n              PACKAGE=\"Biostrings\")\n    }\n)\n\nsetMethod(\"injectHardMask\", \"MaskedXString\",\n    function(x, letter=\"+\")\n    {\n        y <- as(x, \"XStringViews\")\n        injectHardMask(y, letter=letter)\n    }\n)\n\n",
        "letter.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"letter\" new generic.\n###\n\n### Return a character vector.\nsetGeneric(\"letter\", signature=\"x\",\n    function(x, i) standardGeneric(\"letter\")\n)\n\n### Return a character vector of the same length as 'x'\n### where all non-NA elements have length(i) characters.\nsetMethod(\"letter\", \"character\",\n    function(x, i)\n    {\n        if (!is.numeric(i) || anyNA(i))\n            stop(\"subscript 'i' must be an NA-free numeric vector\")\n        if (length(x) == 0)\n            return(character(0))\n        if (length(i) == 0)\n            return(character(length(x)))\n        noNA_x <- x[!is.na(x)]\n        imax <- min(nchar(noNA_x))\n        if (!all(i >= 1) || !all(i <= imax))\n            stop(\"subscript out of bounds\")\n        ## Which one is faster? Looping on i with substr or looping\n        ## on noNA_x with substring? It depends...\n        if (length(x) >= length(i)) {\n            tmp <- lapply(i, function(i1) substr(noNA_x, i1, i1))\n            x[!is.na(x)] <- do.call(paste, c(tmp, sep=\"\"))\n        } else {\n            x[!is.na(x)] <- sapply(\n                                noNA_x,\n                                function(x1) paste(substring(x1, i, i), collapse=\"\"),\n                                USE.NAMES=FALSE\n                            )\n        }\n        x\n    }\n)\n\n### Return a character vector of length 1.\nsetMethod(\"letter\", \"XString\",\n    function(x, i)\n    {\n        if (!is.numeric(i) || anyNA(i))\n            stop(\"subscript 'i' must be an NA-free numeric vector\")\n        if (!is.integer(i))\n            i <- as.integer(i)\n        imax <- length(x)\n        if (!all(i >= 1) || !all(i <= imax))\n            stop(\"subscript out of bounds\")\n        extract_character_from_XString_by_positions(x, i, collapse=TRUE)\n    }\n)\n\n### Return a character vector of the same length as 'x'.\nsetMethod(\"letter\", \"XStringViews\",\n    function(x, i)\n    {\n        if (!is.numeric(i) || anyNA(i))\n            stop(\"subscript 'i' must be an NA-free numeric vector\")\n        if (!is.integer(i))\n            i <- as.integer(i)\n        if (length(x) == 0)\n            return(character(0))\n        imax <- min(width(x))\n        if (!all(i >= 1L) || !all(i <= imax))\n            stop(\"subscript out of bounds\")\n        sapply(x, letter, i)\n    }\n)\n\nsetMethod(\"letter\", \"MaskedXString\",\n    function(x, i)\n        letter(unmasked(x), i)\n)\n\n",
        "letterFrequency.R": "### =========================================================================\n### alphabetFrequency()\n### hasOnlyBaseLetters()\n### uniqueLetters()\n### letterFrequencyInSlidingView()\n### letterFrequency()\n### mkAllStrings()\n### oligonucleotideFrequency()\n### dinucleotideFrequency()\n### trinucleotideFrequency()\n### oligonucleotideTransitions()\n### nucleotideFrequencyAt()\n### consensusMatrix() and consensusString()\n### -------------------------------------------------------------------------\n\n.normargWidth <- function(width, argname=\"width\", min.width=1L)\n{\n    if (!isSingleNumber(width))\n        stop(\"'\", argname, \"' must be a single integer\")\n    width <- as.integer(width)\n    if (width < min.width)\n        stop(\"'\", argname, \"' must be an integer >= \", min.width)\n    width\n}\n\n.normargStep <- function(step)\n{\n    if (!isSingleNumber(step))\n        stop(\"'step' must be a single integer\")\n    step <- as.integer(step)\n    if (step <= 0L)\n        stop(\"'step' must be a positive integer\")\n    step\n}\n\n.normargCollapse <- function(collapse)\n{\n    if (!isTRUEorFALSE(collapse))\n        stop(\"'collapse' must be TRUE or FALSE\")\n    collapse\n}\n\n.normargAsArray <- function(as.array)\n{\n    if (!isTRUEorFALSE(as.array))\n        stop(\"'as.array' must be TRUE or FALSE\")\n    as.array\n}\n\n.normargFastMovingSide <- function(fast.moving.side, as.array=FALSE)\n{\n    if (as.array)\n        return(\"left\")\n    if (!isSingleString(fast.moving.side))\n        stop(\"'fast.moving.side' must be a single string\")\n    match.arg(fast.moving.side, c(\"left\", \"right\"))\n}\n\n.normargWithLabels <- function(with.labels)\n{\n    if (!isTRUEorFALSE(with.labels))\n        stop(\"'with.labels' must be TRUE or FALSE\")\n    with.labels\n}\n\n.normargSimplifyAs <- function(simplify.as, as.array)\n{\n    if (!isSingleString(simplify.as))\n        stop(\"'simplify.as' must be a single string\")\n    simplify.as <- match.arg(simplify.as, c(\"matrix\", \"list\", \"collapsed\"))\n    if (simplify.as == \"matrix\" && as.array)\n        stop(\"'as.array' cannot be TRUE when 'simplify.as' is \\\"matrix\\\"\")\n    simplify.as\n}\n\n### Author: HJ\n.normargLetters <- function(letters, alphabet)\n{\n    if (!is.character(letters) || any(is.na(letters)))\n        stop(\"'letters' must be a character vector with no NAs\")\n    if (any(nchar(letters) == 0L))\n        stop(\"'letters' cannot contain empty strings\")\n    single_letters <- unlist(strsplit(letters, NULL, fixed=TRUE))\n    if (any(duplicated(single_letters)))\n        stop(\"letters in 'letters' must be unique\")\n    if (!is.null(alphabet)) {\n        is_valid_letter <- single_letters %in% alphabet\n        if (!all(is_valid_letter))\n            stop(\"invalid letter(s): \",\n                 paste(single_letters[!is_valid_letter], collapse=\", \"))\n    }\n    single_letters\n}\n\n.normargOR <- function(OR)\n{\n    if (!isSingleString(OR) && !(isSingleNumber(OR) && OR == 0))\n        stop(\"'OR' must be a single string or 0\")\n    OR\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"alphabetFrequency\" generic and methods.\n###\n### sum(alphabetFrequency(x)) should always be exactly nchar(x)\n###\n\n.XString.letter_frequency <- function(x, as.prob)\n{\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    ans <- .Call2(\"XString_letter_frequency\",\n                 x, NULL, FALSE,\n                 PACKAGE=\"Biostrings\")\n    if (as.prob)\n        ans <- ans / nchar(x) # nchar(x) is sum(ans) but faster\n    ans\n}\n\n.XString.nucleotide_frequency <- function(x, as.prob, baseOnly)\n{\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    codes <- xscodes(x, baseOnly=baseOnly)\n    ans <- .Call2(\"XString_letter_frequency\",\n                 x, codes, baseOnly,\n                 PACKAGE=\"Biostrings\")\n    if (as.prob)\n        ans <- ans / nchar(x) # nchar(x) is sum(ans) but faster\n    ans\n}\n\n.XString.amino_acid_frequency <- function(x, as.prob, baseOnly)\n{\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    codes <- xscodes(x, baseOnly=baseOnly)\n    ans <- .Call2(\"XString_letter_frequency\",\n                 x, codes, baseOnly,\n                 PACKAGE=\"Biostrings\")\n    if (as.prob)\n        ans <- ans / nchar(x) # nchar(x) is sum(ans) but faster\n    ans\n}\n\n.XStringSet.letter_frequency <- function(x, as.prob, collapse)\n{\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    collapse <- .normargCollapse(collapse)\n    ans <- .Call2(\"XStringSet_letter_frequency\",\n                 x, collapse, NULL, FALSE,\n                 PACKAGE=\"Biostrings\")\n    if (as.prob) {\n        if (collapse)\n            ans <- ans / sum(ans)\n        else\n            ans <- ans / nchar(x)\n    }\n    ans\n}\n\n.XStringSet.nucleotide_frequency <- function(x, as.prob, collapse, baseOnly)\n{\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    collapse <- .normargCollapse(collapse)\n    codes <- xscodes(x, baseOnly=baseOnly)\n    ans <- .Call2(\"XStringSet_letter_frequency\",\n                 x, collapse, codes, baseOnly,\n                 PACKAGE=\"Biostrings\")\n    if (as.prob) {\n        if (collapse)\n            ans <- ans / sum(ans)\n        else\n            ans <- ans / nchar(x)\n    }\n    ans\n}\n\n.XStringSet.amino_acid_frequency <- function(x, as.prob, collapse, baseOnly)\n{\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    collapse <- .normargCollapse(collapse)\n    codes <- xscodes(x, baseOnly=baseOnly)\n    ans <- .Call2(\"XStringSet_letter_frequency\",\n                 x, collapse, codes, baseOnly,\n                 PACKAGE=\"Biostrings\")\n    if (as.prob) {\n        if (collapse)\n            ans <- ans / sum(ans)\n        else\n            ans <- ans / nchar(x)\n    }\n    ans\n}\n\nsetGeneric(\"alphabetFrequency\", signature=\"x\",\n    function(x, as.prob=FALSE, ...) standardGeneric(\"alphabetFrequency\")\n)\n\nsetMethod(\"alphabetFrequency\", \"XString\",\n    function(x, as.prob=FALSE)\n        .XString.letter_frequency(x, as.prob)\n)\n\nsetMethod(\"alphabetFrequency\", \"DNAString\",\n    function(x, as.prob=FALSE, baseOnly=FALSE)\n        .XString.nucleotide_frequency(x, as.prob, baseOnly)\n)\n\nsetMethod(\"alphabetFrequency\", \"RNAString\",\n    function(x, as.prob=FALSE, baseOnly=FALSE)\n        .XString.nucleotide_frequency(x, as.prob, baseOnly)\n)\n\nsetMethod(\"alphabetFrequency\", \"AAString\",\n    function(x, as.prob=FALSE, baseOnly=FALSE)\n        .XString.amino_acid_frequency(x, as.prob, baseOnly)\n)\n\nsetMethod(\"alphabetFrequency\", \"XStringSet\",\n    function(x, as.prob=FALSE, collapse=FALSE)\n        .XStringSet.letter_frequency(x, as.prob, collapse)\n)\n\nsetMethod(\"alphabetFrequency\", \"DNAStringSet\",\n    function(x, as.prob=FALSE, collapse=FALSE, baseOnly=FALSE)\n        .XStringSet.nucleotide_frequency(x, as.prob, collapse, baseOnly)\n)\n\nsetMethod(\"alphabetFrequency\", \"RNAStringSet\",\n    function(x, as.prob=FALSE, collapse=FALSE, baseOnly=FALSE)\n        .XStringSet.nucleotide_frequency(x, as.prob, collapse, baseOnly)\n)\n\nsetMethod(\"alphabetFrequency\", \"AAStringSet\",\n    function(x, as.prob=FALSE, collapse=FALSE, baseOnly=FALSE)\n        .XStringSet.amino_acid_frequency(x, as.prob, collapse, baseOnly)\n)\n\n### library(drosophila2probe)\n### dict0 <- drosophila2probe$sequence\n### x <- DNAStringSet(dict0[1:2000])\n### alphabetFrequency(x, baseOnly=TRUE)\n### y <- as(x, \"Views\")\n### alphabetFrequency(y, baseOnly=TRUE)\nsetMethod(\"alphabetFrequency\", \"XStringViews\",\n    function(x, as.prob=FALSE, ...)\n    {\n        y <- fromXStringViewsToStringSet(x)\n        alphabetFrequency(y, as.prob=as.prob, ...)\n    }\n)\n\nsetMethod(\"alphabetFrequency\", \"MaskedXString\",\n    function(x, as.prob=FALSE, ...)\n    {\n        y <- as(x, \"XStringViews\")\n        alphabetFrequency(y, as.prob=as.prob, collapse=TRUE, ...)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"hasOnlyBaseLetters\" generic and methods.\n###\n\nsetGeneric(\"hasOnlyBaseLetters\", function(x) standardGeneric(\"hasOnlyBaseLetters\"))\n\nsetMethod(\"hasOnlyBaseLetters\", \"DNAString\",\n    function(x)\n        alphabetFrequency(x, baseOnly=TRUE)[[\"other\"]] == 0L\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"RNAString\",\n    function(x) hasOnlyBaseLetters(DNAString(x))\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"AAString\",\n    function(x)\n        alphabetFrequency(x, baseOnly=TRUE)[[\"other\"]] == 0L\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"DNAStringSet\",\n    function(x)\n        alphabetFrequency(x, collapse=TRUE, baseOnly=TRUE)[[\"other\"]] == 0L\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"RNAStringSet\",\n    function(x) hasOnlyBaseLetters(DNAStringSet(x))\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"AAStringSet\",\n    function(x)\n        alphabetFrequency(x, collapse=TRUE, baseOnly=TRUE)[[\"other\"]] == 0L\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"XStringViews\",\n    function(x)\n    {\n        y <- fromXStringViewsToStringSet(x)\n        hasOnlyBaseLetters(y)\n    }\n)\n\nsetMethod(\"hasOnlyBaseLetters\", \"MaskedXString\",\n    function(x)\n    {\n        y <- as(x, \"XStringViews\")\n        hasOnlyBaseLetters(y)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"uniqueLetters\" generic and methods.\n###\n\n.alphabetFrequencyToUniqueLetters <- function(x_af, x_codes)\n{\n    if (!is.null(names(x_af)))\n        return(names(x_af)[x_af != 0])\n    if (!identical(x_codes, 0:255))\n        stop(\"Biostrings internal anomaly: cannot infer names of \",\n             \"vector returned by 'alphabetFrequency(x)'\")\n    x_codes <- x_codes[x_af != 0]\n    if (length(x_codes) != 0 && min(x_codes) == 0)\n        warning(\"'x' contains embedded nuls\")\n    intToUtf8(x_codes, multiple=TRUE)\n}\n\nsetGeneric(\"uniqueLetters\", function(x) standardGeneric(\"uniqueLetters\"))\n\nsetMethod(\"uniqueLetters\", \"XString\",\n    function(x)\n    {\n        x_af <- alphabetFrequency(x)\n        .alphabetFrequencyToUniqueLetters(x_af, xscodes(x))\n    }\n)\n\nsetMethod(\"uniqueLetters\", \"XStringSet\",\n    function(x)\n    {\n        x_af <- alphabetFrequency(x, collapse=TRUE)\n        .alphabetFrequencyToUniqueLetters(x_af, xscodes(x))\n    }\n)\n\nsetMethod(\"uniqueLetters\", \"XStringViews\",\n    function(x)\n    {\n        y <- fromXStringViewsToStringSet(x)\n        uniqueLetters(y)\n    }\n)\n\nsetMethod(\"uniqueLetters\", \"MaskedXString\",\n    function(x)\n    {\n        y <- as(x, \"XStringViews\")\n        uniqueLetters(y)\n    }\n)\n\n### We need to be able to map *any* character whose UTF8 code is between 0 and\n### 255 to its code, even the nul character.\n### 'x' represents the set of characters to map: it must be a vector of\n### 1-letter or empty strings, the empty string being used to represent the nul\n### character. Typically, 'x' will be what was returned by uniqueLetters().\n### For internal use only (not exported).\nsafeLettersToInt <- function(x, letters.as.names=FALSE)\n{\n    ii <- which(x == \"\")\n    ans <- utf8ToInt(paste(x, collapse=\"\"))\n    for (i in ii)\n        ans <- append(ans, 0, after=i-1)\n    if (letters.as.names)\n        names(ans) <- x\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"letterFrequency\" and \"letterFrequencyInSlidingView\"\n### generics and methods.\n### Author: HJ\n###\n\n### joint C interface\n### The value is a matrix for letterFrequencyInSlidingView\n### and a matrix for letterFrequency unless collapse=TRUE.\n.letterFrequency <- function(x, view.width, letters, OR, collapse=FALSE)\n{\n    ## letterFrequency / letterFrequencyInSlidingView switch\n    is_sliding <- !is.na(view.width)\n    single_letters <- .normargLetters(letters, alphabet(x))\n    OR <- .normargOR(OR)\n    codes <- xscodes(x)\n    if (is.null(names(codes)))\n        single_codes <- as.integer(BString(paste(single_letters, collapse=\"\")))\n    else\n        single_codes <- codes[single_letters]\n    ## Unless 'OR == 0', letters in multi-character elements of\n    ## 'letters' are to be grouped (i.e. tabulated in common).\n    ## We send a vector indicating the column (1-based) into which each\n    ## letter in 'letters' should be tabulated.  For example, for\n    ## 'letters = c(\"CG\", \"AT\")' and 'OR != 0', we send 'c(1,1,2,2)'.\n    ## The columns of the result are named accordingly using the OR symbol.\n    nc <- nchar(letters)\n    if (all(nc == 1L) || OR == 0) {\n        colmap <- NULL\n        colnames <- single_letters\n    } else {\n        colmap <- rep.int(seq_len(length(letters)), nc)\n        colnames <- sapply(strsplit(letters, NULL, fixed=TRUE),\n                           function(z) paste(z, collapse=OR))\n    }\n    if (is_sliding)\n        .Call2(\"XString_letterFrequencyInSlidingView\",\n              x, view.width, single_codes, colmap, colnames,\n              PACKAGE=\"Biostrings\")\n    else\n        .Call2(\"XStringSet_letterFrequency\",\n              x, single_codes, colmap, colnames, collapse,\n              PACKAGE=\"Biostrings\")\n}\n\n### letterFrequencyInSlidingView\nsetGeneric(\"letterFrequencyInSlidingView\", signature=\"x\",\n    function(x, view.width, letters, OR=\"|\", as.prob=FALSE)\n        standardGeneric(\"letterFrequencyInSlidingView\")\n)\n\n### Ensure 'view.width' is not NA\nsetMethod(\"letterFrequencyInSlidingView\", \"XString\",\n    function(x, view.width, letters, OR=\"|\", as.prob=FALSE)\n    {\n        view.width <- .normargWidth(view.width, \"view.width\")\n        if (!isTRUEorFALSE(as.prob))\n            stop(\"'as.prob' must be TRUE or FALSE\")\n        ans <- .letterFrequency(x, view.width, letters=letters, OR=OR)\n        if (as.prob)\n            ans <- ans / view.width\n        ans\n    }\n)\n\n### letterFrequency\nsetGeneric(\"letterFrequency\", signature=\"x\",\n    function(x, letters, OR=\"|\", as.prob=FALSE, ...)\n        standardGeneric(\"letterFrequency\")\n)\n\nsetMethod(\"letterFrequency\", \"XStringSet\",\n    function(x, letters, OR=\"|\", as.prob=FALSE, collapse=FALSE)\n    {\n        if (!isTRUEorFALSE(as.prob))\n            stop(\"'as.prob' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(collapse))\n            stop(\"'collapse' must be TRUE or FALSE\")\n        ans <- .letterFrequency(x, NA, letters=letters, OR=OR,\n                                collapse=collapse)\n        if (as.prob) {\n            nc <- nchar(x)\n            if (collapse)\n                nc <- sum(nc)\n            ans <- ans / nc\n        }\n        ans\n    }\n)\n\nsetMethod(\"letterFrequency\", \"XString\",\n    function(x, letters, OR=\"|\", as.prob=FALSE)\n        letterFrequency(as(x, \"XStringSet\"),\n            letters=letters, OR=OR, as.prob=as.prob, collapse=TRUE)\n)\n\nsetMethod(\"letterFrequency\", \"XStringViews\",\n    function(x, letters, OR=\"|\", as.prob=FALSE, ...)\n        letterFrequency(as(x, \"XStringSet\"),\n            letters=letters, OR=OR, as.prob=as.prob, ...)\n)\n\nsetMethod(\"letterFrequency\", \"MaskedXString\",\n    function(x, letters, OR=\"|\", as.prob=FALSE)\n        letterFrequency(as(x, \"XStringViews\"),\n            letters=letters, OR=OR, as.prob=as.prob, collapse=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"mkAllStrings\" function.\n###\n\n.mkAllStringsR <- function(alphabet, width)\n{\n    if (width == 0L)\n        return(\"\")\n    ansR <- .mkAllStringsR(alphabet, width - 1L)\n    unlist(lapply(alphabet, function(l) paste(l, ansR, sep=\"\")))\n}\n\n.mkAllStringsL <- function(alphabet, width)\n{\n    if (width == 0L)\n        return(\"\")\n    ansL <- .mkAllStringsL(alphabet, width - 1L)\n    unlist(lapply(alphabet, function(l) paste(ansL, l, sep=\"\")))\n}\n\n.mkAllStrings <- function(alphabet, width, fast.moving.side)\n{\n    if (length(alphabet) == 0L && width != 0L)\n        return(character(0))\n    if (fast.moving.side == \"right\")\n        .mkAllStringsR(alphabet, width)\n    else\n        .mkAllStringsL(alphabet, width)\n}\n\nmkAllStrings <- function(alphabet, width, fast.moving.side=\"right\")\n{\n    if (!is.character(alphabet))\n        stop(\"'alphabet' must be a character vector\")\n    .mkAllStrings(alphabet,\n                  .normargWidth(width, min.width=0L),\n                  .normargFastMovingSide(fast.moving.side))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"oligonucleotideFrequency\" generic and methods.\n###\n### Except for the 'other' element, oligonucleotideFrequency(x, 1L)\n### should be the same as alphabetFrequency(x, baseOnly=TRUE).\n###\n### Something else worth checking:\n###   library(BSgenome.Dmelanogaster.UCSC.dm3)\n###   chr3R <- Dmelanogaster$chr3R\n###   width <- 12\n###   dict0 <- mkAllStrings(names(Biostrings:::DNAcodes(TRUE)), width)\n###   names(dict0) <- dict0\n###   pdict <- PDict(dict0)\n###   system.time(c1 <- countPDict(pdict, chr3R))\n###   system.time(c2 <- oligonucleotideFrequency(chr3R, width, with.labels=FALSE))\n###   identical(c1, c2) # must be TRUE\n### Then try for other values of 'width' (1 <= width <= 12).\n### Of course oligonucleotideFrequency() is much better: it is >10x faster, does\n### not require preprocessing, and uses much less memory.\n###\n\nsetGeneric(\"oligonucleotideFrequency\", signature=\"x\",\n    function(x, width, step=1,\n             as.prob=FALSE, as.array=FALSE,\n             fast.moving.side=\"right\", with.labels=TRUE, ...)\n        standardGeneric(\"oligonucleotideFrequency\")\n)\n\nsetMethod(\"oligonucleotideFrequency\", \"XString\",\n    function(x, width, step=1,\n             as.prob=FALSE, as.array=FALSE,\n             fast.moving.side=\"right\", with.labels=TRUE)\n    {\n        if (!(seqtype(x) %in% c(\"DNA\", \"RNA\")))\n            stop(\"'x' must contain sequences of type DNA or RNA\")\n        width <- .normargWidth(width)\n        step <- .normargStep(step)\n        if (!isTRUEorFALSE(as.prob))\n            stop(\"'as.prob' must be TRUE or FALSE\")\n        as.array <- .normargAsArray(as.array)\n        fast.moving.side <- .normargFastMovingSide(fast.moving.side, as.array)\n        with.labels <- .normargWithLabels(with.labels)\n        base_codes <- xscodes(x, baseOnly=TRUE)\n        .Call2(\"XString_oligo_frequency\",\n               x, width, step,\n               as.prob, as.array,\n               fast.moving.side, with.labels,\n               base_codes,\n               PACKAGE=\"Biostrings\")\n    }\n)\n\nsetMethod(\"oligonucleotideFrequency\", \"XStringSet\",\n    function(x, width, step=1,\n             as.prob=FALSE, as.array=FALSE,\n             fast.moving.side=\"right\", with.labels=TRUE,\n             simplify.as=\"matrix\")\n    {\n        if (!(seqtype(x) %in% c(\"DNA\", \"RNA\")))\n            stop(\"'x' must contain sequences of type DNA or RNA\")\n        width <- .normargWidth(width)\n        step <- .normargStep(step)\n        if (!isTRUEorFALSE(as.prob))\n            stop(\"'as.prob' must be TRUE or FALSE\")\n        as.array <- .normargAsArray(as.array)\n        fast.moving.side <- .normargFastMovingSide(fast.moving.side, as.array)\n        with.labels <- .normargWithLabels(with.labels)\n        simplify.as <- .normargSimplifyAs(simplify.as, as.array)\n        base_codes <- xscodes(x, baseOnly=TRUE)\n        .Call2(\"XStringSet_oligo_frequency\",\n               x, width, step,\n               as.prob, as.array,\n               fast.moving.side, with.labels, simplify.as,\n               base_codes,\n               PACKAGE=\"Biostrings\")\n    }\n)\n\nsetMethod(\"oligonucleotideFrequency\", \"XStringViews\",\n    function(x, width, step=1,\n             as.prob=FALSE, as.array=FALSE,\n             fast.moving.side=\"right\", with.labels=TRUE, ...)\n    {\n        y <- fromXStringViewsToStringSet(x)\n        oligonucleotideFrequency(y, width, step=step,\n                                 as.prob=as.prob, as.array=as.array,\n                                 fast.moving.side=fast.moving.side,\n                                 with.labels=with.labels, ...)\n    }\n)\n\nsetMethod(\"oligonucleotideFrequency\", \"MaskedXString\",\n    function(x, width, step=1,\n             as.prob=FALSE, as.array=FALSE,\n             fast.moving.side=\"right\", with.labels=TRUE)\n    {\n        y <- as(x, \"XStringViews\")\n        oligonucleotideFrequency(y, width, step=step,\n                                 as.prob=as.prob, as.array=as.array,\n                                 fast.moving.side=fast.moving.side,\n                                 with.labels=with.labels,\n                                 simplify.as=\"collapsed\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"dinucleotideFrequency\", \"trinucleotideFrequency\", and\n### \"oligonucleotideTransitions\" convenience wrappers.\n###\n\ndinucleotideFrequency <- function(x, step=1,\n                                  as.prob=FALSE, as.matrix=FALSE,\n                                  fast.moving.side=\"right\",\n                                  with.labels=TRUE, ...)\n{\n    oligonucleotideFrequency(x, 2L, step=step,\n                             as.prob=as.prob, as.array=as.matrix,\n                             fast.moving.side=fast.moving.side,\n                             with.labels=with.labels, ...)\n}\n\ntrinucleotideFrequency <- function(x, step=1,\n                                   as.prob=FALSE, as.array=FALSE,\n                                   fast.moving.side=\"right\",\n                                   with.labels=TRUE, ...)\n{\n    oligonucleotideFrequency(x, 3L, step=step,\n                             as.prob=as.prob, as.array=as.array,\n                             fast.moving.side=fast.moving.side,\n                             with.labels=with.labels, ...)\n}\n\noligonucleotideTransitions <- function(x, left=1, right=1, as.prob=FALSE)\n{\n    if (!isSingleNumber(left))\n        stop(\"'left' must be a single integer value\")\n    if (!is.integer(left))\n        left <- as.integer(left)\n    if (left < 1L)\n        stop(\"'left' must be >= 1\")\n    if (!isSingleNumber(right))\n        stop(\"'right' must be a single integer value\")\n    if (!is.integer(right))\n        right <- as.integer(right)\n    if (right < 1L)\n        stop(\"'right' must be >= 1\")\n    if (!isTRUEorFALSE(as.prob))\n        stop(\"'as.prob' must be TRUE or FALSE\")\n    if (is(x, \"XStringSet\") || is(x, \"XStringViews\")) {\n        freqs <- oligonucleotideFrequency(x, width=left+right, as.prob=FALSE,\n                                          simplify.as=\"collapsed\")\n    } else {\n        freqs <- oligonucleotideFrequency(x, width=left+right, as.prob=FALSE)\n    }\n    ans_rownames <- mkAllStrings(DNA_BASES, left)\n    ans_colnames <- mkAllStrings(DNA_BASES, right)\n    ## A sanity check\n    expected_freqs_names <- paste(rep(ans_rownames, each=length(ans_colnames)),\n                                  ans_colnames, sep=\"\")\n    if (!identical(names(freqs), expected_freqs_names))\n        stop(\"Biostrings internal error in oligonucleotideTransitions(): \",\n             \"'freqs' has unexpected or missing names\")\n    ans <- matrix(freqs, ncol=length(ans_colnames), byrow=TRUE,\n                  dimnames=list(ans_rownames, ans_colnames))\n    if (as.prob)\n        ans <- ans / rowSums(ans)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"nucleotideFrequencyAt\" generic and methods.\n###\n\nsetGeneric(\"nucleotideFrequencyAt\", signature=\"x\",\n    function(x, at, as.prob=FALSE, as.array=TRUE,\n             fast.moving.side=\"right\", with.labels=TRUE, ...)\n        standardGeneric(\"nucleotideFrequencyAt\")\n)\n\nsetMethod(\"nucleotideFrequencyAt\", \"XStringSet\",\n    function(x, at, as.prob=FALSE, as.array=TRUE,\n             fast.moving.side=\"right\", with.labels=TRUE)\n    {\n        if (!(seqtype(x) %in% c(\"DNA\", \"RNA\")))\n            stop(\"'x' must contain sequences of type DNA or RNA\")\n        if (!is.numeric(at))\n            stop(\"'at' must be a vector of integers\")\n        if (!is.integer(at))\n            at <- as.integer(at)\n        if (!isTRUEorFALSE(as.prob))\n            stop(\"'as.prob' must be TRUE or FALSE\")\n        as.array <- .normargAsArray(as.array)\n        fast.moving.side <- .normargFastMovingSide(fast.moving.side, as.array)\n        with.labels <- .normargWithLabels(with.labels)\n        base_codes <- xscodes(x, baseOnly=TRUE)\n        .Call2(\"XStringSet_nucleotide_frequency_at\",\n              x, at, as.prob, as.array,\n              fast.moving.side, with.labels,\n              base_codes,\n              PACKAGE=\"Biostrings\")\n    }\n)\n\nsetMethod(\"nucleotideFrequencyAt\", \"XStringViews\",\n    function(x, at, as.prob=FALSE, as.array=TRUE,\n             fast.moving.side=\"right\", with.labels=TRUE, ...)\n    {\n        y <- fromXStringViewsToStringSet(x)\n        if (any(width(y) < width(x)))\n            stop(\"x contains \\\"out of limits\\\" views\")\n        nucleotideFrequencyAt(y, at, as.prob=as.prob, as.array=as.array,\n                              fast.moving.side=fast.moving.side,\n                              with.labels=with.labels, ...)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### consensusMatrix() and consensusString().\n###\n\nsetGeneric(\"consensusMatrix\", signature=\"x\",\n    function(x, as.prob=FALSE, shift=0L, width=NULL, ...)\n        standardGeneric(\"consensusMatrix\"))\n\nsetMethod(\"consensusMatrix\", \"character\",\n    function(x, as.prob=FALSE, shift=0L, width=NULL)\n        consensusMatrix(BStringSet(x),\n                        as.prob=as.prob, shift=shift, width=width)\n)\n\nsetMethod(\"consensusMatrix\", \"matrix\",\n    function(x, as.prob=FALSE, shift=0L, width=NULL)\n        consensusMatrix(BStringSet(apply(x, 1, paste, collapse=\"\")),\n                        as.prob=as.prob, shift=shift, width=width)\n)\n\nsetMethod(\"consensusMatrix\", \"XStringSet\",\n    function(x, as.prob=FALSE, shift=0L, width=NULL, baseOnly=FALSE)\n    {\n        if (!isTRUEorFALSE(as.prob))\n            stop(\"'as.prob' must be TRUE or FALSE\")\n        if (!is.integer(shift))\n            shift <- as.integer(shift)\n        if (length(x) != 0 && length(shift) > length(x))\n            stop(\"'shift' has more elements than 'x'\")\n        if (!is.null(width)) {\n            if (!isSingleNumber(width) || width < 0L)\n                stop(\"'width' must be NULL or a single non-negative integer\")\n            if (!is.integer(width))\n                width <- as.integer(width)\n        }\n        codes <- xscodes(x, baseOnly=baseOnly)\n        if (is.null(names(codes))) {\n            names(codes) <- intToUtf8(codes, multiple = TRUE)\n            removeUnused <- TRUE\n        } else {\n            removeUnused <- FALSE\n        }\n        if (length(x) == 0L) {\n            ans <- matrix(ifelse(as.prob, 0, 0L),\n                          ncol=0,\n                          nrow=ifelse(removeUnused, 0, length(codes)))\n            if (!removeUnused) {\n                rownames(ans) <- names(codes)\n            }\n        } else {\n            ans <- .Call2(\"XStringSet_consensus_matrix\",\n                         x, shift, width, baseOnly, codes,\n                         PACKAGE=\"Biostrings\")\n        }\n        if (removeUnused) {\n            ans <- ans[rowSums(ans) > 0, , drop=FALSE]\n        }\n        if (as.prob) {\n            col_sums <- colSums(ans)\n            col_sums[col_sums == 0] <- 1  # to avoid division by 0\n            ans <- ans / rep(col_sums, each=nrow(ans))\n        }\n        ans\n    }\n)\n\nsetMethod(\"consensusMatrix\", \"XStringViews\",\n    function(x, as.prob=FALSE, shift=0L, width=NULL, ...)\n    {\n        y <- fromXStringViewsToStringSet(x)\n        consensusMatrix(y, as.prob=as.prob, shift=shift, width=width, ...)\n    }\n)\n\nsetGeneric(\"consensusString\", function(x, ...) standardGeneric(\"consensusString\"))\n\nsetMethod(\"consensusString\", \"matrix\",\n    function(x, ambiguityMap=\"?\", threshold=0.5)\n    {\n        x <- x[rowSums(x, na.rm=TRUE) > 0, , drop=FALSE]\n        k <- nrow(x)\n        if (k == 0)\n            return(character())\n        err_msg <- c(\"Please make sure 'x' was obtained by a \",\n                     \"call to consensusMatrix(..., as.prob=TRUE)\")\n        all_letters <- rownames(x)\n        if (is.null(all_letters))\n            stop(\"invalid consensus matrix 'x' (has no row names).\\n\",\n                 \"  \", err_msg)\n        if (!all(nchar(all_letters) == 1))\n            stop(\"invalid consensus matrix 'x' (row names must be single letters).\\n\",\n                 \"  \", err_msg)\n        if (is.integer(x)) {\n            col_sums <- colSums(x)\n            col_sums[col_sums == 0] <- 1  # to avoid division by 0\n            x <- x / rep(col_sums, each=k)\n        }\n        if (any(is.na(x) | x < 0 | x > 1))\n            stop(\"invalid consensus matrix 'x' \",\n                 \"(contains NAs/NaNs or values outside [0, 1]).\\n\",\n                 \"  \", err_msg)\n        if (any(abs(colSums(x) - 1) > .Machine$double.eps ^ 0.5))\n            stop(\"invalid consensus matrix 'x' \",\n                 \"(some columns do not sum to 1).\\n\",\n                 \"  \", err_msg)\n        if (isSingleString(ambiguityMap)) {\n            if (nchar(ambiguityMap) != 1)\n                stop(\"'ambiguityMap' must be a single character or a map \",\n                     \"(e.g. IUPAC_CODE_MAP)\")\n            if (!isSingleNumber(threshold) || threshold <= 0 || threshold > 1)\n                stop(\"'threshold' must be a numeric in (0, 1]\")\n            consensusLetter <- function(col)\n            {\n                i <- which(col >= threshold)\n                if (length(i) == 1 && col[i] >= threshold)\n                    all_letters[i]\n                else\n                    ambiguityMap\n            }\n        } else {\n            if (!is.character(ambiguityMap) || is.null(names(ambiguityMap)))\n                stop(\"'ambiguityMap' must be a named character vector\")\n            if (!all(rownames(x) %in% names(ambiguityMap)))\n                stop(\"'ambiguityMap' does not contain the complete alphabet\")\n            alphabet <- unname(ambiguityMap[nchar(ambiguityMap) == 1])\n            if (!isSingleNumber(threshold) || threshold <= 0 ||\n                (threshold - .Machine$double.eps ^ 0.5) > 1/length(alphabet))\n                stop(\"'threshold' must be a numeric in \",\n                     \"(0, 1/sum(nchar(ambiguityMap) == 1)]\")\n            P <-\n              sapply(strsplit(ambiguityMap[rownames(x)], \"\"),\n                     function(y) {z <- alphabet %in% y;z/sum(z)})\n            x <- P %*% x\n            consensusLetter <- function(col)\n            {\n                i <- paste(alphabet[col >= threshold], collapse = \"\")\n                ans <- names(ambiguityMap[ambiguityMap == i])\n                if (length(ans) == 0)\n                    stop(\"'ambiguityMap' is missing some combinations of row names\")\n                ans\n            }\n        }\n        paste(apply(x, 2, consensusLetter), collapse=\"\")\n    }\n)\n\nsetMethod(\"consensusString\", \"BStringSet\",\n    function(x, ambiguityMap=\"?\", threshold=0.5, shift=0L, width=NULL)\n        consensusString(consensusMatrix(x, as.prob=TRUE, shift=shift, width=width),\n                        ambiguityMap=ambiguityMap, threshold=threshold)\n)\n\nsetMethod(\"consensusString\", \"DNAStringSet\",\n    function(x, ambiguityMap=IUPAC_CODE_MAP, threshold=0.25, shift=0L, width=NULL)\n        consensusString(consensusMatrix(x, as.prob=TRUE, shift=shift, width=width),\n                        ambiguityMap=ambiguityMap, threshold=threshold)\n)\n\nsetMethod(\"consensusString\", \"RNAStringSet\",\n    function(x,\n             ambiguityMap=\n             structure(as.character(RNAStringSet(DNAStringSet(IUPAC_CODE_MAP))),\n                       names=\n                       as.character(RNAStringSet(DNAStringSet(names(IUPAC_CODE_MAP))))),\n             threshold=0.25, shift=0L, width=NULL)\n        consensusString(consensusMatrix(x, as.prob=TRUE, shift=shift, width=width),\n                        ambiguityMap=ambiguityMap, threshold=threshold)\n)\n\nsetMethod(\"consensusString\", \"XStringViews\",\n    function(x, ambiguityMap, threshold, shift=0L, width=NULL)\n    {\n        x <- as(x, \"XStringSet\")\n        callGeneric()\n    }\n)\n\nsetMethod(\"consensusString\", \"ANY\",\n    function(x, ambiguityMap=\"?\", threshold=0.5)\n        consensusString(consensusMatrix(x, as.prob=TRUE),\n                        ambiguityMap=ambiguityMap, threshold=threshold)\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"twoWayAlphabetFrequency\" generic and methods.\n###\n### Calculates two-way table of letter frequencies for two same-length inputs\n###\n\n.XString.two_way_code_frequency <- function(x, y, as.prob, baseOnly)\n{\n  if (!isTRUEorFALSE(as.prob))\n    stop(\"'as.prob' must be TRUE or FALSE\")\n  x.codes <- xscodes(x, baseOnly=baseOnly)\n  y.codes <- xscodes(y, baseOnly=baseOnly)\n  ans <- .Call2(\"XString_two_way_letter_frequency\",\n                x, y, x.codes, y.codes, baseOnly,\n                PACKAGE=\"Biostrings\")\n  if (as.prob)\n    ans <- ans / nchar(x) # nchar(x) is sum(ans) but faster\n  ans\n}\n\n.XStringSet.two_way_code_frequency <- function(x, y, as.prob, collapse,\n                                               baseOnly)\n{\n  if (!isTRUEorFALSE(as.prob))\n    stop(\"'as.prob' must be TRUE or FALSE\")\n  collapse <- .normargCollapse(collapse)\n  x.codes <- xscodes(x, baseOnly=baseOnly)\n  y.codes <- xscodes(y, baseOnly=baseOnly)\n  ans <- .Call2(\"XStringSet_two_way_letter_frequency\",\n                x, y, collapse, x.codes, y.codes, baseOnly,\n                PACKAGE=\"Biostrings\")\n  if (as.prob) {\n    if (collapse)\n      ans <- ans / sum(as.numeric(ans))\n    else\n      ans <- ans / rep(nchar(x), each = prod(dim(ans)[1:2]))\n  }\n  ans\n}\n\nsetGeneric(\"twoWayAlphabetFrequency\", signature=c(\"x\", \"y\"),\n           function(x, y, as.prob=FALSE, ...)\n           standardGeneric(\"twoWayAlphabetFrequency\")\n           )\n\nsetMethod(\"twoWayAlphabetFrequency\", c(\"XString\", \"XString\"),\n          function(x, y, as.prob=FALSE, baseOnly=FALSE)\n          .XString.two_way_code_frequency(x, y, as.prob, baseOnly)\n          )\n\nsetMethod(\"twoWayAlphabetFrequency\", c(\"XString\", \"XStringSet\"),\n          function(x, y, as.prob=FALSE, collapse=FALSE, baseOnly=FALSE) {\n          x <- rep(as(x, \"XStringSet\"), length(y))\n          .XStringSet.two_way_code_frequency(x, y, as.prob, collapse, baseOnly)\n          }\n          )\n\nsetMethod(\"twoWayAlphabetFrequency\", c(\"XStringSet\", \"XString\"),\n          function(x, y, as.prob=FALSE, collapse=FALSE, baseOnly=FALSE) {\n          y <- rep(as(y, \"XStringSet\"), length(x))\n          .XStringSet.two_way_code_frequency(x, y, as.prob, collapse, baseOnly)\n          }\n          )\n\nsetMethod(\"twoWayAlphabetFrequency\", c(\"XStringSet\", \"XStringSet\"),\n          function(x, y, as.prob=FALSE, collapse=FALSE, baseOnly=FALSE)\n          .XStringSet.two_way_code_frequency(x, y, as.prob, collapse, baseOnly)\n          )\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"twoWayAlphabetFrequencyByQuality\" generic and methods.\n###\n### Not sure about this yet. We may want a threeWayAlphabetFrequency,\n### where the qualities are combined apriori.\n###\n\n.XStringSet.two_way_code_frequency_by_quality <-\n  function(x, y, x.quality, y.quality, as.prob, baseOnly)\n{\n  if (!isTRUEorFALSE(as.prob))\n    stop(\"'as.prob' must be TRUE or FALSE\")\n  codes <- xscodes(x, baseOnly=baseOnly)\n  ans <- .Call2(\"XStringSet_two_way_letter_frequency_by_quality\",\n                x, y, x.quality, y.quality, collapse, codes, baseOnly,\n                PACKAGE=\"Biostrings\")\n  if (as.prob) {\n    ans <- ans / rep(nchar(x), each = prod(dim(ans)[1:2]))\n  }\n  ans\n}\n\nsetGeneric(\"twoWayAlphabetFrequencyByQuality\", signature=c(\"x\", \"y\"),\n           function(x, y, as.prob=FALSE, ...)\n           standardGeneric(\"twoWayAlphabetFrequencyByQuality\")\n           )\n\nsetMethod(\"twoWayAlphabetFrequencyByQuality\", \"QualityScaledXStringSet\",\n          function(x, y, as.prob=FALSE, baseOnly=FALSE)\n          .XStringSet.two_way_code_frequency_by_quality(x, y,\n                                                        quality(x),\n                                                        quality(y),\n                                                        as.prob,\n                                                        baseOnly)\n          )\n",
        "lowlevel-matching.R": "### =========================================================================\n### Low-level matching functions\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions (not exported) used by matching functions from other\n### files (like matchPattern(), matchPDict(), etc...) to check and normalize\n### their arguments.\n###\n\nnormargSubject <- function(subject, argname=\"subject\")\n{\n    if (is(subject, \"XString\") || is(subject, \"XStringSet\"))\n        return(subject)\n    if (!is.character(subject))\n        stop(\"'\", argname, \"' must be a character vector, \",\n             \"or an XString or XStringSet object\")\n    if (length(subject) == 1L)\n        subject <- as(subject, \"XString\")\n    else\n        subject <- as(subject, \"XStringSet\")\n    subject\n}\n\nnormargPattern <- function(pattern, subject, argname=\"pattern\")\n{\n    subject_baseclass <- xsbaseclass(subject)\n    if (is(pattern, \"XString\")) {\n        if (xsbaseclass(pattern) == subject_baseclass)\n            return(pattern)\n    } else if (!isSingleString(pattern))\n        stop(\"'\", argname, \"' must be a single string or an XString object\")\n    pattern <- try(XString(seqtype(subject), pattern))\n    if (is(pattern, \"try-error\"))\n        stop(\"could not turn '\", argname, \"' into a \",\n             subject_baseclass, \" instance\")\n    pattern\n}\n\nnormargMaxMismatch <- function(max.mismatch, argname=\"max.mismatch\")\n{\n    if (!isSingleNumber(max.mismatch))\n        stop(\"'\", argname, \"' must be a single integer\")\n    max.mismatch <- as.integer(max.mismatch)\n    if (max.mismatch < 0L)\n        stop(\"'\", argname, \"' must be a non-negative integer\")\n    max.mismatch\n}\n\nnormargMinMismatch <- function(min.mismatch, max.mismatch, argname=\"min.mismatch\")\n{\n    if (!isSingleNumber(min.mismatch))\n        stop(\"'\", argname, \"' must be a single integer\")\n    min.mismatch <- as.integer(min.mismatch)\n    if (min.mismatch < 0L)\n        stop(\"'\", argname, \"' must be a non-negative integer\")\n    if (min.mismatch > max.mismatch)\n        stop(\"'\", argname, \"' must be <= 'max.mismatch'\")\n    min.mismatch\n}\n\nnormargWithIndels <- function(with.indels, argname=\"with.indels\")\n{\n    if (!isTRUEorFALSE(with.indels))\n        stop(\"'\", argname, \"' must be TRUE or FALSE\")\n    with.indels\n}\n\n### Return a logical vector of length 2.\nnormargFixed <- function(fixed, subject, argname=\"fixed\")\n{\n    if (!is.logical(fixed) && !is.character(fixed))\n        stop(\"'\", argname, \"' not a logical or character vector\")\n    if (is.logical(fixed)) {\n        if (any(is.na(fixed)))\n            stop(\"'\", argname, \"' has NAs\")\n        fixed_names <- names(fixed)\n        if (is.null(fixed_names)) {\n            if (!(length(fixed) %in% 1:2))\n                stop(\"when an unnamed logical vector, '\", argname,\n                     \"' fixed must be of length 1 or 2\")\n            if (length(fixed) == 1)\n                fixed <- c(fixed, fixed)\n        } else {\n            if (length(fixed) != 2)\n                stop(\"when a named logical vector, '\", argname, \"' must be of length 2\")\n            if (!setequal(fixed_names, c(\"pattern\", \"subject\")))\n                stop(\"'\", argname, \"' names must be \\\"pattern\\\" and \\\"subject\\\"\")\n            fixed <- c(fixed[\"pattern\"], fixed[\"subject\"])\n        }\n    } else if (is.character(fixed)) {\n        if (any(duplicated(fixed)) || !all(fixed %in% c(\"pattern\", \"subject\")))\n            stop(\"when a character vector, '\", argname, \"' must be \",\n                 \"a subset of 'c(\\\"pattern\\\", \\\"subject\\\")' \",\n                 \"with no duplicated\")\n        fixed <- c(\"pattern\" %in% fixed, \"subject\" %in% fixed)\n    }\n    if (!all(fixed) && !(seqtype(subject) %in% c(\"DNA\", \"RNA\")))\n        stop(\"'\", argname, \"' value only supported for a DNA or RNA subject \",\n             \"(you can only use 'fixed=TRUE' with your subject)\")\n    fixed\n}\n\nnormargCollapse <- function(collapse)\n{\n    if (identical(collapse, FALSE))\n        return(0L)\n    if (!isSingleNumber(collapse) || !(collapse %in% 0:2))\n        stop(\"'collapse' must be FALSE, 1 or 2\")\n    as.integer(collapse)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .matchPatternAt()\n###\n### This is the horse-power behind the neditStartingAt(), neditEndingAt(),\n### isMatchingStartingAt(), isMatchingEndingAt(), which.isMatchingStartingAt()\n### and which.isMatchingEndingAt() low-level matching functions defined later\n### in this file.\n### If 'at.type == 0' then 'at' contains starting positions, otherwise it\n### contains ending positions.\n###\n\n.matchPatternAt <- function(pattern, subject, at, at.type,\n                            max.mismatch, min.mismatch, with.indels, fixed,\n                            ans.type, auto.reduce.pattern=FALSE)\n{\n    subject <- normargSubject(subject)\n    pattern <- normargPattern(pattern, subject)\n    if (!is.numeric(at)) {\n        what <- if (at.type == 0L) \"starting.at\" else \"ending.at\"\n        stop(\"'\", what, \"' must be a vector of integers\")\n    }\n    if (!is.integer(at))\n        at <- as.integer(at)\n\n    if (auto.reduce.pattern) {\n        at.length <- length(at)\n        P <- nchar(pattern)\n        if (at.length == 1)\n            at <- rep.int(at, P)\n        else if (at.length != P || length(unique(at)) > 1)\n            stop(\"With 'auto.reduce.pattern', 'at' must be a single integer\")\n    }\n\n    if (ans.type == 0L) {\n        max.mismatch <- length(pattern)\n    } else {\n        if (!is.numeric(max.mismatch))\n            stop(\"'max.mismatch' must be a vector of integers\")\n        if (!is.integer(max.mismatch))\n            max.mismatch <- as.integer(max.mismatch)\n        if (!is.numeric(min.mismatch))\n            stop(\"'min.mismatch' must be a vector of integers\")\n        if (!is.integer(min.mismatch))\n            min.mismatch <- as.integer(min.mismatch)\n    }\n    with.indels <- normargWithIndels(with.indels)\n    fixed <- normargFixed(fixed, subject)\n    if (is(subject, \"XString\"))\n        .Call2(\"XString_match_pattern_at\",\n              pattern, subject, at, at.type,\n              max.mismatch, min.mismatch, with.indels, fixed, ans.type,\n              auto.reduce.pattern, PACKAGE=\"Biostrings\")\n    else\n        .Call2(\"XStringSet_vmatch_pattern_at\",\n              pattern, subject, at, at.type,\n              max.mismatch, min.mismatch, with.indels, fixed, ans.type,\n              auto.reduce.pattern, PACKAGE=\"Biostrings\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### neditStartingAt(), neditEndingAt() and neditAt().\n###\n### 'starting.at' (or 'ending.at') must be integer vectors containing the\n### starting (or ending) positions of the pattern relatively to the subject.\n### These functions return an integer vector of the same length as\n### 'starting.at' (or 'ending.at').\n###\n\nsetGeneric(\"neditStartingAt\", signature=\"subject\",\n    function(pattern, subject, starting.at=1, with.indels=FALSE, fixed=TRUE)\n        standardGeneric(\"neditStartingAt\")\n)\n\nsetGeneric(\"neditEndingAt\", signature=\"subject\",\n    function(pattern, subject, ending.at=1, with.indels=FALSE, fixed=TRUE)\n        standardGeneric(\"neditEndingAt\")\n)\n\nneditAt <- function(pattern, subject, at=1, with.indels=FALSE, fixed=TRUE)\n{\n    if (!is.numeric(at))\n        stop(\"'at' must be a vector of integers\")\n    neditStartingAt(pattern, subject, starting.at=at, with.indels=with.indels, fixed=fixed)\n}\n\n### Dispatch on 'subject' (see signature of generic).\n\nsetMethod(\"neditStartingAt\", \"character\",\n    function(pattern, subject, starting.at=1, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        NA, NA, with.indels, fixed, 0L)\n)\n\nsetMethod(\"neditStartingAt\", \"XString\",\n    function(pattern, subject, starting.at=1, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        NA, NA, with.indels, fixed, 0L)\n)\n\nsetMethod(\"neditStartingAt\", \"XStringSet\",\n    function(pattern, subject, starting.at=1, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        NA, NA, with.indels, fixed, 0L)\n)\n\nsetMethod(\"neditEndingAt\", \"character\",\n    function(pattern, subject, ending.at=1, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        NA, NA, with.indels, fixed, 0L)\n)\n\nsetMethod(\"neditEndingAt\", \"XString\",\n    function(pattern, subject, ending.at=1, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        NA, NA, with.indels, fixed, 0L)\n)\n\nsetMethod(\"neditEndingAt\", \"XStringSet\",\n    function(pattern, subject, ending.at=1, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        NA, NA, with.indels, fixed, 0L)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isMatchingStartingAt(), isMatchingEndingAt() and isMatchingAt().\n###\n### 'starting.at' (or 'ending.at') must be integer vectors containing the\n### starting (or ending) positions of the pattern relatively to the subject.\n### These functions return a logical vector of the same length as\n### 'starting.at' (or 'ending.at').\n###\n\nsetGeneric(\"isMatchingStartingAt\", signature=\"subject\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        standardGeneric(\"isMatchingStartingAt\")\n)\n\nsetGeneric(\"isMatchingEndingAt\", signature=\"subject\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        standardGeneric(\"isMatchingEndingAt\")\n)\n\nisMatchingAt <- function(pattern, subject, at=1,\n                         max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n{\n    if (!is.numeric(at))\n        stop(\"'at' must be a vector of integers\")\n    isMatchingStartingAt(pattern, subject, starting.at=at,\n                         max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                         with.indels=with.indels, fixed=fixed)\n}\n\n### Dispatch on 'subject' (see signature of generic).\n\nsetMethod(\"isMatchingStartingAt\", \"character\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        max.mismatch, min.mismatch, with.indels, fixed, 1L)\n)\n\nsetMethod(\"isMatchingStartingAt\", \"XString\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        max.mismatch, min.mismatch, with.indels, fixed, 1L)\n)\n\nsetMethod(\"isMatchingStartingAt\", \"XStringSet\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        max.mismatch, min.mismatch, with.indels, fixed, 1L)\n)\n\nsetMethod(\"isMatchingEndingAt\", \"character\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        max.mismatch, min.mismatch, with.indels, fixed, 1L)\n)\n\nsetMethod(\"isMatchingEndingAt\", \"XString\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        max.mismatch, min.mismatch, with.indels, fixed, 1L)\n)\n\nsetMethod(\"isMatchingEndingAt\", \"XStringSet\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        max.mismatch, min.mismatch, with.indels, fixed, 1L)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### which.isMatchingStartingAt(), which.isMatchingEndingAt() and\n### which.isMatchingAt().\n###\n### 'starting.at' (or 'ending.at') must be integer vectors containing the\n### starting (or ending) positions of the pattern relatively to the subject.\n### These functions return the lowest *index* in 'starting.at' (or 'ending.at')\n### for which a match occurred (or NA if no match occurred).\n###\n\nsetGeneric(\"which.isMatchingStartingAt\", signature=\"subject\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        standardGeneric(\"which.isMatchingStartingAt\")\n)\n\nsetGeneric(\"which.isMatchingEndingAt\", signature=\"subject\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        standardGeneric(\"which.isMatchingEndingAt\")\n)\n\nwhich.isMatchingAt <- function(pattern, subject, at=1,\n                               max.mismatch=0, min.mismatch=0,\n                               with.indels=FALSE, fixed=TRUE,\n                               follow.index=FALSE, auto.reduce.pattern=FALSE)\n{\n    if (!is.numeric(at))\n        stop(\"'at' must be a vector of integers\")\n    which.isMatchingStartingAt(pattern, subject, starting.at=at,\n                               max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                               with.indels=with.indels, fixed=fixed,\n                               follow.index=follow.index,\n                               auto.reduce.pattern=auto.reduce.pattern)\n}\n\n.to.ans.type <- function(follow.index)\n{\n    if (!isTRUEorFALSE(follow.index))\n        stop(\"'follow.index' must be TRUE or FALSE\")\n    if (follow.index)\n        return(3L)\n    return(2L)\n}\n\n### Dispatch on 'subject' (see signature of generic).\n\nsetMethod(\"which.isMatchingStartingAt\", \"character\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        .to.ans.type(follow.index), auto.reduce.pattern)\n)\n\nsetMethod(\"which.isMatchingStartingAt\", \"XString\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        .to.ans.type(follow.index), auto.reduce.pattern)\n)\n\nsetMethod(\"which.isMatchingStartingAt\", \"XStringSet\",\n    function(pattern, subject, starting.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        .matchPatternAt(pattern, subject, starting.at, 0L,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        .to.ans.type(follow.index), auto.reduce.pattern)\n)\n\nsetMethod(\"which.isMatchingEndingAt\", \"character\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        .to.ans.type(follow.index), auto.reduce.pattern)\n)\n\nsetMethod(\"which.isMatchingEndingAt\", \"XString\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        .to.ans.type(follow.index), auto.reduce.pattern)\n)\n\nsetMethod(\"which.isMatchingEndingAt\", \"XStringSet\",\n    function(pattern, subject, ending.at=1,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             follow.index=FALSE, auto.reduce.pattern=FALSE)\n        .matchPatternAt(pattern, subject, ending.at, 1L,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        .to.ans.type(follow.index), auto.reduce.pattern)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### hasLetterAt()\n###\n\nhasLetterAt <- function(x, letter, at, fixed=TRUE)\n{\n    if (!is(x, \"XStringSet\")) {\n        if (!is.character(x) && !is(x, \"XString\"))\n            stop(\"'x' must be a character vector, or an XString or XStringSet object\")\n        x <- as(x, \"XStringSet\")\n    }\n    if (!is(letter, \"XString\")) {\n        if (!isSingleString(letter))\n            stop(\"'letter' must be a character string or an XString object\")\n        letter <- XString(seqtype(x), letter)\n    } else {\n        if (seqtype(letter) != seqtype(x))\n            stop(\"'x' and 'letter' must have the same sequence type\")\n    }\n    if (!is.numeric(at))\n        stop(\"'at' must be a vector of integers\")\n    if (length(at) != length(letter))\n        stop(\"'letter' and 'at' must have the same length\")\n    if (!is.integer(at))\n        at <- as.integer(at)\n    if (any(is.na(at)))\n        stop(\"'at' cannot contain NAs\")\n    fixed <- normargFixed(fixed, x)\n\n    .hasLetterAt1 <- function(x, l1, at1)\n    {\n        ans <- .Call2(\"XStringSet_vmatch_pattern_at\",\n                     l1, x, at1, 0L, 0L, 0L, FALSE, fixed, 1L, FALSE,\n                     PACKAGE=\"Biostrings\")\n        ans[at1 < 1 | at1 > width(x)] <- NA\n        ans\n    }\n    sapply(seq_len(length(letter)),\n           function(i)\n               .hasLetterAt1(x, subseq(letter, start=i, width=1L), at[i]))\n}\n\n",
        "maskMotif.R": "### =========================================================================\n### The maskMotif() generic & methods\n### -------------------------------------------------------------------------\n\n\nsetGeneric(\"maskMotif\", signature=c(\"x\", \"motif\"),\n    function(x, motif, min.block.width=1, ...) standardGeneric(\"maskMotif\")\n)\n\nsetMethod(\"maskMotif\", signature(x=\"MaskedXString\", motif=\"XString\"),\n    function(x, motif, min.block.width=1, ...)\n    {\n        if (!isSingleNumber(min.block.width))\n            stop(\"'min.block.width' must be a single integer\")\n        if (!is.integer(min.block.width))\n            min.block.width <- as.integer(min.block.width)\n        nir1 <- as(matchPattern(motif, x, ...), \"NormalIRanges\")\n        desc1 <- paste(as.character(motif), \"-blocks\", sep=\"\")\n        if (min.block.width > length(motif)) {\n            nir1 <- nir1[width(nir1) >= min.block.width]\n            desc1 <- paste(desc1, \" [width>=\", min.block.width, \"]\", sep=\"\")\n        }\n        mask1 <- new2(\"MaskCollection\", nir_list=list(nir1),\n                                        width=length(x),\n                                        active=TRUE,\n                                        desc=desc1,\n                                        check=FALSE)\n        masks(x) <- append(masks(x), mask1)\n        x\n    }\n)\n\nsetMethod(\"maskMotif\", signature(x=\"MaskedXString\", motif=\"character\"),\n    function(x, motif, min.block.width=1, ...)\n    {\n        motif <- XString(seqtype(x), motif)\n        maskMotif(x, motif, min.block.width=min.block.width, ...)\n    }\n)\n\nsetMethod(\"maskMotif\", signature(x=\"XString\", motif=\"ANY\"),\n    function(x, motif, min.block.width=1, ...)\n    {\n        x <- as(x, paste(\"Masked\", xsbaseclass(x), sep=\"\"))\n        maskMotif(x, motif, min.block.width=min.block.width, ...)\n    }\n)\n\n### Used in Robert's book!\n### mask() was introduced at the time where only XStringViews objects were\n### available in Biostrings so it returns one instead of a MaskedXString\n### object.\n### Deprecate in Biostrings 2.9!\nmask <- function(x, start=NA, end=NA, pattern)\n{\n    #msg <- c(\"mask() is deprecated and will be removed in a future release. \",\n    #         \"Please use Mask() or maskMotif() instead.\")\n    #.Deprecated(msg=wmsg(msg))\n    if (!is(x, \"XString\"))\n        x <- XString(NULL, x)\n    if (missing(pattern)) {\n        if (isNumericOrNAs(start)) {\n            if (length(start) == 1L && is.na(start))\n                start <- 1L\n            if (length(end) == 1L && is.na(end))\n                end <- length(x)\n            return(gaps(Views(x, start=start, end=end)))\n        }\n        if (!missing(end))\n            stop(\"invalid 'start' argument\")\n        pattern <- start\n    } else {\n        if (!missing(start) || !missing(end))\n            stop(\"can't give 'start' (or 'end') when 'pattern' is given\")\n    }\n    as(maskMotif(x, pattern), \"XStringViews\")\n}\n\n",
        "match-utils.R": "### =========================================================================\n### Miscellaneous helper/utility functions related to string matching.\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some helper functions used by matchPattern(), matchPDict(), etc...\n###\n\n.CHARACTER.ALGOS <- c(\"gregexpr\", \"gregexpr2\")\n\nisCharacterAlgo <- function(algo) {algo %in% .CHARACTER.ALGOS}\n\n.ALL.ALGOS <- c(\n    \"auto\",\n    \"naive-exact\",\n    \"naive-inexact\",\n    \"boyer-moore\",\n    \"shift-or\",\n    \"indels\",\n    .CHARACTER.ALGOS\n)\n\nnormargAlgorithm <- function(algorithm)\n{\n    if (!isSingleString(algorithm))\n        stop(\"'algorithm' must be a single string\")\n    match.arg(algorithm, .ALL.ALGOS)\n}\n\n### Return a character vector containing the valid algos (best suited first)\n### for the given search criteria (the search criteria is described by the\n### values of 'pattern', 'max.mismatch', 'with.indels' and 'fixed').\n### Raise an error if the problem \"doesn't make sense\".\n### All its arguments must have been normalized (thru the normarg*() functions)\n### before they are passed to .valid.algos().\n.valid.algos <- function(pattern, max.mismatch, min.mismatch,\n                         with.indels, fixed)\n{\n    if (is(pattern, \"XString\")) {\n        pattern_min_length <- pattern_max_length <- length(pattern)\n    } else if (is(pattern, \"XStringSet\")) {\n        pattern_min_length <- min(width(pattern))\n        pattern_max_length <- max(width(pattern))\n    } else {\n        stop(\"'pattern' not an XString or XStringSet object\")\n    }\n    if (pattern_min_length == 0L)\n        stop(\"empty patterns are not supported\")\n    ## Some arbitrary limit just to limit the size of the dynamic buffers\n    ## used by the Boyer Moore algo to preprocess the pattern.\n    if (pattern_max_length > 20000L)\n        stop(\"patterns with more than 20000 letters are not supported\")\n    if (max.mismatch != 0L && with.indels) {\n        if (min.mismatch != 0L)\n            stop(\"'min.mismatch' must be 0 when 'with.indels' is TRUE\")\n        return(\"indels\")\n    }\n    algos <- character(0)\n    if (max.mismatch == 0L && all(fixed)) {\n        algos <- c(algos, \"boyer-moore\")\n        if (pattern_max_length <= .Clongint.nbits())\n            algos <- c(algos, \"shift-or\")\n        algos <- c(algos, \"naive-exact\")\n    } else {\n        if (min.mismatch == 0L && fixed[1] == fixed[2]\n         && pattern_max_length <= .Clongint.nbits())\n            algos <- c(algos, \"shift-or\")\n    }\n    c(algos, \"naive-inexact\") # \"naive-inexact\" is universal but slow\n}\n\nselectAlgo <- function(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n{\n    algos <- .valid.algos(pattern, max.mismatch, min.mismatch,\n                          with.indels, fixed)\n    if (algo == \"auto\")\n        return(algos[1])\n    if (!(algo %in% algos))\n        stop(\"valid algos for your string matching problem (best suited first): \",\n             paste(paste(\"\\\"\", algos, \"\\\"\", sep=\"\"), collapse=\", \"))\n    algo\n}\n\n\n### =========================================================================\n### Some utility functions for operating on the matches returned by a\n### high-level matching function like matchPattern(), matchPDict(), etc...\n###\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### mismatch()\n###\n\n### Returns a vector of the positions of mismatches of 'pattern'\n### in a view on 'subject' starting at 'start' and whose width is\n### length(pattern).\n.bsMismatch <- function(pattern, subject, start, fixed)\n{\n    mm <- integer(0)\n    j0 <- start - as.integer(1)\n    for (i in seq_len(length(pattern))) {\n        j <- j0 + i\n        if (j < 1 || j > length(subject)) {\n            mm <- c(mm, i)\n        } else {\n            l <- subseq(pattern, start=i, end=i)\n            cp <- isMatchingAt(l, subject, at=j, fixed=fixed)\n            if (cp == 0)\n                mm <- c(mm, i)\n        }\n    }\n    mm\n}\n\n.mismatch <- function(pattern, x, fixed)\n{\n    if (length(x) == 0)\n        return(list())\n    if (any(width(x) != length(pattern)))\n        warning(\"some views in 'x' have a width that differs from 'length(pattern)'\")\n    lapply(1:length(x),\n           function(i) .bsMismatch(pattern, subject(x), start(x)[i], fixed))\n}\n\nsetGeneric(\"mismatch\", signature=c(\"pattern\", \"x\"),\n    function(pattern, x, fixed=TRUE) standardGeneric(\"mismatch\")\n)\n\n### Typical use:\n###   mp <- matchPattern(\"TGA\", DNAString(\"GTGACGTGCAT\"), max.mismatch=2)\n###   mismatch(\"TGA\", mp)\n### Dispatch on 'x' (see signature of generic).\nsetMethod(\"mismatch\", c(pattern=\"ANY\", x=\"XStringViews\"),\n    function(pattern, x, fixed)\n    {\n        pattern <- normargPattern(pattern, x)\n        .mismatch(pattern, x, fixed)\n    }\n)\n\nsetGeneric(\"nmatch\", signature=c(\"pattern\", \"x\"),\n    function(pattern, x, fixed=TRUE) standardGeneric(\"nmatch\")\n)\n\nsetMethod(\"nmatch\", c(pattern=\"ANY\", x=\"XStringViews\"),\n    function(pattern, x, fixed)\n    {\n        funCall <- match.call()\n        funCall[[1]] <- as.name(\"nmismatch\")\n        nchar(pattern) - eval(funCall, sys.parent())\n    }\n)\n\nsetGeneric(\"nmismatch\", signature=c(\"pattern\", \"x\"),\n    function(pattern, x, fixed=TRUE) standardGeneric(\"nmismatch\")\n)\n\nsetMethod(\"nmismatch\", c(pattern=\"ANY\", x=\"XStringViews\"),\n    function(pattern, x, fixed)\n    {\n        funCall <- match.call()\n        funCall[[1]] <- as.name(\"mismatch\")\n        mismatches <- eval(funCall, sys.parent())\n        elementNROWS(mismatches)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"coverage\" methods.\n###\n\nsetMethod(\"coverage\", \"MaskedXString\",\n    function(x, shift=0L, width=NULL, weight=1L)\n        coverage(masks(x), shift=shift, width=width, weight=weight)\n)\n\nsetMethod(\"coverage\", \"MIndex\",\n    function(x, shift=0L, width=NULL, weight=1L)\n        coverage(unlist(x), shift=shift, width=width, weight=weight)\n)\n\n",
        "matchLRPatterns.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"matchLRPatterns\" new generic.\n###\n\nsetGeneric(\"matchLRPatterns\", signature=\"subject\",\n    function(Lpattern, Rpattern, max.gaplength, subject,\n             max.Lmismatch=0, max.Rmismatch=0,\n             with.Lindels=FALSE, with.Rindels=FALSE,\n             Lfixed=TRUE, Rfixed=TRUE)\n        standardGeneric(\"matchLRPatterns\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchLRPatterns\", \"XString\", \n    function(Lpattern, Rpattern, max.gaplength, subject,\n             max.Lmismatch=0, max.Rmismatch=0,\n             with.Lindels=FALSE, with.Rindels=FALSE,\n             Lfixed=TRUE, Rfixed=TRUE)\n    {\n        ans_start <- ans_end <- integer(0)\n        Lmatches <- matchPattern(Lpattern, subject,\n                                 max.mismatch=max.Lmismatch,\n                                 with.indels=with.Lindels,\n                                 fixed=Lfixed)\n        if (length(Lmatches) != 0L) {\n            Rmatches <- matchPattern(Rpattern, subject,\n                                     max.mismatch=max.Rmismatch,\n                                     with.indels=with.Rindels,\n                                     fixed=Rfixed)\n            if (length(Rmatches) != 0L) {\n                for (i in seq_len(length(Lmatches))) {\n                    gaplength <- start(Rmatches) - end(Lmatches)[i] - 1L\n                    jj <- which(0L <= gaplength & gaplength <= max.gaplength)\n                    ans_start <- c(ans_start, rep.int(start(Lmatches)[i], length(jj)))\n                    ans_end <- c(ans_end, end(Rmatches)[jj])\n                }\n            }\n        }\n        ans_width <- ans_end - ans_start + 1L\n        Views(subject, start=ans_start, width=ans_width)\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\n### WARNING: Unlike the other \"matchLRPatterns\" methods, the XStringViews object\n### returned by this method is not guaranteed to have its views ordered from\n### left to right in general! One important particular case where this is\n### guaranteed though is when 'isNormal(subject)' is TRUE (i.e. 'subject' is\n### a normal XStringViews object) and 'max.mismatch=0' and 'max.Rmismatch=0'\n### (so there are no \"out of limits\" matches).\nsetMethod(\"matchLRPatterns\", \"XStringViews\",\n    function(Lpattern, Rpattern, max.gaplength, subject,\n             max.Lmismatch=0, max.Rmismatch=0,\n             with.Lindels=FALSE, with.Rindels=FALSE,\n             Lfixed=TRUE, Rfixed=TRUE)\n    {\n        ans_start <- ans_width <- integer(0)\n        subject <- trim(subject)\n        Lcounts <- vcountPattern(Lpattern, subject,\n                                 max.mismatch=max.Lmismatch,\n                                 with.indels=with.Lindels,\n                                 fixed=Lfixed)\n        candidates <- which(Lcounts > 0L)\n        if (length(candidates) != 0L) {\n            subject <- subject[candidates]\n            Lcounts <- Lcounts[candidates]\n            Lmatches <- matchPattern(Lpattern, subject,\n                                     max.mismatch=max.Lmismatch,\n                                     with.indels=with.Lindels,\n                                     fixed=Lfixed)\n            Rranges <- IRanges(start=end(Lmatches) + 1L,\n                               width=max.gaplength + nchar(Rpattern))\n            Rranges <- pintersect(Rranges,\n                                  rep(as(subject, \"IRanges\"), Lcounts))\n            Rsubject <- as(Views(subject(subject), Rranges), \"XStringSet\")\n            Rmatches <- vmatchPattern(Rpattern, Rsubject,\n                                      max.mismatch=max.Rmismatch,\n                                      with.indels=with.Rindels,\n                                      fixed=Rfixed)\n            Rcounts <- elementNROWS(Rmatches)\n            Roffset <- unlist(endIndex(Rmatches), use.names=FALSE)\n            if (length(Roffset) != 0L) {\n                ans_start <- rep.int(start(Lmatches), Rcounts)\n                ans_width <- rep.int(width(Lmatches), Rcounts) + Roffset\n            }\n        }\n        Views(subject(subject), start=ans_start, width=ans_width)\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchLRPatterns\", \"MaskedXString\",\n    function(Lpattern, Rpattern, max.gaplength, subject,\n             max.Lmismatch=0, max.Rmismatch=0,\n             with.Lindels=FALSE, with.Rindels=FALSE,\n             Lfixed=TRUE, Rfixed=TRUE)\n        matchLRPatterns(Lpattern, Rpattern, max.gaplength,\n                        toXStringViewsOrXString(subject),\n                        max.Lmismatch=max.Lmismatch,\n                        max.Rmismatch=max.Rmismatch,\n                        with.Lindels=with.Lindels,\n                        with.Rindels=with.Rindels,\n                        Lfixed=Lfixed, Rfixed=Rfixed)\n)\n\n",
        "matchPDict.R": "### =========================================================================\n### The matchPDict() generic & related functions\n### -------------------------------------------------------------------------\n###\n### Some examples below with a PDict object of type \"ACtree\".\n### TODO: Update the timings obtained when using the ACtree2 algo. All these\n### examples need to go somewhere else!\n###\n### I. A real use-case\n### ------------------\n###   > library(hgu95av2probe)\n###   > dict <- DNAStringSet(hgu95av2probe$sequence) # the original dict\n###   > pdict <- PDict(dict)\n###   > pdict\n###   > library(BSgenome.Hsapiens.UCSC.hg18)\n###   > chr1 <- Hsapiens$chr1\n###   > system.time(end_index <- endIndex(matchPDict(pdict, chr1)))\n###      user  system elapsed \n###    50.663   0.000  50.763\n###   > count_index <- sapply(end_index, length)\n###   > table(count_index)\n###   > id0 <- which(count_index == max(count_index))\n###   > p0 <- pdict[[id0]]\n###   > p0\n###     25-letter \"DNAString\" instance\n###   Value: CTGTAATCCCAGCACTTTGGGAGGC\n###   > subseq(chr1, start=end_index[[id0]][1]-24, end=end_index[[id0]][1]) == p0\n###   [1] TRUE\n### For a more extensive validation:\n###   > pidOK <- sapply(seq_len(length(end_index)),\n###                     function(pid)\n###                         identical(end_index[[pid]],\n###                         end(matchPattern(pdict[[pid]], chr1))))\n###   > all(pidOK)\n### but be aware that THIS WILL TAKE THE WHOLE DAY!!! (20-24 hours)\n###\n### II. With a big random dictionary, on george1\n### --------------------------------------------\n### 1. Trying to simulate Solexa data:\n###      > library(Biostrings)\n###      > dict_length <- 10^6\n###      > s <- DNAString(paste(sample(DNA_BASES, 36*dict_length,\n###                                    replace=TRUE), collapse=\"\"))\n###      > views_start <- (0:(dict_length-1)) * 36 + 1\n###      > dict <- Views(s, start=views_start, end=views_start + 35) # the original dict\n###\n### 2. Building the Aho-Corasick 4-ary tree from the original dictionary:\n###      > pdict <- PDict(dict)\n###\n### 3. Using pdict on Human chr1:\n###      > library(BSgenome.Hsapiens.UCSC.hg18)\n###      > chr1 <- DNAString(Hsapiens$chr1)\n###      > system.time(end_index <- endIndex(matchPDict(pdict, chr1)))\n###         user  system elapsed\n###      105.239   0.188 105.429\n###      > count_index <- sapply(end_index, length)\n###      > sum(count_index) # most likely no match were found\n###\n### Results obtained with some random dictionaries on george1:\n###\n###     dict    dict   preprocess   pdict   searching   searching     total nb\n###   length   width         time    size   chr1 time       again   of matches\n###   ------   -----   ----------   -----   ---------   ---------   ----------\n###       1M      36      2.5 sec    717M     106 sec     103 sec            0\n###      10M      36       56 sec   6724M     351 sec     200 sec            0\n###      10M      12      7.5 sec    340M     227 sec     216 sec         100M\n###      30M      12       27 sec    523M     491 sec           ? \n### \n### III. Inexact matching\n### ---------------------\n###   pdict <- PDict(c(\"acgt\", \"gt\", \"cgt\", \"ac\"), tb.end=2)\n###   endIndex(matchPDict(pdict, DNAString(\"acggaccg\"), max.mismatch=0))\n###   endIndex(matchPDict(pdict, DNAString(\"acggaccg\"), max.mismatch=1))\n###   endIndex(matchPDict(pdict, DNAString(\"acggaccg\"), max.mismatch=2))\n###\n### TODO: Rerun the benchmarks below on the entire dict0.\n###   > library(drosophila2probe)\n###   > dict0 <- DNAStringSet(drosophila2probe$sequence)\n###   > system.time(pdict0 <- PDict(dict0[1:40000]))\n###      user  system elapsed\n###     0.040   0.032   0.072\n###   > system.time(pdict <- PDict(dict0[1:40000], tb.end=10))\n###      user  system elapsed\n###    38.158   0.052  38.217\n###\n###   > library(BSgenome.Dmelanogaster.UCSC.dm3)\n###   > chr3R <- Dmelanogaster$chr3R\n###   > system.time(mindex0 <- matchPDict(pdict0, chr3R))\n###      user  system elapsed\n###     1.352   0.000   1.352\n###   > system.time(mindex <- matchPDict(pdict, chr3R))\n###      user  system elapsed\n###     1.332   0.008   1.338\n###   > identical(elementNROWS(mindex0), elementNROWS(mindex))\n###   [1] TRUE\n###\n### Allowing mismatches is fast:\n###   > system.time(mindex_mm6 <- matchPDict(pdict, chr3R, max.mismatch=4))\n###      user  system elapsed\n###     1.377   0.000   1.375\n###   > mindex_mm6[[103]]\n###        start      end width\n###   1  9381276  9381285    10\n###   2 16070100 16070109    10\n###   > v <- Views(chr3R, start=start(mindex_mm6[[103]]), end=end(mindex_mm6[[103]])+15)\n###   > mismatch(dict0[[103]], v)\n###   [[1]]\n###   [1] 14 15 19 23 24 25\n###\n###   [[2]]\n###   integer(0)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Checking the user-supplied arguments.\n###\n\n.checkUserArgsWhenTrustedBandIsFull <- function(max.mismatch, fixed)\n{\n    if (max.mismatch != 0L)\n        stop(\"'max.mismatch' must be 0 when there is no head and no tail\")\n    if (!fixed[1L])\n        warning(\"the value you specified for 'fixed' means that IUPAC\\n\",\n                \"extended letters in the patterns should be treated as\\n\",\n                \"ambiguities, but this has no effect because the patterns\\n\",\n                \"don't contain such letters\")\n}\n\n.checkMaxMismatch <- function(max.mismatch, NTB)\n{\n    max.mismatch0 <- NTB - 1L\n    if (max.mismatch > max.mismatch0)\n        stop(\"cannot use vmatchPDict()/vcountPDict()/vwhichPDict() \",\n             \"with an MTB_PDict object that was preprocessed to be used \",\n             \"with 'max.mismatch' <= \", max.mismatch0)\n    if (max.mismatch < max.mismatch0)\n        cat(\"WARNING: using 'max.mismatch=\", max.mismatch, \"' with an \",\n            \"MTB_PDict object that was preprocessed for allowing up to \",\n            max.mismatch0, \" mismatching letter(s) per match is not optimal\\n\",\n            sep=\"\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Convenience wrappers to .Call2().\n###\n\n### 'threeparts' is a PDict3Parts object.\n.match.PDict3Parts.XString <- function(threeparts, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, matches.as, envir)\n{\n    fixed <- normargFixed(fixed, subject)\n    with.indels <- normargWithIndels(with.indels)\n    if (with.indels)\n        stop(\"at the moment, matchPDict() and family only support indels \",\n             \"on a non-preprocessed pattern dictionary, sorry\")\n    if (!identical(algorithm, \"auto\"))\n        warning(\"'algorithm' is ignored when 'pdict' is a PDict object\")\n    if (is.null(head(threeparts)) && is.null(tail(threeparts)))\n        .checkUserArgsWhenTrustedBandIsFull(max.mismatch, fixed)\n    .Call2(\"match_PDict3Parts_XString\",\n          threeparts@pptb, head(threeparts), tail(threeparts),\n          subject,\n          max.mismatch, min.mismatch, fixed,\n          matches.as, envir,\n          PACKAGE=\"Biostrings\")\n}\n\n### 'pattern' is an XStringSet object.\n.match.XStringSet.XString <- function(pattern, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, matches.as, envir)\n{\n    fixed <- normargFixed(fixed, subject)\n    with.indels <- normargWithIndels(with.indels)\n    if (with.indels &&\n        !(matches.as %in% c(\"MATCHES_AS_WHICH\", \"MATCHES_AS_COUNTS\")))\n        stop(\"at the moment, within the matchPDict family, only \",\n             \"countPDict(), whichPDict(), vcountPDict() and vwhichPDict() \",\n             \"support indels\")\n    algo <- normargAlgorithm(algorithm)\n    algo <- selectAlgo(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n    .Call2(\"match_XStringSet_XString\",\n          pattern,\n          subject,\n          max.mismatch, min.mismatch, with.indels, fixed,\n          algo, matches.as, envir,\n          PACKAGE=\"Biostrings\")\n}\n\n### 'threeparts' is a PDict3Parts object.\n.match.PDict3Parts.XStringViews <- function(threeparts, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, matches.as, envir)\n{\n    fixed <- normargFixed(fixed, subject)\n    with.indels <- normargWithIndels(with.indels)\n    if (with.indels)\n        stop(\"at the moment, matchPDict() and family only support indels \",\n             \"on a non-preprocessed pattern dictionary, sorry\")\n    if (!identical(algorithm, \"auto\"))\n        warning(\"'algorithm' is ignored when 'pdict' is a PDict object\")\n    if (is.null(head(threeparts)) && is.null(tail(threeparts)))\n        .checkUserArgsWhenTrustedBandIsFull(max.mismatch, fixed)\n    .Call2(\"match_PDict3Parts_XStringViews\",\n          threeparts@pptb, head(threeparts), tail(threeparts),\n          subject(subject), start(subject), width(subject),\n          max.mismatch, min.mismatch, fixed,\n          matches.as, envir,\n          PACKAGE=\"Biostrings\")\n}\n\n### 'pattern' is an XStringSet object.\n.match.XStringSet.XStringViews <- function(pattern, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, matches.as, envir)\n{\n    fixed <- normargFixed(fixed, subject)\n    with.indels <- normargWithIndels(with.indels)\n    if (with.indels &&\n        !(matches.as %in% c(\"MATCHES_AS_WHICH\", \"MATCHES_AS_COUNTS\")))\n        stop(\"at the moment, within the matchPDict family, only \",\n             \"countPDict(), whichPDict(), vcountPDict() and vwhichPDict() \",\n             \"support indels\")\n    algo <- normargAlgorithm(algorithm)\n    algo <- selectAlgo(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n    .Call2(\"match_XStringSet_XStringViews\",\n          pattern,\n          subject(subject), start(subject), width(subject),\n          max.mismatch, min.mismatch, with.indels, fixed,\n          algo, matches.as, envir,\n          PACKAGE=\"Biostrings\")\n}\n\n### 'threeparts' is a PDict3Parts object.\n.vmatch.PDict3Parts.XStringSet <- function(threeparts, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, collapse, weight,\n                matches.as, envir)\n{\n    fixed <- normargFixed(fixed, subject)\n    with.indels <- normargWithIndels(with.indels)\n    if (with.indels)\n        stop(\"at the moment, matchPDict() and family only support indels \",\n             \"on a non-preprocessed pattern dictionary, sorry\")\n    if (!identical(algorithm, \"auto\"))\n        warning(\"'algorithm' is ignored when 'pdict' is a PDict object\")\n    if (is.null(head(threeparts)) && is.null(tail(threeparts)))\n        .checkUserArgsWhenTrustedBandIsFull(max.mismatch, fixed)\n    .Call2(\"vmatch_PDict3Parts_XStringSet\",\n          threeparts@pptb, head(threeparts), tail(threeparts),\n          subject,\n          max.mismatch, min.mismatch, fixed,\n          collapse, weight,\n          matches.as, envir,\n          PACKAGE=\"Biostrings\")\n}\n\n### 'pattern' is an XStringSet object.\n.vmatch.XStringSet.XStringSet <- function(pattern, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, collapse, weight,\n                matches.as, envir)\n{\n    fixed <- normargFixed(fixed, subject)\n    with.indels <- normargWithIndels(with.indels)\n    if (with.indels &&\n        !(matches.as %in% c(\"MATCHES_AS_WHICH\", \"MATCHES_AS_COUNTS\")))\n        stop(\"at the moment, within the matchPDict family, only \",\n             \"countPDict(), whichPDict(), vcountPDict() and vwhichPDict() \",\n             \"support indels\")\n    algo <- normargAlgorithm(algorithm)\n    algo <- selectAlgo(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n    .Call2(\"vmatch_XStringSet_XStringSet\",\n          pattern,\n          subject,\n          max.mismatch, min.mismatch, with.indels, fixed,\n          algo, collapse, weight,\n          matches.as, envir,\n          PACKAGE=\"Biostrings\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Combining the results obtained for each component of an MTB_PDict object.\n###\n\n.combine.which.compons <- function(ans_compons)\n    unique(sort(unlist(ans_compons)))\n\n.combine.vwhich.compons <- function(ans_compons)\n{\n    lapply(seq_len(length(ans_compons[[1L]])),\n        function(i)\n        {\n            ans_compons_elts <- lapply(ans_compons, \"[[\", i)\n            .combine.which.compons(ans_compons_elts)\n        }\n    )\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .matchPDict()\n###\n\n### 'pdict' is a TB_PDict object.\n.match.TB_PDict <- function(pdict, subject,\n                            max.mismatch, min.mismatch, with.indels, fixed,\n                            algorithm, verbose, matches.as)\n{\n    if (is(subject, \"DNAString\"))\n        C_ans <- .match.PDict3Parts.XString(pdict@threeparts, subject,\n                     max.mismatch, min.mismatch, with.indels, fixed,\n                     algorithm, matches.as, NULL)\n    else if (is(subject, \"XStringViews\") && is(subject(subject), \"DNAString\"))\n        C_ans <- .match.PDict3Parts.XStringViews(pdict@threeparts, subject,\n                     max.mismatch, min.mismatch, with.indels, fixed,\n                     algorithm, matches.as, NULL)\n    else\n        stop(\"'subject' must be a DNAString object,\\n\",\n             \"  a MaskedDNAString object,\\n\",\n             \"  or an XStringViews object with a DNAString subject\")\n    if (matches.as != \"MATCHES_AS_ENDS\")\n        return(C_ans)\n    # matchPDict()\n    new(\"ByPos_MIndex\", width0=width(pdict), NAMES=names(pdict), ends=C_ans)\n}\n\n### 'pdict' is an MTB_PDict object.\n.match.MTB_PDict <- function(pdict, subject,\n                             max.mismatch, min.mismatch, with.indels, fixed,\n                             algorithm, verbose, matches.as)\n{\n    tb_pdicts <- as.list(pdict)\n    NTB <- length(tb_pdicts)\n    .checkMaxMismatch(max.mismatch, NTB)\n    if (matches.as == \"MATCHES_AS_COUNTS\")\n        matches.as2 <- \"MATCHES_AS_ENDS\"\n    else\n        matches.as2 <- matches.as\n    ans_compons <- lapply(seq_len(NTB),\n        function(i)\n        {\n            if (verbose)\n                cat(\"Getting results for TB_PDict component \",\n                    i, \"/\", NTB, \" ...\\n\", sep=\"\")\n            tb_pdict <- tb_pdicts[[i]]\n            st <- system.time({\n                ans_compon <- .match.TB_PDict(tb_pdict, subject,\n                                max.mismatch, min.mismatch, with.indels, fixed,\n                                algorithm, verbose, matches.as2)\n                  }, gcFirst=TRUE)\n            if (verbose) {\n                print(st)\n                cat(sum(elementNROWS(ans_compon)), \" match(es) found\\n\",\n                    sep=\"\")\n            }\n            ans_compon\n        }\n    )\n    if (verbose)\n        cat(\"Combining the results obtained for \",\n            \"each TB_PDict component...\\n\", sep=\"\")\n    if (matches.as == \"MATCHES_AS_WHICH\")\n        return(.combine.which.compons(ans_compons))\n    st <- system.time(ans <- ByPos_MIndex.combine(ans_compons), gcFirst=TRUE)\n    if (verbose)\n        print(st)\n    if (matches.as == \"MATCHES_AS_COUNTS\")\n        return(elementNROWS(ans))\n    return(ans)\n}\n\n### 'pattern' is an XStringSet object.\n.match.XStringSet <- function(pattern, subject,\n                              max.mismatch, min.mismatch, with.indels, fixed,\n                              algorithm, verbose, matches.as)\n{\n    if (is(subject, \"XString\"))\n        C_ans <- .match.XStringSet.XString(pattern, subject,\n                     max.mismatch, min.mismatch, with.indels, fixed,\n                     algorithm, matches.as, NULL)\n    else if (is(subject, \"XStringViews\"))\n        C_ans <- .match.XStringSet.XStringViews(pattern, subject,\n                     max.mismatch, min.mismatch, with.indels, fixed,\n                     algorithm, matches.as, NULL)\n    else\n        stop(\"unsupported 'subject' type\")\n    if (matches.as != \"MATCHES_AS_ENDS\")\n        return(C_ans)\n    # matchPDict()\n    new(\"ByPos_MIndex\", width0=width(pattern), NAMES=names(pattern), ends=C_ans)\n}\n\n.matchPDict <- function(pdict, subject,\n                        max.mismatch, min.mismatch, with.indels, fixed,\n                        algorithm, verbose, matches.as=\"MATCHES_AS_ENDS\")\n{\n    which_pp_excluded <- NULL\n    if (is(pdict, \"PDict\")) {\n        if (seqtype(subject) != \"DNA\")\n            stop(\"'subject' must be DNA\")\n        dups0 <- dups(pdict)\n        if (!is.null(dups0))\n            which_pp_excluded <- which(duplicated(dups0))\n    } else if (is(pdict, \"XStringSet\")) {\n        if (seqtype(pdict) != seqtype(subject))\n            stop(\"'pdict' and 'subject' must contain \",\n                 \"sequences of the same type\")\n    } else {\n        stop(\"'pdict' must be a PDict or XStringSet object\")\n    }\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    min.mismatch <- normargMinMismatch(min.mismatch, max.mismatch)\n    if (!isTRUEorFALSE(verbose))\n        stop(\"'verbose' must be TRUE or FALSE\")\n    ## We are doing our own dispatch here, based on the type of 'pdict'.\n    ## TODO: Revisit this. Would probably be a better design to use a\n    ## generic/methods approach and rely on the standard dispatch mechanism.\n    ## Those low-level generic/methods wouldn't need to be exported.\n    if (is(pdict, \"TB_PDict\"))\n        ans <- .match.TB_PDict(pdict, subject,\n                       max.mismatch, min.mismatch, with.indels, fixed,\n                       algorithm, verbose, matches.as)\n    else if (is(pdict, \"MTB_PDict\"))\n        ans <- .match.MTB_PDict(pdict, subject,\n                       max.mismatch, min.mismatch, with.indels, fixed,\n                       algorithm, verbose, matches.as)\n    else\n        ans <- .match.XStringSet(pdict, subject,\n                       max.mismatch, min.mismatch, with.indels, fixed,\n                       algorithm, verbose, matches.as)\n    if (is.null(which_pp_excluded))\n        return(ans)\n    if (matches.as == \"MATCHES_AS_WHICH\")\n        return(members(dups0, ans))\n    if (matches.as == \"MATCHES_AS_COUNTS\") {\n        ans[which_pp_excluded] <- ans[togroup(dups0, which_pp_excluded)]\n        return(ans)\n    }\n    if (is(ans, \"ByPos_MIndex\")) {\n        ans@dups0 <- dups0\n    } else {\n        stop(\"don't know how to store the dup info in a \",\n             class(ans), \" object\")\n    }\n    return(ans)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .vmatchPDict()\n###\n\n### 'pdict' is an TB_PDict object.\n.vmatch.TB_PDict <- function(pdict, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, collapse, weight,\n                verbose, matches.as)\n{\n    .vmatch.PDict3Parts.XStringSet(pdict@threeparts, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, collapse, weight,\n                    matches.as, NULL)\n}\n\n### 'pdict' is an MTB_PDict object.\n.vmatch.MTB_PDict <- function(pdict, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, collapse, weight,\n                verbose, matches.as)\n{\n    tb_pdicts <- as.list(pdict)\n    NTB <- length(tb_pdicts)\n    .checkMaxMismatch(max.mismatch, NTB)\n    if (matches.as != \"MATCHES_AS_WHICH\")\n        stop(\"MTB_PDict objects are not supported yet, sorry\")\n    ans_compons <- lapply(seq_len(NTB),\n        function(i)\n        {\n            if (verbose)\n                cat(\"Getting results for TB_PDict component \",\n                    i, \"/\", NTB, \" ...\\n\", sep=\"\")\n            tb_pdict <- tb_pdicts[[i]]\n            .vmatch.TB_PDict(tb_pdict, subject,\n                             max.mismatch, min.mismatch, with.indels, fixed,\n                             algorithm, collapse, weight,\n                             verbose, matches.as)\n        }\n    )\n    if (verbose)\n        cat(\"Combining the results obtained for \",\n            \"each TB_PDict component...\\n\", sep=\"\")\n    .combine.vwhich.compons(ans_compons)\n}\n\n### 'pattern' is an XStringSet object.\n.vmatch.XStringSet <- function(pattern, subject,\n                max.mismatch, min.mismatch, with.indels, fixed,\n                algorithm, collapse, weight,\n                verbose, matches.as)\n{\n    .vmatch.XStringSet.XStringSet(pattern, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, collapse, weight,\n                    matches.as, NULL)\n}\n\n.vmatchPDict <- function(pdict, subject,\n                         max.mismatch, min.mismatch, with.indels, fixed,\n                         algorithm, collapse, weight,\n                         verbose, matches.as=\"MATCHES_AS_ENDS\")\n{\n    which_pp_excluded <- NULL\n    if (is(pdict, \"PDict\")) {\n        if (seqtype(subject) != \"DNA\")\n            stop(\"'subject' must be DNA\")\n        dups0 <- dups(pdict)\n        if (!is.null(dups0))\n            which_pp_excluded <- which(duplicated(dups0))\n    } else if (is(pdict, \"XStringSet\")) {\n        if (seqtype(pdict) != seqtype(subject))\n            stop(\"'pdict' and 'subject' must contain \",\n                 \"sequences of the same type\")\n    } else {\n        stop(\"'pdict' must be a PDict or XStringSet object\")\n    }\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    min.mismatch <- normargMinMismatch(min.mismatch, max.mismatch)\n    if (!isTRUEorFALSE(verbose))\n        stop(\"'verbose' must be TRUE or FALSE\")\n    if (matches.as == \"MATCHES_AS_WHICH\") {\n        ## vwhichPDict()\n    } else if (matches.as == \"MATCHES_AS_COUNTS\") {\n        ## vcountPDict()\n        collapse <- normargCollapse(collapse)\n        if (collapse) {\n            if (collapse == 1L) {\n                weight <- recycleNumericArg(weight, \"weight\", length(subject))\n            } else {\n                weight <- recycleNumericArg(weight, \"weight\", length(pdict))\n                if (!is.null(which_pp_excluded)) {\n                    ## Collapse weights of duplicates.\n                    ## TODO: Implement this in C.\n                    which_is_not_unique <-\n                        which(!sapply(low2high(dups0), is.null))\n                    if (length(which_is_not_unique) != 0L) {\n                        weight[which_is_not_unique] <-\n                            weight[which_is_not_unique] +\n                            sapply(which_is_not_unique,\n                                function(i) sum(weight[low2high(dups0)[[i]]]))\n                    }\n                }\n            }\n        } else {\n            if (!identical(weight, 1L))\n                warning(\"'weight' is ignored when 'collapse=FALSE'\")\n        }\n    } else {\n        ## vmatchPDict()\n        stop(\"vmatchPDict() is not supported yet, sorry\")\n    }\n    ## We are doing our own dispatch here, based on the type of 'pdict'.\n    ## TODO: Revisit this. Would probably be a better design to use a\n    ## generic/methods approach and rely on the standard dispatch mechanism.\n    ## Those low-level generic/methods wouldn't need to be exported.\n    if (is(pdict, \"TB_PDict\"))\n        ans <- .vmatch.TB_PDict(pdict, subject,\n                       max.mismatch, min.mismatch, with.indels, fixed,\n                       algorithm, collapse, weight,\n                       verbose, matches.as)\n    else if (is(pdict, \"MTB_PDict\"))\n        ans <- .vmatch.MTB_PDict(pdict, subject,\n                       max.mismatch, min.mismatch, with.indels, fixed,\n                       algorithm, collapse, weight,\n                       verbose, matches.as)\n    else\n        ans <- .vmatch.XStringSet(pdict, subject,\n                       max.mismatch, min.mismatch, with.indels, fixed,\n                       algorithm, collapse, weight,\n                       verbose, matches.as)\n    if (is.null(which_pp_excluded))\n        return(ans)\n    if (matches.as == \"MATCHES_AS_WHICH\") {\n        ## vwhichPDict()\n        return(vmembers(dups0, ans))\n    }\n    if (matches.as == \"MATCHES_AS_COUNTS\") {\n        ## vcountPDict()\n        if (collapse == 0L) {\n            ans[which_pp_excluded, ] <- ans[togroup(dups0, which_pp_excluded), ]\n        } else if (collapse == 1L) {\n            ans[which_pp_excluded] <- ans[togroup(dups0, which_pp_excluded)]\n        }\n        return(ans)\n    }\n    ## vmatchPDict()\n    stop(\"vmatchPDict() is not supported yet, sorry\")\n    return(ans)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"matchPDict\" generic and methods.\n###\n\nsetGeneric(\"matchPDict\", signature=\"subject\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        standardGeneric(\"matchPDict\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPDict\", \"XString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .matchPDict(pdict, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, verbose)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPDict\", \"XStringSet\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use vmatchPDict() when 'subject' is an XStringSet \",\n             \"object (multiple sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPDict\", \"XStringViews\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .matchPDict(pdict, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, verbose)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPDict\", \"MaskedXString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        matchPDict(pdict, toXStringViewsOrXString(subject),\n                   max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                   with.indels=with.indels, fixed=fixed,\n                   algorithm=algorithm, verbose=verbose)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"countPDict\" generic and methods.\n###\n\nsetGeneric(\"countPDict\", signature=\"subject\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        standardGeneric(\"countPDict\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPDict\", \"XString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .matchPDict(pdict, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, verbose, matches.as=\"MATCHES_AS_COUNTS\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPDict\", \"XStringSet\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use vcountPDict() when 'subject' is an XStringSet \",\n             \"object (multiple sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPDict\", \"XStringViews\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .matchPDict(pdict, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, verbose, matches.as=\"MATCHES_AS_COUNTS\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPDict\", \"MaskedXString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        countPDict(pdict, toXStringViewsOrXString(subject),\n                   max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                   with.indels=with.indels, fixed=fixed,\n                   algorithm=algorithm, verbose=verbose)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"whichPDict\" generic and methods.\n###\n\nsetGeneric(\"whichPDict\", signature=\"subject\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        standardGeneric(\"whichPDict\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"whichPDict\", \"XString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .matchPDict(pdict, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, verbose, matches.as=\"MATCHES_AS_WHICH\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"whichPDict\", \"XStringSet\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use vwhichPDict() when 'subject' is an XStringSet \",\n             \"object (multiple sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"whichPDict\", \"XStringViews\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .matchPDict(pdict, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed,\n                    algorithm, verbose, matches.as=\"MATCHES_AS_WHICH\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"whichPDict\", \"MaskedXString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        whichPDict(pdict, toXStringViewsOrXString(subject),\n                   max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                   with.indels=with.indels, fixed=fixed,\n                   algorithm=algorithm, verbose=verbose)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"vmatchPDict\", \"vcountPDict\" and \"vwhichPDict\" generic and methods.\n###\n### These are vectorized versions of matchPDict(), countPDict() and\n### whichPDict(). If M denotes the number of patterns in 'pdict' and N the\n### number of sequences in 'subject', then:\n###   o vwhichPDict(): 'vwhichPDict(pdict, subject, ...)' is equivalent to\n###     'lapply(subject, function(s) whichPDict(pdict, s, ...))'.\n###      The returned object is a list of length N.\n###   o vcountPDict(): returns an M x N matrix of integers.\n###   o vmatchPDict(): not supported yet! (first we need a container to\n###     store the results)\n###\n\nsetGeneric(\"vmatchPDict\", signature=\"subject\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE, ...)\n        standardGeneric(\"vmatchPDict\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vmatchPDict\", \"ANY\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"vmatchPDict() is not ready yet, sorry\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vmatchPDict\", \"XString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use matchPDict() when 'subject' is an XString \",\n             \"object (single sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vmatchPDict\", \"MaskedXString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use matchPDict() when 'subject' is a MaskedXString \",\n             \"object (single sequence)\")\n)\n\nsetGeneric(\"vcountPDict\", signature=\"subject\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", collapse=FALSE, weight=1L, verbose=FALSE, ...)\n        standardGeneric(\"vcountPDict\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vcountPDict\", \"XString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", collapse=FALSE, weight=1L, verbose=FALSE)\n        stop(\"please use countPDict() when 'subject' is an XString \",\n             \"object (single sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vcountPDict\", \"XStringSet\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", collapse=FALSE, weight=1L, verbose=FALSE)\n        .vmatchPDict(pdict, subject,\n                     max.mismatch, min.mismatch, with.indels, fixed,\n                     algorithm, collapse, weight,\n                     verbose, matches.as=\"MATCHES_AS_COUNTS\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vcountPDict\", \"XStringViews\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", collapse=FALSE, weight=1L, verbose=FALSE)\n        vcountPDict(pdict, fromXStringViewsToStringSet(subject),\n                    max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                    with.indels=with.indels, fixed=fixed,\n                    algorithm=algorithm, collapse=collapse, weight=weight,\n                    verbose=verbose)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vcountPDict\", \"MaskedXString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", collapse=FALSE, weight=1L, verbose=FALSE)\n        stop(\"please use countPDict() when 'subject' is a MaskedXString \",\n             \"object (single sequence)\")\n)\n\nsetGeneric(\"vwhichPDict\", signature=\"subject\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        standardGeneric(\"vwhichPDict\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vwhichPDict\", \"XString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use whichPDict() when 'subject' is an XString \",\n             \"object (single sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vwhichPDict\", \"XStringSet\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        .vmatchPDict(pdict, subject,\n                     max.mismatch, min.mismatch, with.indels, fixed,\n                     algorithm, 0L, 1L,\n                     verbose, matches.as=\"MATCHES_AS_WHICH\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vwhichPDict\", \"XStringViews\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        vwhichPDict(pdict, fromXStringViewsToStringSet(subject),\n                    max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                    with.indels=with.indels, fixed=fixed,\n                    algorithm=algorithm, verbose=verbose)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"vwhichPDict\", \"MaskedXString\",\n    function(pdict, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", verbose=FALSE)\n        stop(\"please use whichPDict() when 'subject' is a MaskedXString \",\n             \"object (single sequence)\")\n)\n\n",
        "matchPWM.R": "### =========================================================================\n### Position Weight Matrix (PWM) functions\n### -------------------------------------------------------------------------\n\n### A Position Weight Matrix (PWM) is represented as an ordinary matrix.\n### We don't use an S4 class for this, not even an S3 class.\n.normargPwm <- function(pwm, argname=\"pwm\")\n{\n    if (!is.matrix(pwm) || !is.numeric(pwm))\n        stop(\"'\", argname, \"' must be a numeric matrix\")\n    if (!identical(rownames(pwm), DNA_BASES))\n        stop(\"'rownames(\", argname, \")' must be the 4 DNA bases ('DNA_BASES')\")\n    if (!is.double(pwm))\n        storage.mode(pwm) <- \"double\"\n    if (any(is.na(pwm)))\n        stop(\"'\", argname, \"' contains NAs\")\n    pwm\n}\n\n### A Position Frequency Matrix (PFM) is also represented as an ordinary\n### matrix. Unlike a PWM, it must be of type integer (it will typically be\n### the result of consensusMatrix()).\n.normargPfm <- function(x)\n{\n    if (!is.matrix(x) || !is.integer(x))\n        stop(\"invalid PFM 'x': not an integer matrix\")\n    ## Check the row names.\n    if (is.null(rownames(x)))\n        stop(\"invalid PFM 'x': no row names\")\n    if (!all(rownames(x) %in% DNA_ALPHABET))\n        stop(\"invalid PFM 'x': row names must be in 'DNA_ALPHABET'\")\n    if (!all(DNA_BASES %in% rownames(x)))\n        stop(\"invalid PFM 'x': row names must contain A, C, G and T\")\n    if (any(duplicated(rownames(x))))\n        stop(\"invalid PFM 'x': duplicated row names\")\n    ## Check the nb of cols.\n    if (ncol(x) == 0L)\n        stop(\"invalid PFM 'x': no columns\")\n    ## Check the values.\n    if (any(is.na(x)) || any(x < 0L))\n        stop(\"invalid PFM 'x': values cannot be NA or negative\")\n    if (any(x[!(rownames(x) %in% DNA_BASES), ] != 0L))\n        stop(\"invalid PFM 'x': IUPAC ambiguity letters are represented\")\n    x <- x[DNA_BASES, , drop=FALSE]\n    if (!isConstant(colSums(x)))\n        stop(\"invalid PFM 'x': all columns in 'x' must sum to the same \",\n             \"value.\\n  If the PFM was obtained by calling consensusMatrix() \",\n             \"on a DNAStringSet\\n  object, please make sure that this object \",\n             \"is rectangular (i.e. has a\\n  constant width).\")\n    x\n}\n\n### Typical 'prior.params' vector: c(A=0.25, C=0.25, G=0.25, T=0.25)\n.normargPriorParams <- function(prior.params)\n{\n    if (!is.numeric(prior.params))\n        stop(\"'prior.params' must be a numeric vector\")\n    if (length(prior.params) != length(DNA_BASES) ||\n        !setequal(names(prior.params), DNA_BASES))\n        stop(\"'prior.params' elements must be named A, C, G and T\")\n    ## Re-order the elements.\n    prior.params <- prior.params[DNA_BASES]\n    if (any(is.na(prior.params)) || any(prior.params < 0))\n        stop(\"'prior.params' contains NAs and/or negative values\")\n    prior.params\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some utilities to operate on a PWM.\n###\n\n### Extracts the max weight for each position (i.e. column) in a PWM.\nsetGeneric(\"maxWeights\", function(x) standardGeneric(\"maxWeights\"))\n\nsetMethod(\"maxWeights\", \"matrix\",\n    function(x)\n    {\n        x <- .normargPwm(x, argname=\"x\")\n        #sapply(seq_len(ncol(x)), function(i) max(x[ , i]))\n        ## This will be faster than the above on large matrices\n        do.call(pmax, lapply(seq_len(nrow(x)), function(i) x[i, ]))\n    })\n\n### Extracts the min weight for each position (i.e. column) in a PWM.\nsetGeneric(\"minWeights\", function(x) standardGeneric(\"minWeights\"))\n\nsetMethod(\"minWeights\", \"matrix\",\n    function(x)\n    {\n        x <- .normargPwm(x, argname=\"x\")\n        #sapply(seq_len(ncol(x)), function(i) max(x[ , i]))\n        ## This will be faster than the above on large matrices\n        do.call(pmin, lapply(seq_len(nrow(x)), function(i) x[i, ]))\n    })\n\n### Computes the highest possible score that can be obtained with a PWM.\nsetGeneric(\"maxScore\", function(x) standardGeneric(\"maxScore\"))\nsetMethod(\"maxScore\", \"ANY\", function(x) sum(maxWeights(x)))\n\n### Computes the lowest possible score that can be obtained with a PWM.\nsetGeneric(\"minScore\", function(x) standardGeneric(\"minScore\"))\nsetMethod(\"minScore\", \"ANY\", function(x) sum(minWeights(x)))\n\n### TODO: There is no reason to treat this differently than the above\n### utilities. So either this should be implemented as a generic+method\n### or the above utilities should be implemented as ordinary functions.\nunitScale <- function(x)\n{\n    minS <- minScore(x)\n    (x - minS/ncol(x)) / (maxScore(x) - minS)\n}\n\n### Method needed for searching the minus strand of a chromosome like\n### this:\n###   > matchPWM(reverseComplement(pwm), chr1)\n### Note that the generic function is defined in Biostrings.\nsetMethod(\"reverseComplement\", \"matrix\",\n    function(x, ...)\n    {\n        ans <- rev(x)\n        attributes(ans) <- attributes(x)\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"PWM\" generic and methods.\n###\n\nsetGeneric(\"PWM\", signature=\"x\",\n    function(x, type = c(\"log2probratio\", \"prob\"),\n             prior.params = c(A=0.25, C=0.25, G=0.25, T=0.25))\n        standardGeneric(\"PWM\")\n)\n\nsetMethod(\"PWM\", \"character\",\n    function(x, type = c(\"log2probratio\", \"prob\"),\n             prior.params = c(A=0.25, C=0.25, G=0.25, T=0.25))\n    {\n        dnaset <- DNAStringSet(x)\n        PWM(dnaset, type = type, prior.params = prior.params)\n    }\n)\n\nsetMethod(\"PWM\", \"DNAStringSet\",\n    function(x, type = c(\"log2probratio\", \"prob\"),\n             prior.params = c(A=0.25, C=0.25, G=0.25, T=0.25))\n    {\n        if (!isConstant(width(x)))\n            stop(\"'x' must be rectangular (i.e. have a constant width)\")\n        pfm <- consensusMatrix(x)\n        PWM(pfm, type = type, prior.params = prior.params)\n    }\n)\n\n### Assumes 'x' is a Position *Frequency* Matrix (PFM) and computes the\n### corresponding Position *Weight* Matrix (PWM).\nsetMethod(\"PWM\", \"matrix\",\n    function(x, type = c(\"log2probratio\", \"prob\"),\n             prior.params = c(A=0.25, C=0.25, G=0.25, T=0.25))\n    {\n        x <- .normargPfm(x)\n        ## From here 'x' is guaranteed to have at least 1 column and to have\n        ## all its columns sum to the same value.\n        nseq <- sum(x[ , 1L])\n        type <- match.arg(type)\n        prior.params <- .normargPriorParams(prior.params)\n        priorN <- sum(prior.params)\n        ## NOTE (H.P.): What's the purpose of dividing by nseq + priorN here?\n        ## It won't have any impact on the final result (because of the\n        ## unitScale final step).\n        postProbs <- (x + prior.params) / (nseq + priorN)\n        if (type == \"log2probratio\") {\n            if (any(prior.params == 0))\n                stop(\"infinite values in PWM due to 0's in 'prior.params'\")\n            prior.probs <- prior.params / priorN\n            ans <- log2(postProbs / prior.probs)\n        } else {\n            ans <- postProbs\n        }\n        unitScale(ans)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"PWMscoreStartingAt\" function.\n###\n\n.normargSubject <- function(subject)\n{\n    if (is.character(subject)) {\n        subject <- DNAString(subject)\n    } else if (is(subject, \"MaskedDNAString\")) {\n        if (any(active(masks(subject))))\n            stop(\"active masks are not supported yet, please complain!\")\n        subject <- unmasked(subject)\n    } else if (is(subject, \"XStringViews\")) {\n        subject <- subject(subject)\n    }\n    if (!is(subject, \"DNAString\"))\n        stop(\"'subject' must be a single character string, \",\n             \"or a DNAString object, or a MaskedDNAString object with \",\n             \"no active masks, or a Views object on a DNAString subject\")\n    subject\n}\n\n### TODO: There is no reason to treat this differently than anything else\n### in this file. So maybe this should be implemented as a generic+method\n### too (or matchPWM/countPWM shouldn't).\nPWMscoreStartingAt <- function(pwm, subject, starting.at=1)\n{\n    ## checking 'pwm'\n    pwm <- .normargPwm(pwm)\n    ## checking 'subject'\n    subject <- .normargSubject(subject)\n    ## checking 'starting.at'\n    if (!is.numeric(starting.at))\n        stop(\"'starting.at' must be a vector of integers\")\n    if (!is.integer(starting.at))\n        starting.at <- as.integer(starting.at)\n\n    base_codes <- xscodes(subject, baseOnly=TRUE)\n    .Call2(\"PWM_score_starting_at\",\n          pwm, subject, starting.at, base_codes,\n          PACKAGE=\"Biostrings\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"matchPWM\" generic and methods.\n###\n\n.normargMinScore <- function(min.score, pwm)\n{\n    if (!isSingleNumber(min.score) && !isSingleString(min.score))\n        stop(\"'min.score' must be a single number or string\")\n    if (is.numeric(min.score)) {\n        if (!is.double(min.score))\n            storage.mode(min.score) <- \"double\"\n        return(min.score)\n    }\n    nc <- nchar(min.score)\n    if (substr(min.score, nc, nc) == \"%\")\n        min.score <- substr(min.score, 1L, nc-1L)\n    maxScore(pwm) * as.double(min.score) / 100.00\n}\n\n### pwm: the Position Weight Matrix (numeric matrix with row names A, C, G\n###      and T);\n### subject: a DNAString object containing the subject sequence;\n### min.score: given as a percentage (e.g. \"90%\") of the highest possible\n###            score or as a single number.\n.XString.matchPWM <- function(pwm, subject, min.score,\n                              with.score=FALSE, count.only=FALSE)\n{\n    ## checking 'pwm'\n    pwm <- .normargPwm(pwm)\n    ## checking 'min.score'\n    min.score <- .normargMinScore(min.score, pwm)\n    ## checking 'with.score'\n    if (!isTRUEorFALSE(with.score))\n        stop(\"'with.score' must be TRUE or FALSE\")\n    ## no need to check 'count.only' (not a user controlled argument)\n\n    base_codes <- xscodes(subject, baseOnly=TRUE)\n    C_ans <- .Call2(\"XString_match_PWM\",\n                   pwm, subject, min.score, count.only, base_codes,\n                   PACKAGE=\"Biostrings\")\n    if (count.only)\n        return(C_ans)\n    ans_start <- start(C_ans)\n    ans_width <- width(C_ans)\n    ans <- unsafe.newXStringViews(subject, ans_start, ans_width)\n    if (with.score) {\n        score <- PWMscoreStartingAt(pwm, subject, starting.at=ans_start)\n        mcols(ans) <- DataFrame(score=score)\n    }\n    ans\n}\n\n.XStringViews.matchPWM <- function(pwm, subject, min.score,\n                                   with.score=FALSE, count.only=FALSE)\n{\n    ## checking 'pwm'\n    pwm <- .normargPwm(pwm)\n    ## checking 'min.score'\n    min.score <- .normargMinScore(min.score, pwm)\n    ## checking 'with.score'\n    if (!isTRUEorFALSE(with.score))\n        stop(\"'with.score' must be TRUE or FALSE\")\n    ## no need to check 'count.only' (not a user controlled argument)\n\n    subject0 <- subject(subject)\n    base_codes <- xscodes(subject0, baseOnly=TRUE)\n    C_ans <- .Call2(\"XStringViews_match_PWM\",\n                   pwm,\n                   subject0, start(subject), width(subject),\n                   min.score, count.only, base_codes,\n                   PACKAGE=\"Biostrings\")\n    if (count.only)\n        return(C_ans)\n    ans_start <- start(C_ans)\n    ans_width <- width(C_ans)\n    ans <- unsafe.newXStringViews(subject0, ans_start, ans_width)\n    if (with.score) {\n        score <- PWMscoreStartingAt(pwm, subject0, starting.at=ans_start)\n        mcols(ans) <- DataFrame(score=score)\n    }\n    ans\n}\n\n### Note the dispatch on 'subject'.\nsetGeneric(\"matchPWM\", signature=\"subject\",\n    function(pwm, subject, min.score=\"80%\", with.score=FALSE, ...)\n        standardGeneric(\"matchPWM\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPWM\", \"character\",\n    function(pwm, subject, min.score=\"80%\", with.score=FALSE)\n        matchPWM(pwm, DNAString(subject),\n                 min.score=min.score, with.score=with.score)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPWM\", \"DNAString\",\n    function(pwm, subject, min.score=\"80%\", with.score=FALSE)\n        .XString.matchPWM(pwm, subject, min.score, with.score=with.score)\n)\n\n### Dispatch on 'subject' (see signature of generic).\n### WARNING: Unlike the other \"matchPWM\" methods, the XStringViews object\n### returned by this method is not guaranteed to have its views ordered from\n### left to right in general! One important particular case where this is\n### guaranteed though is when 'isNormal(subject)' is TRUE (i.e. 'subject' is\n### a normal XStringViews object).\n### matchPWM does not support \"out of limits\"  matches.\nsetMethod(\"matchPWM\", \"XStringViews\",\n    function(pwm, subject, min.score=\"80%\", with.score=FALSE)\n        .XStringViews.matchPWM(pwm, subject, min.score, with.score=with.score)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPWM\", \"MaskedDNAString\",\n    function(pwm, subject, min.score=\"80%\", with.score=FALSE)\n        matchPWM(pwm, toXStringViewsOrXString(subject),\n                 min.score=min.score, with.score=with.score)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"countPWM\" generic and methods.\n###\n\n### Note the dispatch on 'subject'.\nsetGeneric(\"countPWM\", signature=\"subject\",\n    function(pwm, subject, min.score=\"80%\", ...)\n        standardGeneric(\"countPWM\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPWM\", \"character\",\n    function(pwm, subject, min.score=\"80%\")\n        countPWM(pwm, DNAString(subject), min.score)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPWM\", \"DNAString\",\n    function(pwm, subject, min.score=\"80%\")\n        .XString.matchPWM(pwm, subject, min.score, count.only=TRUE)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPWM\", \"XStringViews\",\n    function(pwm, subject, min.score=\"80%\")\n        .XStringViews.matchPWM(pwm, subject, min.score, count.only=TRUE)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPWM\", \"MaskedDNAString\",\n    function(pwm, subject, min.score=\"80%\")\n        countPWM(pwm, toXStringViewsOrXString(subject), min.score)\n)\n\n",
        "matchPattern.R": "### =========================================================================\n### The matchPattern() generic & related functions\n### -------------------------------------------------------------------------\n\n\n.Clongint.nbits <- function()\n{\n    .Call2(\"bits_per_long\", PACKAGE=\"Biostrings\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### matchPattern algos for standard character vectors.\n###\n### Note that these algos are not documented.\n###\n\n### This matchPattern algo can miss matches (see below why).\n.matchPattern.gregexpr <- function(pattern, subject)\n{\n    matches <- gregexpr(pattern, subject, fixed=TRUE)[[1]]\n    if (length(matches) == 1 && matches == -1)\n        matches <- integer(0)\n    else\n        attr(matches, \"match.length\") <- NULL\n    matches\n}\n\n### Standard R gregexpr() misses matches when they are overlapping:\n###   > gregexpr(\"aa\", c(\"XaaaYaa\", \"a\"), fixed=TRUE)\n###   [[1]]\n###   [1] 2 6\n###   attr(,\"match.length\")\n###   [1] 2 2\n###\n###   [[2]]\n###   [1] -1\n###   attr(,\"match.length\")\n###   [1] -1\n###\n### gregexpr2() is a modified version of gregexpr() that returns _all_\n### matches but it only works in 'fixed=TRUE' mode (i.e. for exact matching,\n### no regular expression):\n###   > gregexpr2(\"aa\", c(\"XaaaYaa\", \"a\"))\n###   [[1]]\n###   [1] 2 3 6\n###\n###   [[2]]\n###   [1] -1\n###\n### Note that, unlike gregexpr(), gregexpr2() doesn't attach a \"match.length\"\n### attribute to each element of the returned list because, since it only works\n### in 'fixed=TRUE' mode, then all the matches have the length of the pattern.\n### Another difference with gregexpr() is that with gregexpr2(), the 'pattern'\n### argument must be a single (non-NA, non-empty) string.\n\ngregexpr2 <- function(pattern, text)\n{\n    if (!is.character(pattern) || length(pattern) != 1\n      || is.na(pattern) || nchar(pattern) == 0)\n        stop(\"invalid pattern\")\n    matches <- gregexpr(pattern, text, fixed=TRUE)\n    nP <- nchar(pattern)\n    for (i in 1:length(text)) {\n        mi <- matches[[i]]\n        if (length(mi) == 1 && mi == -1) {\n            attr(matches[[i]], \"match.length\") <- NULL\n        } else {\n            subtexts <- substring(text[i], mi + 1, mi + 2*nP - 2)\n            missing_matches <- gregexpr2(pattern, subtexts)\n            for (j in 1:length(mi)) {\n                mj <- missing_matches[[j]]\n                if (length(mj) != 1 || mj != -1)\n                    matches[[i]] <- c(matches[[i]], mi[j] + mj)\n            }\n            matches[[i]] <- sort(matches[[i]])\n        }\n    }\n    matches\n}\n\n.matchPattern.gregexpr2 <- function(pattern, subject)\n{\n    matches <- gregexpr2(pattern, subject)[[1]]\n    if (length(matches) == 1 && matches == -1)\n        matches <- integer(0)\n    matches\n}\n\n.character.matchPattern <- function(pattern, subject,\n                                    max.mismatch, fixed, algo, count.only)\n{\n    if (!isSingleString(pattern) || nchar(pattern) == 0)\n        stop(\"'pattern' must be a single (non-empty) string \",\n             \"for this algorithm\")\n    if (!isSingleString(subject) || nchar(subject) == 0)\n        stop(\"'subject' must be a single (non-empty) string \",\n             \"for this algorithm\")\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    ## we cheat on normargFixed() to keep it quiet\n    fixed <- normargFixed(fixed, DNAString())\n    if (!(max.mismatch == 0L && all(fixed)))\n        stop(\"this algorithm only supports exact matching \",\n             \"(i.e. 'max.mismatch=0' and 'fixed=TRUE')\")\n    if (!isTRUEorFALSE(count.only))\n        stop(\"'count.only' must be TRUE or FALSE\")\n    matches <- switch(algo,\n                      \"gregexpr\"=.matchPattern.gregexpr(pattern, subject),\n                      \"gregexpr2\"=.matchPattern.gregexpr2(pattern, subject))\n    if (count.only) length(matches) else matches\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .XString.matchPattern() and .XStringViews.matchPattern()\n###\n\n.XString.matchPattern <- function(pattern, subject,\n                                  max.mismatch, min.mismatch, with.indels, fixed,\n                                  algorithm,\n                                  count.only=FALSE)\n{\n    algo <- normargAlgorithm(algorithm)\n    if (isCharacterAlgo(algo))\n        return(.character.matchPattern(pattern, subject,\n                                       max.mismatch, fixed, algo, count.only))\n    if (!is(subject, \"XString\"))\n        subject <- XString(NULL, subject)\n    pattern <- normargPattern(pattern, subject)\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    min.mismatch <- normargMinMismatch(min.mismatch, max.mismatch)\n    with.indels <- normargWithIndels(with.indels)\n    fixed <- normargFixed(fixed, subject)\n    if (!isTRUEorFALSE(count.only))\n        stop(\"'count.only' must be TRUE or FALSE\")\n    algo <- selectAlgo(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n    C_ans <- .Call2(\"XString_match_pattern\",\n                   pattern, subject,\n                   max.mismatch, min.mismatch, with.indels, fixed,\n                   algo, count.only,\n                   PACKAGE=\"Biostrings\")\n    if (count.only)\n        return(C_ans)\n    Views(subject, start=start(C_ans), width=width(C_ans))\n}\n\n.XStringViews.matchPattern <- function(pattern, subject,\n                                       max.mismatch, min.mismatch, with.indels, fixed,\n                                       algorithm,\n                                       count.only=FALSE)\n{\n    algo <- normargAlgorithm(algorithm)\n    if (isCharacterAlgo(algo))\n        stop(\"'subject' must be a single (non-empty) string \",\n             \"for this algorithm\")\n    pattern <- normargPattern(pattern, subject)\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    min.mismatch <- normargMinMismatch(min.mismatch, max.mismatch)\n    with.indels <- normargWithIndels(with.indels)\n    fixed <- normargFixed(fixed, subject)\n    if (!isTRUEorFALSE(count.only))\n        stop(\"'count.only' must be TRUE or FALSE\")\n    algo <- selectAlgo(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n    C_ans <- .Call2(\"XStringViews_match_pattern\",\n                   pattern, subject(subject), start(subject), width(subject),\n                   max.mismatch, min.mismatch, with.indels, fixed,\n                   algo, count.only,\n                   PACKAGE=\"Biostrings\")\n    if (count.only)\n        return(C_ans)\n    Views(subject(subject), start=start(C_ans), width=width(C_ans))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"matchPattern\" generic and methods.\n###\n### Typical use:\n###   matchPattern(\"TG\", DNAString(\"GTGACGTGCAT\"))\n###   matchPattern(\"TG\", DNAString(\"GTGACGTGCAT\"), algo=\"shift\", max.mismatch=1)\n### Edge cases:\n###   matchPattern(\"---\", DNAString(\"ACGTGCA\"), max.mismatch=3)\n###   matchPattern(\"---\", DNAString(\"A\"))\n###\n\nsetGeneric(\"matchPattern\", signature=\"subject\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        standardGeneric(\"matchPattern\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPattern\", \"character\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XString.matchPattern(pattern, subject,\n                              max.mismatch, min.mismatch, with.indels, fixed,\n                              algorithm)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPattern\", \"XString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XString.matchPattern(pattern, subject,\n                              max.mismatch, min.mismatch, with.indels, fixed,\n                              algorithm)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPattern\", \"XStringSet\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"please use vmatchPattern() when 'subject' is an XStringSet object (multiple sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\n### WARNING: Unlike the other \"matchPattern\" methods, the XStringViews object\n### returned by this method is not guaranteed to have its views ordered from\n### left to right in general! One important particular case where this is\n### guaranteed though is when 'isNormal(subject)' is TRUE (i.e. 'subject' is\n### a normal XStringViews object) and 'max.mismatch=0' (no \"out of limits\"\n### matches).\nsetMethod(\"matchPattern\", \"XStringViews\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XStringViews.matchPattern(pattern, subject,\n                                   max.mismatch, min.mismatch, with.indels, fixed,\n                                   algorithm)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchPattern\", \"MaskedXString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        matchPattern(pattern, toXStringViewsOrXString(subject),\n                     max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                     with.indels=with.indels, fixed=fixed, algorithm=algorithm)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"countPattern\" generic and methods.\n###\n### countPattern() is equivalent to length(matchPattern()) but should be\n### slightly faster, especially when there is a high number of matches.\n###\n### Typical use:\n###   countPattern(\"TG\", DNAString(\"GTGACGTGCAT\"))\n###   countPattern(\"TG\", DNAString(\"GTGACGTGCAT\"), max.mismatch=1)\n### Edge cases:\n###   countPattern(\"---\", DNAString(\"ACGTGCA\"), max.mismatch=3)\n###   countPattern(\"---\", DNAString(\"A\"))\n###\n\nsetGeneric(\"countPattern\", signature=\"subject\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        standardGeneric(\"countPattern\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPattern\", \"character\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XString.matchPattern(pattern, subject,\n                              max.mismatch, min.mismatch, with.indels, fixed,\n                              algorithm,\n                              count.only=TRUE)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPattern\", \"XString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XString.matchPattern(pattern, subject,\n                              max.mismatch, min.mismatch, with.indels, fixed,\n                              algorithm,\n                              count.only=TRUE)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPattern\", \"XStringSet\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"please use vcountPattern() when 'subject' is an XStringSet object (multiple sequence)\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPattern\", \"XStringViews\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XStringViews.matchPattern(pattern, subject,\n                                   max.mismatch, min.mismatch, with.indels, fixed,\n                                   algorithm, count.only=TRUE)\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"countPattern\", \"MaskedXString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        countPattern(pattern, toXStringViewsOrXString(subject),\n                     max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                     with.indels=with.indels, fixed=fixed, algorithm=algorithm)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"vmatchPattern\" and \"vcountPattern\" generic and methods.\n###\n### These are vectorized versions of matchPattern() and countPattern().\n### vmatchPattern() returns an MIndex object and vcountPattern() an integer\n### vector (like matchPDict() and countPDict(), respectively).\n###\n\n.XStringSet.vmatchPattern <- function(pattern, subject,\n                                      max.mismatch, min.mismatch,\n                                      with.indels, fixed,\n                                      algorithm,\n                                      count.only=FALSE)\n{\n    if (!isTRUEorFALSE(count.only)) \n        stop(\"'count.only' must be TRUE or FALSE\")\n    if (!is(subject, \"XStringSet\"))\n        subject <- XStringSet(NULL, subject)\n    algo <- normargAlgorithm(algorithm)\n    if (isCharacterAlgo(algo)) \n        stop(\"'subject' must be a single (non-empty) string \", \n             \"for this algorithm\")\n    pattern <- normargPattern(pattern, subject)\n    max.mismatch <- normargMaxMismatch(max.mismatch)\n    min.mismatch <- normargMinMismatch(min.mismatch, max.mismatch)\n    with.indels <- normargWithIndels(with.indels)\n    fixed <- normargFixed(fixed, subject)\n    algo <- selectAlgo(algo, pattern, max.mismatch, min.mismatch,\n                       with.indels, fixed)\n    # because MIndex objects do not support variable-width matches yet\n    if (algo == \"indels\" && !count.only)\n        stop(\"vmatchPattern() does not support indels yet\")\n    C_ans <- .Call2(\"XStringSet_vmatch_pattern\", pattern, subject,\n                    max.mismatch, min.mismatch, with.indels, fixed, algo,\n                    ifelse(count.only, \"MATCHES_AS_COUNTS\", \"MATCHES_AS_ENDS\"),\n                    PACKAGE=\"Biostrings\")\n    if (count.only)\n        return(C_ans)\n    ans_width0 <- rep.int(length(pattern), length(subject))\n    new(\"ByPos_MIndex\", width0=ans_width0, NAMES=names(subject), ends=C_ans)\n}\n\nsetGeneric(\"vmatchPattern\", signature=\"subject\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", ...)\n        standardGeneric(\"vmatchPattern\")\n)\n\nsetMethod(\"vmatchPattern\", \"character\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XStringSet.vmatchPattern(pattern, subject,\n                                  max.mismatch, min.mismatch, with.indels, fixed,\n                                  algorithm)\n)\n\nsetMethod(\"vmatchPattern\", \"XString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"please use matchPattern() when 'subject' is an XString object (single sequence)\")\n)\n\nsetMethod(\"vmatchPattern\", \"XStringSet\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XStringSet.vmatchPattern(pattern, subject, \n                                  max.mismatch, min.mismatch, with.indels, fixed,\n                                  algorithm)\n)\n\n# TODO: Add a \"vmatchPattern\" method for XStringViews objects.\n# Note that the start/end of the matches need to be returned as relative\n# to subject(subject).\nsetMethod(\"vmatchPattern\", \"XStringViews\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"XStringViews objects are not supported yet, sorry\")\n)\n\nsetMethod(\"vmatchPattern\", \"MaskedXString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"please use matchPattern() when 'subject' is a MaskedXString object (single sequence)\")\n)\n\nsetGeneric(\"vcountPattern\", signature=\"subject\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\", ...)\n        standardGeneric(\"vcountPattern\")\n)\n\nsetMethod(\"vcountPattern\", \"character\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XStringSet.vmatchPattern(pattern, subject, \n                                  max.mismatch, min.mismatch, with.indels, fixed,\n                                  algorithm,\n                                  count.only=TRUE)\n)\n\nsetMethod(\"vcountPattern\", \"XString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"please use countPattern() when 'subject' is an XString object (single sequence)\")\n)\n\nsetMethod(\"vcountPattern\", \"XStringSet\",\n    function(pattern, subject,\n             max.mismatch=0L, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        .XStringSet.vmatchPattern(pattern, subject,\n                                  max.mismatch, min.mismatch, with.indels, fixed,\n                                  algorithm,\n                                  count.only=TRUE)\n)\n\nsetMethod(\"vcountPattern\", \"XStringViews\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        vcountPattern(pattern, fromXStringViewsToStringSet(subject),\n                      max.mismatch=max.mismatch, min.mismatch=min.mismatch,\n                      with.indels=with.indels, fixed=fixed,\n                      algorithm=algorithm)\n)\n\nsetMethod(\"vcountPattern\", \"MaskedXString\",\n    function(pattern, subject,\n             max.mismatch=0, min.mismatch=0, with.indels=FALSE, fixed=TRUE,\n             algorithm=\"auto\")\n        stop(\"please use countPattern() when 'subject' is a MaskedXString object (single sequence)\")\n)\n\n",
        "matchProbePair.R": "### =========================================================================\n### matchProbePair()\n### ----------------\n###\n### -------------------------------------------------------------------------\n\n\n# NOT USED, NOT EXPORTED\n# 'x' and 'y' must be numerics\n# Return the _list_ of all (x0, y0) pairs such that\n#   d(x0,y0) == min{d(xx,yy), xx in x, yy in y}\nclosestValues <- function(x, y)\n{\n    sux <- sort(unique(x))\n    suy <- sort(unique(y))\n    lsux <- length(sux)\n    lsuy <- length(suy)\n    x0 <- sux[1]\n    y0 <- suy[1]\n    d0 <- abs(x0 - y0)\n    i <- j <- 1\n    repeat {\n        if (sux[i] <= suy[j]) i <- i + 1 else j <- j + 1\n        if (i > lsux || j > lsuy)\n            break\n        xx <- sux[i]\n        yy <- suy[j]\n        d <- abs(xx - yy)\n        if (d < d0) {\n            x0 <- xx\n            y0 <- yy\n            d0 <- d\n        } else if (d == d0) {\n            x0 <- append(x0, xx)\n            y0 <- append(y0, yy)\n        }\n    }\n    ans <- list()\n    for (k in 1:length(x0))\n        ans[[k]] <- c(x0[k], y0[k])\n    ans\n}\n\nreduceProbePairMatches <- function(start, end)\n{\n    start <- sort(unique(start))\n    end <- sort(unique(end))\n    nstart <- length(start)\n    nend <- length(end)\n    i <- j <- 1\n    start0 <- end0 <- integer(0)\n    while (i <= nstart && j <= nend) {\n        if (end[j] < start[i]) {\n            j <- j + 1\n            next\n        }\n        while (i < nstart && start[i + 1] <= end[j])\n            i <- i + 1\n        start0 <- c(start0, start[i])\n        end0 <- c(end0, end[j])\n        i <- i + 1\n        j <- j + 1\n    }\n    data.frame(start=start0, end=end0)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"matchProbePair\" new generic.\n###\n### Simulates a PCR experiment by finding the \"theoretical amplicons\" mapped\n### to a given probe pair.\n###\n\nsetGeneric(\"matchProbePair\", signature=\"subject\",\n    function(Fprobe, Rprobe, subject, algorithm=\"auto\",\n             logfile=NULL, verbose=FALSE, ...)\n        standardGeneric(\"matchProbePair\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"matchProbePair\", \"DNAString\",\n    function(Fprobe, Rprobe, subject, algorithm=\"auto\",\n             logfile=NULL, verbose=FALSE, ...)\n    {\n        ## This won't copy the data if Fprobe and Rprobe are already DNAString objects\n        F <- DNAString(Fprobe)\n        R <- DNAString(Rprobe)\n\n        ## F and R hits on the + strand\n        Fp_hits <- start(matchPattern(F, subject, algorithm=algorithm, ...))\n        Rp_hits <- start(matchPattern(R, subject, algorithm=algorithm, ...))\n\n        ## F and R hits on the - strand\n        Fm_hits <- end(matchPattern(reverseComplement(F),\n                                    subject, algorithm=algorithm, ...))\n        Rm_hits <- end(matchPattern(reverseComplement(R),\n                                    subject, algorithm=algorithm, ...))\n\n        if (verbose) {\n            cat(\"Fp_hits:\", Fp_hits, \"  Rp_hits:\", Rp_hits,\n                \"  Fm_hits:\", Fm_hits, \"  Rm_hits:\", Rm_hits, \"\\n\")\n        }\n\n        matches0 <- reduceProbePairMatches(c(Fp_hits, Rp_hits), c(Fm_hits, Rm_hits))\n        ans <- Views(subject, start=matches0$start, end=matches0$end)\n\n        if (!is.null(logfile)) {\n            nFp <- length(Fp_hits)\n            nRp <- length(Rp_hits)\n            nFm <- length(Fm_hits)\n            nRm <- length(Rm_hits)\n            nmatches0 <- length(ans)\n            ## cat(\"\", ..., sep=\"\\t\") is a trick to get an extra tab\n            cat(\"\", nFp, nRp, nFm, nRm, nmatches0, file=logfile, sep=\"\\t\")\n        }\n        ans\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\n### WARNING: Unlike the other \"matchProbePair\" methods, the XStringViews object\n### returned by this method is not guaranteed to have its views ordered from\n### left to right in general! One important particular case where this is\n### guaranteed though is when 'isNormal(subject)' is TRUE (i.e. 'subject' is\n### a normal XStringViews object).\nsetMethod(\"matchProbePair\", \"XStringViews\",\n    function(Fprobe, Rprobe, subject, algorithm=\"auto\", logfile=NULL, verbose=FALSE, ...)\n    {\n        ans_start <- ans_width <- integer(0)\n        for (i in seq_len(length(subject))) {\n            pm <- matchProbePair(Fprobe, Rprobe, subject[[i]],\n                                 algorithm=algorithm, logfile=logfile, verbose=verbose, ...)\n            offset <- start(subject)[i] - 1L\n            ans_start <- c(ans_start, offset + start(pm))\n            ans_width <- c(ans_width, width(pm))\n        }\n        unsafe.newXStringViews(subject(subject), ans_start, ans_width)\n    }\n)\n\nsetMethod(\"matchProbePair\", \"MaskedDNAString\",\n    function(Fprobe, Rprobe, subject, algorithm=\"auto\", logfile=NULL, verbose=FALSE, ...)\n        matchProbePair(Fprobe, Rprobe, toXStringViewsOrXString(subject),\n                       algorithm=algorithm, logfile=logfile, verbose=verbose, ...)\n)\n\n",
        "matchprobes.R": "matchprobes <- function(query, records, probepos=FALSE) {\n  msg <- \"matchprobes() is deprecated. Please use matchPdict() instead.\"\n  .Deprecated(msg=msg)\n  .Call2(\"MP_matchprobes\", toupper(query), toupper(records), probepos, PACKAGE=\"Biostrings\")\n}\n\nlongestConsecutive <- function(seq, letter) {\n  .Call2(\"MP_longestConsecutive\", seq, letter, PACKAGE=\"Biostrings\")\n}\n\n",
        "misc.R": "### Some miscellaneous stuff\n\nN50 <- function(csizes)\n{\n    if (!is.numeric(csizes))\n        stop(\"'csizes' must be a vector containing the contig sizes\")\n    #If only integer, then genome size maxes out at 2.1Gbp, so coerce to double:\n    if(is.integer(csizes))\n        csizes <- as.numeric(csizes)\n    decreasing_csizes <- sort(csizes, decreasing=TRUE)\n    tmp <- cumsum(decreasing_csizes)\n    total_size <- tmp[length(tmp)]\n    N50 <- decreasing_csizes[which(tmp >= total_size/2)[1]]\n    return(N50)\n}\n\n",
        "moved_to_pwalign.R": "### Everything in this file has moved to the pwalign package\n\n\n### TODO: Move this to S4Vectors (or BiocBaseUtils).\n.load_package_gracefully <- function(package, ...)\n{\n    if (!requireNamespace(package, quietly=TRUE))\n        stop(\"Could not load package \", package, \". Is it installed?\\n\\n  \",\n             wmsg(\"Note that \", ..., \" requires the \", package, \" package. \",\n                  \"Please install it with:\"),\n             \"\\n\\n    BiocManager::install(\\\"\", package, \"\\\")\")\n}\n\n.call_fun_in_pwalign <- function(fun, ...)\n{\n    .load_package_gracefully(\"pwalign\", \"starting with BioC 3.19, \",\n                             \"calling \", fun, \"()\")\n    msg <- c(fun, \"() has moved from Biostrings to the pwalign package, \",\n             \"and is formally deprecated in Biostrings >= 2.75.1. \",\n             \"Please call pwalign::\", fun, \"() to get rid of this warning.\")\n    .Deprecated(msg=wmsg(msg))\n    FUN <- base::get(fun, envir=asNamespace(\"pwalign\"), inherits=FALSE)\n    do.call(FUN, list(...))\n}\n\nwritePairwiseAlignments <-\n    function(...) .call_fun_in_pwalign(\"writePairwiseAlignments\", ...)\n\nnucleotideSubstitutionMatrix <-\n    function(...) .call_fun_in_pwalign(\"nucleotideSubstitutionMatrix\", ...)\n\nerrorSubstitutionMatrices <-\n    function(...) .call_fun_in_pwalign(\"errorSubstitutionMatrices\", ...)\n\nqualitySubstitutionMatrices <-\n    function(...) .call_fun_in_pwalign(\"qualitySubstitutionMatrices\", ...)\n\ninsertion <-\n    function(...) .call_fun_in_pwalign(\"insertion\", ...)\n\ndeletion <-\n    function(...) .call_fun_in_pwalign(\"deletion\", ...)\n\nunaligned <-\n    function(...) .call_fun_in_pwalign(\"unaligned\", ...)\n\naligned <-\n    function(...) .call_fun_in_pwalign(\"aligned\", ...)\n\nindel <-\n    function(...) .call_fun_in_pwalign(\"indel\", ...)\n\nnindel <-\n    function(...) .call_fun_in_pwalign(\"nindel\", ...)\n\nPairwiseAlignments <-\n    function(...) .call_fun_in_pwalign(\"PairwiseAlignments\", ...)\n\npattern <-\n    function(...) .call_fun_in_pwalign(\"pattern\", ...)\n\nalignedPattern <-\n    function(...) .call_fun_in_pwalign(\"alignedPattern\", ...)\n\nalignedSubject <-\n    function(...) .call_fun_in_pwalign(\"alignedSubject\", ...)\n\nPairwiseAlignmentsSingleSubject <-\n    function(...) .call_fun_in_pwalign(\"PairwiseAlignmentsSingleSubject\", ...)\n\nnedit <-\n    function(...) .call_fun_in_pwalign(\"nedit\", ...)\n\nmismatchTable <-\n    function(...) .call_fun_in_pwalign(\"mismatchTable\", ...)\n\nmismatchSummary <-\n    function(...) .call_fun_in_pwalign(\"mismatchSummary\", ...)\n\ncompareStrings <-\n    function(...) .call_fun_in_pwalign(\"compareStrings\", ...)\n\npid <-\n    function(...) .call_fun_in_pwalign(\"pid\", ...)\n\npairwiseAlignment <-\n    function(...) .call_fun_in_pwalign(\"pairwiseAlignment\", ...)\n\nstringDist <-\n    function(...) .call_fun_in_pwalign(\"stringDist\", ...)\n\nprint.moved_to_pwalign_pkg <- function(x, ...)\n    warning(wmsg(\"all the BLOSUM* and PAM* scoring matrices are now located \",\n                 \"in the pwalign package and will soon be removed from the \",\n                 \"Biostrings package\"))\n\n",
        "needwunsQS.R": "### =========================================================================\n### The needwunsQS() generic & related functions\n### -------------------------------------------------------------------------\n\n\nneedwunsQS <- function(s1, s2, substmat, gappen=8) .Defunct(\"pairwiseAlignment\")\n\n",
        "padAndClip.R": "### =========================================================================\n### padAndClip() and stackStrings()\n### -------------------------------------------------------------------------\n\n\n### Return an XString object of length 1.\n.normarg_padding.letter <- function(padding.letter, seqtype, what)\n{\n    if (seqtype != \"B\" && identical(padding.letter, \" \"))\n        stop(\"'\", what, \"' must be supplied if 'x' is not \",\n             \"a BStringSet object\")\n    class <- paste0(seqtype, \"String\")\n    if (isSingleString(padding.letter) && nchar(padding.letter) == 1L)\n        return(as(padding.letter, class))\n    if (is(padding.letter, \"XString\") && length(padding.letter) == 1L)\n        return(as(padding.letter, class))\n    if (is(padding.letter, \"XStringSet\") &&\n        length(padding.letter) == 1L && width(padding.letter) == 1L)\n        return(as(padding.letter[[1L]], class))\n    stop(\"'\", what, \"' must be a single letter\")\n}\n\n### 'filler_width' must be an integer vector, and 'letter' an XString object\n### of length 1.\n.make_sequence_fillers_from_widths <- function(filler_width, letter)\n{\n    if (length(filler_width) == 0L) {\n        max_width <- 0L\n        at <- IRanges()\n    } else {\n        max_width <- max(filler_width)\n        at <- IRanges(1L, filler_width)\n    }\n    biggest_filler <- rep.int(letter, max_width)\n    extractAt(biggest_filler, at)\n}\n\npadAndClip <- function(x, views, Lpadding.letter=\" \", Rpadding.letter=\" \",\n                       remove.out.of.view.strings=FALSE)\n{\n    if (!is(x, \"XStringSet\"))\n        stop(\"'x' must be an XStringSet object\")\n    x_width <- width(x)\n    x_names <- names(x)\n    x_mcols <- mcols(x)\n\n    if (!is(views, \"IntegerRanges\"))\n        stop(\"'views' must be an IntegerRanges object\")\n    ## .V_recycle() is currently defined in replaceAt.R but it needs to move\n    ## to a place more appropriate for sharing (see TODO note in replaceAt.R).\n    views_start <- .V_recycle(start(views), x, \"views\", \"'length(x)'\")\n    ## We don't want to generate the same warning twice.    \n    views_width <- suppressWarnings(.V_recycle(width(views), x,\n                                               \"views\", \"'length(x)'\"))\n\n    x_seqtype <- seqtype(x)\n    Lpadding.letter <- .normarg_padding.letter(Lpadding.letter, x_seqtype,\n                                               \"Lpadding.letter\")\n    Rpadding.letter <- .normarg_padding.letter(Rpadding.letter, x_seqtype,\n                                               \"Rpadding.letter\")\n\n    if (!isTRUEorFALSE(remove.out.of.view.strings))\n        stop(\"'remove.out.of.view.strings' must be TRUE or FALSE\")\n\n    ## Left and right margins.\n    Lmargin <- 1L - views_start\n    Rmargin <- views_width - x_width - Lmargin\n\n    ## Clip. Eventhough padAndClip() conceptually pads first (with an\n    ## infinite number of padding letters on the left and right) and then\n    ## clips, in practice we clip first and then pad.\n    Lclipping <- pmin(pmax(-Lmargin, 0L), x_width)\n    Rclipping <- pmin(pmax(-Rmargin, 0L), x_width)\n    clipped_x <- narrow(x, start=1L+Lclipping, end=x_width-Rclipping,\n                           use.names=FALSE)\n\n    ## Left and right padding.\n    Lpad_width <- pmin(pmax(Lmargin, 0L), views_width)\n    Rpad_width <- pmin(pmax(Rmargin, 0L), views_width)\n\n    if (remove.out.of.view.strings) {\n        idx <- which(Lpad_width == views_width | Rpad_width == views_width)\n        if (length(idx) != 0L) {\n            idx <- -idx\n            x_names <- x_names[idx]\n            x_mcols <- x_mcols[idx]\n            clipped_x <- clipped_x[idx]\n            Lpad_width <- Lpad_width[idx]\n            Rpad_width <- Rpad_width[idx]\n        }\n    }\n\n    Lpad <- .make_sequence_fillers_from_widths(Lpad_width, Lpadding.letter)\n    Rpad <- .make_sequence_fillers_from_widths(Rpad_width, Rpadding.letter)\n    ans <- xscat(Lpad, clipped_x, Rpad)\n\n    names(ans) <- x_names\n    mcols(ans) <- x_mcols\n    ans\n}\n\n### Convenience wrapper to padAndClip(). Returned object is always rectangular\n### (i.e. constant-width).\nstackStrings <- function(x, from, to, shift=0L,\n                         Lpadding.letter=\" \", Rpadding.letter=\" \",\n                         remove.out.of.view.strings=FALSE)\n{\n    if (!is(x, \"XStringSet\"))\n        stop(\"'x' must be an XStringSet object\")\n\n    ## Normalize 'from'.\n    if (!isSingleNumber(from))\n        stop(\"'from' must be a single integer\")\n    if (!is.integer(from))\n        from <- as.integer(from)\n\n    ## Normalize 'to'.\n    if (!isSingleNumber(to))\n        stop(\"'to' must be a single integer\")\n    if (!is.integer(to))\n        to <- as.integer(to)\n    if (to < from - 1L)\n        stop(\"'to' must be >= 'from - 1L'\")\n\n    ## Normalize 'shift'.\n    if (!is.numeric(shift))\n        stop(\"'shift' must be a vector of integers\")\n    if (!is.integer(shift)) \n        shift <- as.integer(shift)\n    ## .V_recycle() is currently defined in replaceAt.R but it needs to move\n    ## to a place more appropriate for sharing (see TODO note in replaceAt.R).\n    shift <- .V_recycle(shift, x, \"shift\", \"'length(x)'\")\n\n    views <- IRanges(from - shift, to - shift)\n    padAndClip(x, views,\n               Lpadding.letter=Lpadding.letter,\n               Rpadding.letter=Rpadding.letter,\n               remove.out.of.view.strings=remove.out.of.view.strings)\n}\n\n",
        "pmatchPattern.R": "### =========================================================================\n### The \"pmatchPattern\" generic\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Longest Common Prefix: the \"lcprefix\" new generic\n###\n\n### 's1' and 's2' must be XString objects containing sequences of the same\n### type. Return the length (integer) of the Longest Common Prefix.\nXString.lcprefix <- function(s1, s2)\n{\n    .Call2(\"lcprefix\", s1@shared@xp, s1@offset, s1@length,\n                      s2@shared@xp, s2@offset, s2@length,\n                      PACKAGE=\"Biostrings\")\n}\n\nsetGeneric(\"lcprefix\", signature=c(\"s1\", \"s2\"),\n    function(s1, s2) standardGeneric(\"lcprefix\")\n)\nsetMethod(\"lcprefix\", signature(s1=\"character\", s2=\"character\"),\n    function(s1, s2)\n        XString.lcprefix(BString(s1), BString(s2))\n)\nsetMethod(\"lcprefix\", signature(s1=\"character\", s2=\"XString\"),\n    function(s1, s2)\n        XString.lcprefix(XString(seqtype(s2), s1), s2)\n)\nsetMethod(\"lcprefix\", signature(s1=\"XString\", s2=\"character\"),\n    function(s1, s2)\n        XString.lcprefix(s1, XString(seqtype(s1), s2))\n)\nsetMethod(\"lcprefix\", signature(s1=\"XString\", s2=\"XString\"),\n    function(s1, s2)\n    {\n        if (seqtype(s1) != seqtype(s2))\n            stop(\"'s1' and 's2' must be XString objects containing \",\n                 \"sequences of the same type\")\n        XString.lcprefix(s1, s2)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Longest Common Suffix: the \"lcsuffix\" new generic\n###\n\n### 's1' and 's2' must be XString objects containing sequences of the same\n### type. Return the length (integer) of the Longest Common Suffix.\nXString.lcsuffix <- function(s1, s2)\n{\n    .Call2(\"lcsuffix\", s1@shared@xp, s1@offset, s1@length,\n                      s2@shared@xp, s2@offset, s2@length,\n                      PACKAGE=\"Biostrings\")\n}\n\nsetGeneric(\"lcsuffix\", signature=c(\"s1\", \"s2\"),\n    function(s1, s2) standardGeneric(\"lcsuffix\")\n)\nsetMethod(\"lcsuffix\", signature(s1=\"character\", s2=\"character\"),\n    function(s1, s2)\n        XString.lcsuffix(BString(s1), BString(s2))\n)\nsetMethod(\"lcsuffix\", signature(s1=\"character\", s2=\"XString\"),\n    function(s1, s2)\n        XString.lcsuffix(XString(seqtype(s2), s1), s2)\n)\nsetMethod(\"lcsuffix\", signature(s1=\"XString\", s2=\"character\"),\n    function(s1, s2)\n        XString.lcsuffix(s1, XString(seqtype(s1), s2))\n)\nsetMethod(\"lcsuffix\", signature(s1=\"XString\", s2=\"XString\"),\n    function(s1, s2)\n    {\n        if (seqtype(s1) != seqtype(s2))\n            stop(\"'s1' and 's2' must be XString objects containing \",\n                 \"sequences of the same type\")\n        XString.lcsuffix(s1, s2)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"pmatchPattern\" generic\n###\n\n### 'subject' must be an XString object.\n### Return an XStringPartialMatches object.\n### Speed (on my Thinkpad):\n###   > library(BSgenome.Scerevisiae.UCSC.sacCer1)\n###   > Scerevisiae$chr1\n###   > file <- system.file(\"extdata\", \"someORF.fa\", package=\"Biostrings\")\n###   > orf <- readDNAStringSet(file)\n###   > system.time(pmatchPattern(orf[[2]], Scerevisiae$chr1, max=1))\n###      user  system elapsed\n###     0.900   0.012   0.913\n###   > system.time(pmatchPattern(orf[[2]], Scerevisiae$chr1, max=6))\n###      user  system elapsed\n###   102.910   2.460 105.689\n.pmatchPattern.rec <- function(pattern, subject, maxlength.out)\n{\n    pattern <- normargPattern(pattern, subject)\n    if (nchar(pattern) <= 20000) {\n        sv <- matchPattern(pattern, subject)\n        if (length(sv) >= maxlength.out || nchar(pattern) < 2L) {\n            pv <- unsafe.newXStringViews(pattern,\n                                         rep.int(1L, length(sv)),\n                                         rep.int(nchar(pattern), length(sv)))\n            ans <- new(\"XStringPartialMatches\", sv, subpatterns=pv)\n            return(ans)\n        }\n    }\n    ## Split 'pattern' in 2 parts\n    Lnc <- nchar(pattern) %/% 2L\n    Lpattern <- subseq(pattern, start=1L, end=Lnc)\n    Rpattern <- subseq(pattern, start=Lnc+1L, end=nchar(pattern))\n    ## Recursive call on the left part\n    Lpm <- .pmatchPattern.rec(Lpattern, subject, maxlength.out)\n    Lpm_start <- start(Lpm)\n    Lpm_end <- end(Lpm)\n    Lpv <- subpatterns(Lpm)\n    Lpv_end <- end(Lpv)\n    Lindex <- which((Lpv_end == nchar(Lpattern)) & (Lpm_end < nchar(subject)))\n    Loverlapping <- integer(0)\n    for (i in Lindex) {\n        overlap <- XString.lcprefix(Rpattern, subseq(subject, start=Lpm_end[i]+1L, end=nchar(subject)))\n        if (overlap == 0L)\n            next\n        Loverlapping <- c(Loverlapping, i)\n        Lpv_end[i] <- Lpv_end[i] + overlap\n        Lpm_end[i] <- Lpm_end[i] + overlap\n    }\n    Lpv_start <- start(Lpv)\n    ## Recursive call on the right part\n    Rpm <- .pmatchPattern.rec(Rpattern, subject, maxlength.out)\n    Rpm_start <- start(Rpm)\n    Rpm_end <- end(Rpm)\n    Rpv <- subpatterns(Rpm)\n    Rpv_start <- start(Rpv)\n    Rindex <- which((Rpv_start == 1L) & (Rpm_start > 1L))\n    Roverlapping <- integer(0)\n    for (i in Rindex) {\n        overlap <- XString.lcsuffix(Lpattern, subseq(subject, start=1L, end=Rpm_start[i]-1L))\n        if (overlap == 0L)\n            next\n        Roverlapping <- c(Roverlapping, i)\n        Rpv_start[i] <- Rpv_start[i] - overlap\n        Rpm_start[i] <- Rpm_start[i] - overlap\n    }\n    Rpv_start <- Rpv_start + Lnc\n    Rpv_end <- end(Rpv) + Lnc\n    ## Remove duplicates (using a data frame might not be the most efficient\n    ## way to achieve this)\n    if (length(Loverlapping) != 0 && length(Roverlapping) != 0)\n    {\n        Loverlaps <- data.frame(start=Lpm_start[Loverlapping],\n                                end=Lpm_end[Loverlapping],\n                                spstart=Lpv_start[Loverlapping],\n                                spend=Lpv_end[Loverlapping])\n        Roverlaps <- data.frame(start=Rpm_start[Roverlapping],\n                                end=Rpm_end[Roverlapping],\n                                spstart=Rpv_start[Roverlapping],\n                                spend=Rpv_end[Roverlapping])\n        overlaps <- rbind(Loverlaps, Roverlaps)\n        dup <- duplicated(overlaps)\n        if (any(dup)) {\n            which_dup <- Roverlapping[which(dup) - nrow(Loverlaps)]\n            Rpm_start <- Rpm_start[-which_dup]\n            Rpm_end <- Rpm_end[-which_dup]\n            Rpv_start <- Rpv_start[-which_dup]\n            Rpv_end <- Rpv_end[-which_dup]\n        }\n    }\n    ## Merge left results with right results\n    sv_start <- c(Lpm_start, Rpm_start)\n    sv_width <- c(Lpm_end, Rpm_end) - sv_start + 1L\n    sv <- unsafe.newXStringViews(subject, sv_start, sv_width)\n    pv_start <- c(Lpv_start, Rpv_start)\n    pv_width <- c(Lpv_end, Rpv_end) - pv_start + 1L\n    pv <- unsafe.newXStringViews(pattern, pv_start, pv_width)\n    ans <- new(\"XStringPartialMatches\", sv, subpatterns=pv)\n    ii <- order(width(ans), -start(ans), decreasing=TRUE)\n    minwidth <- width(ans)[ii[1]] %/% 2\n    ii <- ii[(width(ans)[ii] >= minwidth) | (seq_along(ii) <= maxlength.out)]\n    ans[ii]\n}\n\n### 'subject' must be an XString object.\n### Return an XStringPartialMatches object.\n.pmatchPattern <- function(pattern, subject, maxlength.out)\n{\n    ans <- .pmatchPattern.rec(pattern, subject, maxlength.out)\n    if (length(ans) > maxlength.out)\n        ans <- ans[seq_len(maxlength.out)]\n    ans\n}\n\nsetGeneric(\"pmatchPattern\", signature=\"subject\",\n    function(pattern, subject, maxlength.out=1L)\n        standardGeneric(\"pmatchPattern\")\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"pmatchPattern\", \"character\",\n    function(pattern, subject, maxlength.out)\n    {\n        .pmatchPattern(pattern, BString(subject), maxlength.out)\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"pmatchPattern\", \"XString\",\n    function(pattern, subject, maxlength.out)\n    {\n        .pmatchPattern(pattern, subject, maxlength.out)\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"pmatchPattern\", \"XStringViews\",\n    function(pattern, subject, maxlength.out)\n    {\n        if (length(subject) != 1)\n            stop(\"'subject' must have a single view\")\n        .pmatchPattern(pattern, subject[[1]], maxlength.out)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Longest Common Substring: the \"lcsubstr\" new generic\n###\n\n### 's1' and 's2' must be XString objects containing sequences of the same\n### type. Implementation taken from \n###   http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring\nXString.lcsubstr <- function(s1, s2)\n{\n    stop(\"coming soon...\")\n}\n\nsetGeneric(\"lcsubstr\", signature=c(\"s1\", \"s2\"),\n    function(s1, s2) standardGeneric(\"lcsubstr\")\n)\nsetMethod(\"lcsubstr\", signature(s1=\"character\", s2=\"character\"),\n    function(s1, s2)\n        XString.lcsubstr(BString(s1), BString(s2))\n)\nsetMethod(\"lcsubstr\", signature(s1=\"character\", s2=\"XString\"),\n    function(s1, s2)\n        XString.lcsubstr(XString(seqtype(s2), s1), s2)\n)\nsetMethod(\"lcsubstr\", signature(s1=\"XString\", s2=\"character\"),\n    function(s1, s2)\n        XString.lcsubstr(s1, XString(seqtype(s1), s2))\n)\nsetMethod(\"lcsubstr\", signature(s1=\"XString\", s2=\"XString\"),\n    function(s1, s2)\n    {\n        if (seqtype(s1) != seqtype(s2))\n            stop(\"'s1' and 's2' must be XString objects containing \",\n                 \"sequences of the same type\")\n        XString.lcsubstr(s1, s2)\n    }\n)\n\n",
        "replaceAt.R": "### =========================================================================\n### extractAt() & replaceAt()\n### -------------------------------------------------------------------------\n\n\n### Extracts multiple subsequences from XString object 'x', or from the\n### sequences of XStringSet object 'x', at the ranges of positions specified\n### thru 'at'.\nsetGeneric(\"extractAt\", signature=\"x\",\n    function(x, at) standardGeneric(\"extractAt\")\n)\n\n### Performs multiple subsequence replacements (a.k.a. substitutions) in\n### XString object 'x', or in the sequences of XStringSet object 'x', at the\n### ranges of positions specified thru 'at'.\nsetGeneric(\"replaceAt\", signature=\"x\",\n    function(x, at, value=\"\") standardGeneric(\"replaceAt\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions for checking that the ranges in an IntegerRanges or\n### IntegerRangesList object are within specified limits.\n###\n\n### Checks that the ranges in 'at' are within the limits specified by single\n### integer values 'min_start' and 'max_end'.\n.is_within_limits1 <- function(at, min_start, max_end)\n{\n    stopifnot(is(at, \"IntegerRanges\"))\n    stopifnot(isSingleInteger(min_start))\n    stopifnot(isSingleInteger(max_end))\n\n    at_len <- length(at)\n    if (at_len == 0L)\n        return(TRUE)\n    at_min_start <- min(start(at))\n    at_max_end <- max(end(at))\n    at_min_start >= min_start && at_max_end <= max_end\n}\n\n### For all valid 'i', checks that the ranges in 'at[[i]]' are within the\n### limits specified by 'limits[i]'.\n.is_within_limits2 <- function(at, limits)\n{\n    stopifnot(is(at, \"IntegerRangesList\"))\n    stopifnot(is(limits, \"IntegerRanges\"))\n    stopifnot(length(at) == length(limits))\n\n    unlisted_at <- unlist(at, use.names=FALSE)\n    tmp <- rep.int(limits, elementNROWS(at))\n    min_starts <- start(tmp)\n    max_ends <- end(tmp)\n    all(start(unlisted_at) >= min_starts) && all(end(unlisted_at) <= max_ends)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions for \"vertical\" and \"horizontal\" recycling.\n###\n### TODO: This stuff is very generic. Move it to IRanges so it can be shared\n### and re-used across the IRanges/GenomicRanges/XVector/Biostrings\n### infrastructure.\n###\n\n.wrap_msg <- function(...)\n    paste0(strwrap(paste0(...)), collapse=\"\\n  \")\n\n### Vertical recycling (of any vector-like object).\n.V_recycle <- function(x, skeleton, x_what, skeleton_what)\n{\n    x_len <- length(x)\n    skeleton_len <- length(skeleton)\n    if (x_len == skeleton_len)\n        return(x)\n    if (x_len > skeleton_len && x_len != 1L)\n        stop(.wrap_msg(\n            \"'\", x_what, \"' cannot be longer than \", skeleton_what\n        ))\n    if (x_len == 0L)\n        stop(.wrap_msg(\n            \"'\", x_what, \"' is a zero-length object but \", skeleton_what,\n            \" is not zero\"\n        ))\n    if (skeleton_len %% x_len != 0L)\n        warning(.wrap_msg(\n            skeleton_what, \" is not a multiple of 'length(\", x_what, \")'\"\n        ))\n    rep(x, length.out=skeleton_len)\n}\n\n### Horizontal recycling (of a list-like object only).\n.H_recycle <- function(x, skeleton, x_what, skeleton_what, more_blahblah=NA)\n{\n    ## TODO: Remove this when utils::relist() is fixed.\n    ## See https://stat.ethz.ch/pipermail/r-devel/2013-June/066780.html for\n    ## the original bug report.\n    if (is.list(skeleton))\n        stop(.wrap_msg(\n            \"because of a bug in utils::relist(), 'skeleton' cannot be \",\n            \"a list at the moment. Please use a List object instead \",\n            \"(e.g. by passing 'as(skeleton, \\\"List\\\")' instead of 'skeleton').\"\n        ))\n\n    stopifnot(is.list(x) || is(x, \"List\"))\n    stopifnot(is.list(skeleton) || is(skeleton, \"List\"))\n    x_len <- length(x)\n    skeleton_len <- length(skeleton)\n    stopifnot(x_len == skeleton_len)\n\n    x_what2 <- paste0(\"some list elements in '\", x_what, \"'\")\n    if (!is.na(more_blahblah))\n        x_what2 <- paste0(x_what2, \" (\", more_blahblah, \")\")\n\n    x_eltNROWS <- unname(elementNROWS(x))\n    skeleton_eltNROWS <- unname(elementNROWS(skeleton))\n    idx <- which(x_eltNROWS != skeleton_eltNROWS)\n    if (length(idx) == 0L)\n        return(x)\n\n    longer_idx <- which(x_eltNROWS > skeleton_eltNROWS)\n    shorter_idx <- which(x_eltNROWS < skeleton_eltNROWS)\n    if (length(longer_idx) == 0L && length(shorter_idx) == 0L)\n        return(x)\n    if (length(longer_idx) != 0L) {\n        if (max(x_eltNROWS[longer_idx]) >= 2L)\n            stop(.wrap_msg(\n                x_what2, \" are longer than their corresponding \",\n                \"list element in '\", skeleton_what, \"'\"\n            ))\n    }\n    if (length(shorter_idx) != 0L) {\n        tmp <- x_eltNROWS[shorter_idx]\n        if (min(tmp) == 0L)\n            stop(.wrap_msg(\n                x_what2, \" are of length 0, but their corresponding \",\n                \"list element in '\", skeleton_what, \"' is not\"\n            ))\n        if (max(tmp) >= 2L)\n            stop(.wrap_msg(\n                x_what2, \" are shorter than their corresponding \",\n                \"list element in '\", skeleton_what, \"', but have \",\n                \"a length >= 2. \\\"Horizontal\\\" recycling only supports \",\n                \"list elements of length 1 at the moment.\"\n            ))\n    }\n\n    ## From here 'x[idx]' is guaranteed to contain list elements of length 1.\n\n    ## We use an \"unlist => stretch => relist\" algo to perform the horizontal\n    ## recycling. Because of this, the returned value is not necessary of the\n    ## same class as 'x' (e.g. can be an IntegerList if 'x' is an ordinary\n    ## list of integers and 'skeleton' a List object).\n    unlisted_x <- unlist(x, use.names=FALSE)\n    times <- rep.int(1L, length(unlisted_x))\n    idx2 <- cumsum(x_eltNROWS)[idx]\n    times[idx2] <- skeleton_eltNROWS[idx]\n    unlisted_ans <- rep.int(unlisted_x, times)\n    ans <- relist(unlisted_ans, skeleton)\n    names(ans) <- names(x)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions for normalizing the 'at' argument.\n###\n\n### The integers in 'at' are interpreted as the start positions of zero-width\n### ranges.\n.make_IRanges_from_numeric <- function(at) IRanges(at, width=0L)\n\n.make_CompressedIRangesList_from_IntegerList <- function(at)\n{\n    relist(.make_IRanges_from_numeric(unlist(at, use.names=FALSE)), at)\n}\n\n.make_IRanges_from_at <- function(at)\n{\n    if (is.numeric(at))\n        at <- .make_IRanges_from_numeric(at)\n    if (!is(at, \"IntegerRanges\"))\n        stop(.wrap_msg(\n            \"'at' must be an IntegerRanges object (or a numeric vector \",\n            \"containing the start positions of zero-width ranges)\"\n        ))\n    as(at, \"IRanges\", strict=FALSE)\n}\n\n.make_CompressedIRangesList_from_at <- function(at)\n{\n    if (is.numeric(at))\n        at <- .make_IRanges_from_numeric(at)\n    if (is(at, \"IntegerRanges\"))\n        at <- IRangesList(at)\n    if (is.list(at))\n        at <- IntegerList(at)\n    if (is(at, \"IntegerList\"))\n        at <- .make_CompressedIRangesList_from_IntegerList(at)\n    if (!is(at, \"IntegerRangesList\"))\n        stop(.wrap_msg(\n            \"'at' must be an IntegerRangesList object (or an IntegerList \",\n            \"object or a list of numeric vectors, containing the start \",\n            \"positions of zero-width ranges). \",\n            \"Also it can be an IntegerRanges object (or a numeric vector \",\n            \"containing the start positions of zero-width ranges) and in \",\n            \"that case is interpreted as a IntegerRangesList object of \",\n            \"length 1.\"\n        ))\n    as(at, \"CompressedIRangesList\", strict=FALSE)\n}\n\n.normarg_at1 <- function(at, x)\n{\n    at <- .make_IRanges_from_at(at)\n    if (!.is_within_limits1(at, 1L, length(x)))\n        stop(\"some ranges in 'at' are off-limits with respect to sequence 'x'\")\n    at\n}\n\n### Returns an IntegerRangesList object of the same length as 'x'.\n.normarg_at2 <- function(at, x)\n{\n    at <- .make_CompressedIRangesList_from_at(at)\n    if (!is.null(names(at))) {\n        names(at) <- NULL\n        warning(\"'at' names were ignored\")\n    }\n    at <- .V_recycle(at, x, \"at\", \"'length(x)'\")\n    if (!.is_within_limits2(at, IRanges(1L, width(x))))\n        stop(.wrap_msg(\n            \"some ranges in 'at' are off-limits with respect to \",\n            \"their corresponding sequence in 'x'\"\n        ))\n    at\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions for normalizing the 'value' argument.\n###\n\n.make_XStringSet_from_value <- function(value, x_seqtype)\n{\n    if (!is(value, \"XStringSet\")) {\n        value_class <- paste0(x_seqtype, \"StringSet\")\n        value <- try(as(value, value_class), silent=TRUE)\n        if (is(value, \"try-error\"))\n            stop(\"failed to coerce 'value' to a \", value_class, \" object\")\n    } else if (seqtype(value) != x_seqtype) {\n        seqtype(value) <- x_seqtype\n    }\n    value\n}\n\n.make_XStringSetList_from_value <- function(value, x_seqtype)\n{\n    if (is.character(value)) {\n        value_class <- paste0(x_seqtype, \"StringSet\")\n        value <- as(value, value_class)\n    }\n    if (is(value, \"XStringSet\"))\n        value <- relist(value, list(seq_along(value)))\n    if (is.list(value))\n        value <- CharacterList(value)\n    if (is(value, \"CharacterList\")) {\n        unlisted_value <- unlist(value, use.names=FALSE)\n        unlisted_value <- .make_XStringSet_from_value(unlisted_value, x_seqtype)\n        value <- relist(unlisted_value, value)\n    }\n    if (!is(value, \"XStringSetList\"))\n        stop(\"invalid type of 'value'\")\n    if (seqtype(value) != x_seqtype)\n        seqtype(value) <- x_seqtype\n    value\n}\n\n.normarg_value1 <- function(value, at, x_seqtype)\n{\n    value <- .make_XStringSet_from_value(value, x_seqtype)\n    .V_recycle(value, at, \"value\", \"the number of replacements\")\n}\n\n### 'at' is assumed to be normalized so it has the length of 'x'.\n.normarg_value2 <- function(value, at, x_seqtype)\n{\n    value <- .make_XStringSetList_from_value(value, x_seqtype)\n    value <- .V_recycle(value, at, \"value\", \"'length(x)'\")\n    .H_recycle(value, at, \"value\", \"at\",\n        \"after recycling of 'at' and 'value' to the length of 'x'\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extractAt()\n###\n\nsetMethod(\"extractAt\", \"XString\",\n    function(x, at)\n    {\n        at <- .make_IRanges_from_at(at)\n        ## extractList() will check that all the ranges in 'at' are within\n        ## the limits of sequence 'x'.\n        extractList(x, at)\n    }\n)\n\nsetMethod(\"extractAt\", \"XStringSet\",\n    function(x, at)\n    {\n        at <- .normarg_at2(at, x)\n        at_eltNROWS <- elementNROWS(at)\n        x2 <- rep.int(unname(x), at_eltNROWS)\n        unlisted_at <- unlist(at, use.names=FALSE)\n        unlisted_ans <- subseq(x2, start=start(unlisted_at),\n                                   width=width(unlisted_at))\n        names(unlisted_ans) <- names(unlisted_at)\n        ans <- relist(unlisted_ans, at)\n        names(ans) <- names(x)\n        ans\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### replaceAt()\n###\n\nsetMethod(\"replaceAt\", \"XString\",\n    function(x, at, value=\"\")\n    {\n        if (length(at) == 0L && length(value) == 0L)\n            return(x)\n        at <- .normarg_at1(at, x)\n        value <- .normarg_value1(value, at, seqtype(x))\n        NR <- length(at)  # same as length(value) -- nb of replacements\n        if (NR == 0L)\n            return(x)\n        .Call2(\"XString_replaceAt\", x, at, value,\n               PACKAGE=\"Biostrings\")\n    }\n)\n\nsetMethod(\"replaceAt\", \"XStringSet\",\n    function(x, at, value=\"\")\n    {\n        if (length(at) == 0L && length(value) == 0L)\n            return(x)\n        at <- .normarg_at2(at, x)\n        value <- .normarg_value2(value, at, seqtype(x))\n        ans <- .Call2(\"XStringSet_replaceAt\", x, at, value,\n                      PACKAGE=\"Biostrings\")\n        names(ans) <- names(x)\n        mcols(ans) <- mcols(x)\n        ans\n    }\n)\n",
        "replaceLetterAt.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"replaceLetterAt\" generic function and methods.\n###\n\nsetGeneric(\"replaceLetterAt\", signature=\"x\",\n    function(x, at, letter, if.not.extending=\"replace\", verbose=FALSE)\n        standardGeneric(\"replaceLetterAt\")\n)\n\nsetMethod(\"replaceLetterAt\", \"DNAString\",\n    function(x, at, letter, if.not.extending=\"replace\", verbose=FALSE)\n    {\n        if (is(at, \"Rle\"))\n            at <- as.vector(at)\n        if (is.logical(at)) {\n            if (length(at) != length(x))\n                stop(\"when 'at' is a logical sequence, it must have the \",\n                     \"same length as 'x'\")\n            at <- which(at)\n        } else {\n            if (!is.numeric(at))\n                stop(\"'at' must be a vector of integers\")\n            if (!is.integer(at))\n                at <- as.integer(at)\n        }\n        if (is(letter, \"DNAString\"))\n            letter <- as.character(letter)\n        else if (!is.character(letter))\n            stop(\"'letter' must be a DNAString object or a character vector\")\n        lkup <- get_seqtype_conversion_lookup(\"B\", seqtype(x))\n        if (!isSingleString(if.not.extending))\n            stop(\"'if.not.extending' must be a single string\")\n        if.not.extending <- match.arg(if.not.extending, c(\"replace\", \"skip\", \"merge\", \"error\"))\n        if (!isTRUEorFALSE(verbose))\n            stop(\"'verbose' must be TRUE or FALSE\")\n        .Call2(\"XString_replace_letter_at\",\n              x, at, letter, lkup, if.not.extending, verbose,\n              PACKAGE=\"Biostrings\")\n    }\n)\n\n## Current restrictions: 'x' and 'at' must be rectangular i.e. 'x' must have\n## a constant width and 'at' must be a logical matrix.\n## TODO: Get rid of these restrictions.\nsetMethod(\"replaceLetterAt\", \"DNAStringSet\",\n    function(x, at, letter, if.not.extending=\"replace\", verbose=FALSE)\n    {\n        if (length(x) == 0L)\n            stop(\"'x' has no element\")\n        x_width <- width(x)\n        if (!isConstant(x_width))\n            stop(\"'x' must be rectangular (i.e. have a constant width)\")\n        if (!is.logical(at) || !is.matrix(at))\n            stop(\"'at' must be a matrix of logicals\")\n        if (nrow(at) != length(x) || ncol(at) != x_width[1])\n            stop(\"'x' and 'at' must have the same dimensions\")\n        if (is(letter, \"DNAStringSet\"))\n            letter <- as.character(letter)\n        else if (!is.character(letter))\n            stop(\"'letter' must be a DNAStringSet object or a character vector\")\n        if (length(letter) != length(x))\n            stop(\"'x' and 'letter' must have the same length\")\n        if (!all(width(letter) == rowSums(at)))\n            stop(\"width(letter) and rowSums(at) must be the same\")\n        unlisted_x <- unlist(x, use.names=FALSE)\n        unlisted_ans <- replaceLetterAt(unlisted_x, as.vector(t(at)), letter,\n                                        if.not.extending=if.not.extending,\n                                        verbose=verbose)\n        relist(unlisted_ans, x)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \".inplaceReplaceLetterAt\" function.\n###\n### The user should NEVER use this function!\n### This function is used by the BSgenome package for injecting SNPs into the\n### sequences of a BSgenome object at sequence-load time.\n###\n\n.inplaceReplaceLetterAt <- function(x, at, letter)\n{\n    lkup <- get_seqtype_conversion_lookup(\"B\", seqtype(x))\n    .Call2(\"XString_inplace_replace_letter_at\",\n          x, at, letter, lkup,\n          PACKAGE=\"Biostrings\")\n}\n\n",
        "reverseComplement.R": "### =========================================================================\n### Sequence reversing and complementing\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"reverse\" methods.\n###\n\nsetMethod(\"reverse\", \"MaskedXString\",\n    function(x, ...)\n    {\n        x@unmasked <- reverse(unmasked(x))\n        x@masks <- reverse(masks(x))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"complement\" generic and methods.\n###\n\nsetGeneric(\"complement\", signature=\"x\",\n    function(x, ...) standardGeneric(\"complement\")\n)\n\nsetMethod(\"complement\", \"DNAString\",\n    function(x, ...) xvcopy(x, lkup=getDNAComplementLookup())\n)\n\nsetMethod(\"complement\", \"RNAString\",\n    function(x, ...) xvcopy(x, lkup=getRNAComplementLookup())\n)\n\nsetMethod(\"complement\", \"DNAStringSet\",\n    function(x, ...) xvcopy(x, lkup=getDNAComplementLookup())\n)\n\nsetMethod(\"complement\", \"RNAStringSet\",\n    function(x, ...) xvcopy(x, lkup=getRNAComplementLookup())\n)\n\nsetMethod(\"complement\", \"XStringViews\",\n    function(x, ...)\n    {\n        x@subject <- complement(subject(x))\n        x\n    }\n)\n\nsetMethod(\"complement\", \"MaskedDNAString\",\n    function(x, ...)\n    {\n        x@unmasked <- complement(unmasked(x))\n        x\n    }\n)\n\nsetMethod(\"complement\", \"MaskedRNAString\",\n    function(x, ...)\n    {\n        x@unmasked <- complement(unmasked(x))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"reverseComplement\" generic and methods.\n###\n### We could just do this:\n###   reverseComplement <- function(x) reverse(complement(x))\n### But we want to perform only 1 copy of the sequence data!\n### With the above implementation, reverseComplement(x) would copy the\n### sequence data in 'x' twice: a first (temporary) copy to get the\n### complement, followed by a second (final) copy to reverse it. Remember\n### that the sequence data can be very big e.g. 250MB for Human chr1!\n###\n\nsetGeneric(\"reverseComplement\", signature=\"x\",\n    function(x, ...) standardGeneric(\"reverseComplement\")\n)\n\nsetMethod(\"reverseComplement\", \"DNAString\",\n    function(x, ...) xvcopy(x, lkup=getDNAComplementLookup(), reverse=TRUE)\n)\n\nsetMethod(\"reverseComplement\", \"RNAString\",\n    function(x, ...) xvcopy(x, lkup=getRNAComplementLookup(), reverse=TRUE)\n)\n\nsetMethod(\"reverseComplement\", \"DNAStringSet\",\n    function(x, ...) xvcopy(x, lkup=getDNAComplementLookup(), reverse=TRUE)\n)\n\nsetMethod(\"reverseComplement\", \"RNAStringSet\",\n    function(x, ...) xvcopy(x, lkup=getRNAComplementLookup(), reverse=TRUE)\n)\n\nsetMethod(\"reverseComplement\", \"XStringViews\",\n    function(x, ...)\n    {\n        x@subject <- reverseComplement(subject(x))\n        x@ranges <- reverse(ranges(x), start=1L, end=length(subject(x)))\n        x\n    }\n)\n\nsetMethod(\"reverseComplement\", \"MaskedDNAString\",\n    function(x, ...)\n    {\n        x@unmasked <- reverseComplement(unmasked(x))\n        x@masks <- reverse(masks(x))\n        x\n    }\n)\n\nsetMethod(\"reverseComplement\", \"MaskedRNAString\",\n    function(x, ...)\n    {\n        x@unmasked <- reverseComplement(unmasked(x))\n        x@masks <- reverse(masks(x))\n        x\n    }\n)\n\n",
        "seqinfo-methods.R": "### =========================================================================\n### seqinfo() methods\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqinfo() getter and setter for DNAStringSet objects\n###\n\n.get_DNAStringSet_seqinfo <- function(x)\n{\n    ans_seqnames <- names(x)\n    if (is.null(ans_seqnames))\n        ans_seqnames <- as.character(seq_along(x))\n\n    ans_seqlengths <- width(x)\n\n    ans_is_circular <- metadata(x)$is_circular\n    if (is.null(ans_is_circular))\n        ans_is_circular <- NA\n\n    ans_genome <- metadata(x)$genome\n    if (is.null(ans_genome))\n        ans_genome <- NA\n\n    Seqinfo(ans_seqnames, ans_seqlengths, ans_is_circular, ans_genome)\n}\n\nsetMethod(\"seqinfo\", \"DNAStringSet\", .get_DNAStringSet_seqinfo)\n\n### We implement a restricted seqinfo() setter for DNAStringSet object 'x'\n### that supports altering **only** the seqlevels and/or circularity flags\n### and/or genome of 'seqinfo(x)'.\n### It does NOT allow subsetting 'seqinfo(x)' (by dropping/reordering some\n### of its seqlevels), or altering its seqlengths!\n### In other words, except for their seqnames() or isCircular() or genome(),\n### Seqinfo objects 'new_seqinfo' and 'old_seqinfo' must be identical. This\n### is all we need to make the seqlevelsStyle() setter work on a DNAStringSet\n### object.\n.check_new2old_and_new_seqinfo <-\n    function(new2old, new_seqinfo, old_seqinfo, context=\"\")\n{\n    if (length(new_seqinfo) != length(old_seqinfo))\n        stop(wmsg(\"the supplied 'seqinfo' must have the same \",\n                  \"length as the current 'seqinfo'\", context))\n    if (!(is.null(new2old) || identical(new2old, seq_along(new_seqinfo))))\n        stop(wmsg(\"'new2old' can only be set to NULL or \",\n                  \"'seq_along(seqinfo(x))'\", context))\n    seqnames(old_seqinfo) <- seqnames(new_seqinfo)\n    isCircular(old_seqinfo) <- isCircular(new_seqinfo)\n    genome(old_seqinfo) <- genome(new_seqinfo)\n    if (!identical(new_seqinfo, old_seqinfo))\n        stop(wmsg(\"the seqlengths() of the supplied 'seqinfo' must be \",\n                  \"identical to those of the current 'seqinfo'\", context))\n}\n\n.set_DNAStringSet_seqinfo <-\n    function(x, new2old=NULL,\n                pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n                value)\n{\n    if (!is(value, \"Seqinfo\"))\n        stop(\"the supplied 'seqinfo' must be a Seqinfo object\")\n\n    context <- paste0(\" when replacing the 'seqinfo' of a \",\n                      classNameForDisplay(x), \" object\")\n    pruning.mode <- match.arg(pruning.mode)\n    if (pruning.mode != \"error\")\n        stop(wmsg(\"'pruning.mode' is not supported\", context))\n    .check_new2old_and_new_seqinfo(new2old, value, seqinfo(x), context)\n\n    new_names <- seqnames(value)\n    if (identical(new_names, as.character(seq_along(x))))\n        new_names <- NULL\n    names(x) <- new_names\n\n    new_is_circular <- isCircular(value)\n    if (all(is.na(new_is_circular)))\n        new_is_circular <- NULL\n    metadata(x)$is_circular <- new_is_circular\n\n    new_genome <- genome(value)\n    if (all(is.na(new_genome)))\n        new_genome <- NULL\n    metadata(x)$genome <- new_genome\n\n    x\n}\n\nsetReplaceMethod(\"seqinfo\", \"DNAStringSet\", .set_DNAStringSet_seqinfo)\n\n",
        "seqtype.R": "### =========================================================================\n### The seqtype() generic & related functions\n### -------------------------------------------------------------------------\n###\n### Most sequence containers in Biostrings have a \"sequence type\" that\n### indicates the nature of the sequence(s) that the container can store:\n###\n###   sequence  |                           |              |\n###   type      | description               | alphabet     | encoded\n###   ----------|---------------------------|--------------|--------\n###   \"B\"       | general purpose string(s) | bytes 0-255  | no\n###   \"DNA\"     | DNA sequence(s)           | DNA_ALPHABET | yes\n###   \"RNA\"     | RNA sequence(s)           | RNA_ALPHABET | yes\n###   \"AA\"      | amino acid sequence(s)    | AA_ALPHABET  | yes\n###\n### seqtype() returns that sequence type. For example 'seqtype(AAString())'\n### returns \"AA\".\n### Unless specified otherwise, things in this file are not exported.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"seqtype\" and \"seqtype<-\" generics.\n###\n### seqtype() and `seqtype<-`() have methods defined for the 4 basic\n### string containers: XString (single sequence), XStringSet (multiple\n### sequences), XStringViews (multiple sequences) and MaskedXString (single\n### sequence).\n###\n\n### Exported.\nsetGeneric(\"seqtype\", function(x) standardGeneric(\"seqtype\"))\n\n### Exported.\nsetGeneric(\"seqtype<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"seqtype<-\")\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helper functions for which the returned value depends on 'seqtype(x)',\n### not on what particular data are in 'x'. Not exported.\n###\n\nxsbaseclass <- function(x) paste(seqtype(x), \"String\", sep=\"\")\n\nsetGeneric(\"xscodes\", signature=\"x\",\n    function(x, baseOnly=FALSE, ...) standardGeneric(\"xscodes\")\n)\n\nsetMethod(\"xscodes\", \"ANY\",\n    function(x, baseOnly=FALSE)\n    {\n        if (!isTRUEorFALSE(baseOnly))\n            stop(\"'baseOnly' must be TRUE or FALSE\")\n        seqtype <- seqtype(x)\n        switch(seqtype,\n               DNA=DNAcodes(baseOnly),\n               RNA=RNAcodes(baseOnly),\n               AA=AAcodes(baseOnly),\n               0:255\n        )\n    }\n)\n\nxscodec <- function(x)\n{\n    switch(seqtype(x),\n        DNA=DNA_STRING_CODEC,\n        RNA=RNA_STRING_CODEC,\n        AA=AA_STRING_CODEC,\n        NULL\n    )\n}\n\nxs_enc_lkup <- function(x)\n{\n    codec <- xscodec(x)\n    if (is.null(codec)) NULL else codec@enc_lkup\n}\n\nxs_dec_lkup <- function(x)\n{\n    codec <- xscodec(x)\n    if (is.null(codec)) NULL else codec@dec_lkup\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some restrictions apply for converting from a sequence type to another or\n### for comparing XString objects of different sequence types. This is\n### due to the fact that XString objects with different sequence types can use\n### different encodings for their sequence data (or no encoding at all) or\n### simply to the fact that the conversion or comparison doesn't make sense\n### from a biological perspective.\n### The helper functions below are used internally (they are NOT exported) to\n### determine those restrictions.\n###\n\ncompatible_seqtypes <- function(seqtype1, seqtype2)\n{\n    if (seqtype1 %in% c(\"DNA\", \"RNA\"))\n        return(seqtype2 != \"AA\")\n    if (seqtype1 == \"AA\")\n        return(!(seqtype2 %in% c(\"DNA\", \"RNA\")))\n    TRUE\n}\n\n### Exported.\nget_seqtype_conversion_lookup <- function(from_seqtype, to_seqtype)\n{\n    if (!compatible_seqtypes(from_seqtype, to_seqtype))\n        stop(\"incompatible sequence types \\\"\",\n             from_seqtype, \"\\\" and \\\"\", to_seqtype, \"\\\"\")\n    from_nucleo <- from_seqtype %in% c(\"DNA\", \"RNA\", \"AA\")\n    to_nucleo <- to_seqtype %in% c(\"DNA\", \"RNA\", \"AA\")\n    if (from_nucleo == to_nucleo)\n        return(NULL)\n    if (to_seqtype == \"DNA\")\n        return(DNA_STRING_CODEC@enc_lkup)\n    if (to_seqtype == \"RNA\")\n        return(RNA_STRING_CODEC@enc_lkup)\n    if (to_seqtype == \"AA\")\n        return(AA_STRING_CODEC@enc_lkup)\n    if (from_seqtype == \"DNA\")\n        return(DNA_STRING_CODEC@dec_lkup)\n    if (from_seqtype == \"RNA\")\n        return(RNA_STRING_CODEC@dec_lkup)\n    if (from_seqtype == \"AA\")\n        return(AA_STRING_CODEC@dec_lkup)\n    stop(\"Biostrings internal error, please report\") # should never happen\n}\n\ncomparable_seqtypes <- function(seqtype1, seqtype2)\n{\n    is_nucleo1 <- seqtype1 %in% c(\"DNA\", \"RNA\")\n    is_nucleo2 <- seqtype2 %in% c(\"DNA\", \"RNA\")\n    is_nucleo1 == is_nucleo2\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### alphabet()\n###\n### Exported.\n\n### Could be made just a regular function but that would cause problems to\n### people wanting to redefine alphabet() for their own objects (this is the\n### case at least in the ShortRead package).\nsetGeneric(\"alphabet\", function(x, ...) standardGeneric(\"alphabet\"))\n\nsetMethod(\"alphabet\", \"ANY\",\n    function(x, baseOnly=FALSE)\n    {\n        if (!isTRUEorFALSE(baseOnly))\n            stop(\"'baseOnly' must be TRUE or FALSE\")\n        switch(seqtype(x),\n            DNA=if (baseOnly) DNA_BASES else DNA_ALPHABET,\n            RNA=if (baseOnly) RNA_BASES else RNA_ALPHABET,\n            AA=AA_ALPHABET,\n            NULL\n        )\n    }\n)\n",
        "strsplit-methods.R": "### =========================================================================\n### strsplit() / unstrsplit()\n### -------------------------------------------------------------------------\n\n\n.strsplit.useAsDefault <- function(x, ...) base::strsplit(x, ...)\nsetGeneric(\"strsplit\", signature=\"x\",\n    function(x, ...) standardGeneric(\"strsplit\"),\n    useAsDefault=.strsplit.useAsDefault\n)\n\nsetMethod(\"strsplit\", \"XStringSet\",\n    function(x, split, ...)\n    {\n        mi <- vmatchPattern(split, x, ...)\n        at <- gaps(as(mi, \"CompressedIRangesList\"),\n                   start=1L, end=width(x))\n        extractAt(x, at)\n    }\n)\n\nsetMethod(\"unstrsplit\", \"XStringSetList\",\n    function(x, sep=\"\")\n    {\n        x_seqtype <- seqtype(x)\n        sep <- XString(x_seqtype, sep)\n        .Call(\"XStringSetList_unstrsplit\", x, sep, x_seqtype,\n              PACKAGE=\"Biostrings\")\n    }\n)\n\nsetMethod(\"unstrsplit\", \"XStringSet\",\n    function(x, sep=\"\")\n    {\n        x\n    }\n)\n\n",
        "toComplex.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"toComplex\" new generic.\n###\n\nsetGeneric(\"toComplex\",\n    function(x, baseValues)\n        standardGeneric(\"toComplex\")\n)\n\n### 'baseValues' must be a named complex vector containing the values\n### associated to each base e.g.\n###   baseValues=c(A=1+0i, G=0+1i, T=-1+0i, C=0-1i)\nsetMethod(\"toComplex\", \"DNAString\",\n    function(x, baseValues)\n    {\n        if (is.null(names(baseValues)))\n            stop(\"'baseValues' must have names\")\n        if (any(duplicated(names(baseValues))))\n            stop(\"'baseValues' must have unique names\")\n        base_codes <- xscodes(x)\n        if (!all(names(baseValues) %in% names(base_codes)))\n            stop(\"'baseValues' names must be valid DNA letters\")\n        if (!is.complex(baseValues))\n            class(baseValues) <- \"complex\" # as.complex() would drop the names!\n        lkup <- buildLookupTable(base_codes[names(baseValues)], baseValues)\n        SharedRaw.readComplexes(x@shared, x@offset + 1L, x@offset + x@length, lkup)\n    }\n)\n\n",
        "translate.R": "### =========================================================================\n### Translating DNA/RNA sequences\n### -------------------------------------------------------------------------\n\n\n.normarg_genetic.code <- function(genetic.code)\n{\n    if (!is.character(genetic.code) || any(is.na(genetic.code)))\n        stop(\"'genetic.code' must be a character vector with no NAs\")\n    if (!identical(names(genetic.code), names(GENETIC_CODE)))\n        stop(\"'genetic.code' must have the same names as \",\n             \"predefined constant GENETIC_CODE\")\n    if (!all(nchar(genetic.code) == 1L))\n        stop(\"'genetic.code' must contain 1-letter strings\")\n    ## Just a warning for now. Might become an error in the future.\n    ## 07/26/2024: updated to error since AAString() enforces alphabet\n    if (!all(genetic.code %in% AA_ALPHABET))\n        stop(\"some codons in 'genetic.code' are mapped to letters \",\n             \"not in the Amino Acid\\n  alphabet (AA_ALPHABET)\")\n    alt_init_codons <- attr(genetic.code, \"alt_init_codons\", exact=TRUE)\n    if (is.null(alt_init_codons)\n     || !is.character(alt_init_codons)\n     || any(is.na(alt_init_codons))\n     || anyDuplicated(alt_init_codons)\n     || !all(alt_init_codons %in% names(genetic.code)))\n        stop(wmsg(\"'genetic.code' must have an \\\"alt_init_codons\\\" attribute \",\n                  \"that lists alternative initiation codons\"))\n    genetic.code\n}\n\n### Returns a character vector of length 2.\n.normarg_if.fuzzy.codon <- function(if.fuzzy.codon)\n{\n    if (!is.character(if.fuzzy.codon)\n     || !(length(if.fuzzy.codon) == 1L || length(if.fuzzy.codon) == 2L))\n        stop(\"'if.fuzzy.codon' must be a single string or \",\n             \"a character vector of length 2\")\n    if (length(if.fuzzy.codon) == 1L) {\n        choices <- c(\"error\", \"solve\", \"error.if.X\", \"X\")\n        if.fuzzy.codon <- match.arg(if.fuzzy.codon, choices)\n        if.fuzzy.codon <- switch(if.fuzzy.codon,\n                                 error=c(\"error\", \"error\"),\n                                 solve=c(\"solve\", \"X\"),\n                                 error.if.X=c(\"solve\", \"error\"),\n                                 X=c(\"X\", \"X\"))\n        return(if.fuzzy.codon)\n    }\n    ## From now on, 'if.fuzzy.codon' is guaranteed to have length 2.\n    if.non.ambig <- if.fuzzy.codon[[1L]]\n    choices1 <- c(\"error\", \"solve\", \"X\")\n    if.non.ambig <- match.arg(if.non.ambig, choices1)\n\n    if.ambig <- if.fuzzy.codon[[2L]]\n    choices2 <- c(\"error\", \"X\")\n    if.ambig <- match.arg(if.ambig, choices2)\n    c(if.non.ambig, if.ambig)\n}\n\n.make_fuzzy_genetic_code <- function(genetic.code, keep.ambig.codons=FALSE)\n{\n    if (!isTRUEorFALSE(keep.ambig.codons))\n        stop(\"'keep.ambig.codons' must be TRUE or FALSE\")\n    iupac_codes <- names(IUPAC_CODE_MAP)\n    fuzzy_codons <- mkAllStrings(iupac_codes, 3L)\n    nonfuzzy_codons <- DNAStringSet(names(genetic.code))\n    fuzzy2nonfuzzy <- vwhichPDict(nonfuzzy_codons, DNAStringSet(fuzzy_codons),\n                                  fixed=\"pattern\")\n    fuzzy2AAs <- relist(unname(genetic.code)[unlist(fuzzy2nonfuzzy)],\n                        PartitioningByEnd(fuzzy2nonfuzzy))\n    fuzzy2AAs <- unique(fuzzy2AAs)\n    nAAs <- elementNROWS(fuzzy2AAs)\n    names(fuzzy2AAs) <- fuzzy_codons\n    stopifnot(all(nAAs >= 1L))\n    if (keep.ambig.codons) {\n        idx <- which(nAAs != 1L)\n        fuzzy2AAs[idx] <- \"X\"\n    } else {\n        idx <- which(nAAs == 1L)\n        fuzzy2AAs <- fuzzy2AAs[idx]\n    }\n    unlist(fuzzy2AAs)\n}\n\n.aa2byte <- function(aa) as.integer(charToRaw(paste0(aa, collapse=\"\")))\n\n.make_translation_lkup <- function(codon_alphabet, genetic.code)\n{\n    codons <- mkAllStrings(codon_alphabet, 3)\n    m <- match(codons, names(genetic.code))\n    if (any(is.na(m)))\n        stop(\"some codons are not in 'genetic.code'\")\n    .aa2byte(genetic.code[m])\n}\n\n.translate <- function(x, genetic.code=GENETIC_CODE, no.init.codon=FALSE,\n                          if.fuzzy.codon=\"error\")\n{\n    genetic_code <- .normarg_genetic.code(genetic.code)\n    if (!isTRUEorFALSE(no.init.codon))\n        stop(wmsg(\"'no.init.codon' must be TRUE or FALSE\"))\n    if (!no.init.codon) {\n        init_genetic_code <- genetic_code\n        alt_init_codons <- attr(genetic_code, \"alt_init_codons\")\n        init_genetic_code[alt_init_codons] <- \"M\"\n    }\n\n    if.fuzzy.codon <- .normarg_if.fuzzy.codon(if.fuzzy.codon)\n    if.non.ambig <- if.fuzzy.codon[[1L]]\n    if.ambig <- if.fuzzy.codon[[2L]]\n\n    if (if.non.ambig == \"error\" && if.ambig == \"error\") {\n        codon_alphabet <- DNA_BASES\n    } else {\n        codon_alphabet <- names(IUPAC_CODE_MAP)\n        genetic_code <- .make_fuzzy_genetic_code(genetic_code,\n                                                 keep.ambig.codons=TRUE)\n        if (!no.init.codon)\n            init_genetic_code <-\n                        .make_fuzzy_genetic_code(init_genetic_code,\n                                                 keep.ambig.codons=TRUE)\n    }\n\n    lkup <- .make_translation_lkup(codon_alphabet, genetic_code)\n    if (no.init.codon) {\n        init_lkup <- lkup\n    } else {\n        init_lkup <- .make_translation_lkup(codon_alphabet, init_genetic_code)\n    }\n    dna_codes <- DNAcodes(baseOnly=FALSE)\n    skip_code <- dna_codes[[\"+\"]]\n    ans <- .Call2(\"DNAStringSet_translate\",\n                  x, skip_code, dna_codes[codon_alphabet],\n                  lkup, init_lkup,\n                  if.non.ambig, if.ambig,\n                  PACKAGE=\"Biostrings\")\n    names(ans) <- names(x)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"translate\" generic and methods.\n###\n\nsetGeneric(\"translate\", signature=\"x\",\n    function(x, genetic.code=GENETIC_CODE, no.init.codon=FALSE,\n                if.fuzzy.codon=\"error\")\n        standardGeneric(\"translate\")\n)\n\nsetMethod(\"translate\", \"DNAStringSet\", .translate)\n\nsetMethod(\"translate\", \"RNAStringSet\", .translate)\n\nsetMethod(\"translate\", \"DNAString\",\n    function(x, genetic.code=GENETIC_CODE, no.init.codon=FALSE,\n                if.fuzzy.codon=\"error\")\n        translate(DNAStringSet(x),\n                  genetic.code=genetic.code,\n                  no.init.codon=no.init.codon,\n                  if.fuzzy.codon=if.fuzzy.codon)[[1L]]\n)\n\nsetMethod(\"translate\", \"RNAString\",\n    function(x, genetic.code=GENETIC_CODE, no.init.codon=FALSE,\n                if.fuzzy.codon=\"error\")\n        translate(RNAStringSet(x),\n                  genetic.code=genetic.code,\n                  no.init.codon=no.init.codon,\n                  if.fuzzy.codon=if.fuzzy.codon)[[1L]]\n)\n\nsetMethod(\"translate\", \"MaskedDNAString\",\n    function(x, genetic.code=GENETIC_CODE, no.init.codon=FALSE,\n                if.fuzzy.codon=\"error\")\n        translate(injectHardMask(x),\n                  genetic.code=genetic.code,\n                  no.init.codon=no.init.codon,\n                  if.fuzzy.codon=if.fuzzy.codon)\n)\n\nsetMethod(\"translate\", \"MaskedRNAString\",\n    function(x, genetic.code=GENETIC_CODE, no.init.codon=FALSE,\n                if.fuzzy.codon=\"error\")\n        translate(injectHardMask(x),\n                  genetic.code=genetic.code,\n                  no.init.codon=no.init.codon,\n                  if.fuzzy.codon=if.fuzzy.codon)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The \"codons\" generic and methods.\n###\n\nsetGeneric(\"codons\", signature=\"x\",\n    function(x) standardGeneric(\"codons\")\n)\n\n\n### 'x' must be a DNAString or RNAString object\n.XString.codons <- function(x)\n{\n    if (length(x) %% 3L != 0L)\n        warning(\"the number of nucleotides in 'x' is not a multiple of 3\")\n    ans <- successiveViews(x, rep.int(3L, length(x) %/% 3L))\n    if (alphabetFrequency(ans, baseOnly=TRUE, collapse=TRUE)[[\"other\"]] != 0)\n        stop(\"some trinucleotides in 'x' contain non-base letters\")\n    ans\n}\n\n### 'x' is assumed to in the coding strand of the DNA\nsetMethod(\"codons\", \"DNAString\", function(x) .XString.codons(x))\n\nsetMethod(\"codons\", \"RNAString\", function(x) .XString.codons(x))\n\n\n### 'x' must be a MaskedDNAString or MaskedRNAString object.\n### Return 1 view per codon. Each view is guaranteed to contain exactly\n### 3 base letters plus eventually some '+' letters (removed during\n### translation).\n.MaskedXString.codons <- function(x)\n{\n    if (nchar(x) %% 3L != 0L)\n        warning(\"the number of unmasked nucleotides in 'x' is not a multiple of 3\")\n    if (alphabetFrequency(x, baseOnly=TRUE)[[\"other\"]] != 0)\n        stop(\"some trinucleotides in 'x' contain non-base letters\")\n    ans_length <- nchar(x) %/% 3L\n    ans_start <- integer(ans_length)\n    ans_end <- integer(ans_length)\n    x0 <- injectHardMask(x)\n    codon_start <- 1L\n    for (i in seq_len(ans_length)) {\n        while (letter(x0, codon_start) == '+')\n            codon_start <- codon_start + 1L\n        codon_end <- codon_start\n        codon_nchar <- 1L\n        while (codon_nchar < 3L) {\n            codon_end <- codon_end + 1L\n            if (letter(x0, codon_end) != '+')\n                codon_nchar <- codon_nchar + 1L\n        }\n        ans_start[i] <- codon_start\n        ans_end[i] <- codon_end\n        codon_start <- codon_end + 1L\n    }\n    Views(x0, start=ans_start, end=ans_end)\n}\n\nsetMethod(\"codons\", \"MaskedDNAString\", function(x) .MaskedXString.codons(x))\n\nsetMethod(\"codons\", \"MaskedRNAString\", function(x) .MaskedXString.codons(x))\n\n",
        "trimLRPatterns.R": "### =========================================================================\n### The \"trimLRPatterns\" generic.\n### -------------------------------------------------------------------------\n\n\nsetGeneric(\"trimLRPatterns\", signature = \"subject\",\n    function(Lpattern = \"\", Rpattern = \"\", subject,\n             max.Lmismatch = 0, max.Rmismatch = 0,\n             with.Lindels = FALSE, with.Rindels = FALSE,\n             Lfixed = TRUE, Rfixed = TRUE, ranges = FALSE)\n        standardGeneric(\"trimLRPatterns\")\n)\n\n.normarg_maxLmismatch <- function(max.Lmismatch, Lpattern_len, LorR=\"L\")\n{\n    argname <- paste0(\"max.\", LorR, \"mismatch\", collapse=\"\")\n    if (!is.numeric(max.Lmismatch))\n        stop(\"'\", argname, \"' must be numeric\")\n    if (any(is.na(max.Lmismatch)))\n        stop(\"'\", argname, \"' cannot contain NAs\")\n    if (length(max.Lmismatch) == 1L\n     && max.Lmismatch >= 0 && max.Lmismatch < 1) {\n        max.Lmismatch <- as.integer(max.Lmismatch * seq_len(Lpattern_len))\n    } else if (length(max.Lmismatch) > Lpattern_len) {\n        stop(\"'\", argname, \"' cannot be longer than '\", LorR, \"pattern'\")\n    } else {\n        max.Lmismatch <- as.integer(max.Lmismatch)\n        if (length(max.Lmismatch) < Lpattern_len) {\n            max.Lmismatch <-\n                c(rep.int(-1L, Lpattern_len - length(max.Lmismatch)),\n                  max.Lmismatch)\n        }\n    }\n    rev(max.Lmismatch)\n}\n\n### 'subject' must be an XStringSet object of length != 0.\n### Returns an integer vector of the same length as 'subject' where the i-th\n### value is guaranteed to be >= 1 and <= width(subject)[i] + 1.\n.computeTrimStart <- function(Lpattern, subject,\n                              max.Lmismatch, with.Lindels, Lfixed)\n{\n    Lpattern <- normargPattern(Lpattern, subject, argname=\"Lpattern\")\n    Lpattern_len <- length(Lpattern)\n    if (Lpattern_len == 0L)\n        return(rep.int(1L, length(subject)))\n    max.Lmismatch <- .normarg_maxLmismatch(max.Lmismatch, Lpattern_len,\n                                           LorR=\"L\")\n    ## Test the pattern \"from the inside out\" (moving it to the left).\n    ii <- which.isMatchingStartingAt(Lpattern,\n                                     subject,\n                                     starting.at = 1L,\n                                     max.mismatch = max.Lmismatch,\n                                     with.indels = with.Lindels,\n                                     fixed = Lfixed,\n                                     auto.reduce.pattern = TRUE)\n    ii[is.na(ii)] <- Lpattern_len + 1L\n    start <- Lpattern_len + 2L - ii\n    if (length(start) == 0L)\n        return(start)\n    ## For elements in 'subject' shorter than 'Lpattern', 'start' can be\n    ## > width(subject) + 1L.\n    pmin(start, width(subject) + 1L)\n}\n\n### 'subject' must be an XStringSet object of length != 0.\n### Returns an integer vector of the same length as 'subject' where the i-th\n### value is guaranteed to be >= 0 and <= width(subject)[i].\n.computeTrimEnd <- function(Rpattern, subject,\n                            max.Rmismatch, with.Rindels, Rfixed)\n{\n    Rpattern <- normargPattern(Rpattern, subject, argname=\"Rpattern\")\n    Rpattern_len <- length(Rpattern)\n    if (Rpattern_len == 0L)\n        return(width(subject))\n    ## Because we want to use which.isMatchingEndingAt() with\n    ## 'auto.reduce.pattern=TRUE', the 'ending.at' arg will need to be a\n    ## single value. But that won't be possible if 'subject' is not\n    ## rectangular hence the ugly trick.\n    if (!isConstant(width(subject))) {\n        tmp <- .computeTrimStart(reverse(Rpattern), reverse(subject),\n                                 max.Rmismatch, with.Rindels, Rfixed)\n        return(width(subject) - tmp + 1L)\n    }\n    max.Rmismatch <- .normarg_maxLmismatch(max.Rmismatch, Rpattern_len,\n                                           LorR=\"R\")\n    ## Test the pattern \"from the inside out\" (moving it to the right).\n    subject_width <- width(subject)[1L]\n    ii <- which.isMatchingEndingAt(pattern=Rpattern,\n                                   subject=subject,\n                                   ending.at=subject_width,\n                                   max.mismatch=max.Rmismatch,\n                                   with.indels=with.Rindels,\n                                   fixed=Rfixed,\n                                   auto.reduce.pattern=TRUE)\n    ii[is.na(ii)] <- Rpattern_len + 1L\n    end <- subject_width - Rpattern_len - 1L + ii\n    if (length(end) == 0L)\n        return(end)\n    ## For elements in 'subject' shorter than 'Rpattern', 'end' can be < 0L.\n    pmax(end, 0L)\n}\n\n.XStringSet.trimLRPatterns <- function(Lpattern, Rpattern, subject,\n                                       max.Lmismatch, max.Rmismatch,\n                                       with.Lindels, with.Rindels,\n                                       Lfixed, Rfixed, ranges)\n{\n    if (!isTRUEorFALSE(ranges))\n        stop(\"'ranges' must be TRUE or FALSE\")\n    if (length(subject) == 0L) {\n        if (ranges)\n            return(IRanges())\n        return(subject)\n    }\n    start <- .computeTrimStart(Lpattern, subject,\n                               max.Lmismatch, with.Lindels, Lfixed)\n    end <- .computeTrimEnd(Rpattern, subject,\n                           max.Rmismatch, with.Rindels, Rfixed)\n    ## For those invalid ranges where 'start > end + 1L', we arbitrarily\n    ## decide to set the 'start' to 'end + 1' (another reasonable choice\n    ## would have been to set the 'end' to 'start - 1').\n    idx <- which(start > end + 1L)\n    start[idx] <- end[idx] + 1L\n    if (ranges)\n        return(IRanges(start=start, end=end))\n    return(narrow(subject, start=start, end=end))\n}\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"trimLRPatterns\", \"XString\",\n    function(Lpattern = \"\", Rpattern = \"\", subject,\n             max.Lmismatch = 0, max.Rmismatch = 0,\n             with.Lindels = FALSE, with.Rindels = FALSE,\n             Lfixed = TRUE, Rfixed = TRUE, ranges = FALSE)\n    {\n        subject <- as(subject, \"XStringSet\")\n        ans <- .XStringSet.trimLRPatterns(Lpattern, Rpattern, subject,\n                                          max.Lmismatch, max.Rmismatch,\n                                          with.Lindels, with.Rindels,\n                                          Lfixed, Rfixed, ranges)\n        if (is(ans, \"XStringSet\"))\n            ans <- ans[[1L]]\n        ans\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"trimLRPatterns\", \"XStringSet\",\n    function(Lpattern = \"\", Rpattern = \"\", subject,\n             max.Lmismatch = 0, max.Rmismatch = 0,\n             with.Lindels = FALSE, with.Rindels = FALSE,\n             Lfixed = TRUE, Rfixed = TRUE, ranges = FALSE)\n    {\n        .XStringSet.trimLRPatterns(Lpattern, Rpattern, subject,\n                                   max.Lmismatch, max.Rmismatch,\n                                   with.Lindels, with.Rindels,\n                                   Lfixed, Rfixed, ranges)\n    }\n)\n\n### Dispatch on 'subject' (see signature of generic).\nsetMethod(\"trimLRPatterns\", \"character\",\n    function(Lpattern = \"\", Rpattern = \"\", subject,\n             max.Lmismatch = 0, max.Rmismatch = 0,\n             with.Lindels = FALSE, with.Rindels = FALSE,\n             Lfixed = TRUE, Rfixed = TRUE, ranges = FALSE)\n    {\n        subject <- as(subject, \"XStringSet\")\n        ans <- .XStringSet.trimLRPatterns(Lpattern, Rpattern, subject,\n                                          max.Lmismatch, max.Rmismatch,\n                                          with.Lindels, with.Rindels,\n                                          Lfixed, Rfixed, ranges)\n        if (is(ans, \"XStringSet\"))\n            ans <- as.character(ans)\n        ans\n    }\n)\n\n",
        "utils.R": "###\n### We register the old-style (a.k.a. S3) class below as a formally defined\n### class (a.k.a. S4) because we are using it in some method signatures.\n### Note that dispatch still works without this registration but causes\n### 'R CMD INSTALL' to (gently) complain.\n###\n\nsetOldClass(\"probetable\")\n\n\n###\n### Some low-level (not exported) helper functions.\n###\n\nisNumericOrNAs <- function(x)\n{\n    is.numeric(x) || (is.atomic(x) && is.vector(x) && all(is.na(x)))\n}\n\nnormargUseNames <- function(use.names)\n{\n    if (is.null(use.names))\n        return(TRUE)\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    use.names\n}\n\n### Returns an integer vector.\npow.int <- function(x, y)\n{\n    if (!is.numeric(x))\n        stop(\"'x' must be a numeric vector\")\n    if (!is.integer(x))\n        x <- as.integer(x)\n    ans <- rep.int(1L, length(x))\n    for (i in seq_len(y))\n        ans <- ans * x\n    ans\n}\n\n",
        "xscat.R": "### =========================================================================\n### The xscat() function\n### -------------------------------------------------------------------------\n###\n\n### Check the types of the arguments and determine the cardinality of the\n### answer:\n###   if 0 => empty XStringSet\n###   if 1 => XString\n###   if >= 2 => XStringSet\n.get_xscat_ans_cardinality <- function(...)\n{\n    get_arg_cardinality <- function(arg)\n    {\n        if (is.character(arg))\n            return(length(arg))\n        if (is(arg, \"XString\"))\n            return(1L)\n        if (is(arg, \"XStringSet\") || is(arg, \"XStringViews\")) {\n            if (length(arg) == 0L)\n                return(0L)\n            return(2L)  # yes return 2, even if length(arg) == 1\n        }\n        stop(\"xscat() arguments must be character vectors (with no NAs) \",\n             \"or XString/XStringSet/XStringViews objects\")\n    }\n    arg_cards <- sapply(list(...), get_arg_cardinality)\n    if (all(arg_cards == 0L))\n        return(0L)\n    if (any(arg_cards == 0L))\n        stop(\"xscat() cannot mix arguments made of 0 sequence with arguments \",\n             \"made of 1 or more sequences\")\n    if (all(arg_cards == 1L))\n        return(1L)\n    return(2L)\n}\n\n.get_xscat_ans_seqtype <- function(...)\n{\n    get_arg_seqtype <- function(arg)\n    {\n        if (is.character(arg)) \"B\" else seqtype(arg)\n    }\n    arg_seqtypes <- unique(sapply(list(...), get_arg_seqtype))\n    ans_seqtype <- setdiff(arg_seqtypes, \"B\")\n    if (length(ans_seqtype) >= 2L)\n        stop(\"xscat() cannot mix \", ans_seqtype[1L],\n             \" and \", ans_seqtype[2L], \" input\")\n    if (length(ans_seqtype) == 0L)\n        ans_seqtype <- \"B\"\n    ans_seqtype\n}\n\nxscat <- function(...)\n{\n    if (length(list(...)) == 0)\n        stop(\"no input\")\n    ans_card <- .get_xscat_ans_cardinality(...)\n    ans_seqtype <- .get_xscat_ans_seqtype(...)\n    if (ans_card == 1L) {\n        ans_class <- paste(ans_seqtype, \"String\", sep=\"\")\n    } else {\n        ans_class <- paste(ans_seqtype, \"StringSet\", sep=\"\")\n        if (ans_card == 0L)\n            return(as(character(0), ans_class))\n    }\n    args <- lapply(list(...),\n                   function(arg)\n                   {\n                       if (is(arg, ans_class)) arg else as(arg, ans_class)\n                   })\n    if (ans_card == 1L) {\n        .Call2(\"XString_xscat\", args, PACKAGE=\"Biostrings\")\n    } else {\n        .Call2(\"XStringSet_xscat\", args, PACKAGE=\"Biostrings\")\n    }\n}\n\n",
        "zzz.R": "###\n\n.pkgenv <- new.env(parent=emptyenv())\n\n.onLoad <- function(libname, pkgname)\n{\n    .Call2(\"init_DNAlkups\",\n          DNA_STRING_CODEC@enc_lkup, DNA_STRING_CODEC@dec_lkup,\n          PACKAGE=pkgname)\n    .Call2(\"init_RNAlkups\",\n          RNA_STRING_CODEC@enc_lkup, RNA_STRING_CODEC@dec_lkup,\n          PACKAGE=pkgname)\n    .Call2(\"init_AAlkups\",\n          AA_STRING_CODEC@enc_lkup, AA_STRING_CODEC@dec_lkup,\n          PACKAGE=pkgname)\n\n    assign(\"DNA_AND_RNA_COLORED_LETTERS\", make_DNA_AND_RNA_COLORED_LETTERS(), envir=.pkgenv)\n    assign(\"AA_COLORED_LETTERS\", make_AA_COLORED_LETTERS(), envir=.pkgenv)\n    assign(\"B_COLORED_LETTERS\", character(0L), envir=.pkgenv)\n\n    option_name <- \"Biostrings.coloring\"\n    if (!(option_name %in% names(.Options)))\n        options(setNames(list(TRUE), option_name))\n}\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"Biostrings\", libpath)\n}\n\n.test <- function() BiocGenerics:::testPackage(\"Biostrings\")\n"
    },
    "GenomicRanges": {
        "DelegatingGenomicRanges-class.R": "### =========================================================================\n### DelegatingGenomicRanges objects\n### -------------------------------------------------------------------------\n###\n### Virtual class that delegates GenomicRanges data access to a\n### GenomicRanges delegate.\n###\n\nsetClass(\"DelegatingGenomicRanges\",\n         representation(delegate=\"GenomicRanges\"),\n         contains=c(\"GenomicRanges\", \"VIRTUAL\"))\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Slot getters and setters.\n###\n\nsetMethod(\"seqnames\", \"DelegatingGenomicRanges\",\n          function(x) seqnames(x@delegate))\n\nsetMethod(\"ranges\", \"DelegatingGenomicRanges\",\n          function(x, ...) ranges(x@delegate, ...))\n\nsetMethod(\"strand\", \"DelegatingGenomicRanges\", function(x) strand(x@delegate))\nsetMethod(\"seqinfo\", \"DelegatingGenomicRanges\", function(x) seqinfo(x@delegate))\n\nsetMethod(\"update\", \"DelegatingGenomicRanges\", function (object, ...) {\n  object@delegate <- update(object@delegate, ...)\n  object\n})\n",
        "GNCList-class.R": "### =========================================================================\n### GNCList objects\n### -------------------------------------------------------------------------\n###\n### GNCList is a container for storing a preprocessed GenomicRanges object\n### that can be used for fast findOverlaps().\n###\n\nsetClass(\"GNCList\",\n    contains=\"GenomicRanges\",\n    representation(\n        nclists=\"list\",\n        granges=\"GRanges\"\n    )\n)\n\n.get_circle_length <- function(x)\n{\n    circle_length <- seqlengths(x)\n    circle_length[!(isCircular(x) %in% TRUE)] <- NA_integer_\n    circle_length\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"granges\", \"GNCList\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(use.mcols))\n            stop(\"'use.mcols' must be TRUE or FALSE\")\n        ans <- x@granges\n        if (!use.names)\n            names(ans) <- NULL\n        if (use.mcols)\n            mcols(ans) <- mcols(x, use.names=FALSE)\n        ans\n    }\n)\n\nsetMethod(\"length\", \"GNCList\", function(x) length(granges(x)))\nsetMethod(\"names\", \"GNCList\", function(x) names(granges(x)))\nsetMethod(\"seqnames\", \"GNCList\", function(x) seqnames(granges(x)))\nsetMethod(\"start\", \"GNCList\", function(x, ...) start(granges(x)))\nsetMethod(\"end\", \"GNCList\", function(x, ...) end(granges(x)))\nsetMethod(\"width\", \"GNCList\", function(x) width(granges(x)))\nsetMethod(\"ranges\", \"GNCList\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n        ranges(granges(x, use.names=use.names, use.mcols=use.mcols),\n               use.names=TRUE, use.mcols=use.mcols)\n)\nsetMethod(\"strand\", \"GNCList\", function(x) strand(granges(x)))\nsetMethod(\"seqinfo\", \"GNCList\", function(x) seqinfo(granges(x)))\n\nsetAs(\"GNCList\", \"GRanges\", function(from) granges(from, use.mcols=TRUE))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.extract_groups_from_GenomicRanges <- function(x)\n    splitAsList(seq_along(x) - 1L, seqnames(x))\n\nGNCList <- function(x)\n{\n    if (!is(x, \"GenomicRanges\"))\n        stop(\"'x' must be a GenomicRanges object\")\n    if (!is(x, \"GRanges\"))\n        x <- as(x, \"GRanges\")\n    ans_mcols <- mcols(x, use.names=FALSE)\n    mcols(x) <- NULL\n    x_groups <- .extract_groups_from_GenomicRanges(x)\n    x_ranges <- IRanges:::.shift_ranges_in_groups_to_first_circle(ranges(x),\n                                   x_groups, .get_circle_length(x))\n    ranges(x) <- x_ranges\n    x_nclists <- IRanges:::.nclists(x_ranges, x_groups)\n    new2(\"GNCList\", nclists=x_nclists,\n                    granges=x,\n                    elementMetadata=ans_mcols,\n                    check=FALSE)\n}\n\nsetAs(\"GenomicRanges\", \"GNCList\", function(from) GNCList(from))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\nsetMethod(\"extractROWS\", \"GNCList\",\n    function(x, i) as(callGeneric(as(x, \"GRanges\"), i), class(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### findOverlaps_GNCList()\n###\n\n### NOT exported.\nfindOverlaps_GNCList <- function(query, subject,\n             maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"extend\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\", \"count\"),\n             ignore.strand=FALSE)\n{\n    if (!(is(query, \"GenomicRanges\") && is(subject, \"GenomicRanges\")))\n        stop(\"'query' and 'subject' must be GenomicRanges objects\")\n    type <- match.arg(type)\n    select <- match.arg(select)\n    if (!isTRUEorFALSE(ignore.strand))\n        stop(\"'ignore.strand' must be TRUE or FALSE\")\n\n    si <- merge(seqinfo(query), seqinfo(subject))\n    q_seqlevels <- seqlevels(query)\n    s_seqlevels <- seqlevels(subject)\n    common_seqlevels <- intersect(q_seqlevels, s_seqlevels)\n    NG <- length(common_seqlevels)\n    q_group_idx <- match(common_seqlevels, q_seqlevels)  # of length NG\n    s_group_idx <- match(common_seqlevels, s_seqlevels)  # of length NG\n\n    ## Extract 'q_groups' and 's_groups' (both of length NG).\n    q_groups <- .extract_groups_from_GenomicRanges(query)[q_group_idx]\n    s_groups <- .extract_groups_from_GenomicRanges(subject)[s_group_idx]\n\n    ## Extract 'nclists' and 'nclist_is_q' (both of length NG).\n    if (is(subject, \"GNCList\")) {\n        nclists <- subject@nclists[s_group_idx]\n        nclist_is_q <- rep.int(FALSE, NG)\n    } else if (is(query, \"GNCList\")) {\n        nclists <- query@nclists[q_group_idx]\n        nclist_is_q <- rep.int(TRUE, NG)\n    } else {\n        ## We'll do \"on-the-fly preprocessing\".\n        nclists <- vector(mode=\"list\", length=NG)\n        nclist_is_q <- rep.int(NA, NG)\n    }\n\n    ## Extract 'circle_length' (of length NG).\n    circle_length <- .get_circle_length(si)[q_group_idx]\n\n    ## Extract 'q_space' and 's_space'.\n    if (ignore.strand) {\n        q_space <- s_space <- NULL\n    } else {\n        q_space <- as.integer(strand(query)) - 3L\n        s_space <- as.integer(strand(subject)) - 3L\n    }\n\n    ## GO!\n    IRanges:::find_overlaps_in_groups_NCList(\n                          ranges(query), q_space, q_groups,\n                          ranges(subject), s_space, s_groups,\n                          nclists, nclist_is_q,\n                          maxgap, minoverlap, type, select, circle_length)\n}\n\n",
        "GPos-class.R": "### =========================================================================\n### GPos objects\n### -------------------------------------------------------------------------\n###\n\n\n### FIXME: Oct 6, 2023 -- With hindsight, I'm no longer convinced it was such\n### a good idea to make GPos a subclass of GRanges and to inherit its 'ranges'\n### slot. Maybe it would be cleaner to only contain GenomicPos, and to rename\n### the 'ranges' slot to 'pos'. This would be more consistent with the\n### IPos/IRanges relationship (IPos is not a subclass of IRanges). This\n### would also probably simplify greatly many of the acrobatics required\n### by the various coercion methods defined below in this file for switching\n### between GRanges and GPos/UnstitchedGPos/StitchedGPos. Finally this would\n### also mean that the specification of the 'ranges' slot in the definition\n### of the GRanges class could be set back to \"IRanges\" instead of\n### \"IRanges_OR_IPos\", and that the IRanges_OR_IPos class could go away.\n### Note that this would bring back the definition of the GRanges class from\n### the pre-GPos era. See GRanges-class.R.\nsetClass(\"GPos\",\n    contains=c(\"GenomicPos\", \"GRanges\"),\n    representation(\n        \"VIRTUAL\",\n        ranges=\"IPos\"\n    )\n)\n\nsetClass(\"UnstitchedGPos\",\n    contains=\"GPos\",\n    representation(\n        ranges=\"UnstitchedIPos\"\n    )\n)\n\nsetClass(\"StitchedGPos\",\n    contains=\"GPos\",\n    representation(\n        ranges=\"StitchedIPos\"\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.OLD_GPOS_INSTANCE_MSG <- c(\n    \"Starting with BioC 3.10, the class attribute of all \",\n    \"GPos **instances** needs to be set to \\\"StitchedGPos\\\". \",\n    \"Please update this object with 'updateObject(object, verbose=TRUE)' \",\n    \"and re-serialize it.\"\n)\n\n.validate_GPos <- function(x)\n{\n    if (class(x) == \"GPos\")\n        return(paste(.OLD_GPOS_INSTANCE_MSG, collapse=\"\"))\n\n    NULL\n}\n\nsetValidity2(\"GPos\", .validate_GPos)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"pos\", \"GPos\", function(x) pos(ranges(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Collapse runs of \"stitchable genomic ranges\"\n###\n### 2 genomic ranges are \"stitchable\" if, in addition to be stitchable from\n### an integer ranges point-of-view (see stitch_IntegerRanges() in\n### IRanges/R/IPos-class.R for what that means), they are also on the same\n### chromosome and strand.\n\n### stitch_GenomicRanges() below takes any GenomicRanges derivative and\n### returns a GRanges object (so is NOT an endomorphism). Note that this\n### transformation preserves 'sum(width(x))'.\n### Also note that this is an \"inter range transformation\". However unlike\n### range(), reduce(), gaps(), or disjoin(), its result depends on the order\n### of the elements in the input vector. It's also idempotent like range(),\n### reduce(), and disjoin() (gaps() is not).\n\n### TODO: Define and export stitch() generic and method for IntegerRanges\n### objects in the IRanges package (in inter-range-methods.R). Then make\n### stitch_GenomicRanges() and stitch_StitchedGPos() the \"stitch\" methods\n### for GenomicRanges and StitchedGPos objects, respectively, and support\n### the 'ignore.strand' argument.\n\n### To be as fast as possible, we don't use internal low-level constructor\n### new_GRanges() and we don't check the new object.\n.new_stitched_GRanges <- function(seqnames, ranges, strand, seqinfo)\n{\n    mcols <- make_zero_col_DFrame(length(ranges))\n    new2(\"GRanges\", seqnames=seqnames,\n                    ranges=ranges,\n                    strand=strand,\n                    elementMetadata=mcols,\n                    seqinfo=seqinfo,\n                    check=FALSE)\n}\n\nstitch_GenomicRanges <- function(x)\n{\n    if (length(x) == 0L)\n        return(granges(x, use.names=FALSE))  # returning GRanges() would loose\n                                             # the seqinfo\n\n    x_seqnames <- seqnames(x)\n    x_strand <- strand(x)\n    x_start <- start(x)\n    x_end <- end(x)\n\n    ## Find runs of stitchable elements along 'x'.\n    ## Each run is described by the indices of its first ('run_from') and\n    ## last ('run_to') elements in 'x'.\n    ## The runs form a partitioning of 'x'.\n    is_new_run <- x_seqnames[-1L] != x_seqnames[-length(x)] |\n                  x_strand[-1L] != x_strand[-length(x)] |\n                  Rle(x_start[-1L] != x_end[-length(x)] + 1L)\n    new_run_idx <- which(is_new_run)\n    run_from <- c(1L, new_run_idx + 1L)\n    run_to <- c(new_run_idx, length(x))\n\n    ans_ranges <- IRanges(x_start[run_from], x_end[run_to])\n    ans_seqnames <- x_seqnames[run_from]  # same as x_seqnames[run_to]\n    ans_strand <- x_strand[run_from]      # same as x_strand[run_to]\n    .new_stitched_GRanges(ans_seqnames, ans_ranges, ans_strand, seqinfo(x))\n}\n\nstitch_StitchedGPos <- function(x)\n{\n    if (length(x) == 0L)\n        return(granges(x, use.names=FALSE))  # returning GRanges() would loose\n                                             # the seqinfo\n\n    x_seqnames <- seqnames(x)\n    x_strand <- strand(x)\n\n    ## Find runs of identical (seqnames, strand) pairs along 'x'.\n    ## The runs are described by IRanges object 'runs'.\n    ## They form a partitioning of 'x'.\n    is_new_run <- x_seqnames[-1L] != x_seqnames[-length(x)] |\n                  x_strand[-1L] != x_strand[-length(x)]\n    new_run_idx <- which(is_new_run)\n    run_from <- c(1L, new_run_idx + 1L)\n    run_to <- c(new_run_idx, length(x))\n    runs <- IRanges(run_from, run_to)\n\n    ans_ranges <- IRanges:::extract_pos_runs_by_ranges(x@ranges@pos_runs, runs)\n    breakpoints <- cumsum(width(ans_ranges))\n    ans_seqnames <- x_seqnames[breakpoints]\n    ans_strand <- x_strand[breakpoints]\n    .new_stitched_GRanges(ans_seqnames, ans_ranges, ans_strand, seqinfo(x))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### High-level GPos constructor.\nGPos <- function(seqnames=NULL, pos=NULL, strand=NULL,\n                 ..., seqinfo=NULL, seqlengths=NULL, stitch=NA)\n{\n    mcols <- DataFrame(..., check.names=FALSE)\n\n    if (!is.null(pos)) {\n        pos <- IPos(pos, stitch=stitch)\n    } else if (is.null(seqnames)) {\n        pos <- IPos(stitch=stitch)\n    } else {\n        if (is(seqnames, \"GPos\")) {\n            x <- seqnames\n        } else {\n            x <- as(seqnames, \"GRanges\")\n        }\n        x_ranges <- x@ranges  # either IPos or IRanges\n        pos <- IPos(x_ranges, stitch=stitch)\n        seqnames <- x@seqnames\n        if (is(x_ranges, \"IRanges\"))  # i.e. 'x' is not a GPos\n            seqnames <- rep.int(seqnames, width(x_ranges))\n        if (is.null(strand)) {\n            strand <- x@strand\n            if (is(x_ranges, \"IRanges\"))  # i.e. 'x' is not a GPos\n                strand <- rep.int(strand, width(x_ranges))\n        }\n        if (length(mcols) == 0L && is(x, \"GPos\"))\n            mcols <- mcols(x, use.names=FALSE)\n        if (is.null(seqinfo))\n            seqinfo <- seqinfo(x)\n    }\n\n    seqinfo <- normarg_seqinfo2(seqinfo, seqlengths)\n\n    ## We use as.character() to get rid of the \"package\" attribute on the\n    ## class name returned by class(pos).\n    Class <- sub(\"IPos$\", \"GPos\", as.character(class(pos)))\n\n    new_GRanges(Class, seqnames=seqnames, ranges=pos, strand=strand,\n                       mcols=mcols, seqinfo=seqinfo)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n.try_to_coerce_to_GRanges_first <- function(from, to)\n{\n    if (is(from, \"GRanges\"))\n        return(from)\n    from <- try(as(from, \"GRanges\"), silent=TRUE)\n    if (inherits(from, \"try-error\"))\n        stop(wmsg(\"object to coerce to \", to, \" \",\n                  \"couldn't be coerced to GRanges first\"))\n    from\n}\n.check_GenomicRanges_for_coercion_to_GPos <- function(from, to)\n{\n    if (!all(width(from) == 1L))\n        stop(wmsg(\"all the ranges in the object to \",\n                  \"coerce to \", to, \" must have a width of 1\"))\n}\n.from_ANY_to_UnstitchedGPos <- function(from)\n{\n    from <- .try_to_coerce_to_GRanges_first(from, \"UnstitchedGPos\")\n    .check_GenomicRanges_for_coercion_to_GPos(from, \"UnstitchedGPos\")\n    class(from) <- \"UnstitchedGPos\"  # temporarily broken instance!\n    from@ranges <- as(from@ranges, \"UnstitchedIPos\")  # now fixed :-)\n    from\n}\n.from_ANY_to_StitchedGPos <- function(from)\n{\n    from <- .try_to_coerce_to_GRanges_first(from, \"StitchedGPos\")\n    .check_GenomicRanges_for_coercion_to_GPos(from, \"StitchedGPos\")\n    class(from) <- \"StitchedGPos\"  # temporarily broken instance!\n    from@ranges <- as(from@ranges, \"StitchedIPos\")  # now fixed :-)\n    from\n}\nsetAs(\"ANY\", \"UnstitchedGPos\", .from_ANY_to_UnstitchedGPos)\nsetAs(\"ANY\", \"StitchedGPos\", .from_ANY_to_StitchedGPos)\nsetAs(\"ANY\", \"GPos\", .from_ANY_to_UnstitchedGPos)\n\n### Yes, we also need to define the 3 coercion methods below, even though\n### they seem redundant with the 3 coercion methods above. This is because\n### the oh-so-smart methods package wants to automatically define these\n### coercion methods in case they are not explicitly defined by the user.\n### Unfortunately, and not too surprisingly, these automatic coercion\n### methods get it wrong! How could they possibly know what they are doing?\nsetAs(\"GRanges\", \"UnstitchedGPos\", .from_ANY_to_UnstitchedGPos)\nsetAs(\"GRanges\", \"StitchedGPos\", .from_ANY_to_StitchedGPos)\nsetAs(\"GRanges\", \"GPos\", .from_ANY_to_UnstitchedGPos)\n\n### Of course we want 'as(UnstitchedGPos, \"GRanges\", strict=FALSE)' and\n### 'as(StitchedGPos, \"GRanges\", strict=FALSE)' to do the right thing\n### (i.e. to be no-ops), but, unfortunately, as() won't do that if\n### coerce,UnstitchedGPos,GRanges and coerce,StitchedGPos,GRanges methods\n### are defined, because, in this case, as() will **always** call the\n### method, EVEN WHEN strict=FALSE AND THE OBJECT TO COERCE ALREADY DERIVES\n### FROM THE TARGET CLASS! (This is a serious flaw in as() current\n### design/implementation but I wouldn't be surprised if someone argued\n### that this is a feature and working as intended.)\n### Anyway, a workaround is to support the 'strict=FALSE' case at the level\n### of the coerce() method itself. However setAs() doesn't let us do that\n### so this is why we use setMethod(\"coerce\", ...) to define these methods.\nfrom_GPos_to_GRanges <- function(from, to=\"GRanges\", strict=TRUE)\n{\n    if (!isTRUEorFALSE(strict))\n        stop(\"'strict' must be TRUE or FALSE\")\n    if (!strict)\n        return(from)\n    class(from) <- class(new(\"GRanges\"))  # temporarily broken instance!\n    from@ranges <- as(from@ranges, \"IRanges\")  # now fixed :-)\n    from\n}\nsetMethod(\"coerce\", c(\"UnstitchedGPos\", \"GRanges\"), from_GPos_to_GRanges)\nsetMethod(\"coerce\", c(\"StitchedGPos\", \"GRanges\"), from_GPos_to_GRanges)\n### One might think that defining the coerce,GPos,GRanges method below would\n### cover the UnstitchedGPos->GRanges and StitchedGPos->GRanges cases, but no\n### such luck! Again, this is because the oh-so-smart methods package wants\n### to automatically define the 2 coercion methods above in case they are not\n### explicitly defined by the user. And once again, these automatic coercion\n### methods get it wrong!\n### For the same reason, UnstitchedGPos or StitchedGPos extensions (like the\n### CTSS class in the CAGEr package) need to define a coercion method to\n### GRanges otherwise they'll also get a broken automatic coercion method.\n### They can do this with (from_GPos_to_GRanges is exported):\n###   setMethod(\"coerce\", c(\"CTSS\", \"GRanges\"), from_GPos_to_GRanges)\n#setMethod(\"coerce\", c(\"GPos\", \"GRanges\"), from_GPos_to_GRanges)\n\n### S3/S4 combo for as.data.frame.GPos\n### The \"as.data.frame\" method for GenomicRanges objects works on a GPos\n### object but returns a data.frame with identical \"start\" and \"end\" columns,\n### and a \"width\" column filled with 1. We overwrite it to return a data.frame\n### with a \"pos\" column instead of the \"start\" and \"end\" columns, and no\n### \"width\" column.\n.as.data.frame.GPos <- function(x, row.names=NULL, optional=FALSE)\n{\n    ans <- data.frame(seqnames=as.factor(seqnames(x)),\n                      pos=pos(x),\n                      strand=as.factor(strand(x)),\n                      row.names=row.names,\n                      stringsAsFactors=FALSE)\n    x_mcols <- mcols(x, use.names=FALSE)  # always a DataFrame parallel to 'x'\n    cbind(ans, as.data.frame(x_mcols, optional=optional))\n}\nas.data.frame.GPos <- function(x, row.names=NULL, optional=FALSE, ...)\n    .as.data.frame.GPos(x, row.names=NULL, optional=FALSE, ...)\nsetMethod(\"as.data.frame\", \"GPos\", .as.data.frame.GPos)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n### Internal representation of GPos objects has changed in GenomicRanges\n### 1.29.10 (Bioc 3.6).\n###\n\n.get_GPos_version <- function(object)\n{\n    if (class(object) != \"GPos\")\n        return(\"current\")\n\n    if (!.hasSlot(object, \"pos_runs\"))\n        return(\">= 1.29.10 and < 1.37.7\")\n\n    return(\"< 1.29.10\")\n}\n\nsetMethod(\"updateObject\", \"GPos\",\n    function(object, ..., verbose=FALSE)\n    {\n        version <- .get_GPos_version(object)\n        if (.hasSlot(object, \"pos_runs\")) {\n            if (verbose)\n                message(\"[updateObject] \", class(object), \" object \",\n                        \"uses internal representation from\\n\",\n                        \"[updateObject] GenomicRanges \", version, \". \",\n                        \"Updating it ... \", appendLF=FALSE)\n            ans <- GPos(object@pos_runs)\n            mcols(ans) <- mcols(object)\n            metadata(ans) <- metadata(object)\n            if (verbose)\n                message(\"OK\")\n            return(ans)\n        }\n        if (class(object) == \"GPos\") {\n            if (verbose)\n                message(\"[updateObject] Settting class attribute of GPos \",\n                        \"instance to \\\"StitchedGPos\\\" ... \", appendLF=FALSE)\n            class(object) <- class(new(\"StitchedGPos\"))\n            if (verbose)\n                message(\"OK\")\n        }\n        if (IRanges:::get_IPos_version(object@ranges) == \"current\" && verbose) {\n            message(\"[updateObject] Internal representation of \",\n                    class(object), \" object is current.\\n\",\n                    \"[updateObject] Nothing to update.\")\n        }\n\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.GPos\nsummary.GPos <- summary.IPos\nsetMethod(\"summary\", \"GPos\", summary.GPos)\n\n.from_GPos_to_naked_character_matrix_for_display <- function(x)\n{\n    m <- cbind(seqnames=showAsCell(seqnames(x)),\n               pos=showAsCell(pos(x)),\n               strand=showAsCell(strand(x)))\n    cbind_mcols_for_display(m, x)\n}\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"GPos\",\n    .from_GPos_to_naked_character_matrix_for_display\n)\n\nshow_GPos <- function(x, margin=\"\",\n                      print.classinfo=FALSE, print.seqinfo=FALSE)\n{\n    version <- .get_GPos_version(x)\n    if (version != \"current\")\n        stop(c(wmsg(\"This \", class(x), \" object uses internal representation \",\n                    \"from GenomicRanges \", version, \", and so needs to be \",\n                    \"updated before it can be displayed or used. \",\n                    \"Please update it with:\"),\n               \"\\n\\n    object <- updateObject(object, verbose=TRUE)\",\n               \"\\n\\n  and re-serialize it.\"))\n    cat(margin, summary(x), \":\\n\", sep=\"\")\n    ## makePrettyMatrixForCompactPrinting() assumes that head() and tail()\n    ## work on 'x'.\n    out <- makePrettyMatrixForCompactPrinting(x)\n    if (print.classinfo) {\n        .COL2CLASS <- c(\n            seqnames=\"Rle\",\n            pos=\"integer\",\n            strand=\"Rle\"\n        )\n        classinfo <- makeClassinfoRowForCompactPrinting(x, .COL2CLASS)\n        ## A sanity check, but this should never happen!\n        stopifnot(identical(colnames(classinfo), colnames(out)))\n        out <- rbind(classinfo, out)\n    }\n    if (nrow(out) != 0L)\n        rownames(out) <- paste0(margin, \"  \", rownames(out))\n    ## We set 'max' to 'length(out)' to avoid the getOption(\"max.print\")\n    ## limit that would typically be reached when 'showHeadLines' global\n    ## option is set to Inf.\n    print(out, quote=FALSE, right=TRUE, max=length(out))\n    if (print.seqinfo) {\n        cat(margin, \"  -------\\n\", sep=\"\")\n        cat(margin, \"  seqinfo: \", summary(seqinfo(x)), \"\\n\", sep=\"\")\n    }\n}\n\nsetMethod(\"show\", \"GPos\",\n    function(object)\n        show_GPos(object, print.classinfo=TRUE, print.seqinfo=TRUE)\n)\n\n",
        "GRanges-class.R": "### =========================================================================\n### GRanges objects\n### -------------------------------------------------------------------------\n###\n\n\nsetClassUnion(\"IRanges_OR_IPos\", c(\"IRanges\", \"IPos\"))\n\nsetClass(\"GRanges\",\n    contains=\"GenomicRanges\",\n    representation(\n        seqnames=\"Rle\",\n        ranges=\"IRanges_OR_IPos\",  # an IPos only for GPos\n        strand=\"Rle\",\n        seqinfo=\"Seqinfo\"\n    ),\n    prototype(\n        seqnames=Rle(factor()),\n        strand=Rle(strand())\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel_slot_names()\n###\n\n### Combine the new \"parallel slots\" with those of the parent class. Make\n### sure to put the new parallel slots **first**. See R/Vector-class.R file\n### in the S4Vectors package for what slots should or should not be considered\n### \"parallel\".\nsetMethod(\"parallel_slot_names\", \"GRanges\",\n    #function(x) c(\"seqnames\", \"ranges\", \"strand\", callNextMethod())\n\n    ## TEMPORARY DEFINITION.\n    ## TODO: Remove this temporary definition and add parallel_slot_names()\n    ## methods to all packages that define extraColumnSlotNames() methods\n    ## (e.g. VariantAnnotation, GenomicTuples, InteractionSet, SGSeq).\n    function(x) c(extraColumnSlotNames(x), \"seqnames\", \"ranges\", \"strand\",\n                  callNextMethod())\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.valid.GRanges.ranges <- function(x)\n{\n    if (!is.null(x@ranges@elementMetadata))\n        return(\"slot 'ranges' cannot have metadata columns\")\n    NULL\n}\n\n.valid.GRanges.mcols <- function(x)\n{\n    x_mcols <- x@elementMetadata\n    if (!is.null(rownames(x_mcols)))\n        return(\"'mcols(x)' cannot have row names\")\n    NULL\n}\n\n.valid.GRanges <- function(x)\n{\n    c(.valid.GRanges.ranges(x), .valid.GRanges.mcols(x))\n}\n\nsetValidity2(\"GRanges\", .valid.GRanges)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n### Internal representation of GRanges objects has changed in GenomicRanges\n### 1.31.16 (Bioc 3.7).\n###\n\n.get_GRanges_version <- function(object)\n{\n    if (.hasSlot(object, \"elementType\")) \"current\" else \"< 1.31.16\"\n}\n\nsetMethod(\"updateObject\", \"GRanges\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## elementType slot.\n        version <- .get_GRanges_version(object)\n        if (version == \"current\") {\n            if (verbose)\n                message(\"[updateObject] Internal representation of \",\n                        class(object), \" object is current.\\n\",\n                        \"[updateObject] Nothing to update.\")\n        } else {\n            if (verbose)\n                message(\"[updateObject] \", class(object), \" object \",\n                        \"uses internal representation from\\n\",\n                        \"[updateObject] GenomicRanges \", version, \". \",\n                        \"Updating it ... \", appendLF=FALSE)\n            object@elementType <- new(class(object))@elementType\n            if (verbose)\n                message(\"OK\")\n        }\n\n        ## ranges slot.\n        object@ranges <- updateObject(object@ranges, ..., verbose=verbose)\n\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"update\" method\n###\n\n### Having update() redirect to BiocGenerics:::replaceSlots() on GRanges\n### objects makes all the methods for GenomicRanges objects defined in\n### R/GenomicRanges-class.R work on GRanges objects.\nsetMethod(\"update\", \"GRanges\",\n    function(object, ...)\n    {\n        ## Fix old GRanges instances on-the-fly.\n        object <- updateObject(object, check=FALSE)\n        BiocGenerics:::replaceSlots(object, ...)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### Internal low-level constructor. Used by high-level GRanges/GPos\n### constructors. Not meant to be used directly by the end user.\n### NOTE: 'ranges' is trusted! (should have been checked by the caller).\nnew_GRanges <- function(Class, seqnames=NULL, ranges=NULL, strand=NULL,\n                               mcols=NULL, seqinfo=NULL)\n{\n    seqnames <- normarg_seqnames1(seqnames)\n\n    if (is.null(seqinfo)) {\n        seqinfo <- Seqinfo(levels(seqnames))\n    } else {\n        seqinfo <- normarg_seqinfo1(seqinfo)\n        seqnames <- normarg_seqnames2(seqnames, seqinfo)\n    }\n\n    seqnames_len <- length(seqnames)\n    strand <- normarg_strand(strand, seqnames_len)\n\n    ranges_len <- length(ranges)\n    strand_len <- length(strand)\n    ans_len <- max(seqnames_len, ranges_len, strand_len)\n    if (ans_len != 0L) {\n        stop_if_wrong_length <- function(what, ans_len)\n            stop(wmsg(what, \" must have the length of the object \",\n                      \"to construct (\", ans_len, \") or length 1\"))\n        if (seqnames_len == 0L)\n            stop_if_wrong_length(\"'seqnames'\", ans_len)\n        if (ranges_len == 0L) {\n            what <- if (is(ranges, \"IPos\")) \"'pos'\" else \"'ranges'\"\n            stop_if_wrong_length(what, ans_len)\n        }\n        if (strand_len == 0L)\n            stop_if_wrong_length(\"'strand'\", ans_len)\n        if (ans_len > 1L) {\n            if (seqnames_len == 1L)\n                seqnames <- rep(seqnames, ans_len)\n            else if (seqnames_len != ans_len)\n                stop_if_wrong_length(\"'seqnames'\", ans_len)\n            if (ranges_len == 1L)\n                ranges <- rep(ranges, ans_len)\n            else if (ranges_len != ans_len) {\n                what <- if (is(ranges, \"IPos\")) \"'pos'\" else \"'ranges'\"\n                stop_if_wrong_length(what, ans_len)\n            }\n            if (strand_len == 1L)\n                strand <- rep(strand, ans_len)\n            else if (strand_len != ans_len)\n                stop_if_wrong_length(\"'strand'\", ans_len)\n        }\n    }\n\n    ## From now on, 'seqnames', 'ranges', and 'strand' are guaranteed\n    ## to be of length 'ans_len'.\n\n    if (length(mcols) == 0L)\n        mcols <- mcols(ranges, use.names=FALSE)\n    mcols <- S4Vectors:::normarg_mcols(mcols, Class, ans_len)\n\n    if (!is.null(mcols(ranges, use.names=FALSE)))\n        mcols(ranges) <- NULL\n    if (!is.null(rownames(mcols))) {\n        if (is.null(names(ranges)))\n            names(ranges) <- rownames(mcols)\n        rownames(mcols) <- NULL\n    }\n\n    new2(Class, seqnames=seqnames, ranges=ranges, strand=strand,\n                elementMetadata=mcols, seqinfo=seqinfo, check=FALSE)\n}\n\n### High-level GRanges constructor.\nGRanges <- function(seqnames=NULL, ranges=NULL, strand=NULL,\n                    ..., seqinfo=NULL, seqlengths=NULL)\n{\n    mcols <- DataFrame(..., check.names=FALSE)\n\n    if (!is.null(ranges)) {\n        ranges <- as(ranges, \"IRanges\")\n    } else if (is.null(seqnames)) {\n        ranges <- IRanges()\n    } else {\n        ## The user supplied the 'seqnames' argument but not the 'ranges'\n        ## argument. This typically happens when they call GRanges() on a\n        ## GenomicRanges derivative (e.g. on a GPos object) or on something\n        ## that is expected to be coercible to GRanges. Note that, in this\n        ## case, the GRanges() constructor still allows the user to supply\n        ## additional arguments to alter the result of the coercion to GRanges,\n        ## e.g. 'GRanges(<GPos>, strand=\"+\")'.\n        ans <- as(seqnames, \"GRanges\")\n        ok1 <- is.null(strand)\n        ok2 <- length(mcols) == 0L\n        ok3 <- is.null(seqinfo)\n        ok4 <- is.null(seqlengths)\n        if (ok1 && ok2 && ok3 && ok4) {\n            ## The user supplied no additional arguments.\n            return(ans)  # return 'ans' as-is\n        }\n        ## The user supplied additional arguments so 'ans' needs to be\n        ## altered accordingly. Instead of trying to do this by calling\n        ## various setters on the object, we will let new_GRanges() reconstruct\n        ## it below. This way the alteration is atomic instead of incremental,\n        ## so will generate less copies of the object, and therefore it should\n        ## be more efficient.\n        seqnames <- ans@seqnames\n        ranges <- ans@ranges\n        if (ok1)\n            strand <- strand(ans)\n        if (ok2)\n            mcols <- mcols(ans, use.names=FALSE)\n        if (ok3)\n            seqinfo <- seqinfo(ans)\n        if (ok4)\n            seqlengths <- seqlengths(ans)\n    }\n\n    seqinfo <- normarg_seqinfo2(seqinfo, seqlengths)\n\n    ans <- new_GRanges(\"GRanges\", seqnames=seqnames,\n                                  ranges=ranges, strand=strand,\n                                  mcols=mcols, seqinfo=seqinfo)\n    ## new_GRanges() doesn't check validity so we do it here. Note that 'ans'\n    ## should be valid except for the silly INVALID.GR.COLNAMES restriction.\n    ## If it wasn't for this restriction, we actually wouldn't need to\n    ## validate 'ans'.\n    validObject(ans)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"seqnames\", \"GRanges\", function(x) x@seqnames)\n\nsetMethod(\"strand\", \"GRanges\", function(x) x@strand)\n\nsetMethod(\"seqinfo\", \"GRanges\", function(x) x@seqinfo)\n\n### Range squeezer.\nsetMethod(\"ranges\", \"GRanges\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(wmsg(\"'use.names' must be TRUE or FALSE\"))\n        if (!isTRUEorFALSE(use.mcols))\n            stop(wmsg(\"'use.mcols' must be TRUE or FALSE\"))\n        ## We call updateObject() in case 'x@ranges' is an old IPos object\n        ## (see updateObject() method for IPos objects).\n        ans <- updateObject(x@ranges, check=FALSE)\n        if (!use.names)\n            names(ans) <- NULL\n        if (use.mcols)\n            mcols(ans) <- mcols(x, use.names=FALSE)\n        ans\n    }\n)\n\n### Genomic range squeezer.\nsetMethod(\"granges\", \"GenomicRanges\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.mcols))\n            stop(wmsg(\"'use.mcols' must be TRUE or FALSE\"))\n        ans <- GRanges(seqnames(x),\n                       ranges(x, use.names=use.names),\n                       strand(x),\n                       seqinfo=seqinfo(x))\n        if (use.mcols)\n            mcols(ans) <- cbind(extraColumnSlotsAsDF(x),\n                                mcols(x, use.names=FALSE))\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\nsetAs(\"GenomicRanges\", \"GRanges\",\n    function(from) granges(from, use.mcols=TRUE)\n)\n\n.from_character_to_GRanges <- function(from)\n{\n    stopifnot(is.character(from))\n    if (anyNA(from))\n        stop(wmsg(\"converting a character vector to a GRanges object \",\n                  \"does not support NAs\"))\n    error_msg <- c(\n        \"The character vector to convert to a GRanges object must contain \",\n        \"strings of the form \\\"chr:start-end\\\" or \\\"chr:start-end:strand\\\", \",\n        \"with end >= start - 1, or \\\"chr:pos\\\" or \\\"chr:pos:strand\\\". \",\n        \"For example: \\\"chr1:2501-2900\\\", \\\"chr1:2501-2900:+\\\", or \",\n        \"\\\"chr1:740\\\". Note that \\\"..\\\" is a valid alternate start/end \",\n        \"separator. Strand can be \\\"+\\\", \\\"-\\\", \\\"*\\\", or missing.\"\n    )\n    split0 <- CharacterList(strsplit(from, \":\", fixed=TRUE))\n    split0_eltNROWS <- elementNROWS(split0)\n    if (S4Vectors:::anyMissingOrOutside(split0_eltNROWS, 2L, 3L))\n        stop(wmsg(error_msg))\n    ans_strand <- as.character(tails(split0, n=-2L))\n    ans_strand[is.na(ans_strand)] <- \"*\"\n    split1 <- heads(split0, n=2L)\n    ans_seqnames <- as.character(heads(split1, n=1L))\n    ranges <- tails(split1, n=-1L)\n    ranges <- setNames(as.character(ranges), names(ranges))\n    ans_ranges <- try(as(ranges, \"IRanges\"), silent=TRUE)\n    if (is(ans_ranges, \"try-error\"))\n        stop(wmsg(error_msg))\n    GRanges(ans_seqnames, ans_ranges, ans_strand)\n}\nsetAs(\"character\", \"GRanges\", .from_character_to_GRanges)\n\n.from_factor_to_GRanges <- function(from)\n{\n    from <- setNames(as.character(from), names(from))\n    .from_character_to_GRanges(from)\n}\nsetAs(\"factor\", \"GRanges\", .from_factor_to_GRanges)\n\n### Does NOT propagate the ranges names and metadata columns i.e. always\n### returns an unnamed GRanges object with no metadata columns.\nsetAs(\"IntegerRangesList\", \"GRanges\",\n      function(from)\n      {\n        if (!length(from))\n          return(GRanges())\n        from <- as(from, \"CompressedIRangesList\")\n        ranges <- unlist(from, use.names=FALSE)\n        ranges <- IRanges(start=start(ranges), width=width(ranges))\n        ## From now, ranges is guaranteed to be an IRanges *instance*.\n        if (is.null(space(from))) {\n          stop(wmsg(\"cannot create GRanges when 'space(from)' is NULL\"))\n        }\n        gr <- GRanges(seqnames = space(from),\n                      ranges = ranges,\n                      strand = Rle(\"*\", length(ranges)),\n                      seqinfo = seqinfo(from))\n        metadata(gr) <- metadata(from)\n        gr\n      })\n\n.from_Seqinfo_to_GRanges <- function(from)\n{\n    if (anyNA(seqlengths(from)))\n        stop(wmsg(\"cannot create a GRanges object \",\n                  \"from a Seqinfo object with NA seqlengths\"))\n    GRanges(seqnames(from),\n            IRanges(rep.int(1L, length(from)),\n                    width=seqlengths(from),\n                    names=seqnames(from)),\n            seqinfo=from)\n}\n\nsetAs(\"Seqinfo\", \"GRanges\", .from_Seqinfo_to_GRanges)\n\nsetAs(\"Seqinfo\", \"IntegerRangesList\",\n    function(from) as(as(from, \"GRanges\"), \"IntegerRangesList\")\n)\n\nsetAs(\"ANY\", \"GenomicRanges\", function(from) as(from, \"GRanges\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n\n.DollarNames.GRanges <- .DollarNames.GenomicRanges\n\nsetMethod(\"replaceROWS\", \"GRanges\",\n    function(x, i, value)\n    {\n        i <- normalizeSingleBracketSubscript(i, x, as.NSBS=TRUE)\n        seqinfo(x) <- merge(seqinfo(x), seqinfo(value))\n        ans_seqnames <- replaceROWS(seqnames(x), i, seqnames(value))\n        ans_ranges <- replaceROWS(ranges(x), i, ranges(value))\n        ans_strand <- replaceROWS(strand(x), i, strand(value))\n        ans_mcols <- replaceROWS(mcols(x, use.names=FALSE), i,\n                                 mcols(value, use.names=FALSE))\n        ans_ecs_names <- extraColumnSlotNames(x)\n        ans_necs <- length(ans_ecs_names)\n        if (ans_necs == 0L) {\n            ans_ecs <- NULL\n        } else {\n            value_ecs_names <- extraColumnSlotNames(value)\n            if (!identical(head(value_ecs_names, n=ans_necs),\n                           ans_ecs_names))\n                stop(wmsg(\"'value' can have more extra column slots \",\n                          \"but not less\"))\n            ans_ecs <- extraColumnSlotsAsDF(x)\n            value_ecs <- extraColumnSlotsAsDF(value)\n            ans_ecs <- replaceROWS(ans_ecs, i, value_ecs[seq_len(ans_necs)])\n        }\n        BiocGenerics:::replaceSlots(x, seqnames=ans_seqnames,\n                                       ranges=ans_ranges,\n                                       strand=ans_strand,\n                                       elementMetadata=ans_mcols,\n                                       .slotList=as.list(ans_ecs))\n    }\n)\n\n",
        "GRangesFactor-class.R": "### =========================================================================\n### GRangesFactor objects\n### -------------------------------------------------------------------------\n###\n### Factor objects with GRanges levels.\n###\n\nsetClass(\"GRangesFactor\",\n    contains=\"Factor\",\n    representation(\n        levels=\"GRanges\",\n        elementMetadata=\"DataFrame\"\n    ),\n    prototype(\n        elementMetadata=new(\"DFrame\")\n    )\n)\n\nsetMethod(\"FactorToClass\", \"GRanges\", function(x) \"GRangesFactor\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n### Factor() works but this specialized GRangesFactor constructor adds some\n### minor convenience and extra checks.\n###\n\nGRangesFactor <- function(x, levels, index=NULL, ...)\n{\n    if (missing(x) && missing(levels) && missing(levels))\n        return(Factor(levels=GRanges(), index=integer(0), ...))\n    if (!(missing(x) || is(x, \"GRanges\")))\n        stop(wmsg(\"'x' must be a GRanges object\"))\n    if (!(missing(levels) || is(levels, \"GRanges\")))\n        stop(wmsg(\"'levels' must be a GRanges object\"))\n    Factor(x, levels, index=index, ...)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"seqnames\", \"GRangesFactor\",\n    function(x) extractROWS(seqnames(levels(x)), x@index)\n)\n\nsetMethod(\"start\", \"GRangesFactor\",\n    function(x) extractROWS(start(levels(x)), x@index)\n)\n\nsetMethod(\"end\", \"GRangesFactor\",\n    function(x) extractROWS(end(levels(x)), x@index)\n)\n\nsetMethod(\"width\", \"GRangesFactor\",\n    function(x) extractROWS(width(levels(x)), x@index)\n)\n\nsetMethod(\"pos\", \"GRangesFactor\",\n    function(x) extractROWS(pos(levels(x)), x@index)\n)\n\nsetMethod(\"strand\", \"GRangesFactor\",\n    function(x, ...) extractROWS(strand(levels(x), ...), x@index)\n)\n\nsetMethod(\"seqinfo\", \"GRangesFactor\", function(x) seqinfo(levels(x)))\n\nsetMethod(\"granges\", \"GRangesFactor\",\n    function(x, use.names=TRUE, use.mcols=FALSE, ...)\n        granges(unfactor(x), use.names=use.names, use.mcols=use.mcols, ...)\n)\n\nsetMethod(\"ranges\", \"GRangesFactor\",\n    function(x, use.names=TRUE, use.mcols=FALSE, ...)\n        ranges(unfactor(x), use.names=use.names, use.mcols=use.mcols, ...)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n### In addition to the basic coercions defined for Factor objects, we\n### support coercion back and forth between GRanges and GRangesFactor.\n###\n\nsetAs(\"ANY\", \"GRangesFactor\",\n    function(from)\n    {\n        if (!is(from, \"GRanges\"))\n            from <- as(from, \"GRanges\")\n        as(from, \"Factor\")\n    }\n)\n\nsetAs(\"Factor\", \"GRanges\",\n    function(from)\n    {\n        ans <- unfactor(from)\n        if (!is(ans, \"GRanges\"))\n            ans <- as(ans, \"GRanges\")\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show\n###\n\n.print_levels <- function(levels, margin=\"\", max.print.levels=20L)\n{\n    nlevels <- length(levels)\n    cat(margin, nlevels, \" \", if (nlevels == 1L) \"level\" else \"levels\", sep=\"\")\n    if (nlevels == 0L) {\n        cat(\"\\n\")\n        return(invisible(NULL))\n    }\n    cat(\":\\n\")\n    if (nlevels > max.print.levels) {\n        level_strings <- as.character(head(levels, n=max.print.levels-1L))\n        level_strings <- c(unname(level_strings), \"...\")\n    } else {\n        level_strings <- unname(as.character(levels))\n    }\n    levels_margin <- paste0(margin, \"  \")\n    old_width <- getOption(\"width\")\n    new_width <- old_width - nchar(levels_margin)\n    options(width=new_width)\n    on.exit(options(width=old_width))\n    out <- capture.output(print(level_strings, quote=FALSE))\n    if (nlevels > max.print.levels) {\n        footer <- paste0(\" ... \", nlevels - max.print.levels + 1L,\n                         \" more levels ...\")\n        out <- c(out, footer)\n    }\n    options(width=old_width)\n    out <- paste0(levels_margin, out)\n    cat(out, sep=\"\\n\")\n}\n\n.show_GRangesFactor <- function(x, margin=\"\",\n                                print.classinfo=FALSE, print.seqinfo=FALSE)\n{\n    show_GenomicRanges(x, margin=margin,\n                       print.classinfo=print.classinfo,\n                       print.seqinfo=print.seqinfo)\n    .print_levels(levels(x), margin=margin, 20L)\n}\n\nsetMethod(\"show\", \"GRangesFactor\",\n    function(object)\n        .show_GRangesFactor(object, print.classinfo=TRUE)\n)\n\n",
        "GRangesList-class.R": "### =========================================================================\n### GRangesList objects\n### -------------------------------------------------------------------------\n###\n\n\nsetClass(\"GRangesList\",\n    contains=\"GenomicRangesList\",\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"GRanges\")\n)\n\nsetClass(\"SimpleGRangesList\",\n    contains=c(\"GRangesList\", \"SimpleGenomicRangesList\")\n)\n\nsetClass(\"CompressedGRangesList\",\n    contains=c(\"GRangesList\", \"CompressedGenomicRangesList\"),\n    representation(unlistData=\"GRanges\")\n)\n\n### TODO: Get rid of this! Used in RangedSummarizedExperiment class definition\n### to specify the class of the 'rowRanges' slot and was originally introduced\n### to support this use case. However, more packages use it these days e.g.\n### DEFormats, GenomicFiles, ggbio, gmapR, HelloRanges, profileplyr, and maybe\n### more... Everybody now should use GenomicRanges_OR_GenomicRangesList instead\n### of GenomicRanges_OR_GRangesList.\nsetClassUnion(\"GenomicRanges_OR_GRangesList\", c(\"GenomicRanges\", \"GRangesList\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Link GRanges to CompressedGRangesList\n###\n### Used by splitAsList() and family (e.g. relist(), extractList(), etc...)\n### to infer the class of the output when the input is a GRanges object or\n### derivative.\n###\n\nsetMethod(\"relistToClass\", \"GRanges\", function(x) \"CompressedGRangesList\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructors\n###\n\nGRangesList <- function(..., compress=TRUE)\n{\n    if (!isTRUEorFALSE(compress))\n        stop(\"'compress' must be TRUE or FALSE\")\n    objects <- list(...)\n    if (length(objects) == 1L) {\n        tmp <- objects[[1L]]\n        if (is.list(tmp) || (is(tmp, \"List\") && !is(tmp, \"GenomicRanges\")))\n            objects <- tmp\n    }\n    if (compress)\n        suppressWarnings(as(objects, \"CompressedGRangesList\"))\n    else\n        as(objects, \"SimpleGRangesList\")\n}\n\n### Typically, the field values will come from a file that needs to be loaded\n### into a data.frame first.\nmakeGRangesListFromFeatureFragments <- function(seqnames=Rle(factor()),\n                                                fragmentStarts=list(),\n                                                fragmentEnds=list(),\n                                                fragmentWidths=list(),\n                                                strand=character(0),\n                                                sep=\",\")\n{\n    fragmentStarts <- normarg_list_of_integers(fragmentStarts, sep,\n                                               \"fragmentStarts\")\n    nfrag_per_feature <- elementNROWS(fragmentStarts)\n    start <- unlist(fragmentStarts, recursive=FALSE, use.names=FALSE)\n\n    fragmentEnds <- normarg_list_of_integers(fragmentEnds, sep,\n                                             \"fragmentEnds\")\n    nend_per_elt <- elementNROWS(fragmentEnds)\n    if (length(nend_per_elt) != 0L) {\n        if (length(nfrag_per_feature) == 0L)\n            nfrag_per_feature <- nend_per_elt\n        else if (!identical(nend_per_elt, nfrag_per_feature))\n            stop(\"'fragmentStarts' and 'fragmentEnds' have \",\n                 \"incompatible \\\"shapes\\\"\")\n    }\n    end <- unlist(fragmentEnds, recursive=FALSE, use.names=FALSE)\n\n    fragmentWidths <- normarg_list_of_integers(fragmentWidths, sep,\n                                               \"fragmentWidths\")\n    nwidth_per_elt <- elementNROWS(fragmentWidths)\n    if (length(nwidth_per_elt) != 0L) {\n        if (length(nfrag_per_feature) == 0L)\n            nfrag_per_feature <- nwidth_per_elt\n        else if (!identical(nwidth_per_elt, nfrag_per_feature))\n            stop(\"\\\"shape\\\" of 'fragmentWidths' is incompatible \",\n                 \"with \\\"shape\\\" of 'fragmentStarts' or 'fragmentEnds'\")\n    }\n    width <- unlist(fragmentWidths, recursive=FALSE, use.names=FALSE)\n\n    ranges <- IRanges(start=start, end=end, width=width)\n    nfrag <- sum(nfrag_per_feature)\n    if (nfrag != length(ranges))\n        stop(\"GenomicRanges internal error in makeGRangesListFromFields(): \",\n             \"nfrag != length(ranges). This should never happen. \",\n             \"Please report.\")\n    if (nfrag == 0L) {\n        ## Cannot blindly subset by FALSE because it doesn't work on a\n        ## zero-length Rle.\n        if (length(seqnames) != 0L)\n            seqnames <- seqnames[FALSE]\n        if (length(strand) != 0L)\n            strand <- strand[FALSE]\n    } else {\n        if (length(seqnames) != length(nfrag_per_feature) ||\n            length(strand) != length(nfrag_per_feature))\n            stop(\"length of 'seqnames' and/or 'strand' is incompatible \",\n                 \"with fragmentStarts/Ends/Widths\")\n        seqnames <- rep.int(seqnames, nfrag_per_feature)\n        strand <- rep.int(strand, nfrag_per_feature)\n    }\n    unlistData <- GRanges(seqnames=seqnames, ranges=ranges, strand=strand)\n    partitioning <- PartitioningByEnd(cumsum(nfrag_per_feature), names=NULL)\n    relist(unlistData, partitioning)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Accessors\n###\n\nsetMethod(\"ranges\", \"CompressedGRangesList\",\n    function(x, use.names=TRUE, use.mcols=FALSE)\n    {\n        if (!isTRUEorFALSE(use.names))\n            stop(\"'use.names' must be TRUE or FALSE\")\n        if (!isTRUEorFALSE(use.mcols))\n            stop(\"'use.mcols' must be TRUE or FALSE\")\n        unlisted_x <- unlist(x, use.names=FALSE)\n        unlisted_ans <- unlisted_x@ranges\n        if (use.mcols)\n            mcols(unlisted_ans) <- mcols(unlisted_x, use.names=FALSE)\n        ans <- relist(unlisted_ans, x)\n        if (!use.names)\n            names(ans) <- NULL\n        if (use.mcols)\n            mcols(ans) <- mcols(x, use.names=FALSE)\n        ans\n    }\n)\n\nsetReplaceMethod(\"ranges\", \"CompressedGRangesList\",\n    function(x, value)\n    {\n        if (!is(value, \"IntegerRangesList\") ||\n            !identical(elementNROWS(x), elementNROWS(value)))\n            stop(\"replacement 'value' is not an IntegerRangesList with the \",\n                 \"same elementNROWS as 'x'\")\n        ranges(x@unlistData) <- as(unlist(value, use.names = FALSE), \"IRanges\")\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from list-like object to SimpleGRangesList\n###\n\n### Try to turn an arbitrary **list-like** object into an ordinary list of\n### GRanges objects.\n.as_list_of_GRanges <- function(from)\n{\n    if (is(from, \"GenomicRanges\")) {\n        if (!is(from, \"GRanges\"))\n            from <- as(from, \"GRanges\", strict=FALSE)\n        along_idx <- setNames(seq_along(from), names(from))\n        names(from) <- NULL\n        mcols(from) <- NULL\n        lapply(along_idx, function(i) from[i])\n    } else {\n        lapply(from, as, \"GRanges\", strict=FALSE)\n    }\n}\n\n### --- From ordinary list to SimpleGRangesList ---\n### Note that being able to coerce a length-one ordinary list to\n### SimpleGRangesList will automatically make [[<- work on SimpleGRangesList\n### objects.\n\n.from_list_to_SimpleGRangesList <- function(from)\n{\n    x <- .as_list_of_GRanges(from)\n    S4Vectors:::new_SimpleList_from_list(\"SimpleGRangesList\", x)\n}\n\nsetAs(\"list\", \"SimpleGRangesList\", .from_list_to_SimpleGRangesList)\nsetAs(\"list\", \"GRangesList\", .from_list_to_SimpleGRangesList)\n\n### --- From List derivative to SimpleGRangesList ---\n\n.from_List_to_SimpleGRangesList <- function(from)\n{\n    x <- .as_list_of_GRanges(from)\n    S4Vectors:::new_SimpleList_from_list(\"SimpleGRangesList\", x,\n                               metadata=metadata(from),\n                               mcols=mcols(from, use.names=FALSE))\n}\n\nsetAs(\"List\", \"SimpleGRangesList\", .from_List_to_SimpleGRangesList)\n\n### Automatic coercion methods from SimpleList, GenomicRangesList, or\n### SimpleGenomicRangesList to SimpleGRangesList silently return a broken\n### object (unfortunately these dummy automatic coercion methods don't bother\n### to validate the object they return). So we overwrite them.\nsetAs(\"SimpleList\", \"SimpleGRangesList\",\n      .from_List_to_SimpleGRangesList)\nsetAs(\"GenomicRangesList\", \"SimpleGRangesList\",\n      .from_List_to_SimpleGRangesList)\nsetAs(\"SimpleGenomicRangesList\", \"SimpleGRangesList\",\n      .from_List_to_SimpleGRangesList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from list-like object to CompressedGRangesList\n###\n\n### --- From ordinary list to CompressedGRangesList ---\n### Note that being able to coerce a length-one ordinary list to\n### CompressedGRangesList will automatically make [[<- work on\n### CompressedGRangesList objects.\n\n.from_list_to_CompressedGRangesList <- function(from)\n{\n    x <- .as_list_of_GRanges(from)\n    IRanges:::new_CompressedList_from_list(\"CompressedGRangesList\", x)\n}\n\nsetAs(\"list\", \"CompressedGRangesList\", .from_list_to_CompressedGRangesList)\n\n### --- From List derivative to CompressedGRangesList ---\n\n.from_List_to_CompressedGRangesList <- function(from)\n{\n    if (is(from, \"GenomicRanges\")) {\n        ## Perform a \"dumb split\".\n        if (!is(from, \"GRanges\"))\n            from <- as(from, \"GRanges\", strict=FALSE)\n        ## We call IRanges:::from_Vector_to_CompressedList() to perform\n        ## the \"dumb split\". This is **very** efficient!\n        return(IRanges:::from_Vector_to_CompressedList(from))\n    }\n\n    x <- .as_list_of_GRanges(from)\n    IRanges:::new_CompressedList_from_list(\"CompressedGRangesList\", x,\n                                 metadata=metadata(from),\n                                 mcols=mcols(from, use.names=FALSE))\n}\n\nsetAs(\"List\", \"CompressedGRangesList\",\n      .from_List_to_CompressedGRangesList)\n\nsetAs(\"List\", \"GRangesList\",\n    function(from)\n    {\n        if (is(from, \"CompressedList\") || is(from, \"GenomicRanges\"))\n            as(from, \"CompressedGRangesList\")\n        else\n            as(from, \"SimpleGRangesList\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other coercions\n###\n\nsetAs(\"CompressedGRangesList\", \"CompressedIRangesList\",\n    function(from) ranges(from, use.mcols=TRUE)\n)\nsetAs(\"CompressedGRangesList\", \"IRangesList\",\n    function(from) ranges(from, use.mcols=TRUE)\n)\nsetAs(\"CompressedGRangesList\", \"IntegerRangesList\",\n    function(from) ranges(from, use.mcols=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Sorting\n###\n### S3/S4 combo for sort.GRangesList\n.sort.GRangesList <- function(x, decreasing=FALSE, ...)\n{\n    gr <- deconstructGRLintoGR(x)\n    gr2 <- sort(gr, decreasing=decreasing, ...)\n    reconstructGRLfromGR(gr2, x)\n}\nsort.GRangesList <- function(x, decreasing=FALSE, ...)\n    .sort.GRangesList(x, decreasing=decreasing, ...)\nsetMethod(\"sort\", \"CompressedGRangesList\", .sort.GRangesList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting\n###\n### TODO: We should have more general methods defined at the GenomicRangesList\n### level instead of the methods below.\n###\n\n.sBracketSubsetGRList <- function(x, i, j, ..., drop)\n{\n    if (!missing(i)) {\n        x <- callNextMethod(x = x, i = i)\n    }\n    if (!missing(j)) {\n        if (!is.character(j))\n            stop(\"'j' must be a character vector\")\n        withinLevel <- (j %in% colnames(x@unlistData@elementMetadata))\n        if (any(withinLevel) && !all(withinLevel))\n            stop(\"'j' cannot mix between and within metadata column names\")\n        if (any(withinLevel)) {\n            mcols(x, level=\"within\") <-\n              mcols(x, use.names=FALSE, level=\"within\")[, j, drop=FALSE]\n        } else {\n            mcols(x) <- mcols(x, use.names=FALSE)[, j, drop=FALSE]\n        }\n    }\n    x\n}\nsetMethod(\"[\", \"CompressedGRangesList\", .sBracketSubsetGRList)\n\n.sBracketReplaceGRList <- function(x, i, j, ..., value)\n{\n    if (!is(value, class(x)[1]))\n        stop(paste0(\"replacement value must be a \", class(x)[1], \" object\"))\n    if (!missing(i))\n        i <- extractROWS(setNames(seq_along(x), names(x)), i)\n    if (!missing(j)) {\n        if (!is.character(j))\n            stop(\"'j' must be a character vector\")\n        withinLevel <- (j %in% colnames(x@unlistData@elementMetadata))\n        if (any(withinLevel) && !all(withinLevel))\n            stop(\"'j' cannot mix between and within metadata column names\")\n        if (missing(i)) {\n            if (any(withinLevel)) {\n                mcols(x, level=\"within\")[, j] <-\n                  mcols(x, use.names=FALSE, level=\"within\")\n            } else {\n                mcols(x)[, j] <- mcols(x, use.names=FALSE)\n            }\n        } else {\n            if (any(withinLevel)) {\n                mcols(x, level=\"within\")[i, j] <-\n                        mcols(x, use.names=FALSE, level=\"within\")\n            } else {\n                mcols(x)[i, j] <- mcols(x, use.names=FALSE)\n            }\n        }\n    }\n    callNextMethod(x = x, i = i, value = value)\n}\nsetReplaceMethod(\"[\", \"CompressedGRangesList\", .sBracketReplaceGRList)\n\n",
        "GenomicRanges-class.R": "### =========================================================================\n### The GenomicRanges interface\n### -------------------------------------------------------------------------\n###\n\n### TODO: The 'constraint' slot could be moved to the Vector class (or to the\n### Annotated class) so any Vector object could be constrained.\nsetClass(\"GenomicRanges\",\n    contains=\"Ranges\",\n    representation(\n        \"VIRTUAL\",\n        #No more constraint slot for now...\n        #constraint=\"Constraint_OR_NULL\",\n        elementMetadata=\"DataFrame\"\n    ),\n    prototype(\n        elementMetadata=new(\"DFrame\")\n    )\n)\n\nsetClassUnion(\"GenomicRanges_OR_missing\", c(\"GenomicRanges\", \"missing\"))\n\n### The code in this file will work out-of-the-box on 'x' as long as\n### seqnames(x), ranges(x), strand(x), seqlengths(x), seqinfo(),\n### and update(x) are defined.\n\nsetClass(\"GenomicPos\",\n    contains=c(\"GenomicRanges\", \"Pos\"),\n    representation(\"VIRTUAL\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters.\n###\n\n### The method for Ranges does 'length(start(x))' which is very inefficient\n### on a StitchedGPos object so we overwrite it with a method that should be\n### fast on all GenomicRanges derivatives (including StitchedGPos objects).\nsetMethod(\"length\", \"GenomicRanges\", function(x) length(ranges(x)))\n\nsetMethod(\"names\", \"GenomicRanges\", function(x) names(ranges(x)))\n\n#setMethod(\"constraint\", \"GenomicRanges\", function(x) x@constraint)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Extra column slots (added by GRanges subclasses)\n###\n### The \"extra column slots\" are parallel slots added by GRanges subclasses\n### in addition to GRanges parallel slots \"seqnames\", \"ranges\", \"strand\",\n### and \"elementMetadata\".\n###\n### TODO: Packages defining \"extraColumnSlotNames\" methods (e.g.\n### VariantAnnotation, GenomicTuples, InteractionSet, SGSeq) should define\n### parallel_slot_names() methods instead. They'll get more things working\n### out-of-the-box by doing so (e.g. c()). Then the extraColumnSlotNames()\n### generic will become a GenomicRanges private business and could be made\n### a regular function.\n###\n\nsetGeneric(\"extraColumnSlotNames\",\n    function(x) standardGeneric(\"extraColumnSlotNames\")\n)\n\nsetMethod(\"extraColumnSlotNames\", \"ANY\", function(x) character())\n\n#setMethod(\"extraColumnSlotNames\", \"GRanges\",\n#    function(x)\n#    {\n#        GRanges_pslotnames <- parallel_slot_names(new(\"GRanges\"))\n#        setdiff(parallel_slot_names(x), GRanges_pslotnames)\n#    }\n#)\n\nextraColumnSlots <- function(x)\n    sapply(extraColumnSlotNames(x), slot, object=x, simplify=FALSE)\n\nextraColumnSlotsAsDF <- function(x)\n    S4Vectors:::new_DataFrame(extraColumnSlots(x), nrows=length(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 2 low-level helper functions to deal with out-of-bound ranges.\n###\n\n### Returns index of out-of-bound ranges located on non-circular sequences\n### whose length is not NA. Works on a GenomicRanges or GAlignments object.\nget_out_of_bound_index <- function(x)\n{\n    if (length(x) == 0L)\n        return(integer(0))\n    x_seqnames_id <- as.integer(seqnames(x))\n    x_seqlengths <- unname(seqlengths(x))\n    seqlevel_is_circ <- unname(isCircular(x)) %in% TRUE\n    seqlength_is_na <- is.na(x_seqlengths)\n    seqlevel_has_bounds <- !(seqlevel_is_circ | seqlength_is_na)\n    which(seqlevel_has_bounds[x_seqnames_id] &\n          (start(x) < 1L | end(x) > x_seqlengths[x_seqnames_id]))\n}\n\n### Also works on a GenomicRanges or GAlignments object. Note that GAlignments\n### objects are not trimmable so use 'suggest.trim=FALSE' on them.\nmake_out_of_bound_warning_msg <- function(x, idx, suggest.trim)\n{\n    where <- seqlevels(x)[unique(as.integer(seqnames(x))[idx])]\n    if (length(where) == 1L) {\n        on_what <- paste0(\"sequence \", where)\n    } else if (length(where) == 2L) {\n        on_what <- paste0(\"sequences \", where[1L], \" and \", where[2L])\n    } else {\n        seqlevels_in1string <- paste0(head(where, n=-1L), collapse=\", \")\n        on_what <- paste0(\"sequences \", seqlevels_in1string,\n                              \", and \", tail(where, n=1L))\n    }\n    msg <- c(class(x), \" object contains \", length(idx), \" out-of-bound \",\n             \"range\", if (length(idx) >= 2L) \"s\" else \"\", \" located on \",\n             on_what, \". \",\n             \"Note that ranges located on a sequence whose length is unknown \",\n             \"(NA) or on a circular sequence are not considered out-of-bound \",\n             \"(use seqlengths() and isCircular() to get the lengths and \",\n             \"circularity flags of the underlying sequences).\")\n    if (suggest.trim)\n        msg <- c(msg, \" You can use trim() to trim these ranges. \",\n                 \"See ?`trim,GenomicRanges-method` for more information.\")\n    msg\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity.\n###\n### TODO: Should we enforce ranges(x) to be an IRanges *instance* (i.e.\n### class(ranges(x) == \"IRanges\")) instead of just an IRanges *object* (i.e.\n### is(ranges(x), \"IRanges\"))? Right now I can create a GRanges object where\n### the ranges are a Views object on a very long DNAString subject with\n### something like 'GRanges(\"chr1\", Views(subject, start=1:2, end=5))'.\n### Sounds cool but there are also some potential complications with this...\n\n### Used in GenomicAlignments.\n.valid.GenomicRanges.seqnames <- function(x)\n{\n    x_seqnames <- seqnames(x)\n    if (!is(x_seqnames, \"Rle\") || !is.factor(runValue(x_seqnames)))\n        return(\"'seqnames(x)' must be a 'factor' Rle\")\n    if (!is.null(names(x_seqnames)))\n        return(\"'seqnames(x)' must be a 'factor' Rle with no names\")\n    if (S4Vectors:::anyMissing(runValue(x_seqnames)))\n        return(\"'seqnames(x)' contains missing values\")\n    NULL\n}\n\n.valid.GenomicRanges.ranges <- function(x)\n{\n    if (!(class(ranges(x)) %in% c(\"IRanges\", \"StitchedIPos\", \"UnstitchedIPos\")))\n        return(paste0(\"'ranges(x)' must be an IRanges, StitchedIPos, \",\n                      \"or UnstitchedIPos instance\"))\n    NULL\n}\n\n.valid.GenomicRanges.strand <- function(x)\n{\n    if (!is.factor(runValue(strand(x))) ||\n        !identical(levels(runValue(strand(x))), levels(strand())))\n    {\n        msg <- c(\"'strand' should be a 'factor' Rle with levels c(\",\n                 paste0('\"', levels(strand()), '\"', collapse=\", \"),\n                 \")\")\n        return(paste(msg, collapse=\"\"))\n    }\n    if (S4Vectors:::anyMissing(runValue(strand(x))))\n        return(\"'strand' contains missing values\")\n    NULL\n}\n\n### NOTE: This list is also included in the man page for GRanges objects.\n### Keep the 2 lists in sync!\n### We don't put \"genome\" in that list in order to facilitate import of GFF3\n### files as GRanges objects (see ?import.gff3 in rtracklayer).\n### TODO: Get rid of this restriction. Not sure why we ever had it. Doesn't\n### make much sense to me.\nINVALID.GR.COLNAMES <- c(\"seqnames\", \"ranges\", \"strand\",\n                         \"seqlevels\", \"seqlengths\", \"isCircular\",\n                         #\"genome\",\n                         \"start\", \"end\", \"width\", \"element\")\n\n.valid.GenomicRanges.mcols <- function(x)\n{\n    if (any(INVALID.GR.COLNAMES %in% colnames(mcols(x, use.names=FALSE)))) {\n        msg <- c(\"names of metadata columns cannot be one of \",\n                 paste0(\"\\\"\", INVALID.GR.COLNAMES, \"\\\"\", collapse=\", \"))\n        return(paste(msg, collapse=\" \"))\n    }\n    NULL\n}\n\n### Also used by the validity method for GAlignments objects.\nvalid.GenomicRanges.seqinfo <- function(x, suggest.trim=FALSE)\n{\n    x_seqinfo <- seqinfo(x)\n    if (!identical(seqlevels(x_seqinfo), levels(seqnames(x)))) {\n        msg <- c(\"'seqlevels(seqinfo(x))' and 'levels(seqnames(x))'\",\n                 \"are not identical\")\n        return(paste(msg, collapse=\" \"))\n    }\n    idx <- get_out_of_bound_index(x)\n    if (length(idx) != 0L) {\n        msg <- make_out_of_bound_warning_msg(x, idx, suggest.trim)\n        warning(wmsg(msg))\n    }\n    NULL\n}\n\n.valid.GenomicRanges <- function(x)\n{\n    c(.valid.GenomicRanges.seqnames(x),\n      .valid.GenomicRanges.ranges(x),\n      .valid.GenomicRanges.strand(x),\n      .valid.GenomicRanges.mcols(x),\n      valid.GenomicRanges.seqinfo(x, suggest.trim=TRUE))\n      #checkConstraint(x, constraint(x)))\n}\n\nsetValidity2(\"GenomicRanges\", .valid.GenomicRanges)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion\n###\n\n### Propagate the names.\nsetMethod(\"as.character\", \"GenomicRanges\",\n    function(x, ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(wmsg(\"'ignore.strand' must be TRUE or FALSE\"))\n        if (length(x) == 0L)\n            return(setNames(character(0), names(x)))\n        ans <- paste0(seqnames(x), \":\", as.character(ranges(x)))\n        names(ans) <- names(x)\n        if (ignore.strand)\n            return(ans)\n        x_strand <- strand(x)\n        if (all(x_strand == \"*\"))\n            return(ans)\n        setNames(paste0(ans, \":\", x_strand), names(x))\n    }\n)\n\n### The as.factor() generic doesn't have the ... argument so this method\n### cannot support the 'ignore.strand' argument.\nsetMethod(\"as.factor\", \"GenomicRanges\",\n    function(x)\n        factor(as.character(x), levels=as.character(sort(unique(x))))\n)\n\nsetAs(\"GenomicRanges\", \"Grouping\", function(from) {\n    to <- as(grouping(seqnames(from), strand(from), start(from), end(from)),\n             \"ManyToOneGrouping\")\n    mcols(to)$granges <- granges(from)[end(PartitioningByEnd(to))]\n    to\n})\n\nsetMethod(\"as.data.frame\", \"GenomicRanges\",\n    function(x, row.names=NULL, optional=FALSE, ...)\n    {\n        if (missing(row.names))\n            row.names <- names(x)\n        if (!is.null(names(x)))\n            names(x) <- NULL\n        ans <- data.frame(seqnames=as.factor(seqnames(x)),\n                          start=start(x),\n                          end=end(x),\n                          width=width(x),\n                          strand=as.factor(strand(x)),\n                          row.names=row.names,\n                          stringsAsFactors=FALSE)\n        x_mcols <- mcols(x, use.names=FALSE)\n        ans <- cbind(ans, as.data.frame(x_mcols, optional=optional, ...))\n        if (length(extraColumnSlotNames(x)) > 0L) {\n            x_xcols <- extraColumnSlotsAsDF(x)\n            ans <- cbind(ans, as.data.frame(x_xcols, optional=optional, ...))\n        }\n        ans\n    }\n)\n\n.from_GenomicRanges_to_CompressedIRangesList <- function(from)\n{\n    strand_mcols <- DataFrame(strand=strand(from),\n                              mcols(from, use.names=FALSE))\n    ecs <- extraColumnSlotsAsDF(from)\n    if (length(ecs))\n      strand_mcols <- cbind(strand_mcols, ecs)\n    rngs <- ranges(from)\n    mcols(rngs) <- strand_mcols\n    ans <- split(rngs, seqnames(from))\n    mcols(ans) <- DataFrame(seqlengths=seqlengths(from),\n                           isCircular=isCircular(from),\n                           genome=genome(from))\n    metadata(ans) <- metadata(from)\n    metadata(ans)$seqinfo <- seqinfo(from)\n    ans\n}\n\nsetAs(\"GenomicRanges\", \"CompressedIRangesList\",\n    .from_GenomicRanges_to_CompressedIRangesList\n)\nsetAs(\"GenomicRanges\", \"IRangesList\",\n    .from_GenomicRanges_to_CompressedIRangesList\n)\nsetAs(\"GenomicRanges\", \"IntegerRangesList\",\n    .from_GenomicRanges_to_CompressedIRangesList\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Setters.\n###\n\nsetReplaceMethod(\"names\", \"GenomicRanges\",\n    function(x, value)\n    {\n        x_ranges <- setNames(ranges(x), value)\n        update(x, ranges=x_ranges, check=FALSE)\n    }\n)\n\n### Used in GenomicAlignments.\n.normalize_seqnames_replacement_value <- function(value, x)\n{\n    if (!is(value, \"Rle\"))\n        value <- Rle(value)\n    if (!is.factor(runValue(value)))\n        runValue(value) <- factor(runValue(value))\n    if (!identical(levels(value), seqlevels(x)))\n        stop(\"levels of supplied 'seqnames' must be \",\n             \"identical to 'seqlevels(x)'\")\n    S4Vectors:::V_recycle(value, x, x_what=\"value\", skeleton_what=\"x\")\n}\n\nsetReplaceMethod(\"seqnames\", \"GenomicRanges\",\n    function(x, value)\n    {\n        value <- .normalize_seqnames_replacement_value(value, x)\n        update(x, seqnames=value)\n    }\n)\n\nsetReplaceMethod(\"ranges\", \"GenomicRanges\",\n    function(x, value)\n    {\n        if (class(value) != \"IRanges\")\n            value <- as(value, \"IRanges\")\n        mcols(value) <- NULL\n        value <- S4Vectors:::V_recycle(value, x,\n                                       x_what=\"value\", skeleton_what=\"x\")\n        update(x, ranges=value)\n    }\n)\n\nsetReplaceMethod(\"strand\", \"GenomicRanges\",\n    function(x, value)\n    {\n        value <- normalize_strand_replacement_value(value, x)\n        x <- update(x, strand=value, check=FALSE)\n        msg <- .valid.GenomicRanges.strand(x)\n        if (!is.null(msg))\n            stop(msg)\n        x\n    }\n)\n\n### Does NOT suppoprt pruning mode \"fine\". Pruning modes \"coarse\" and \"tidy\"\n### are equivalent on a GenomicRanges object.\nset_GenomicRanges_seqinfo <-\n    function(x, new2old=NULL,\n             pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n             value)\n{\n    if (!is(value, \"Seqinfo\"))\n        stop(\"the supplied 'seqinfo' must be a Seqinfo object\")\n    pruning.mode <- match.arg(pruning.mode)\n    if (pruning.mode == \"fine\")\n        stop(wmsg(\"\\\"fine\\\" pruning mode is not supported on \",\n                  class(x), \" objects\"))\n    dangling_seqlevels <- GenomeInfoDb:::getDanglingSeqlevels(x,\n                              new2old=new2old,\n                              pruning.mode=pruning.mode,\n                              seqlevels(value))\n    if (length(dangling_seqlevels) != 0L) {\n        ## Prune 'x'.\n        idx <- !(seqnames(x) %in% dangling_seqlevels)\n        x <- x[idx]\n    }\n    old_seqinfo <- seqinfo(x)\n    new_seqnames <- GenomeInfoDb:::makeNewSeqnames(x,\n                              new2old=new2old, seqlevels(value))\n    x <- update(x, seqnames=new_seqnames, seqinfo=value, check=FALSE)\n    geom_has_changed <- GenomeInfoDb:::sequenceGeometryHasChanged(\n                              seqinfo(x), old_seqinfo, new2old=new2old)\n    if (any(geom_has_changed, na.rm=TRUE)) {\n        msg <- valid.GenomicRanges.seqinfo(x, suggest.trim=TRUE)\n        if (!is.null(msg))\n            stop(msg)\n    }\n    x\n}\nsetReplaceMethod(\"seqinfo\", \"GenomicRanges\", set_GenomicRanges_seqinfo)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The score() accessor\n###\n### Kind of a silly accessor. And why is it defined at the GenomicRanges\n### level and not at the Vector level? Or at least at the Ranges and\n### RangesList levels so it works on IRanges and IRangesList objects too.\n###\n\nsetMethod(\"score\", \"GenomicRanges\",\n    function(x) mcols(x, use.names=FALSE)$score\n)\n\nsetReplaceMethod(\"score\", \"GenomicRanges\",\n    function(x, value)\n    {\n        ## Fix old GRanges instances on-the-fly.\n        x <- updateObject(x)\n        mcols(x)$score <- value\n        x\n    }\n)\n\n#setReplaceMethod(\"constraint\", \"GenomicRanges\",\n#    function(x, value)\n#    {\n#        if (isSingleString(value))\n#            value <- new(value)\n#        if (!is(value, \"Constraint_OR_NULL\"))\n#            stop(\"the supplied 'constraint' must be a \",\n#                 \"Constraint object, a single string, or NULL\")\n#        x@constraint <- value\n#        validObject(x)\n#        x\n#    }\n#)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Updating and cloning.\n###\n### An object is either 'update'd in place (usually with a replacement\n### method) or 'clone'd (copied), with specified slots/fields overridden.\n\n### For an object with a pure S4 slot representation, these both map to\n### initialize. Reference classes will want to override 'update'. Other\n### external representations need further customization.\n\nsetGeneric(\"clone\", function(x, ...) standardGeneric(\"clone\"))  # not exported\n\nsetMethod(\"clone\", \"ANY\",  # not exported\n    function(x, ...)\n    {\n        if (nargs() > 1L)\n            update(x, ...)\n        else\n            x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Range accessors\n###\n\nsetMethod(\"start\", \"GenomicRanges\", function(x, ...) start(ranges(x)))\nsetMethod(\"width\", \"GenomicRanges\", function(x) width(ranges(x)))\n\nsetReplaceMethod(\"start\", \"GenomicRanges\",\n    function(x, ..., value)\n    {\n        new_ranges <- `start<-`(ranges(x), ..., value=value)\n        update(x, ranges=new_ranges, ...)\n    }\n)\n\nsetReplaceMethod(\"end\", \"GenomicRanges\",\n    function(x, ..., value)\n    {\n        new_ranges <- `end<-`(ranges(x), ..., value=value)\n        update(x, ranges=new_ranges, ...)\n    }\n)\n\nsetReplaceMethod(\"width\", \"GenomicRanges\",\n    function(x, ..., value)\n    {\n        new_ranges <- `width<-`(ranges(x), ..., value=value)\n        update(x, ranges=new_ranges, ...)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Subsetting.\n###\n\n### Subset a named list-like object *by* a GenomicRanges subscript.\n### The returned object 'ans' is as follow:\n###   (a) 'ans' is parallel to 'gr'.\n###   (b) 'names(ans)' is identical to 'as.character(seqnames(gr))'.\n###   (c) 'elementNROWS(ans)' is the same as 'width(gr)'.\n###   (d) 'class(ans)' is 'relistToClass(x[[1]])' e.g. CompressedRleList if\n###       'x' is an RleList object, or DNAStringSet is 'x' is a DNAStringSet\n###       object.\n.subset_by_GenomicRanges <- function(x, gr)\n{\n    if (!(is.list(x) || is(x, \"List\")))\n        stop(wmsg(\"'x' must be a list-like object when subsetting \",\n                  \"by a GenomicRanges subscript\"))\n    x_names <- names(x)\n    if (is.null(x_names))\n        stop(wmsg(\"'x' must have names when subsetting \",\n                  \"by a GenomicRanges subscript\"))\n    if (anyDuplicated(x_names))\n        stop(wmsg(\"'x' must have unique names when subsetting \",\n                  \"by a GenomicRanges subscript\"))\n    irl <- split(ranges(gr), seqnames(gr), drop=TRUE)\n    seqlevels_in_use <- names(irl)\n    seqlevels2names <- match(seqlevels_in_use, x_names)\n    if (any(is.na(seqlevels2names)))\n        stop(wmsg(\"when subsetting by a GenomicRanges subscript, the names \",\n                  \"of the object to subset must contain the seqnames of the \",\n                  \"subscript\"))\n\n    ## Handle empty case.\n    if (length(gr) == 0L) {\n        if (length(x) != 0L) {\n            x1 <- x[[1L]]\n        } else if (is(x, \"CompressedList\")) {\n            x1 <- unlist(x, use.names=FALSE)\n        } else {\n            x1 <- new(elementType(x))\n        }\n        unlisted_ans <- x1[0]\n        ans_partitioning <- PartitioningByEnd(names=character(0))\n        return(relist(unlisted_ans, ans_partitioning))\n    }\n\n    tmp <- lapply(seq_along(seqlevels_in_use),\n                  function(i) {\n                      seqlevel <- seqlevels_in_use[i]\n                      name <- x_names[seqlevels2names[i]]\n                      extractList(x[[name]], irl[[seqlevel]])\n                  })\n\n    ## Unsplit 'tmp'.\n    ans <- do.call(c, tmp)\n    ans_len <- length(gr)\n    idx <- unlist(split(seq_len(ans_len), seqnames(gr), drop=TRUE))\n    revidx <- integer(ans_len)\n    revidx[idx] <- seq_len(ans_len)\n    names(ans) <- names(idx)\n    ans <- ans[revidx]\n    ans\n}\n\nsetMethod(\"[\", c(\"list_OR_List\", \"GenomicRanges\"),\n    function(x, i, j, ..., drop=TRUE)\n    {\n        if (!missing(j) || length(list(...)) > 0L)\n            stop(\"invalid subsetting\")\n        .subset_by_GenomicRanges(x, i)\n    }\n)\n\n### Avoid infinite recursion that we would otherwise get:\n###   GRanges(\"chr1:1-10\")[[1]]\n###   # Error: C stack usage  7969428 is too close to the limit\nsetMethod(\"getListElement\", \"GenomicRanges\",\n    function(x, i, exact=TRUE)\n    {\n        ## A temporary situation\n        stop(wmsg(class(x), \" objects don't support [[, as.list(), \",\n                  \"lapply(), or unlist() at the moment\"))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### $ and $<- methods\n###\n### Provided as a convenience, for GenomicRanges *only*, and as the result\n### of strong popular demand.\n### Note that those methods are not consistent with the other $ and $<-\n### methods in the IRanges/GenomicRanges infrastructure, and might confuse\n### some users by making them believe that a GenomicRanges object can be\n### manipulated as a data.frame-like object.\n### Therefore we recommend using them only interactively, and we discourage\n### their use in scripts or packages. For the latter, use 'mcols(x)$name'\n### instead of 'x$name'.\n###\n\n.DollarNames.GenomicRanges <- function(x, pattern = \"\")\n    grep(pattern, names(mcols(x, use.names=FALSE)), value=TRUE)\n\nsetMethod(\"$\", \"GenomicRanges\",\n    function(x, name) mcols(x, use.names=FALSE)[[name]]\n)\n\nsetReplaceMethod(\"$\", \"GenomicRanges\",\n    function(x, name, value)\n    {\n        ## Fix old GRanges instances on-the-fly.\n        x <- updateObject(x)\n        mcols(x)[[name]] <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.GenomicRanges\nsummary.GenomicRanges <- summary.IPosRanges\nsetMethod(\"summary\", \"GenomicRanges\", summary.GenomicRanges)\n\n.from_GenomicRanges_to_naked_character_matrix_for_display <- function(x)\n{\n    m <- cbind(seqnames=showAsCell(seqnames(x)),\n               ranges=showAsCell(ranges(x)),\n               strand=showAsCell(strand(x)))\n    extra_col_names <- extraColumnSlotNames(x)\n    if (length(extra_col_names) != 0L) {\n        extra_cols <- lapply(extraColumnSlots(x), showAsCell)\n        m <- do.call(cbind, c(list(m), extra_cols))\n    }\n    cbind_mcols_for_display(m, x)\n}\nsetMethod(\"makeNakedCharacterMatrixForDisplay\", \"GenomicRanges\",\n    .from_GenomicRanges_to_naked_character_matrix_for_display\n)\n\n### If 'x' is a GRanges object, 'coerce.internally.to.GRanges' has no effect.\n### If it's a GenomicRanges object that is not a GRanges object, then\n### show_GenomicRanges() will coerce it to a GRanges object unless\n### 'coerce.internally.to.GRanges' is set to FALSE. Use this if coercing 'x'\n### to GRanges is not supported or is too expensive but only if 'x' supports\n### head() and tail().\nshow_GenomicRanges <- function(x, margin=\"\",\n                               print.classinfo=FALSE, print.seqinfo=FALSE,\n                               coerce.internally.to.GRanges=TRUE)\n{\n    cat(margin, summary(x), \":\\n\", sep=\"\")\n    ## makePrettyMatrixForCompactPrinting() assumes that head() and tail()\n    ## work on 'xx'.\n    if (coerce.internally.to.GRanges) {\n        xx <- as(x, \"GRanges\", strict=FALSE)\n    } else {\n        xx <- x\n    }\n    out <- makePrettyMatrixForCompactPrinting(xx)\n    if (print.classinfo) {\n        .COL2CLASS <- c(\n            seqnames=\"Rle\",\n            ranges=\"IRanges\",\n            strand=\"Rle\"\n        )\n        extra_col_names <- extraColumnSlotNames(x)\n        .COL2CLASS <- c(.COL2CLASS, getSlots(class(x))[extra_col_names])\n        classinfo <- makeClassinfoRowForCompactPrinting(x, .COL2CLASS)\n        ## A sanity check, but this should never happen!\n        stopifnot(identical(colnames(classinfo), colnames(out)))\n        out <- rbind(classinfo, out)\n    }\n    if (nrow(out) != 0L)\n        rownames(out) <- paste0(margin, \"  \", rownames(out))\n    ## We set 'max' to 'length(out)' to avoid the getOption(\"max.print\")\n    ## limit that would typically be reached when 'showHeadLines' global\n    ## option is set to Inf.\n    print(out, quote=FALSE, right=TRUE, max=length(out))\n    if (print.seqinfo) {\n        cat(margin, \"  -------\\n\", sep=\"\")\n        cat(margin, \"  seqinfo: \", summary(seqinfo(x)), \"\\n\", sep=\"\")\n    }\n}\n\nsetMethod(\"show\", \"GenomicRanges\",\n    function(object)\n        show_GenomicRanges(object, print.classinfo=TRUE, print.seqinfo=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Concatenation\n###\n\n### 'x' can be any list-like object and its list elements can be anything\n### that supports seqinfo().\n### Used in the seqinfo() method for GenomicRangesList objects.\ncombine_seqinfo_from_GenomicRanges_objects <- function(x)\n{\n    x_len <- length(x)\n    ## This will typically happen in the context of the seqinfo() method\n    ## for GenomicRangesList objects.\n    if (x_len == 0L)\n        stop(wmsg(\"seqinfo() is not supported on a zero length \",\n                  class(x), \" object\"))\n    do.call(merge, lapply(seq_len(x_len), function(i) seqinfo(x[[i]])))\n}\n\n### NOT exported but used in the GenomicAlignments package.\nconcatenate_GenomicRanges_objects <-\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n{\n    ## Fix old GRanges and GAlignments instance on-the-fly.\n    x <- updateObject(x, check=FALSE)\n\n    objects <- S4Vectors:::prepare_objects_to_bind(x, objects)\n    all_objects <- c(list(x), objects)\n\n    ## Combine seqinfo.\n    seqinfo(x) <- combine_seqinfo_from_GenomicRanges_objects(all_objects)\n\n    ## Call method for Vector objects to concatenate all the parallel slots.\n    callNextMethod()\n}\n\nsetMethod(\"bindROWS\", \"GenomicRanges\", concatenate_GenomicRanges_objects)\n\n",
        "GenomicRanges-comparison.R": "### =========================================================================\n### Comparing and ordering genomic ranges\n### -------------------------------------------------------------------------\n###\n### I. UNIQUE AND DUPLICATED ELEMENTS WITHIN A GenomicRanges OBJECT\n### ---------------------------------------------------------------\n### Two elements of a GenomicRanges object (i.e. two genomic ranges) are\n### considered equal iff they are on the same underlying sequence and strand,\n### and have the same start and width. duplicated() and unique() on a\n### GenomicRanges object are conforming to this.\n###\n### II. ORDERING THE ELEMENTS OF A GenomicRanges OBJECT\n### ---------------------------------------------------\n### The \"natural order\" for the elements of a GenomicRanges object is to order\n### them (a) first by sequence level, (b) then by strand, (c) then by start,\n### (d) and finally by width.\n### This way, the space of genomic ranges is totally ordered.\n### Note that the \"reduce\" method for GenomicRanges uses this \"natural order\"\n### implicitly. Also, note that, because we already do (c) and (d) for regular\n### ranges, genomic ranges that belong to the same underlying sequence\n### and strand are ordered like regular ranges.\n### is.unsorted(), order(), sort(), and rank() on a GenomicRanges object\n### adhere to this \"natural order\".\n###\n### III. ELEMENT-WISE (AKA \"PARALLEL\") COMPARISON OF 2 GenomicRanges OBJECTS\n### ------------------------------------------------------------------------\n### We want the \"==\", \"!=\", \"<=\", \">=\", \"<\" and \">\" operators between 2\n### GenomicRanges objects to be compatible with the \"natural order\" defined\n### previously. Defining those operators when the 2 objects have *identical*\n### seqlevels() is straighforward but we can in fact extend this comparison\n### to the following situation:\n###   (A) 'e1' and 'e2' have compatible sets of underlying sequences, that is,\n###       'seqinfo(e1)' and 'seqinfo(e2)' can be merged.\n###   (B) 'seqlevels(e1)' and 'seqlevels(e2)' are in the same order. Note that\n###       (A) guarantees that the seqlevels of one is a subset of the seqlevels\n###       of the other. (B) is saying that this subset should be a subsequence.\n### Pre-comparison step: if (A) and (B) are satisfied, then the 2 seqinfo() are\n### merged and the seqlevels() of the result is assigned back to each object\n### to compare. This is a way to have 2 objects with identical seqlevels()\n### before the comparison can actually be performed and meaningful.\n### The reason (B) is required for the pre-comparison step is because we want\n### this step to preserve the original order of the seqlevels() in *both*\n### objects. Without this precaution, the expected anti-symetric property of\n### some operators would not be satisfied e.g. 'any(e1 < e2 & e2 < e1)' could\n### be TRUE.\n\n\nsetMethod(\"pcompareRecursively\", \"GenomicRanges\", function(x) FALSE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pcompare()\n###\n### Doing 'pcompare(x, y)' on 2 vector-like objects 'x' and 'y' of length 1\n### must return an integer less than, equal to, or greater than zero if the\n### single element in 'x' is considered to be respectively less than, equal\n### to, or greater than the single element in 'y'.\n###\n### On 2 GenomicRanges objects, it returns one of the 13 predefined codes\n### (>= -6 and <= 6) used by the method for IntegerRanges objects when 'x[i]'\n### and 'y[i]' are on the same space (i.e. on the same underlying sequence\n### and strand). Otherwise, it returns a code that is < -6 if 'x[i] < y[i]',\n### and > 6 if 'x[i] > y[i]'.\n### See '?pcompare' (in IRanges) for the 13 predefined codes.\n.pcompare_GenomicRanges <- function(x, y)\n{\n    ## Pre-comparison step (see above for details).\n    ## merge() will fail if 'x' and 'y' don't have compatible underlying\n    ## sequences.\n    seqinfo <- merge(seqinfo(x), seqinfo(y))\n    seqlevels <- seqlevels(seqinfo)\n    if (any(diff(match(seqlevels(y), seqlevels)) < 0L))\n        stop(\"the 2 objects to compare have seqlevels in incompatible orders\")\n    ## This should only insert new seqlevels in the existing ones i.e. it\n    ## should NEVER drop or reorder existing levels\n    seqlevels(x) <- seqlevels(y) <- seqlevels\n    a <- pcompare(ranges(x), ranges(y))\n    b <- as.integer(strand(x)) - as.integer(strand(y))\n    c <- as.integer(seqnames(x)) - as.integer(seqnames(y))\n    ## Note that sign() always returns a numeric vector, even on an integer\n    ## vector.\n    a + 13L * as.integer(sign(b) + 3L * sign(c))\n}\n\n### The \"pcompare\" method.\nsetMethod(\"pcompare\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, y) .pcompare_GenomicRanges(x, y)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### duplicated()\n###\n### unique() will work out-of-the-box on a GenomicRanges object thanks to the\n### method for Vector objects.\n###\n\n.duplicated.GenomicRanges <- function(x, incomparables=FALSE, fromLast=FALSE,\n                                      nmax = NA,\n                                      method=c(\"auto\", \"quick\", \"hash\"))\n{\n    if (!identical(incomparables, FALSE))\n        stop(\"\\\"duplicated\\\" method for GenomicRanges objects \",\n             \"only accepts 'incomparables=FALSE'\")\n    duplicatedIntegerQuads(as.factor(seqnames(x)), as.factor(strand(x)),\n                               start(x), width(x),\n                           fromLast=fromLast, method=method)\n}\n### S3/S4 combo for duplicated.GenomicRanges\nduplicated.GenomicRanges <- function(x, incomparables=FALSE, ...)\n    .duplicated.GenomicRanges(x, incomparables=incomparables, ...)\nsetMethod(\"duplicated\", \"GenomicRanges\", .duplicated.GenomicRanges)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### match()\n###\n### %in% will work out-of-the-box on GenomicRanges objects thanks to the\n### method for Vector objects.\n###\n\nsetMethod(\"match\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, table, nomatch=NA_integer_, incomparables=NULL,\n                       method=c(\"auto\", \"quick\", \"hash\"),\n                       ignore.strand=FALSE)\n    {\n        if (!isSingleNumberOrNA(nomatch))\n            stop(\"'nomatch' must be a single number or NA\")\n        if (!is.integer(nomatch))\n            nomatch <- as.integer(nomatch)\n        if (!is.null(incomparables))\n            stop(\"\\\"match\\\" method for GenomicRanges objects \",\n                 \"only accepts 'incomparables=NULL'\")\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        ## Calling merge() is the way to check that 'x' and 'table' are based\n        ## on the same reference genome.\n        merge(seqinfo(x), seqinfo(table))\n        x_seqnames <- relevelSeqnamesForMatch(x, table)\n        if (ignore.strand) {\n            x_strand <- integer(length(x))\n            table_strand <- integer(length(table))\n        } else {\n            x_strand <- as.factor(strand(x))\n            table_strand <- as.factor(strand(table))\n        }\n        ## Equivalent to (but faster than):\n        ##     findOverlaps(x, table, type=\"equal\", select=\"first\")\n        ## except when 'x' and 'table' both contain empty ranges.\n        matchIntegerQuads(x_seqnames, x_strand,\n                              start(x), width(x),\n                          as.factor(seqnames(table)), table_strand,\n                              start(table), width(table),\n                          nomatch=nomatch, method=method)\n    }\n)\n\nrelevelSeqnamesForMatch <- function(x, table) {\n  x_seqnames <- as.factor(seqnames(x))\n  if (!hasHead(seqlevels(x), seqlevels(table)) &&\n      !hasHead(seqlevels(table), seqlevels(x))) {\n    x_seqnames <- factor(x_seqnames,\n                         union(seqlevels(table), seqlevels(x)))\n  }\n  x_seqnames\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### selfmatch()\n###\n\nsetMethod(\"selfmatch\", \"GenomicRanges\",\n    function(x, method=c(\"auto\", \"quick\", \"hash\"), ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        x_seqnames <- as.factor(seqnames(x))\n        if (ignore.strand) {\n            x_strand <- integer(length(x))\n        } else {\n            x_strand <- as.factor(strand(x))\n        }\n        selfmatchIntegerQuads(x_seqnames, x_strand, start(x), width(x),\n                              method=method)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### order() and related methods.\n###\n### is.unsorted(), order(), sort(), rank() on GenomicRanges derivatives are\n### consistent with the order implied by pcompare().\n### is.unsorted() is a quick/cheap way of checking whether a GenomicRanges\n### derivative is already sorted, e.g., called prior to a costly sort.\n###\n\n.GenomicRanges_as_integer_quads <- function(x, ignore.strand=FALSE)\n{\n    if (!isTRUEorFALSE(ignore.strand))\n        stop(\"'ignore.strand' must be TRUE of FALSE\")\n    a <- S4Vectors:::decodeRle(seqnames(x))\n    if (ignore.strand) {\n        b <- integer(length(x))\n    } else {\n        b <- S4Vectors:::decodeRle(strand(x))\n    }\n    c <- start(x)\n    d <- width(x)\n    list(a, b, c, d)\n}\n\nsetMethod(\"is.unsorted\", \"GenomicRanges\",\n    function(x, na.rm=FALSE, strictly=FALSE, ignore.strand=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(\"\\\"is.unsorted\\\" method for GenomicRanges objects \",\n                    \"ignores the 'na.rm' argument\")\n        if (!isTRUEorFALSE(strictly))\n            stop(\"'strictly' must be TRUE of FALSE\")\n        ## It seems that creating the integer quads below is faster when\n        ## 'x' is already sorted (TODO: Investigate why). Therefore, and\n        ## somewhat counterintuitively, is.unsorted() can be faster when 'x'\n        ## is already sorted (which, in theory, is the worst-case scenario\n        ## because S4Vectors:::sortedIntegerQuads() will then need to take a\n        ## full walk on 'x') than when it is unsorted (in which case\n        ## S4Vectors:::sortedIntegerQuads() might stop walking on 'x' after\n        ## checking its first 2 elements only -- the best-case scenario).\n        quads <- .GenomicRanges_as_integer_quads(x, ignore.strand)\n        !S4Vectors:::sortedIntegerQuads(quads[[1L]], quads[[2L]],\n                                        quads[[3L]], quads[[4L]],\n                                        strictly=strictly)\n    }\n)\n\n### NOT exported but used in GenomicAlignments package.\norder_GenomicRanges <- function(x, decreasing=FALSE, ignore.strand=FALSE)\n{\n    if (!isTRUEorFALSE(decreasing))\n        stop(\"'decreasing' must be TRUE or FALSE\")\n    quads <- .GenomicRanges_as_integer_quads(x, ignore.strand)\n    orderIntegerQuads(quads[[1L]], quads[[2L]],\n                      quads[[3L]], quads[[4L]],\n                      decreasing=decreasing)\n}\n\n### TODO: Support the 'ignore.strand' argument (the signature of the order()\n### generic doesn't make this as straightforward as it could be).\n### 'na.last' is pointless (GenomicRanges objects don't contain NAs) so is\n### ignored.\n### 'method' is also ignored at the moment.\nsetMethod(\"order\", \"GenomicRanges\",\n    function(..., na.last=TRUE, decreasing=FALSE,\n                  method=c(\"auto\", \"shell\", \"radix\"))\n    {\n        ## Turn off this warning for now since it triggers spurious warnings\n        ## when calling sort() on a GRangesList object. The root of the\n        ## problem is inconsistent defaults for 'na.last' between order() and\n        ## sort(), as reported here:\n        ##   https://stat.ethz.ch/pipermail/r-devel/2015-November/072012.html\n        #if (!identical(na.last, TRUE))\n        #    warning(\"\\\"order\\\" method for GenomicRanges objects \",\n        #            \"ignores the 'na.last' argument\")\n        if (!isTRUEorFALSE(decreasing))\n            stop(\"'decreasing' must be TRUE or FALSE\")\n        ## All arguments in '...' are guaranteed to be GenomicRanges objects.\n        args <- list(...)\n        if (length(args) == 1L)\n            return(order_GenomicRanges(args[[1L]], decreasing))\n        order_args <- c(unlist(lapply(args, .GenomicRanges_as_integer_quads),\n                               recursive=FALSE, use.names=FALSE),\n                        list(na.last=na.last, decreasing=decreasing))\n        do.call(order, order_args)\n    }\n)\n\n### S3/S4 combo for sort.GenomicRanges\n.sort.GenomicRanges <- function(x, decreasing=FALSE, ignore.strand=FALSE, by)\n{\n    if (missing(by)) {\n        oo <- order_GenomicRanges(x, decreasing, ignore.strand)\n    } else {\n        if (!identical(ignore.strand, FALSE))\n            warning(\"'ignore.strand' ignored when 'by' is specified\")\n        oo <- S4Vectors:::orderBy(by, x, decreasing=decreasing)\n    }\n    extractROWS(x, oo)\n}\nsort.GenomicRanges <- function(x, decreasing=FALSE, ...)\n    .sort.GenomicRanges(x, decreasing=decreasing, ...)\nsetMethod(\"sort\", \"GenomicRanges\", .sort.GenomicRanges)\n\nsetMethod(\"rank\", \"GenomicRanges\",\n    function(x, na.last=TRUE,\n             ties.method=c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"),\n             ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE of FALSE\")\n        if (ignore.strand)\n            x <- unstrand(x)\n        callNextMethod(x, na.last=na.last, ties.method=ties.method)\n    }\n)\n\n",
        "GenomicRangesList-class.R": "### =========================================================================\n### GenomicRangesList objects\n### -------------------------------------------------------------------------\n###\n\n\nsetClass(\"GenomicRangesList\",\n    contains=\"RangesList\",\n    representation(\n        \"VIRTUAL\",\n        elementMetadata=\"DataFrame\"\n    ),\n    prototype(\n        elementType=\"GenomicRanges\",\n        elementMetadata=new(\"DFrame\")\n    )\n)\n\n.valid.GenomicRangesList.mcols <- function(x)\n{\n    msg <- NULL\n    x_mcols <- x@elementMetadata\n    if (nrow(x_mcols) != length(x))\n        msg <- \"'mcols(x)' has an incorrect number of rows\"\n    if (any(c(\"seqnames\", \"ranges\", \"strand\", \"start\", \"end\", \"width\",\n              \"element\") %in% colnames(x_mcols)))\n        msg <-\n          c(msg,\n            paste(\"'mcols(x)' cannot have columns named \\\"seqnames\\\", \",\n                  \"\\\"ranges\\\", \\\"strand\\\", \\\"start\\\", \\\"end\\\", \\\"width\\\", \",\n                  \"or \\\"element\\\"\"))\n    if (!is.null(rownames(x_mcols)))\n        msg <- c(msg, \"'mcols(x)' cannot have row names\")\n    msg\n}\n\nOLD_GRANGESLIST_INSTANCE_MSG <- c(\n    \"Note that starting with BioC 3.7, the class attribute \",\n    \"of all GRangesList **instances** needs to be set to \",\n    \"\\\"CompressedGRangesList\\\". Please update this object \",\n    \"with 'updateObject(object, verbose=TRUE)' and \",\n    \"re-serialize it.\"\n)\n\n.valid.GenomicRangesList <- function(x)\n{\n    if (class(x) == \"GRangesList\")\n        return(paste(OLD_GRANGESLIST_INSTANCE_MSG, collapse=\"\"))\n    .valid.GenomicRangesList.mcols(x)\n}\n\nsetValidity2(\"GenomicRangesList\", .valid.GenomicRangesList)\n\n\n### TODO: Use this instead of GenomicRanges_OR_GRangesList in the\n### RangedSummarizedExperiment class definition to specify the class\n### of the 'rowRanges' slot.\nsetClassUnion(\"GenomicRanges_OR_GenomicRangesList\",\n    c(\"GenomicRanges\", \"GenomicRangesList\")\n)\n\n\nsetClass(\"SimpleGenomicRangesList\",\n    contains=c(\"GenomicRangesList\", \"SimpleRangesList\"),\n    representation(\"VIRTUAL\")\n)\n\nsetClass(\"CompressedGenomicRangesList\",\n    contains=c(\"GenomicRangesList\", \"CompressedRangesList\"),\n    representation(\"VIRTUAL\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\n### callNextMethod() searches for the \"closest parent method\" starting from\n### the class used in the **signature** of the method from which it is called,\n### NOT from 'class(x)'. This means that in the context of methods defined\n### for GenomicRangesList objects, like the methods below, callNextMethod()\n### would fail to find methods defined for CompressedList or SimpleList.\n### So we will use .selectClosestMethod1(), which, unlike callNextMethod(),\n### will find the \"closest parent method\" with respect to 'x'.\n.selectClosestMethod1 <- function(f, x)\n{\n    if (is(x, \"CompressedGenomicRangesList\"))\n        return(selectMethod(f, \"CompressedRangesList\"))\n    if (is(x, \"SimpleGenomicRangesList\"))\n        return(selectMethod(f, \"SimpleRangesList\"))\n    stop(wmsg(\"'class(x)' (\\\"\", class(x), \"\\\") is not supported\"))\n}\n\nsetMethod(\"updateObject\", \"GenomicRangesList\",\n    function(object, ..., verbose=FALSE)\n    {\n        ## class attribute.\n        if (class(object) == \"GRangesList\") {\n            ## Starting with GenomicRanges 1.31.13, all GRangesList instances\n            ## need to be replaced with CompressedGRangesList instances. Note\n            ## that this is NOT a change of the internals (GRangesList\n            ## instances have been using the CompressedList representation\n            ## since the beginning), only a change of the class attribute.\n            if (verbose)\n                message(\"[updateObject] Settting class attribute of \",\n                        \"GRangesList instance\\n\",\n                        \"[updateObject] to \\\"CompressedGRangesList\\\" ... \",\n                        appendLF=FALSE)\n            class(object) <- class(new(\"CompressedGRangesList\"))\n            if (verbose)\n                message(\"OK\")\n        } else {\n            if (verbose)\n                message(\"[updateObject] \", class(object), \" object \",\n                        \"is current.\\n\",\n                        \"[updateObject] Nothing to update.\")\n        }\n\n        if (is(object, \"CompressedGenomicRangesList\")) {\n            ## unlistData slot.\n            object@unlistData <- updateObject(object@unlistData,\n                                              ..., verbose=verbose)\n        }\n\n        ## 'METHOD' will be the method for CompressedList objects or\n        ## the method for Vector objects. (The former will update the\n        ## 'partitioning' and 'elementMetadata' slots, while the latter\n        ## will update the 'elementMetadata' slot only.)\n        METHOD <- .selectClosestMethod1(\"updateObject\", object)\n        METHOD(object, ..., verbose=verbose)\n    }\n)\n\n### Temporary hack to make 'length(x)' work on an old GRangesList instance.\nsetMethod(\"length\", \"GenomicRangesList\",\n    function(x)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        METHOD <- .selectClosestMethod1(\"length\", x)\n        METHOD(x)\n    }\n)\n\n### Temporary hack to make 'names(x)' work on an old GRangesList instance.\nsetMethod(\"names\", \"GenomicRangesList\",\n    function(x)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        METHOD <- .selectClosestMethod1(\"names\", x)\n        METHOD(x)\n    }\n)\n\n### Temporary hack to make 'names(x) <- value' work on an old GRangesList\n### instance.\nsetReplaceMethod(\"names\", \"GenomicRangesList\",\n    function(x, value)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        METHOD <- .selectClosestMethod1(\"names<-\", x)\n        METHOD(x, value)\n    }\n)\n\n### Temporary hack to make 'extractROWS(x, i)' work on an old GRangesList\n### instance.\nsetMethod(\"extractROWS\", c(\"GenomicRangesList\", \"ANY\"),\n    function(x, i)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        METHOD <- .selectClosestMethod1(\"extractROWS\", x)\n        METHOD(x, i)\n    }\n)\n\n### Temporary hack to make 'getListElement(x, i)' work on an old GRangesList\n### instance.\nsetMethod(\"getListElement\", \"GenomicRangesList\",\n    function(x, i, exact=TRUE)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        METHOD <- .selectClosestMethod1(\"getListElement\", x)\n        METHOD(x, i, exact=exact)\n    }\n)\n\n### Temporary hack to make 'unlist(x)' work on an old GRangesList instance.\nsetMethod(\"unlist\", \"GenomicRangesList\",\n    function(x, recursive=TRUE, use.names=TRUE)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        if (is(x, \"CompressedGenomicRangesList\")) {\n            if (!isTRUEorFALSE(use.names))\n                stop(\"'use.names' must be TRUE or FALSE\")\n            ## Update any old GRanges instance (or other GenomicRanges\n            ## derivative) stuck in the 'unlistData' slot.\n            unlisted_x <- updateObject(x@unlistData, check=FALSE)\n            if (use.names)\n                unlisted_x <- S4Vectors:::set_unlisted_names(unlisted_x, x)\n            return(unlisted_x)\n        }\n        METHOD <- .selectClosestMethod1(\"unlist\", x)\n        METHOD(x, recursive=recursive, use.names=use.names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### show()\n###\n\n### NOT exported but used in the GenomicAlignments package.\n### FIXME: Seems to repeat a lot of code from IRanges:::show_IntegerRangesList!\nshow_GenomicRangesList <- function(x, with.header=TRUE)\n{\n    if (class(x) == \"GRangesList\") {\n        warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n        x <- updateObject(x, check=FALSE)\n    }\n    x_len <- length(x)\n    if (with.header)\n        cat(classNameForDisplay(x), \" object of length \", x_len,\n            \":\\n\", sep=\"\")\n    cumsumN <- end(PartitioningByEnd(x))\n    N <- tail(cumsumN, 1)\n    if (x_len == 0L) {\n        cat(\"<0 elements>\\n\")\n    } else if (x_len <= 3L || (x_len <= 5L && N <= 20L)) {\n        ## Display full object.\n        show(as.list(x))\n    } else {\n        ## Display truncated object.\n        if (cumsumN[[3L]] <= 20L) {\n            showK <- 3L\n        } else if (cumsumN[[2L]] <= 20L) {\n            showK <- 2L\n        } else {\n            showK <- 1L\n        }\n        show(as.list(x[seq_len(showK)]))\n        diffK <- x_len - showK\n        cat(\"...\\n\",\n            \"<\", diffK, \" more element\",\n            ifelse(diffK == 1L, \"\", \"s\"), \">\\n\",\n            sep=\"\")\n    }\n    #cat(\"-------\\n\")\n    #cat(\"seqinfo: \", summary(seqinfo(x)), \"\\n\", sep=\"\")\n}\n\nsetMethod(\"show\", \"GenomicRangesList\",\n    function(object) show_GenomicRangesList(object)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### GenomicRangesList getters\n###\n\nsetMethod(\"seqnames\", \"GenomicRangesList\",\n    function(x)\n    {\n        if (!is(x, \"CompressedList\"))\n            return(as(lapply(x, seqnames), \"SimpleRleList\"))\n        unlisted_x <- unlist(x, use.names=FALSE)\n        relist(seqnames(unlisted_x), x)\n    }\n)\n\nsetMethod(\"strand\", \"GenomicRangesList\",\n    function(x)\n    {\n        if (!is(x, \"CompressedList\"))\n            return(as(lapply(x, strand), \"SimpleRleList\"))\n        unlisted_x <- unlist(x, use.names=FALSE)\n        relist(strand(unlisted_x), x)\n    }\n)\n\n### NOT exported but used in the GenomicAlignments package.\n### TODO: This should be defined as a method for RangesList objects (in\n### the IRanges package). Then it would work on all RangesList derivatives,\n### including IntegerRangesList, GenomicRangesList, and GAlignmentsList\n### objects.\nget_GenomicRangesList_mcols <-\n    function(x, use.names=FALSE, level = c(\"between\", \"within\"), ...)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    level <- match.arg(level)\n    if (level == \"between\") {\n        ans <- x@elementMetadata\n        if (use.names)\n            rownames(ans) <- names(x)\n        return(ans)\n    }\n    unlisted_x <- unlist(x, use.names=FALSE)\n    unlisted_ans <- unlisted_x@elementMetadata\n    if (use.names)\n        rownames(unlisted_ans) <- names(unlisted_x)\n    relist(unlisted_ans, x)\n}\nsetMethod(\"elementMetadata\", \"GenomicRangesList\", get_GenomicRangesList_mcols)\n\nsetMethod(\"seqinfo\", \"GenomicRangesList\",\n    combine_seqinfo_from_GenomicRanges_objects\n)\nsetMethod(\"seqinfo\", \"CompressedGenomicRangesList\",\n    function(x) seqinfo(x@unlistData)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### GenomicRangesList setters\n###\n### Note that the setters are implemented on CompressedGenomicRangesList\n### objects **only** at the moment. As a consequence, the setters do NOT\n### work on SimpleGenomicRangesList objects!\n###\n\n### NOT exported but used in the GenomicAlignments package.\nset_CompressedGenomicRangesList_seqnames <- function(x, value)\n{\n    if (!is(value, \"AtomicList\") ||\n        !identical(elementNROWS(x), elementNROWS(value)))\n        stop(\"replacement 'value' is not an AtomicList with the same \",\n             \"elementNROWS as 'x'\")\n    value <- unlist(value, use.names = FALSE)\n    if (!is(value, \"Rle\"))\n        value <- Rle(factor(value))\n    else if (!is.factor(runValue(value)))\n        runValue(value) <- factor(runValue(value))\n    seqnames(x@unlistData) <- value\n    x\n}\nsetReplaceMethod(\"seqnames\", \"CompressedGenomicRangesList\",\n    set_CompressedGenomicRangesList_seqnames\n)\n\n### NOT exported but used in the GenomicAlignments package.\nset_CompressedGenomicRangesList_strand <- function(x, value)\n{\n    if (!is(value, \"AtomicList\") ||\n        !identical(elementNROWS(x), elementNROWS(value)))\n        stop(\"replacement 'value' is not an AtomicList with the same \",\n             \"elementNROWS as 'x'\")\n    value <- unlist(value, use.names = FALSE)\n    if (!is(value, \"Rle\"))\n        value <- Rle(strand(value))\n    else if (!is.factor(runValue(value)) ||\n             !identical(levels(runValue(value)), levels(strand())))\n        runValue(value) <- strand(runValue(value))\n    strand(x@unlistData) <- value\n    x\n}\nsetReplaceMethod(\"strand\", c(\"CompressedGenomicRangesList\", \"ANY\"),\n    set_CompressedGenomicRangesList_strand\n)\nsetReplaceMethod(\"strand\", c(\"CompressedGenomicRangesList\", \"character\"),\n    function(x, ..., value)\n    {\n        if (length(value) > 1L)\n            stop(\"length(value) must be 1\")\n        strand(x@unlistData) <- value\n        x\n    }\n)\n\n### NOT exported but used in the GenomicAlignments package.\n### TODO: This should be defined as a method for RangesList objects (in\n### the IRanges package). Then it would work on all RangesList derivatives,\n### including IntegerRangesList, GenomicRangesList, and GAlignmentsList\n### objects.\nset_CompressedGenomicRangesList_mcols <-\n    function(x, level = c(\"between\", \"within\"), ..., value)\n{\n    level <- match.arg(level)\n    if (level == \"between\") {\n        if (is.null(value))\n            value <- make_zero_col_DFrame(length(x))\n        else if (!is(value, \"DataFrame\"))\n            value <- DataFrame(value)\n        if (!is.null(rownames(value)))\n            rownames(value) <- NULL\n        n <- length(x)\n        k <- nrow(value)\n        if (k != n) {\n            if ((k == 0) || (k > n) || (n %% k != 0))\n                stop(k, \" rows in value to replace \", n, \"rows\")\n            value <- value[rep(seq_len(k), length.out = n), , drop=FALSE]\n        }\n        x@elementMetadata <- value\n    } else {\n        if (is.null(value)) {\n            value <- make_zero_col_DFrame(length(x@unlistData))\n        } else {\n            if (!is(value, \"SplitDataFrameList\") ||\n                !identical(elementNROWS(x), elementNROWS(value))) {\n                stop(\"replacement 'value' is not a SplitDataFrameList with \",\n                        \"the same elementNROWS as 'x'\")\n            }\n            value <- unlist(value, use.names = FALSE)\n        }\n        mcols(x@unlistData) <- value\n    }\n    x\n}\nsetReplaceMethod(\"elementMetadata\", \"CompressedGenomicRangesList\",\n    set_CompressedGenomicRangesList_mcols\n)\n\n### NOT exported but used in the GenomicAlignments package.\nset_CompressedGenomicRangesList_seqinfo <-\n    function(x, new2old=NULL,\n             pruning.mode=c(\"error\", \"coarse\", \"fine\", \"tidy\"),\n             value)\n{\n    if (!is(value, \"Seqinfo\"))\n        stop(\"the supplied 'seqinfo' must be a Seqinfo object\")\n    pruning.mode <- match.arg(pruning.mode)\n    dangling_seqlevels <- GenomeInfoDb:::getDanglingSeqlevels(x,\n                              new2old=new2old,\n                              pruning.mode=pruning.mode,\n                              seqlevels(value))\n    if (length(dangling_seqlevels) != 0L) {\n        ## Prune 'x'.\n        idx <- !(seqnames(x) %in% dangling_seqlevels)\n        if (pruning.mode == \"coarse\") {\n            x <- x[all(idx)]  # \"coarse\" pruning\n        } else {\n            x <- x[idx]  # \"fine\" pruning\n            if (pruning.mode == \"tidy\") {\n                ## Remove list elements that became empty because of \"fine\"\n                ## pruning.\n                x <- x[any(idx) | elementNROWS(idx) == 0L]  # \"tidy\" pruning\n            }\n        }\n    }\n    seqinfo(x@unlistData, new2old=new2old) <- value\n    x\n}\nsetReplaceMethod(\"seqinfo\", \"CompressedGenomicRangesList\",\n    set_CompressedGenomicRangesList_seqinfo\n)\n\n### TODO: For the start, end, and width setters, we should probably have\n### methods for SimpleRangesList and CompressedRangesList objects (in the\n### IRanges package) instead of methods for IntegerRangesList and\n### CompressedGenomicRangesList objects.\n\nsetReplaceMethod(\"start\", \"CompressedGenomicRangesList\",\n    function(x, ..., value)\n    {\n        if (!is(value, \"IntegerList\") ||\n            !identical(elementNROWS(x), elementNROWS(value)))\n            stop(\"replacement 'value' is not an IntegerList with the same \",\n                 \"elementNROWS as 'x'\")\n        value <- unlist(value, use.names=FALSE)\n        start(x@unlistData, ...) <- value\n        x\n    }\n)\n\nsetReplaceMethod(\"end\", \"CompressedGenomicRangesList\",\n    function(x, ..., value)\n    {\n        if (!is(value, \"IntegerList\") ||\n            !identical(elementNROWS(x), elementNROWS(value)))\n            stop(\"replacement 'value' is not an IntegerList with the same \",\n                 \"elementNROWS as 'x'\")\n        value <- unlist(value, use.names = FALSE)\n        end(x@unlistData, ...) <- value\n        x\n    }\n)\n\nsetReplaceMethod(\"width\", \"CompressedGenomicRangesList\",\n    function(x, ..., value)\n    {\n        if (!is(value, \"IntegerList\") ||\n            !identical(elementNROWS(x), elementNROWS(value)))\n            stop(\"replacement 'value' is not an IntegerList with the same \",\n                 \"elementNROWS as 'x'\")\n        value <- unlist(value, use.names = FALSE)\n        width(x@unlistData, ...) <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The score() accessor\n###\n### Kind of a silly accessor. And why is it defined at the GenomicRanges\n### level and not at the Vector level? Or at least at the Ranges and\n### RangesList levels so it works on IRanges and IRangesList objects too.\n###\n\nsetMethod(\"score\", \"GenomicRangesList\",\n    function(x) mcols(x, use.names=FALSE)$score\n)\n\nsetReplaceMethod(\"score\", \"GenomicRangesList\",\n    function(x, value)\n    {\n        mcols(x)$score <- value\n        x\n    }\n)\n\n\n",
        "RangedData-methods.R": "### =========================================================================\n### RangedData/IntegerRangesList implementation of the GenomicRanges API\n### -------------------------------------------------------------------------\n###\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seqinfo\n###\n\n### April 2020: Do we still need these 2 methods? Looks like their main\n### purpose was to support seqinfo() on RangedData objects.\nsetMethod(\"seqinfo\", \"List\", function(x) {\n  si <- metadata(x)$seqinfo\n  if (is.null(si)) {\n    sn <- names(x)\n    if (is.null(sn))\n      sn <- as.character(seq_len(length(x)))\n    si <- Seqinfo(unique(sn))\n  }\n  si  \n})\n\n### FIXME: needs sanity checks\nsetReplaceMethod(\"seqinfo\", \"List\",\n                 function(x, value) {\n                   metadata(x)$seqinfo <- value\n                   x\n                 })\n\n",
        "absoluteRanges.R": "### =========================================================================\n### absoluteRanges() & related\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isSmallGenome()\n###\n\n### TODO: Maybe this could be re-used in tileGenome().\nnormarg_seqlengths <- function(seqlengths)\n{\n    if (!is.numeric(seqlengths)) \n        stop(wmsg(\"'seqlengths' must be a non-empty numeric vector\"))\n    if (length(seqlengths) == 0L)\n        return(setNames(integer(0), character(0)))\n    seqlengths_names <- names(seqlengths)\n    if (is.null(seqlengths_names)) \n        stop(wmsg(\"'seqlengths' must be named\"))\n    if (any(seqlengths_names %in% c(NA_character_, \"\"))) \n        stop(wmsg(\"'seqlengths' has names that are NA or the empty string\"))\n    if (any(duplicated(seqlengths_names))) \n        stop(wmsg(\"'seqlengths' has duplicated names\"))\n    if (!is.integer(seqlengths)) \n        seqlengths <- setNames(as.integer(seqlengths), seqlengths_names)\n    if (any(seqlengths < 0L, na.rm=TRUE))\n        stop(wmsg(\"'seqlengths' contains negative values\"))\n    seqlengths\n}\n\n### 'seqlengths' can be an integer or numeric vector, or any object from which\n### the sequence lengths can be extracted with seqlengths().\n### Returns TRUE if the total length of the underlying sequences is <= \n### '.Machine$integer.max' (e.g. Fly genome), FALSE if not (e.g. Human genome),\n### or NA if it cannot be computed (because some sequence lengths are NA).\nisSmallGenome <- function(seqlengths)\n{\n    if (is.numeric(seqlengths)) {\n        seqlengths <- normarg_seqlengths(seqlengths)\n    } else {\n        seqlengths <- seqlengths(seqlengths)\n    }\n    if (any(is.na(seqlengths)))\n        return(NA)\n    total_length <- sum(seqlengths)  # no more integer overflow in R >= 3.5\n    total_length <= .Machine$integer.max\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### absoluteRanges()\n###\n\n### Transform the genomic ranges in 'x' into \"absolute\" ranges i.e. into\n### ranges counted from the beginning of the virtual sequence obtained by\n### concatenating all the sequences in the genome (in the order reported by\n### 'seqlevels(x)'). Ignore the strand.\n### ONLY WORK ON A SMALL GENOME! (see isSmallGenome() above)\nabsoluteRanges <- function(x)\n{\n    if (!is(x, \"GenomicRanges\"))\n        stop(wmsg(\"'x' must be a GenomicRanges object\"))\n    x_seqlengths <- seqlengths(x)\n    if (!isTRUE(isSmallGenome(x_seqlengths)))\n        stop(wmsg(\"the total length of the underlying sequences is too big \",\n                  \"or couldn't be computed (because some lengths are NA)\"))\n    x_seqids <- as.integer(seqnames(x))\n    idx <- which(start(x) < 1L | end(x) > x_seqlengths[x_seqids])\n    if (length(idx) != 0L)\n        stop(wmsg(\"Some ranges in 'x' are not within the bounds of \",\n                  \"the sequence that they belong to. Cannot convert \",\n                  \"them into absolute ranges.\"))\n    offsets <- c(0L, cumsum(unname(x_seqlengths)[-length(x_seqlengths)]))\n    x_ranges <- ranges(x)\n    shift(x_ranges, shift=offsets[x_seqids])\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### relativeRanges()\n###\n\n### The reverse of absoluteRanges().\n### ONLY WORK ON A SMALL GENOME! (see isSmallGenome() above)\nrelativeRanges <- function(x, seqlengths)\n{\n    if (!is(x, \"IntegerRanges\"))\n        stop(wmsg(\"'x' must be an IntegerRanges object\"))\n    if (is.numeric(seqlengths)) {\n        ans_seqlengths <- normarg_seqlengths(seqlengths)\n        ans_seqinfo <- Seqinfo(seqnames=names(ans_seqlengths),\n                               seqlengths=ans_seqlengths)\n    } else {\n        if (is(seqlengths, \"Seqinfo\")) {\n            ans_seqinfo <- seqlengths\n        } else {\n            ans_seqinfo <- seqinfo(seqlengths)\n        }\n        ans_seqlengths <- seqlengths(ans_seqinfo)\n    }\n    if (!isTRUE(isSmallGenome(ans_seqlengths)))\n        stop(wmsg(\"the total length of the sequences specified \",\n                  \"thru 'seqlengths' is too big or couldn't be \",\n                  \"computed (because some lengths are NA)\"))\n    offsets <- c(0L, cumsum(unname(ans_seqlengths)))\n\n    ## Map each range in 'x' to a sequence in the genome.\n    ticks <- offsets + 1L\n    start2seqid <- findInterval(start(x), ticks)\n    end2seqid <- findInterval(end(x),  ticks)\n    if (!identical(start2seqid, end2seqid))\n        stop(wmsg(\"Some ranges in 'x' cannot be mapped to a sequence in the \",\n                  \"genome because they cross sequence boundaries. \",\n                  \"Cannot convert them into relative ranges.\"))\n    if (any(start2seqid < 1L) || any(start2seqid > length(ans_seqlengths)))\n        stop(wmsg(\"Some ranges in 'x' cannot be mapped to a sequence in the \",\n                  \"genome because they are outside the boundaries of the \",\n                  \"genome. Cannot convert them into relative ranges.\"))\n\n    ans_ranges <- shift(x, shift=-offsets[start2seqid])\n    ans_seqnames <- names(ans_seqlengths)[start2seqid]\n    GRanges(ans_seqnames, ans_ranges, seqinfo=ans_seqinfo)\n}\n\n",
        "constraint.R": "### =========================================================================\n### Enforcing constraints thru Constraint objects\n### -------------------------------------------------------------------------\n###\n### Attaching a Constraint object to an object of class A (the \"constrained\"\n### object) is meant to be a convenient/reusable/extensible way to enforce\n### a particular set of constraints on particular instances of A. It's an\n### alternative to the more traditional approach that consists in creating\n### subclasses of A and implementing specific validity methods for each of\n### them. However, using constraints offers the following advantages over the\n### traditional approach:\n###   (a) The traditional approach often tends to lead to a proliferation\n###       of subclasses of A.\n###   (b) Constraints can easily be re-used across different classes without\n###       the need to create any new class.\n###   (c) Constraints can easily be combined.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constraint objects.\n###\n\n### Virtual class with no slots.\nsetClass(\"Constraint\", representation(\"VIRTUAL\"))\n\n### Like the Constraint virtual class itself, concrete constraint subclasses\n### cannot have slots. A Constraint object doesn't need to contain anything\n### anyway so by enforcing this we make sure that \"combining\" constraints\n### (i.e. creating a Constraint subclass that extends more than one concrete\n### Constraint subclass) always work smoothly (no slot clashes).\nsetValidity2(\"Constraint\",\n    function(x)\n    {\n        if (length(slotNames(x)) != 0L)\n            return(\"Constraint objects cannot have slots\")\n        NULL\n    }\n)\n\n### Constrained objects can store a Constraint object (or NULL if no\n### constraints) in their 'constraint' slot.\nsetClassUnion(\"Constraint_OR_NULL\", c(\"Constraint\", \"NULL\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### constraint() accessor.\n###\n### Get or set the Constraint object stored in the constrained object.\n### Classes that want to support constraints need to implement methods for\n### those 2 generics.\n\nsetGeneric(\"constraint\", function(x) standardGeneric(\"constraint\"))\n\nsetGeneric(\"constraint<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"constraint<-\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The checkConstraint() generic.\n###\n\n### Returns a matrix with 1 signature per row. Less specific signatures are\n### guaranteed to be *before* (i.e. lower row index) the more specific ones.\n.nextCheckConstraintSignatures <- function(xClass, constraintClass)\n{\n    ## Loosely inspired by validObject().\n    xClassDef <- getClassDef(xClass)\n    xAncestors <- sapply(xClassDef@contains,\n                         slot, \"superClass\")\n    xAncestors <- c(\"ANY\", rev(xAncestors), xClass)\n    constraintClassDef <- getClassDef(constraintClass)\n    constraintAncestors <- sapply(constraintClassDef@contains,\n                                  slot, \"superClass\")\n    constraintAncestors <- c(\"ANY\", rev(constraintAncestors), constraintClass)\n    signatures <- NULL\n    for (class1 in xAncestors) {\n        for (class2 in constraintAncestors) {\n            methodDef <- selectMethod(\"checkConstraint\",\n                                      c(class1, class2),\n                                      optional=TRUE,\n                                      doCache=TRUE)\n            if (!is.null(methodDef))\n                signatures <- rbind(signatures, methodDef@defined)\n        }\n    }\n    unique(signatures)\n}\n\n### The checkConstraint() generic function implements its own dispatch\n### algorithm. Like validity methods, \"checkConstraint\" methods must return\n### NULL or a character vector describing the problems found.\nsuppressWarnings(\n  setGeneric(\"checkConstraint\", signature=c(\"x\", \"constraint\"),\n    function(x, constraint, verbose=FALSE)\n    {\n        errors <- NULL\n        signatures <- .nextCheckConstraintSignatures(class(x),\n                                                     class(constraint))\n        if (is.null(signatures))\n            return(errors)\n        ## We check from less specific to more specific constraints.\n        for (i in seq_len(nrow(signatures))) {\n            sig <- signatures[i, ]\n            sigString <- paste(names(sig),\n                               paste0('\"', sig, '\"'),\n                               sep=\"=\", collapse=\", \")\n            if (verbose)\n                message(\"Calling \\\"checkConstraint\\\" method for\\n\",\n                        \"    \", sigString)\n            method <- getMethod(\"checkConstraint\", sig)\n            errors <- method(x, constraint)\n            if (length(errors) != 0L) {\n                errors <- paste0(\"from \\\"checkConstraint\\\" method for c(\",\n                                 sigString, \"): \", errors)\n                ## If a constraint is not satisfied, we don't check the\n                ## remaining constraints (so when implementing a constraint\n                ## a developer can assume that the less specific constraints\n                ## are satisfied).\n                break\n            }\n        }\n        errors\n    }\n  )\n)\n\n",
        "coverage-methods.R": "### =========================================================================\n### \"coverage\" methods\n### -------------------------------------------------------------------------\n###\n\n### Returns a list-like object.\n.normarg_shift_or_weight <- function(arg, argname, x)\n{\n    if (is(arg, \"list_OR_List\")) {\n        if (!identical(names(arg), seqlevels(x)))\n            stop(\"when '\", argname, \"' is a list-like object, it must \",\n                 \"have 1 list element per seqlevel in 'x', and its names \",\n                 \"must be exactly 'seqlevels(x)'\")\n        return(arg)\n    }\n    arg <- IRanges:::replace_with_mcol_if_single_string(arg, x)\n    if (!(is.numeric(arg) || is(arg, \"Rle\") && is.numeric(runValue(arg))))\n        stop(\"'\", argname, \"' must be a numeric vector, a single string, \",\n             \"or a list-like object\")\n    arg <- S4Vectors:::V_recycle(arg, x, argname, \"x\")\n    split(arg, seqnames(x))\n}\n\nsetMethod(\"coverage\", \"GenomicRanges\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        ## Normalize 'shift'.\n        shift <- .normarg_shift_or_weight(shift, \"shift\", x)\n\n        ## Just handle the default 'width' here. Non default will be checked\n        ## in IRanges:::coverage_CompressedIRangesList().\n        if (is.null(width))\n            width <- seqlengths(x)\n\n        ## Normalize 'weight'.\n        weight <- .normarg_shift_or_weight(weight, \"weight\", x)\n\n        x_ranges_list <- split(ranges(x), seqnames(x))\n        circle.length <- seqlengths(x)\n        circle.length[!(isCircular(x) %in% TRUE)] <- NA_integer_\n        IRanges:::coverage_CompressedIRangesList(x_ranges_list,\n                                        shift=shift,\n                                        width=width,\n                                        weight=weight,\n                                        circle.length=circle.length,\n                                        method=method,\n                                        x_names.label=\"'seqlevels(x)'\")\n    }\n)\n\n### Overwrite above method with optimized method for StitchedGPos objects.\nsetMethod(\"coverage\", \"StitchedGPos\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        CAN_ONLY_ETC <- c(\" can only be a single number or a named \",\n                          \"list-like object when calling coverage() \",\n                          \"on a StitchedGPos object\")\n        if (!is(shift, \"list_OR_List\")) {\n            if (!isSingleNumber(shift))\n                stop(wmsg(\"'shift'\", CAN_ONLY_ETC))\n            shift <- Rle(shift)\n        }\n        if (!is(weight, \"list_OR_List\")) {\n            if (!isSingleNumber(weight))\n                stop(wmsg(\"'weight'\", CAN_ONLY_ETC))\n            weight <- Rle(weight)\n        }\n        x <- stitch_StitchedGPos(x)\n        callGeneric()\n    }\n)\n\nsetMethod(\"coverage\", \"GRangesList\",\n    function(x, shift=0L, width=NULL, weight=1L,\n                method=c(\"auto\", \"sort\", \"hash\", \"naive\"))\n    {\n        coverage(x@unlistData, shift=shift, width=width, weight=weight,\n                 method=method)\n    }\n)\n\n",
        "findOverlaps-methods.R": "### =========================================================================\n### findOverlaps methods\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"findOverlaps\" methods for GenomicRanges objects\n###\n\nfindOverlaps_GenomicRanges <- function(query, subject,\n             maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n             ignore.strand=FALSE)\n{\n    type <- match.arg(type)\n    select <- match.arg(select)\n    findOverlaps_GNCList(query, subject,\n                         maxgap=maxgap, minoverlap=minoverlap,\n                         type=type, select=select,\n                         ignore.strand=ignore.strand)\n}\n\nsetMethod(\"findOverlaps\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    findOverlaps_GenomicRanges\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"findOverlaps\" methods for GRangesList objects\n###\n\n.overlapwidth <- function(hits, query, subject)\n{\n    q_ranges <- ranges(query)[queryHits(hits)]\n    s_ranges <- ranges(subject)[subjectHits(hits)]\n    ## TODO: Replace the code below by a call to\n    ## poverlapWidth(q_ranges, s_ranges) when it's available.\n    score <- pmin.int(end(q_ranges), end(s_ranges)) -\n                     pmax.int(start(q_ranges), start(s_ranges)) + 1L\n    pmax.int(score, 0L)\n}\n\n.aggregated_sum <- function(x, f1, f2)\n{\n    sm <- selfmatchIntegerPairs(f1, f2)\n    S4Vectors:::tabulate2(sm, length(sm), weight=x)[sm]\n}\n\nsetMethod(\"findOverlaps\", c(\"GRangesList\", \"GRangesList\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n             ignore.strand=FALSE)\n    {\n        if (!isSingleNumber(minoverlap) || minoverlap < 0L)\n            stop(\"'minoverlap' must be a single non-negative integer\")\n        type <- match.arg(type)\n        select <- match.arg(select)\n\n        unlisted_query <- unlist(query, use.names=FALSE)\n        query_groups <- togroup(PartitioningByWidth(query))\n        unlisted_subject <- unlist(subject, use.names=FALSE)\n        subject_groups <- togroup(PartitioningByWidth(subject))\n \n        if (type == \"start\") {\n            keep <- which(S4Vectors:::diffWithInitialZero(subject_groups) != 0L)\n            unlisted_subject <- unlisted_subject[keep]\n            subject_groups <- subject_groups[keep]\n        } else if (type == \"end\") {\n            keep <- end(subject@partitioning)[elementNROWS(subject) > 0L]\n            unlisted_subject <- unlisted_subject[keep]\n            subject_groups <- subject_groups[keep]\n        }\n \n        ans00 <- findOverlaps(unlisted_query, unlisted_subject,\n                              maxgap=maxgap,\n                              type=type, select=\"all\",\n                              ignore.strand=ignore.strand)\n\n        if (minoverlap > 0L) {\n            owidth <- .overlapwidth(ans00, unlisted_query, unlisted_subject)\n            owidth <- .aggregated_sum(owidth,\n                                      query_groups[queryHits(ans00)],\n                                      subject_groups[subjectHits(ans00)])\n            mcols(ans00) <- DataFrame(owidth=owidth)\n        } \n        if (type == \"within\" || type == \"equal\") {\n            ans01 <- remapHits(ans00, Rnodes.remapping=subject_groups,\n                                      new.nRnode=length(subject))\n            ans11 <- remapHits(ans01, Lnodes.remapping=query_groups,\n                                      new.nLnode=length(query),\n                                      with.counts=TRUE)\n            keep <- mcols(ans11)[ , \"counts\"] ==\n                elementNROWS(query)[queryHits(ans11)]\n            if (type == \"equal\") {\n                ans10 <- remapHits(ans00, Lnodes.remapping=query_groups,\n                                   new.nLnode=length(query))\n                ans11 <- remapHits(ans10, Rnodes.remapping=subject_groups,\n                                   new.nRnode=length(subject),\n                                   with.counts=TRUE)\n                keep <- keep & mcols(ans11)[ , \"counts\"] ==\n                    elementNROWS(subject)[subjectHits(ans11)]\n            }\n            mcols(ans11) <- NULL\n            ans <- ans11[keep]\n        } else {\n            ans <- remapHits(ans00, Lnodes.remapping=query_groups,\n                                    new.nLnode=length(query),\n                                    Rnodes.remapping=subject_groups,\n                                    new.nRnode=length(subject))\n        }\n        if (minoverlap > 0L) {\n            keep_idx <- which(mcols(ans, use.names=FALSE)[ , \"owidth\"] >=\n                              minoverlap)\n            mcols(ans) <- NULL\n            ans <- ans[keep_idx]\n        }\n        selectHits(ans, select=select)\n    }\n)\n\nsetMethod(\"findOverlaps\", c(\"GRangesList\", \"GenomicRanges\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n             ignore.strand=FALSE)\n    {\n        if (!isSingleNumber(minoverlap) || minoverlap < 0L)\n            stop(\"'minoverlap' must be a single non-negative integer\")\n        type <- match.arg(type)\n        select <- match.arg(select)\n\n        unlisted_query <- unlist(query, use.names=FALSE)\n        query_groups <- togroup(PartitioningByWidth(query))\n\n        ans00 <- findOverlaps(unlisted_query, subject,\n                              maxgap=maxgap,\n                              type=type, select=\"all\",\n                              ignore.strand=ignore.strand)\n\n        if (minoverlap > 0L) {\n            owidth <- .overlapwidth(ans00, unlisted_query, subject)\n            owidth <- .aggregated_sum(owidth,\n                                      query_groups[queryHits(ans00)],\n                                      subjectHits(ans00))\n            mcols(ans00) <- DataFrame(owidth=owidth)\n        }\n        if (type == \"within\" || type == \"equal\") {\n            ans10 <- remapHits(ans00, Lnodes.remapping=query_groups,\n                                      new.nLnode=length(query),\n                                      with.counts=TRUE)\n            keep_idx <- which(mcols(ans10, use.names=FALSE)[ , \"counts\"] ==\n                              elementNROWS(query)[queryHits(ans10)])\n            mcols(ans10) <- NULL\n            ans <- ans10[keep_idx]\n        } else {\n            ans <- remapHits(ans00, Lnodes.remapping=query_groups,\n                                    new.nLnode=length(query))\n        }\n        if (minoverlap > 0L) {\n            keep_idx <- which(mcols(ans, use.names=FALSE)[ , \"owidth\"] >=\n                              minoverlap)\n            mcols(ans) <- NULL\n            ans <- ans[keep_idx]\n        }\n        selectHits(ans, select=select)\n    }\n)\n\nsetMethod(\"findOverlaps\", c(\"GenomicRanges\", \"GRangesList\"),\n    function(query, subject, maxgap=-1L, minoverlap=0L,\n             type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n             select=c(\"all\", \"first\", \"last\", \"arbitrary\"),\n             ignore.strand=FALSE)\n    {\n        if (!isSingleNumber(minoverlap) || minoverlap < 0L)\n            stop(\"'minoverlap' must be a single non-negative integer\")\n        type <- match.arg(type)\n        select <- match.arg(select)\n\n        unlisted_subject <- unlist(subject, use.names=FALSE)\n        subject_groups <- togroup(PartitioningByWidth(subject))\n\n        if (type == \"start\") {\n            keep <- which(S4Vectors:::diffWithInitialZero(subject_groups) != 0L)\n            unlisted_subject <-  unlisted_subject[keep]\n            subject_groups <- subject_groups[keep]\n        } else if (type == \"end\") {\n            keep <- end(subject@partitioning)[elementNROWS(subject) > 0L]\n            unlisted_subject <-  unlisted_subject[keep]\n            subject_groups <- subject_groups[keep]\n        }\n\n        ans00 <- findOverlaps(query, unlisted_subject,\n                              maxgap=maxgap,\n                              type=type, select=\"all\",\n                              ignore.strand=ignore.strand)\n\n        if(minoverlap > 0L) {\n            owidth <- .overlapwidth(ans00, query, unlisted_subject)\n            owidth <- .aggregated_sum(owidth,\n                                      queryHits(ans00),\n                                      subject_groups[subjectHits(ans00)])\n            mcols(ans00) <- DataFrame(owidth=owidth)\n        }\n        ans <- remapHits(ans00, Rnodes.remapping=subject_groups,\n                                new.nRnode=length(subject),\n                                with.counts=(type == \"equal\"))\n        if (type == \"equal\") {\n            keep <- mcols(ans)[ , \"counts\"] ==\n                elementNROWS(subject)[subjectHits(ans)]\n            mcols(ans) <- NULL\n            ans <- ans[keep]\n        }\n        if (minoverlap > 0L) {\n            keep_idx <- which(mcols(ans, use.names=FALSE)[ , \"owidth\"] >=\n                              minoverlap)\n            mcols(ans) <- NULL\n            ans <- ans[keep_idx]\n        }\n        selectHits(ans, select=select)\n    }\n)\n\n\n### =========================================================================\n### findOverlaps-based methods\n### -------------------------------------------------------------------------\n\ncountOverlaps_GenomicRanges <- function(query, subject,\n              maxgap=-1L, minoverlap=0L,\n              type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n              ignore.strand=FALSE)\n{\n    type <- match.arg(type)\n    ans <- findOverlaps_GNCList(query, subject,\n                                maxgap=maxgap, minoverlap=minoverlap,\n                                type=type, select=\"count\",\n                                ignore.strand=ignore.strand)\n    names(ans) <- names(query)\n    ans\n}\n\nsetMethod(\"countOverlaps\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    countOverlaps_GenomicRanges\n)\n\ncompatibleStrand <- function(a, b) {\n    a == \"*\" | b == \"*\" | a == b\n}\n\nsetMethod(\"poverlaps\", c(\"GenomicRanges\", \"GenomicRanges\"),\n          function(query, subject, maxgap=0L, minoverlap=1L,\n                   type=c(\"any\", \"start\", \"end\", \"within\", \"equal\"),\n                   ignore.strand=FALSE)\n{\n    seqnames(query) == seqnames(subject) &\n        (if (ignore.strand) TRUE\n         else compatibleStrand(strand(query), strand(subject))) &\n        poverlaps(ranges(query), ranges(subject), maxgap, minoverlap, type)\n})\n",
        "genomic-range-squeezers.R": "### =========================================================================\n### Generic functions for squeezing the genomic ranges out of a range-based\n### object\n### -------------------------------------------------------------------------\n\n\n### Extract the genomic ranges as a GRanges object.\nsetGeneric(\"granges\", signature=\"x\",\n    function(x, use.names=TRUE, use.mcols=FALSE, ...)\n        standardGeneric(\"granges\")\n)\n\n### Extract the genomic ranges as a GRangesList object.\nsetGeneric(\"grglist\", signature=\"x\",\n    function(x, use.names=TRUE, use.mcols=FALSE, ...)\n        standardGeneric(\"grglist\")\n)\n\n### Pairs method.\nsetMethod(\"grglist\", \"Pairs\", function(x, use.names=TRUE, use.mcols=FALSE) {\n              stopifnot(isTRUEorFALSE(use.mcols))\n              grl <- zipup(granges(first(x)), granges(second(x)))\n              if (!use.mcols) {\n                  mcols(grl) <- NULL\n              }\n              grl\n          })\n\n",
        "genomicvars.R": "### =========================================================================\n### Manipulate genomic variables i.e. data/variable defined along a genome\n### -------------------------------------------------------------------------\n###\n### The concept of genomic variables could be formalized via a dedicated\n### container. This container could be a simple extension of GRanges with no\n### additional slots and the following constraints:\n###   - The ranges are unstranded (i.e. strand is set to * for all ranges).\n###   - The ranges are disjoint and ordered.\n### Then the metadata columns are the genomic variables.\n### For now, we just use a GRanges object. We make sure it's disjoint and we\n### ignore its strand. We don't mind if it's not ordered and make sure that\n### the code that operates on it works properly even if it's not ordered.\n###\n\nsetAs(\"RleList\", \"GRanges\",\n    function(from)\n    {\n        what <- \"RleList object to coerce to GRanges\"\n        from_names <- names(from)\n        if (is.null(from_names))\n            stop(what, \" must have names\")\n        msg <- GenomeInfoDb:::.valid.Seqinfo.seqnames(\n                                   from_names,\n                                   what=paste(\"names of\", what))\n        if (!is.null(msg))\n            stop(wmsg(msg))\n        from_runlens <- runLength(from)\n        nrun <- lengths(from_runlens, use.names=FALSE)\n        ans_seqnames <- Rle(factor(from_names, levels=from_names), nrun)\n        ans_width <- unlist(from_runlens, use.names=FALSE)\n        ans_end <- unlist(cumsum(from_runlens), use.names=FALSE)\n        ans_ranges <- IRanges(end=ans_end, width=ans_width)\n        score <- unlist(runValue(from), use.names=FALSE)\n        GRanges(ans_seqnames,\n                ans_ranges,\n                score=score,\n                seqlengths=lengths(from))\n    }\n)\n\n### Works only on a RleViews object with no out-of-limits views.\n.from_RleViews_to_IRanges_with_score_and_view_mcols <- function(from)\n{\n    unlisted_from <- unlist(from, use.names=FALSE)  # will fail if 'from' has\n                                                    # out-of-limits views\n    from_ranges <- ranges(from)\n    q <- PartitioningByWidth(runLength(unlisted_from))\n    s <- PartitioningByWidth(from_ranges)\n    hits <- findOverlaps(q, s, minoverlap=1L)\n    ans <- from_ranges[subjectHits(hits)]\n    Ltrim <- pmax(start(q)[queryHits(hits)] - start(s)[subjectHits(hits)], 0L)\n    Rtrim <- pmax(end(s)[subjectHits(hits)] - end(q)[queryHits(hits)], 0L)\n    ans <- windows(ans, start=1L+Ltrim, end=-1L-Rtrim)\n    score <- runValue(unlisted_from)[queryHits(hits)]\n    view <- subjectHits(hits)\n    mcols(ans) <- DataFrame(score=score, view=view)\n    ans\n}\n\n### Return a GRanges object with \"score\" and \"views\" metadata columns on it.\nsetAs(\"RleViewsList\", \"GRanges\",\n    function(from)\n    {\n        irl <- IRangesList(\n            lapply(from, .from_RleViews_to_IRanges_with_score_and_view_mcols)\n        )\n        ans <- as(irl, \"GRanges\")\n        mcols(ans) <- mcols(unlist(irl, use.names=FALSE), use.names=FALSE)\n        ans\n    }\n)\n\n### Represent a collection of named RleList objects as a GRanges with 1\n### metadata column per RleList object.\nbindAsGRanges <- function(...)\n{\n    args <- list(...)\n    if (length(args) == 0L)\n        stop(\"nothing to bind\")\n    ## TODO: Implement (in C) fast 'elementIs(objects, class)' in S4Vectors\n    ## that does 'sapply(objects, is, class, USE.NAMES=FALSE)', and use it\n    ## here.\n    if (!all(sapply(args, is, \"RleList\", USE.NAMES=FALSE)))\n        stop(\"the objects to bind must be RleList objects\")\n    ans_seqlevels <- names(args[[1L]])\n    if (is.null(ans_seqlevels))\n        stop(\"the RleList objects to combine must have names\")\n    if (any(ans_seqlevels %in% c(NA_character_, \"\"))\n     || anyDuplicated(ans_seqlevels))\n        stop(wmsg(\"the names on the RleList objects cannot contain NAs, \",\n                  \"empty strings, or duplicates\"))\n    if (!all(sapply(args[-1L], function(arg)\n                               identical(names(arg), ans_seqlevels))))\n        stop(wmsg(\"the RleList objects to combine must have the same length \",\n                  \"and the same names in the same order\"))\n    DFL <- cbind(...)  # named CompressedSplitDataFrameList\n    unlisted_DFL <- unlist(DFL, use.names=FALSE)  # DataFrame\n    DFL_partitioning <- PartitioningByEnd(DFL)\n\n    ## Prepare 'ans_seqnames'.\n    ans_seqnames <- Rle(factor(ans_seqlevels, levels=ans_seqlevels),\n                        width(DFL_partitioning))\n\n    ## Prepare 'ans_ranges'.\n    ans_width <- unlisted_DFL[ , \"runLength\"]\n    width_list <- relist(ans_width, DFL)\n    ans_end <- unlist(lapply(width_list, cumsum), use.names=FALSE)\n    ans_ranges <- IRanges(end=ans_end, width=ans_width)\n\n    ## Prepare 'ans_seqlengths'.\n    ans_seqlengths <- setNames(ans_end[end(DFL_partitioning)], names(DFL))\n\n    ## First column is \"runLength\". Get rid of it.\n    ans_mcols <- unlisted_DFL[-1L]\n    ans <- new_GRanges(\"GRanges\", ans_seqnames, ans_ranges,\n                                  mcols=ans_mcols, seqinfo=ans_seqlengths)\n\n    ## Keep only ranges for which at least one variable is not NA.\n    keep_idx <- which(rowSums(!is.na(mcols(ans, use.names=FALSE))) != 0L)\n    ans[keep_idx]\n}\n\n### Return a named RleList with 1 list element per seqlevel in 'x'.\n### Works on any metadata column that can be put in Rle form (i.e. any atomic\n### vector or factor).\nmcolAsRleList <- function(x, varname)\n{\n    if (!is(x, \"GenomicRanges\"))\n        stop(\"'x' must be a GRanges object\")\n    var <- mcols(x, use.names=FALSE)[ , varname]\n\n    ## If 'var' is numeric, then we can use coverage().\n    #if (is.numeric(var))\n    #    return(coverage(x, weight=var))\n\n    ## Otherwise 'x' must be disjoint and we compute the RleList in a loop.\n    ## This would also work on a numeric metadata column but would be slower\n    ## than using coverage(), especially if 'x' has many seqlevels.\n    if (!isDisjoint(x, ignore.strand=TRUE))\n        stop(wmsg(\"cannot turn non-numeric metadata column into a \",\n                  \"named RleList object when 'x' is not disjoint \",\n                  \"(ignoring the strand)\"))\n    rg_per_chrom <- split(ranges(x), seqnames(x))\n    var_per_chrom <- split(var, seqnames(x))\n    rle_list <- mapply(\n        function(seqlen, ir, v) {\n            if (is.na(seqlen))\n                seqlen <- max(end(ir))\n            rle <- Rle(v[NA_integer_], seqlen)\n            rle[ir] <- Rle(v, width(ir))\n            rle\n        },\n        seqlengths(x),\n        rg_per_chrom,\n        var_per_chrom,\n        SIMPLIFY=FALSE\n    )\n    as(rle_list, \"SimpleRleList\")\n}\n\nbinnedAverage <- function(bins, numvar, varname, na.rm=FALSE)\n{\n    if (!is(bins, \"GRanges\"))\n        stop(\"'x' must be a GRanges object\")\n    if (!is(numvar, \"RleList\"))\n        stop(\"'numvar' must be an RleList object\")\n    if (!identical(seqlevels(bins), names(numvar)))\n        stop(\"'seqlevels(bin)' and 'names(numvar)' must be identical\")\n\n    ## A version of viewMeans() that pads \"out of limits\" views with zeros.\n    viewMeans2 <- function(v, na.rm=FALSE) {\n        if (!isTRUEorFALSE(na.rm))\n            stop(\"'na.rm' must be TRUE or FALSE\")\n        means <- viewMeans(v, na.rm=na.rm)\n        w0 <- width(v)\n        v1 <- trim(v)\n        w1 <- width(v1)\n        if (na.rm) {\n            na_count <- sum(is.na(v1))\n            w0 <- w0 - na_count\n            w1 <- w1 - na_count\n        }\n        means <- means * w1 / w0\n        means[w0 != 0L & w1 == 0L] <- 0\n        means\n    }\n\n    bins_per_chrom <- split(ranges(bins), seqnames(bins))\n    means_list <- lapply(names(numvar),\n        function(seqname) {\n            v <- Views(numvar[[seqname]], bins_per_chrom[[seqname]])\n            viewMeans2(v, na.rm=na.rm)\n        })\n    new_mcol <- unsplit(means_list, as.factor(seqnames(bins)))\n    mcols(bins)[[varname]] <- new_mcol\n    bins\n}\n\n",
        "inter-range-methods.R": "### =========================================================================\n### Inter-range methods\n### -------------------------------------------------------------------------\n###\n\n### 'revmap_unlisted' and 'revmap_partitioning': IntegerList and Partitioning\n### objects representing the \"revmap object\", which is *conceptually* an\n### IntegerListList object (of the same length as 'revmap_partitioning').\n### *Conceptually* because, well, we don't actually have such container...\n### 'old2new': IntegerList of the same length as the \"revmap object\".\n.translate_revmap <- function(revmap_unlisted, revmap_partitioning, old2new)\n{\n    ## 'times' has the length of the \"revmap object\".\n    times <- sum(relist(width(PartitioningByEnd(revmap_unlisted)),\n                        revmap_partitioning))\n    ## 'offset' has the length of 'revmap_unlisted@unlistData'.\n    offset <- rep.int(start(PartitioningByEnd(old2new)) - 1L, times)\n    revmap_flat <- revmap_unlisted@unlistData\n    revmap_unlisted@unlistData <- old2new@unlistData[revmap_flat + offset]\n    revmap_unlisted\n}\n\n### 'rgl2' and 'rgl' must be List objects (typically IntegerRangesList or\n### GRangesList) of the same length, both with a \"revmap\" inner metadata\n### column.\n.fix_inner_revmap_mcol <- function(rgl2, rgl)\n{\n    unlisted_rgl2 <- unlist(rgl2, use.names=FALSE)\n    unlisted_revmap2 <- mcols(unlisted_rgl2, use.names=FALSE)$revmap\n    revmap <- relist(mcols(unlist(rgl, use.names=FALSE), use.names=FALSE)$revmap, rgl)\n    mcols(unlisted_rgl2)$revmap <- .translate_revmap(unlisted_revmap2, rgl2,\n                                                     revmap)\n    rgl2 <- relist(unlisted_rgl2, rgl2)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Deconstruction/reconstruction of a GenomicRanges object into/from an\n### IRangesList object.\n###\n### For internal use only (not exported).\n###\n\n.make_spaceid <- function(x, ignore.strand=FALSE, drop=FALSE)\n{\n    spaceid <- seqnames(x)\n    runValue(spaceid) <- 3L * as.integer(runValue(spaceid))\n    if (!ignore.strand) {\n        strandid <- strand(x)\n        runValue(strandid) <- as.integer(runValue(strandid)) - 3L\n        spaceid <- spaceid + strandid\n    }\n    if (!drop) {\n        levels <- as.character(seq_len(3L * length(seqlevels(x))))\n        runValue(spaceid) <- structure(runValue(spaceid),\n                                       levels=levels,\n                                       class=\"factor\")\n    }\n    spaceid\n}\n\n### Work on any GenomicRanges derivative and return a CompressedIRangesList\n### instance.\ndeconstructGRintoRGL <- function(x, with.revmap=FALSE,\n                                    ignore.strand=FALSE, drop=FALSE)\n{\n    if (!isTRUEorFALSE(with.revmap))\n        stop(\"'with.revmap' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(ignore.strand))\n        stop(\"'ignore.strand' must be TRUE or FALSE\")\n    x_ranges <- unname(ranges(x))\n    if (with.revmap)\n        mcols(x_ranges) <- DataFrame(revmap=seq_along(x_ranges))\n    x_spaceid <- .make_spaceid(x, ignore.strand=ignore.strand, drop=drop)\n    split(x_ranges, x_spaceid)\n}\n\n### Return a GRanges instance.\nreconstructGRfromRGL <- function(rgl, x)\n{\n    ## Prepare 'ans_ranges'.\n    ans_ranges <- unlist(rgl, use.names=FALSE)\n\n    ## Prepare 'ans_seqnames' and 'ans_strand'.\n    rgl_eltNROWS <- elementNROWS(rgl)\n    spaceid <- as.integer(names(rgl)) - 1L\n    ans_seqnames <- Rle(structure(spaceid %/% 3L + 1L,\n                                  levels=seqlevels(x),\n                                  class=\"factor\"),\n                        rgl_eltNROWS)\n    ans_strand <- Rle(structure(spaceid %% 3L + 1L,\n                                levels=levels(strand()),\n                                class=\"factor\"),\n                      rgl_eltNROWS)\n\n    ## Prepare 'ans_mcols'.\n    ans_mcols <- mcols(ans_ranges, use.names=FALSE)\n    if (is.null(ans_mcols)) {\n        ans_mcols <- make_zero_col_DFrame(length(ans_ranges))\n    } else {\n        mcols(ans_ranges) <- NULL\n    }\n\n    ## Prepare 'ans_seqinfo'.\n    ans_seqinfo <- seqinfo(x)\n\n    ## To be as fast as possible, we don't use internal low-level constructor\n    ## new_GRanges() and we don't check the new object.\n    new2(\"GRanges\", seqnames=ans_seqnames,\n                    ranges=ans_ranges,\n                    strand=ans_strand,\n                    elementMetadata=ans_mcols,\n                    seqinfo=ans_seqinfo,\n                    check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Deconstruction/reconstruction of a GRangesList object into/from a GRanges\n### object.\n###\n### For internal use only (not exported).\n###\n\n### 'f' is assumed to be an integer vector of non-negative values with no NAs.\n.pad_with_zeros <- function(f)\n{\n    stopifnot(is.integer(f))\n    if (length(f) == 0L)\n        return(character())\n    f_max <- max(f)\n    if (f_max <= 9L)\n        return(as.character(f))\n    nd <- as.integer(log10(f_max)) + 1L\n    sprintf(paste0(\"%0\", nd, \"d\"), f)\n}\n\n.paste12 <- function(f1, f2)\n{\n    paste(.pad_with_zeros(f1), .pad_with_zeros(f2), sep=\"|\")\n}\n\n### Unlist GRangesList object 'x' into a GRanges object but the differences\n### with the \"unlist\" method for GRangesList objects are:\n###   - The sequence names of the returned GRanges object are modified by\n###     embedding the \"grouping by top-level element\" information in them.\n###   - The seqinfo is modified accordingly.\ndeconstructGRLintoGR <- function(x, expand.levels=FALSE)\n{\n    ans <- x@unlistData\n    f1 <- rep.int(seq_along(x), elementNROWS(x))\n    f2 <- as.integer(seqnames(ans))\n    f12 <- .paste12(f1, f2)\n\n    ## Compute 'ans_seqinfo'.\n    if (expand.levels) {\n        x_nlev <- length(seqlevels(x))\n        i1 <- rep(seq_len(length(x)), each=x_nlev)\n        i2 <- rep.int(seq_len(x_nlev), length(x))\n    } else {\n        oo <- orderIntegerPairs(f1, f2)\n        of1 <- f1[oo]\n        of2 <- f2[oo]\n        ## TODO: Support 'method=\"presorted\"' in duplicatedIntegerPairs() for\n        ## when the 2 input vectors are already sorted.\n        notdups <- !duplicatedIntegerPairs(of1, of2)\n        i1 <- of1[notdups]\n        i2 <- of2[notdups]\n    }\n    x_seqinfo <- seqinfo(x)\n    ans_seqlevels <- .paste12(i1, i2)\n    ans_seqlengths <- unname(seqlengths(x_seqinfo))[i2]\n    ans_isCircular <- unname(isCircular(x_seqinfo))[i2]\n    ans_seqinfo <- Seqinfo(ans_seqlevels, ans_seqlengths, ans_isCircular)\n\n    ## The 2 following modifications must be seen as a single atomic\n    ## operation since doing the 1st without doing the 2nd would leave 'ans'\n    ## in a broken state.\n    ans@seqnames <- Rle(factor(f12, ans_seqlevels))\n    ans@seqinfo <- ans_seqinfo\n    ans\n}\n\n### The \"inverse\" transform of deconstructGRLintoGR().\n### More precisely, reconstructGRLfromGR() transforms GRanges object 'gr'\n### with sequence names in the \"f1|f2\" format (as produced by\n### deconstructGRLintoGR() above) back into a GRangesList object with the\n### same length & names & metadata columns & seqinfo as 'x'.\n### The fundamental property of this deconstruction/reconstruction mechanism\n### is that, for any GRangesList object 'x':\n###\n###   reconstructGRLfromGR(deconstructGRLintoGR(x), x) is identical to x\n###\nreconstructGRLfromGR <- function(gr, x, with.revmap=FALSE)\n{\n    snames <- strsplit(as.character(seqnames(gr)), \"|\", fixed=TRUE)\n    m12 <- matrix(as.integer(unlist(snames)), ncol=2, byrow=TRUE)\n\n    ## Restore the real sequence names.\n    f2 <- m12[ , 2L]\n    x_seqlevels <- seqlevels(x)\n    ## The 2 following modifications must be seen as a single atomic\n    ## operation since doing the 1st without doing the 2nd would leave 'ans'\n    ## in a broken state.\n    gr@seqnames <- Rle(factor(x_seqlevels[f2], x_seqlevels))\n    gr@seqinfo <- seqinfo(x)\n\n    ## Split.\n    f1 <- m12[ , 1L]\n    ans <- split(gr, factor(f1, levels=seq_len(length(x))))\n\n    ## Decorate 'ans'.\n    metadata(ans) <- metadata(x)\n    names(ans) <- names(x)\n    if (with.revmap) {\n        unlisted_ans <- unlist(ans, use.names=FALSE)\n        mcols(unlisted_ans)$revmap <-\n            IRanges:::global2local_revmap(mcols(unlisted_ans, use.names=FALSE)$revmap, ans, x)\n        ans <- relist(unlisted_ans, ans)\n    }\n    mcols(ans) <- mcols(x, use.names=FALSE)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### range()\n###\n\n### Always return a GRanges *instance* whatever GenomicRanges derivative the\n### input is, so does NOT act like an endomorphism in general. \nsetMethod(\"range\", \"GenomicRanges\",\n    function(x, ..., with.revmap=FALSE, ignore.strand=FALSE, na.rm=FALSE)\n    {\n        if (!identical(na.rm, FALSE))\n            warning(\"'na.rm' argument is ignored\")\n        args <- unname(list(x, ...))\n        args <- lapply(args, granges)\n        gr <- do.call(c, args)\n\n        rgl <- deconstructGRintoRGL(gr, with.revmap=with.revmap,\n                                    ignore.strand=ignore.strand, drop=TRUE)\n        rgl2 <- callGeneric(rgl, with.revmap=with.revmap)\n        if (with.revmap)\n            rgl2 <- .fix_inner_revmap_mcol(rgl2, rgl)\n        reconstructGRfromRGL(rgl2, gr)\n    }\n)\n\n### Overwrite above method with optimized method for StitchedGPos objects.\n### Like the above method, return a GRanges instance.\nsetMethod(\"range\", \"StitchedGPos\",\n    function(x, ..., with.revmap=FALSE, ignore.strand=FALSE, na.rm=FALSE)\n        callGeneric(stitch_StitchedGPos(x), ...,\n                    with.revmap=with.revmap, ignore.strand=ignore.strand,\n                    na.rm=na.rm)\n)\n\nsetMethod(\"range\", \"GRangesList\",\n    function(x, ..., with.revmap=FALSE, ignore.strand=FALSE, na.rm=FALSE)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        if (is(x, \"CompressedList\")) {\n            gr <- deconstructGRLintoGR(x)\n            ## \"range\" method for GRanges objects is fast.\n            gr2 <- callGeneric(gr, ..., with.revmap=with.revmap,\n                               ignore.strand=ignore.strand, na.rm=na.rm)\n            ans <- reconstructGRLfromGR(gr2, x, with.revmap=with.revmap)\n            return(ans)\n        }\n        endoapply(x, range, ..., with.revmap=with.revmap,\n                     ignore.strand=ignore.strand, na.rm=na.rm)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### reduce()\n###\n\n### Always return a GRanges *instance* whatever GenomicRanges derivative the\n### input is, so does NOT act like an endomorphism in general. \nsetMethod(\"reduce\", \"GenomicRanges\",\n    function(x, drop.empty.ranges=FALSE, min.gapwidth=1L,\n                with.revmap=FALSE,\n                with.inframe.attrib=FALSE, ignore.strand=FALSE)\n    {\n        if (!identical(with.inframe.attrib, FALSE))\n            stop(\"'with.inframe.attrib' argument not supported \",\n                 \"when reducing a GenomicRanges object\")\n        rgl <- deconstructGRintoRGL(x, with.revmap=with.revmap,\n                                       ignore.strand=ignore.strand, drop=TRUE)\n        rgl2 <- callGeneric(rgl, drop.empty.ranges=drop.empty.ranges,\n                                 min.gapwidth=min.gapwidth,\n                                 with.revmap=with.revmap)\n        if (with.revmap)\n            rgl2 <- .fix_inner_revmap_mcol(rgl2, rgl)\n        reconstructGRfromRGL(rgl2, x)\n    }\n)\n\nsetMethod(\"reduce\", \"GRangesList\",\n    function(x, drop.empty.ranges=FALSE, min.gapwidth=1L,\n                with.revmap=FALSE,\n                with.inframe.attrib=FALSE, ignore.strand=FALSE)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        if (!identical(with.inframe.attrib, FALSE)) \n            stop(\"'with.inframe.attrib' argument is not supported \", \n                 \"when reducing a GRangesList object\")\n        if (is(x, \"CompressedList\")) {\n            gr <- deconstructGRLintoGR(x)\n            gr2 <- callGeneric(gr, drop.empty.ranges=drop.empty.ranges,\n                                   min.gapwidth=min.gapwidth,\n                                   with.revmap=with.revmap,\n                                   ignore.strand=ignore.strand)\n            ans <- reconstructGRLfromGR(gr2, x, with.revmap=with.revmap)\n            return(ans)\n        }\n        endoapply(x, reduce, drop.empty.ranges=drop.empty.ranges,\n                             min.gapwidth=min.gapwidth,\n                             with.revmap=with.revmap,\n                             ignore.strand=ignore.strand)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### gaps()\n###\n\n### Always return a GRanges *instance* whatever GenomicRanges derivative the\n### input is, so does NOT act like an endomorphism in general. \nsetMethod(\"gaps\", \"GenomicRanges\",\n    function(x, start=1L, end=seqlengths(x), ignore.strand=FALSE)\n    {\n        seqlevels <- seqlevels(x)\n        if (!is.null(names(start)))\n            start <- start[seqlevels]\n        if (!is.null(names(end)))\n            end <- end[seqlevels]\n        start <- S4Vectors:::recycleVector(start, length(seqlevels))\n        start <- rep(start, each=3L)\n        end <- S4Vectors:::recycleVector(end, length(seqlevels))\n        end <- rep(end, each=3L)\n        rgl <- deconstructGRintoRGL(x, ignore.strand=ignore.strand)\n        rgl2 <- callGeneric(rgl, start=start, end=end)\n        ans <- reconstructGRfromRGL(rgl2, x)\n        if (ignore.strand)\n            ans <- ans[strand(ans) == \"*\"]\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### disjoin()\n###\n\n### Always return a GRanges *instance* whatever GenomicRanges derivative the\n### input is, so does NOT act like an endomorphism in general. \nsetMethod(\"disjoin\", \"GenomicRanges\",\n    function(x, with.revmap=FALSE, ignore.strand=FALSE)\n    {\n        rgl <- deconstructGRintoRGL(x, with.revmap=with.revmap, \n                                       ignore.strand=ignore.strand, drop=TRUE)\n        rgl2 <- callGeneric(rgl, with.revmap=with.revmap)\n        if (with.revmap)\n            rgl2 <- .fix_inner_revmap_mcol(rgl2, rgl)\n        reconstructGRfromRGL(rgl2, x)\n    }\n)\n\nsetMethod(\"disjoin\", \"GRangesList\",\n    function(x, with.revmap=FALSE, ignore.strand=FALSE)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        if (is(x, \"CompressedList\")) {\n            gr <- deconstructGRLintoGR(x)\n            gr2 <- callGeneric(gr, with.revmap=with.revmap,\n                                   ignore.strand=ignore.strand)\n            ans <- reconstructGRLfromGR(gr2, x, with.revmap=with.revmap)\n            return(ans)\n        }\n        endoapply(x, disjoin, with.revmap=with.revmap,\n                     ignore.strand=ignore.strand)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isDisjoint()\n###\n\nsetMethod(\"isDisjoint\", \"GenomicRanges\",\n    function(x, ignore.strand=FALSE)\n    {\n        rgl <- deconstructGRintoRGL(x, ignore.strand=ignore.strand, drop=TRUE)\n        all(callGeneric(rgl))\n    }\n)\n\n### Overwrite above method with optimized method for StitchedGPos objects.\nsetMethod(\"isDisjoint\", \"StitchedGPos\",\n    function(x, ignore.strand=FALSE)\n        callGeneric(stitch_StitchedGPos(x), ignore.strand)\n)\n\nsetMethod(\"isDisjoint\", \"GRangesList\",\n    function(x, ignore.strand=FALSE)\n    {\n        if (class(x) == \"GRangesList\") {\n            #warning(wmsg(OLD_GRANGESLIST_INSTANCE_MSG))\n            x <- updateObject(x, check=FALSE)\n        }\n        if (is(x, \"CompressedList\")) {\n            gr <- deconstructGRLintoGR(x, expand.levels=TRUE)\n            rgl <- deconstructGRintoRGL(gr, ignore.strand=ignore.strand)\n            ans <- callGeneric(rgl)\n            ans <- colSums(matrix(!ans, ncol=length(x))) == 0L\n            names(ans) <- names(x)\n            return(ans)\n        }\n        endoapply(x, isDisjoint, ignore.strand=ignore.strand)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### disjointBins()\n###\n\nsetMethod(\"disjointBins\", \"GenomicRanges\",\n    function(x, ignore.strand=FALSE)\n    {\n        x_spaceid <- .make_spaceid(x, ignore.strand=ignore.strand, drop=TRUE)\n        rgl <- split(unname(ranges(x)), x_spaceid)\n        ans <- callGeneric(rgl)\n        unsplit(ans, x_spaceid)\n    }\n)\n\n",
        "intra-range-methods.R": "### =========================================================================\n### Intra-range methods\n### -------------------------------------------------------------------------\n###\n### The methods implemented in this file should behave consistently with\n### those defined in IRanges intra-range-methods.R\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### update_ranges()\n###\n### For internal use only. Generic defined in the IRanges package.\n###\n\nsetMethod(\"update_ranges\", \"GenomicRanges\",\n    function(x, start=NULL, end=NULL, width=NULL, use.names=TRUE)\n    {\n        new_ranges <- update_ranges(ranges(x), start=start,\n                                               end=end,\n                                               width=width,\n                                               use.names=use.names)\n        update(x, ranges=new_ranges)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### resize()\n###\n\nsetMethod(\"resize\", \"GenomicRanges\",\n    function(x, width, fix=\"start\", use.names=TRUE, ignore.strand=FALSE)\n    {\n        if (!missing(fix) && length(x) > 0L && \n            (length(fix) > length(x) || length(x) %% length(fix) > 0L))\n            stop(\"'x' is not a multiple of 'fix' length\")\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        if (ignore.strand) {\n            fix <- Rle(fix, length(x))\n        } else {\n            revFix <- c(start=\"end\", end=\"start\", center=\"center\")\n            if (length(x) == 0L)\n              fix <- character()\n            else fix <- ifelse(strand(x) == \"-\", revFix[fix], fix)\n        }\n        ## For some unclear reason (likely a bug in callNextMethod) we need\n        ## to explicitly pass the arguments to the call below, otherwise\n        ## it seems that the original unmodified 'start' gets passed.\n        #callNextMethod()\n        callNextMethod(x, width, fix=fix, use.names=use.names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### flank()\n###\n\nsetMethod(\"flank\", \"GenomicRanges\", \n    function(x, width, start=TRUE, both=FALSE, use.names=TRUE,\n                ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        if (!is.logical(start) || S4Vectors:::anyMissing(start))\n            stop(\"'start' must be logical without NA's\")\n        start <- S4Vectors:::recycleVector(unname(start), length(x))\n        if (!ignore.strand)\n            start <- as.vector(start != (strand(x) == \"-\"))\n        ## For some unclear reason (likely a bug in callNextMethod) we need\n        ## to explicitly pass the arguments to the call below, otherwise\n        ## it seems that the original unmodified 'start' gets passed.\n        #callNextMethod()\n        callNextMethod(x, width, start=start, both=both, use.names=use.names)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### promoters() and terminators()\n###\n\n### Returns an IRanges **instance**.\n.compute_promoter_ranges <- function(x, strand, upstream, downstream,\n                                     site=c(\"TSS\", \"TES\"))\n{\n    site <- match.arg(site)\n    stopifnot(is(x, \"IPosRanges\"),\n              length(x) == length(strand),\n              length(x) == length(upstream),\n              length(x) == length(downstream))\n    ans_start <- start(x)\n    ans_end <- end(x)\n    strand_is_minus <- strand == \"-\"\n    plus_idx <- which(!strand_is_minus)\n    minus_idx <- which(strand_is_minus)\n    if (site == \"TSS\") {\n        plus_site <- ans_start[plus_idx]\n        minus_site <- ans_end[minus_idx]\n    } else {\n        plus_site <- ans_end[plus_idx]\n        minus_site <- ans_start[minus_idx]\n    }\n    ans_start[plus_idx] <- plus_site - upstream[plus_idx]\n    ans_end[plus_idx] <- plus_site + downstream[plus_idx] - 1L\n    ans_end[minus_idx] <- minus_site + upstream[minus_idx]\n    ans_start[minus_idx] <- minus_site - downstream[minus_idx] + 1L\n    IRanges(ans_start, ans_end, names=names(x))\n}\n\n### Computes the promoter regions if 'site' is set to \"TSS\" (Transcription\n### Start Site), or the terminator regions if it's set to \"TES\" (Transcription\n### End Site).\n### Always behaves like an endomorphism, except when 'x' is a GPos derivative.\n.GenomicRanges_promoters <- function(x, upstream, downstream, use.names=TRUE,\n                                     site=c(\"TSS\", \"TES\"))\n{\n    site <- match.arg(site)\n    x_len <- length(x)\n    upstream <- recycleIntegerArg(upstream, \"upstream\", x_len)\n    downstream <- recycleIntegerArg(downstream, \"downstream\", x_len)\n    use.names <- S4Vectors:::normargUseNames(use.names)\n    if (x_len == 0L) {\n        if (!use.names)\n            names(x) <- NULL\n        return(x)\n    }\n    if (min(upstream) < 0L || min(downstream) < 0L)\n        stop(\"'upstream' and 'downstream' must be integers >= 0\")\n    old_ranges <- ranges(x, use.names=use.names)\n    new_ranges <- .compute_promoter_ranges(old_ranges,\n                                           strand(x),\n                                           upstream, downstream,\n                                           site=site)\n    ## 'new_ranges' is an IRanges **instance** but a GPos object won't\n    ## accept this in its \"ranges\" slot. So if 'x' is a GPos object,\n    ## we first turn it into a GRanges **instance** so we can stick\n    ## 'new_ranges' in it.\n    if (is(x, \"GPos\"))\n        x <- as(x, \"GRanges\", strict=TRUE)\n    update(x, ranges=new_ranges)\n}\n\nsetMethod(\"promoters\", \"GenomicRanges\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE)\n        .GenomicRanges_promoters(x, upstream, downstream, use.names=use.names,\n                                 site=\"TSS\")\n)\n\nsetMethod(\"terminators\", \"GenomicRanges\",\n    function(x, upstream=2000, downstream=200, use.names=TRUE)\n        .GenomicRanges_promoters(x, upstream, downstream, use.names=use.names,\n                                 site=\"TES\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### reflect()\n###\n\n### TODO: Add \"reflect\" method for GenomicRanges objects.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### restrict()\n###\n\n.checkParms <- function(x, parm)\n{\n    if (!all(is.na(parm))) {\n        if (!all(names(parm) %in% levels(seqnames(x))))\n            stop(\"start should be a named numeric vector \",\n                 \"corresponding to seqnames\")\n    }\n    temp <- structure(rep(NA_integer_, length(levels(seqnames(x)))), \n                      names=levels(seqnames(x)))\n    temp[names(parm)] <- parm\n    temp\n}\n\n.restrictRngs <- function(x, start, end, keep.all.ranges, use.names)\n{\n    tmp <- names(x)\n    names(x) <- seq_len(length(x))\n    rng <- ranges(x)\n    res <- restrict(ranges(x), start, end, keep.all.ranges, use.names=TRUE)\n    x <- x[as.numeric(names(res))]\n    ranges(x) <- res\n    if (!use.names)\n        names(x) <- NULL\n    else \n        names(x) <- tmp[as.numeric(names(res))]\n    x\n}\n\nsetMethod(\"restrict\", \"GenomicRanges\",\n    function(x, start=NA, end=NA, keep.all.ranges=FALSE, use.names=TRUE)\n    {\n        if (is.null(names(start)) && is.null(names(end)))\n            return(.restrictRngs(x, start, end,keep.all.ranges, use.names))\n        x_mcols <- mcols(x, use.names=FALSE)\n        nms <- names(x_mcols)\n        mcols(x) <- cbind(x_mcols, DataFrame(posIndx=seq_len(length(x))))\n        splt <- split(x, seqnames(x))\n        start <- .checkParms(x, start)\n        end <- .checkParms(x, end) \n        res <- lapply(names(splt),\n                      function(i) {\n                          .restrictRngs(splt[[i]], start=start[i], end=end[i],\n                                        keep.all.ranges, use.names)\n                      })\n        names(res) <- names(splt)\n        ord <- unlist(GRangesList(res), use.names=FALSE)\n        df <- data.frame(orig=mcols(ord)[[\"posIndx\"]],\n                         final=seq_len(length(ord)))\n        indx <- order(df[[\"orig\"]], df[[\"final\"]])\n        ord <- ord[indx, ]\n        mcols(ord) <- subset(mcols(ord, use.names=FALSE), select=nms)\n        ord\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### trim()\n###\n\nsetMethod(\"trim\", \"GenomicRanges\",\n    function(x, use.names=TRUE)\n    {\n        ## We trim only out-of-bound ranges located on non-circular sequences\n        ## whose length is not NA.\n        ## See get_out_of_bound_index() in GenomicRanges-class.R\n        idx <- get_out_of_bound_index(x)\n        if (length(idx) == 0L)\n            return(x)\n        new_ranges <- ranges(x)\n        seqnames_id <- as.integer(seqnames(x))[idx]\n        new_end <- unname(seqlengths(x))[seqnames_id]\n        new_ranges[idx] <- restrict(new_ranges[idx], start=1L, end=new_end,\n                                                     keep.all.ranges=TRUE)\n        update(x, ranges=new_ranges)\n    }\n)\n\nsetMethod(\"trim\", \"GRangesList\",\n          function(x, use.names=TRUE)\n          {\n              ## Like seqinfo,GRangesList, assumes that there is a\n              ## single Seqinfo for the entire object. Only guaranteed\n              ## to be true in the compressed case.\n              relist(trim(unlist(x, use.names=FALSE), use.names=use.names), x)\n          })\n\n",
        "makeGRangesFromDataFrame.R": "### =========================================================================\n### makeGRangesFromDataFrame()\n### -------------------------------------------------------------------------\n\n\n.normarg_field <- function(field, what)\n{\n    if (!is.character(field) || any(is.na(field)))\n        stop(\"'\", what, \".field' must be a character vector with no NAs\")\n    tolower(field)\n}\n\n.collect_prefixes <- function(df_colnames, field)\n{\n    df_colnames_nc <- nchar(df_colnames)\n    prefixes <- lapply(field,\n        function(suf) {\n            pref_nc <- df_colnames_nc - nchar(suf)\n            idx <- which(substr(df_colnames, pref_nc + 1L, df_colnames_nc) ==\n                         suf)\n            substr(df_colnames[idx], 1L, pref_nc[idx])\n        })\n    unique(unlist(prefixes))\n}\n\n.find_start_end_cols <- function(df_colnames, start.field, end.field)\n{\n    idx1 <- which(df_colnames %in% start.field)\n    idx2 <- which(df_colnames %in% end.field)\n    if (length(idx1) == 1L && length(idx2) == 1L)\n        return(list(c(start=idx1, end=idx2), \"\"))\n    if (length(idx1) == 0L && length(idx2) == 0L) {\n        prefixes1 <- .collect_prefixes(df_colnames, start.field)\n        prefixes2 <- .collect_prefixes(df_colnames, end.field)\n        if (length(prefixes1) == 1L && length(prefixes2) == 1L\n         && prefixes1 == prefixes2)\n        {\n            prefix <- prefixes1\n            idx1 <- which(df_colnames %in% paste0(prefix, start.field))\n            idx2 <- which(df_colnames %in% paste0(prefix, end.field))\n            if (length(idx1) == 1L && length(idx2) == 1L)\n                return(list(c(start=idx1, end=idx2), prefix))\n        }\n    }\n    stop(\"cannnot determine start/end columns\")\n}\n\n.find_width_col <- function(df_colnames, width.field, prefix)\n{\n    idx <- which(df_colnames %in% paste0(prefix, width.field))\n    if (length(idx) == 0L)\n        idx <- which(df_colnames %in% width.field)\n    if (length(idx) == 0L)\n        return(NA_integer_)\n    if (length(idx) >= 2L) {\n        warning(\"cannnot determine width column unambiguously\")\n        return(idx[[1L]])\n    }\n    idx\n}\n\n.find_seqnames_col <- function(df_colnames, seqnames.field, prefix)\n{\n    idx <- which(df_colnames %in% paste0(prefix, seqnames.field))\n    if (length(idx) == 0L)\n        idx <- which(df_colnames %in% seqnames.field)\n    if (length(idx) == 0L)\n        stop(\"cannnot find seqnames column\")\n    if (length(idx) >= 2L)\n        stop(\"cannnot determine seqnames column unambiguously\")\n    idx\n}\n\n.find_strand_col <- function(df_colnames, strand.field, prefix)\n{\n    idx <- which(df_colnames %in% paste0(prefix, strand.field))\n    if (length(idx) == 0L)\n        idx <- which(df_colnames %in% strand.field)\n    if (length(idx) == 0L)\n        return(NA_integer_)\n    if (length(idx) >= 2L)\n        stop(\"Cannnot determine strand column unambiguously. \",\n             \"(You can use\\n  'ignore.strand=TRUE' to ignore \",\n             \"strand information.)\")\n    idx\n}\n\n### Returns a named integer vector of length 5. Names are: seqnames, start,\n### end, width, and strand. The values must be valid column numbers, except\n### for the width and strand elements that can also be NAs.\n.find_GRanges_cols <- function(df_colnames,\n                               seqnames.field=c(\"seqnames\", \"seqname\",\n                                                \"chromosome\", \"chrom\",\n                                                \"chr\", \"chromosome_name\",\n                                                \"seqid\"),\n                               start.field=\"start\",\n                               end.field=c(\"end\", \"stop\"),\n                               strand.field=\"strand\",\n                               ignore.strand=FALSE)\n{\n    ## Automatic detection of seqnames/start/end/strand columns is case\n    ## insensitive.\n    df_colnames0 <- tolower(df_colnames)\n    seqnames.field0 <- .normarg_field(seqnames.field, \"seqnames\")\n    start.field0 <- .normarg_field(start.field, \"start\")\n    end.field0 <- .normarg_field(end.field, \"end\")\n\n    start_end_cols <- .find_start_end_cols(df_colnames0,\n                                           start.field0,\n                                           end.field0)\n    prefix <- start_end_cols[[2L]]\n    ## Name of \"width\" field is not under user control for now (until we need\n    ## need that).\n    width_col <- .find_width_col(df_colnames0, \"width\", prefix)\n    seqnames_col <- .find_seqnames_col(df_colnames0,\n                                       seqnames.field0,\n                                       prefix)\n    if (ignore.strand) {\n        strand_col <- NA_integer_\n    } else {\n        strand.field0 <- .normarg_field(strand.field, \"strand\")\n        strand_col <- .find_strand_col(df_colnames0,\n                                       strand.field0,\n                                       prefix)\n    }\n    c(seqnames=seqnames_col, start_end_cols[[1L]], width=width_col,\n      strand=strand_col)\n}\n\n.get_data_frame_col_as_numeric <- function(df, col)\n{\n    ans <- df[[col]]\n    if (is(ans, \"Rle\"))\n        ans <- S4Vectors:::decodeRle(ans)\n    if (!is.numeric(ans)) {\n        if (is.factor(ans))\n            ans <- as.character(ans)\n        ans <- suppressWarnings(as.numeric(ans))\n        if (anyNA(ans))\n            stop(wmsg(\"some values in the \",\n                      \"\\\"\", names(df)[[col]], \"\\\" \",\n                      \"column cannot be turned into numeric values\"))\n    }\n    ans\n}\n\n### 'df' must be a data.frame or DataFrame object.\nmakeGRangesFromDataFrame <- function(df,\n                                     keep.extra.columns=FALSE,\n                                     ignore.strand=FALSE,\n                                     seqinfo=NULL,\n                                     seqnames.field=c(\"seqnames\", \"seqname\",\n                                                      \"chromosome\", \"chrom\",\n                                                      \"chr\", \"chromosome_name\",\n                                                      \"seqid\"),\n                                     start.field=\"start\",\n                                     end.field=c(\"end\", \"stop\"),\n                                     strand.field=\"strand\",\n                                     starts.in.df.are.0based=FALSE,\n                                     na.rm=FALSE)\n{\n    ## Check args.\n    if (is.character(df))  # for people that provide the path to a file\n        stop(\"'df' must be a data.frame or DataFrame object\")\n    if (!(is.data.frame(df) || is(df, \"DataFrame\")))\n        df <- as.data.frame(df)\n    if (!isTRUEorFALSE(keep.extra.columns))\n        stop(\"'keep.extra.columns' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(ignore.strand))\n        stop(\"'ignore.strand' must be TRUE or FALSE\")\n    ans_seqinfo <- normarg_seqinfo1(seqinfo)\n    if (!isTRUEorFALSE(starts.in.df.are.0based))\n        stop(\"'starts.in.df.are.0based' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    granges_cols <- .find_GRanges_cols(names(df),\n                                       seqnames.field=seqnames.field,\n                                       start.field=start.field,\n                                       end.field=end.field,\n                                       strand.field=strand.field,\n                                       ignore.strand=ignore.strand)\n\n    ## Prepare 'ans_ranges'.\n    ans_start <- .get_data_frame_col_as_numeric(df, granges_cols[[\"start\"]])\n    ans_end <- .get_data_frame_col_as_numeric(df, granges_cols[[\"end\"]])\n    is_na <- is.na(ans_start) | is.na(ans_end)\n\n    if (any(is_na)) {\n        if (!na.rm) {\n            start_colname <- names(df)[[granges_cols[[\"start\"]]]]\n            end_colname <- names(df)[[granges_cols[[\"end\"]]]]\n            stop(wmsg(\n                \"The \\\"\", start_colname, \"\\\" and/or \\\"\", end_colname, \"\\\" \",\n                \"columns contain NAs. Use 'na.rm=TRUE' to ignore the rows \",\n                \"with NAs.\"\n            ))\n        }\n        keep_idx <- which(!is_na)\n        df <- S4Vectors:::extract_data_frame_rows(df, keep_idx)\n        ans_start <- ans_start[keep_idx]\n        ans_end <- ans_end[keep_idx]\n    }\n\n    ## Prepare 'ans_seqnames'.\n    ans_seqnames <- df[[granges_cols[[\"seqnames\"]]]]\n\n    if (starts.in.df.are.0based)\n        ans_start <- ans_start + 1L\n    ans_names <- rownames(df)\n    if (identical(ans_names, as.character(seq_len(nrow(df)))))\n        ans_names <- NULL\n    ans_ranges <- IRanges(ans_start, ans_end, names=ans_names)\n\n    ## Prepare 'ans_strand'.\n    if (is.na(granges_cols[[\"strand\"]]) || ignore.strand) {\n        ans_strand <- NULL\n    } else {\n        ans_strand <- as.character(df[[granges_cols[[\"strand\"]]]])\n        ans_strand[ans_strand %in% \".\"] <- \"*\"\n    }\n\n    ## Prepare 'ans_mcols'.\n    if (keep.extra.columns) {\n        drop_idx <- c(granges_cols[[\"seqnames\"]],\n                      granges_cols[[\"start\"]],\n                      granges_cols[[\"end\"]])\n        if (!is.na(granges_cols[[\"width\"]]))\n            drop_idx <- c(drop_idx, granges_cols[[\"width\"]])\n        if (!is.na(granges_cols[[\"strand\"]]))\n            drop_idx <- c(drop_idx, granges_cols[[\"strand\"]])\n        ans_mcols <- df[-drop_idx]\n    } else {\n        ans_mcols <- NULL\n    }\n\n    ## Prepare 'ans_seqinfo'.\n    if (is.null(ans_seqinfo)) {\n        ## Only if 'ans_seqnames' is a factor-Rle, we preserve the seqlevels\n        ## in the order they are in 'levels(ans_seqnames)'. Otherwise, we\n        ## order them according to rankSeqlevels().\n        seqlevels <- levels(ans_seqnames)\n        if (is.null(seqlevels)) {\n            seqlevels <- unique(ans_seqnames)\n            if (!is.character(seqlevels))\n                seqlevels <- as.character(seqlevels)\n        }\n        if (!(is(ans_seqnames, \"Rle\") && is.factor(runValue(ans_seqnames))))\n            seqlevels[rankSeqlevels(seqlevels)] <- seqlevels\n        ans_seqinfo <- Seqinfo(seqlevels)\n    }\n\n    ## Make and return the GRanges object.\n    GRanges(ans_seqnames, ans_ranges, strand=ans_strand,\n            ans_mcols, seqinfo=ans_seqinfo)\n}\n\nsetAs(\"data.frame\", \"GRanges\",\n    function(from) makeGRangesFromDataFrame(from, keep.extra.columns=TRUE)\n)\n\nsetAs(\"DataFrame\", \"GRanges\",\n    function(from) makeGRangesFromDataFrame(from, keep.extra.columns=TRUE)\n)\n\n",
        "makeGRangesListFromDataFrame.R": "### =========================================================================\n### makeGRangesListFromDataFrame()\n### -------------------------------------------------------------------------\n\n### 'df' must be a data.frame or DataFrame object.\nmakeGRangesListFromDataFrame <-\n    function(df,\n             split.field = NULL,\n             names.field = NULL,\n             ...)\n{\n    splitIdx <- namesIdx <- integer()\n    if (!is.null(split.field)) {\n        if (!isSingleString(split.field))\n            stop(\"'split.field' must be a single string\")\n        splitIdx <- which(names(df) %in% split.field)\n        if (!length(splitIdx))\n            stop(\"'split.field' is not in 'names(df)'\")\n        if (length(splitIdx) > 1L)\n            stop(\"'split.field' matched more than one 'names(df)'\")\n        splitField <- df[[split.field]]\n    } else splitField <- seq_len(nrow(df))\n\n    if (!is.null(names.field)) {\n        if (!isSingleString(names.field))\n            stop(\"'names.field' must be a single string\")\n        namesIdx <- which(names(df) %in% names.field)\n        if (!length(namesIdx))\n            stop(\"'names.field' is not found in 'names(df)'\")\n        if (length(namesIdx) > 1L)\n            stop(\"'names.field' matched more than one 'names(df)'\")\n        namesField <- df[[names.field]]\n    } else namesField <- NULL \n\n    if (length(c(splitIdx, namesIdx)))\n        df <- df[, -c(splitIdx, namesIdx)]\n    gr <- makeGRangesFromDataFrame(df, ...)\n    names(gr) <- namesField \n    S4Vectors::split(gr, splitField)\n}\n",
        "nearest-methods.R": "### =========================================================================\n### nearest (and related) methods\n### -------------------------------------------------------------------------\n###\n### Dependencies :\n###\n###        distanceToNearest\n###          |          |\n###       nearest    distance\n###       |     |\n###  precede   follow\n\n.orderNumeric <- function(x)            # unstable order\n    sort.list(x, na.last=NA, method=\"quick\")\n\n.GenomicRanges_findNearest0 <-\n    function (query, subject, sentinel, leftOf=TRUE)\n    ## query 'leftOf' subject\n{\n    zeroInSubject <- subject %in% 0L\n    if (any(zeroInSubject))\n        subject <- unique(c(subject, sentinel))\n    else\n        subject <- c(subject, sentinel)\n    ord <- .orderNumeric(subject)\n    subject <- subject[ord]\n\n    rle <- Rle(subject)\n    subject <- runValue(rle)\n\n    ## zero in query\n    i <- findInterval(query - !leftOf, subject) + leftOf\n    zeroInQuery <- i %in% 0L\n    if (any(zeroInQuery)) {\n        if (leftOf)\n            i[zeroInQuery] <- 2L\n        else\n            i[zeroInQuery] <- 1L\n    }\n    ## zero in subject\n    if (any(zeroInSubject))\n        i[subject[i] %in% sentinel & subject[i] != 0L] <- NA_integer_\n    else\n        i[subject[i] %in% sentinel] <- NA_integer_\n\n    IRanges:::vectorToHits(i, rle, ord)\n}\n\n.findNearest_distance <-\n    function(hit, query, subject, leftOf=TRUE)\n    ## query 'leftOf' of subject\n{\n    if (leftOf)\n        start(subject)[subjectHits(hit)] - end(query)[queryHits(hit)]\n    else\n        start(query)[queryHits(hit)] - end(subject)[subjectHits(hit)]\n}\n\n.Hits <- function(queryHits, subjectHits,\n                  queryLength=as.integer(max(c(0, queryHits))),\n                  subjectLength=as.integer(max(c(0, subjectHits))))\n{\n    o <- orderIntegerPairs(queryHits, subjectHits)\n    Hits(queryHits[o], subjectHits[o], queryLength, subjectLength,\n         sort.by.query=TRUE)\n}\n\n.findPrecedeFollow_pmin <-\n    function(hit0, dist0, hit1, dist1)\n    ## hit0, hit1 are (possibly multiple) hits on same query; repeated\n    ## hits are equidistant within hit0 or hit1, but not necessarily\n    ## between\n{\n    stopifnot(queryLength(hit0) == queryLength(hit1))\n    stopifnot(subjectLength(hit0) == subjectLength(hit1))\n    stopifnot(length(hit0) == length(dist0) ||\n        length(hit1) == length(dist1))\n\n    n <- queryLength(hit0)\n    d0 <- d1 <- integer()\n    d0[n] <- d1[n] <- NA_integer_\n\n    i0 <- queryHits(hit0)\n    i1 <- queryHits(hit1)\n\n    d0[i0] <- dist0\n    d1[i1] <- dist1\n\n    dMin <- pmin.int(d0, d1, na.rm=TRUE)\n    i0 <- dist0 == dMin[i0]\n    i1 <- dist1 == dMin[i1]\n\n    .Hits(c(queryHits(hit0)[i0], queryHits(hit1)[i1]),\n          c(subjectHits(hit0)[i0], subjectHits(hit1)[i1]),\n          queryLength(hit0), subjectLength(hit0))\n}\n\n.GenomicRanges_findPrecedeFollow <-\n    function(query, subject, select, ignore.strand,\n             where=c(\"precede\", \"follow\"))\n{\n    if (!length(query) || !length(subject))\n        return(Hits(nLnode=length(query), nRnode=length(subject),\n                    sort.by.query=TRUE))\n\n    leftOf <- \"precede\" == match.arg(where)\n    if (ignore.strand)\n        strand(query) <- strand(subject) <- \"+\"\n\n    if (leftOf) {\n        plusfun <- function(xstart, xend, ystart, yend, sentinel)\n            .GenomicRanges_findNearest0(xend, ystart, sentinel, leftOf)\n        minusfun <- function(xstart, xend, ystart, yend, sentinel)\n            .GenomicRanges_findNearest0(xstart, yend, sentinel, !leftOf)\n    } else {\n        plusfun <- function(xstart, xend, ystart, yend, sentinel)\n            .GenomicRanges_findNearest0(xstart, yend, sentinel, leftOf)\n        minusfun <- function(xstart, xend, ystart, yend, sentinel)\n            .GenomicRanges_findNearest0(xend, ystart, sentinel, !leftOf)\n    }\n\n    ## sentinels marking seqlevels ends\n    endq <- start(query) + width(query) # end(query) incorrect for 0-width\n    ends <- start(subject) + width(subject)\n    maxend <- max(max(endq), max(ends)) + 1\n    lvls <- union(seqlevels(query), seqlevels(subject))\n    offset <- setNames((seq_along(lvls) - 1) * maxend, lvls)\n    stopifnot(typeof(offset) == \"double\")      # avoid integer overflow\n    sentinel <- c(0, seq_along(lvls) * maxend)\n\n    ## offset for sentinels\n    queryOff <- unname(offset[as.character(seqnames(query))])\n    queryStart <- start(query) + queryOff\n    queryEnd <- end(query) + queryOff   # true end + offset\n    qid <- seq_along(query)\n\n    subjectOff <- unname(offset[as.character(seqnames(subject))])\n    subjectStart <- start(subject) + subjectOff\n    subjectEnd <- end(subject) + subjectOff # true end + offset\n    spid <- which(strand(subject) != \"-\")\n    smid <- which(strand(subject) != \"+\")\n\n    ## '+' query\n    idx <- which(strand(query) == \"+\")\n    phit <- plusfun(queryStart[idx], queryEnd[idx],\n                    subjectStart[spid], subjectEnd[spid], sentinel)\n    phit <- .Hits(qid[idx][queryHits(phit)], spid[subjectHits(phit)])\n\n    ## '-' query\n    idx <- which(strand(query) == \"-\")\n    mhit <- minusfun(queryStart[idx], queryEnd[idx],\n                     subjectStart[smid], subjectEnd[smid], sentinel)\n    mhit <- .Hits(qid[idx][queryHits(mhit)], smid[subjectHits(mhit)])\n\n\n    ## '*' query\n    idx <- which(strand(query) == \"*\")\n    starphit <- plusfun(queryStart[idx], queryEnd[idx],\n                    subjectStart[spid], subjectEnd[spid], sentinel)\n    starphit <- .Hits(qid[idx][queryHits(starphit)],\n                      spid[subjectHits(starphit)])\n    ## '*' query and '*' subject pairs are treated as if on '+' strand;\n    ## omit '*' subjects from this test\n    smid <- which(strand(subject) == \"-\")\n    starmhit <- minusfun(queryStart[idx], queryEnd[idx],\n                     subjectStart[smid], subjectEnd[smid], sentinel)\n    starmhit <- .Hits(qid[idx][queryHits(starmhit)], smid[subjectHits(starmhit)])\n    starhit <- .Hits(c(queryHits(starphit), queryHits(starmhit)),\n                     c(subjectHits(starphit), subjectHits(starmhit)),\n                     length(query), length(subject))\n\n    ## '*' strand query can return a value for both mhit and phit.\n    ## Choose the closest range regardless of strand.\n    both <- (idx %in% queryHits(starmhit)) & (idx %in% queryHits(starphit))\n\n    if (any(both)) {\n        x <- query[idx[both]]\n        sidx <- which(queryHits(starhit) %in% idx[both])\n        y <- subject[subjectHits(starhit)[sidx]]\n        repeats <- tabulate(queryHits(starhit))[idx[both]]\n        dist <- distance(rep(x, times=repeats), y)\n        dist_il <- relist(dist, PartitioningByWidth(repeats))\n        sidx_il <- relist(sidx, PartitioningByWidth(repeats))\n        drops_il <- sidx_il[!dist_il == min(dist_il)]\n        drop <- unlist(drops_il)\n        if (length(drop))\n            starhit <- starhit[-drop]\n    }\n\n    qryHits <- c(queryHits(phit), queryHits(mhit), queryHits(starhit))\n    subjHits <- c(subjectHits(phit), subjectHits(mhit), subjectHits(starhit))\n    hits <- .Hits(qryHits, subjHits, length(query), length(subject))\n    ## Break ties\n    if (select == \"all\") {\n        hits\n    } else if (select == \"first\") {\n        first <- rep(NA_integer_, length(query))\n        idx <- which(!duplicated(queryHits(hits)))\n        first[queryHits(hits)[idx]] <- subjectHits(hits)[idx]\n        first\n    } else if (\"last\" == select) {\n        last <- rep(NA_integer_, length(query))\n        rev_query <- rev(queryHits(hits)) ## can't call rev() on Hits\n        idx <- which(!duplicated(rev_query))\n        last[rev_query[idx]] <- rev(subjectHits(hits))[idx]\n        last\n    } else\n        stop(\"'select' must be one of c('first', 'last', 'all')\")\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### precede() and follow()\n###\n\nsetMethod(\"precede\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, subject,\n             select=c(\"first\", \"all\"),\n             ignore.strand=FALSE)\n    {\n        select <- match.arg(select)\n        .GenomicRanges_findPrecedeFollow(x, subject, select, ignore.strand,\n                                         \"precede\")\n    }\n)\n\nsetMethod(\"precede\", c(\"GenomicRanges\", \"missing\"),\n    function(x, subject,\n             select=c(\"first\", \"all\"),\n             ignore.strand=FALSE)\n    {\n        select <- match.arg(select)\n        .GenomicRanges_findPrecedeFollow(x, subject, select, ignore.strand,\n                                         \"precede\")\n    }\n)\n\nsetMethod(\"follow\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, subject,\n             select=c(\"last\", \"all\"),\n             ignore.strand=FALSE)\n    {\n        select <- match.arg(select)\n        .GenomicRanges_findPrecedeFollow(x, subject, select, ignore.strand,\n                                         \"follow\")\n    }\n)\n\nsetMethod(\"follow\", c(\"GenomicRanges\", \"missing\"),\n    function(x, subject,\n             select=c(\"last\", \"all\"),\n             ignore.strand=FALSE)\n    {\n        select <- match.arg(select)\n        .GenomicRanges_findPrecedeFollow(x, subject, select, ignore.strand,\n                                         \"follow\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nearest()\n###\n\n.filterHits <- function(hits, i, map)\n{\n    m <- as.matrix(hits[as(hits, \"IRanges\")[i]])\n    m[, 1L] <- map[m[, 1L]]\n    m\n}\n\n.nearest <- function(x, subject, select, ignore.strand, drop.self=FALSE)\n{\n    ## overlapping ranges\n    if (drop.self) {\n        ol <- findOverlaps(x, maxgap=0L, select=select,\n                           ignore.strand=ignore.strand, drop.self=TRUE)\n    } else {\n        ol <- findOverlaps(x, subject, maxgap=0L, select=select,\n                           ignore.strand=ignore.strand)\n    }\n\n    if (select == \"all\") {\n        olv <- selectHits(ol, select=\"first\")\n    } else {\n        olv <- ol\n    }\n\n    ## non-overlapping ranges\n    if (length(x <- x[is.na(olv)]) != 0) {\n        ## precede() and follow() do not support select=\"arbitrary\"\n        if (select == \"arbitrary\") {\n            p <- precede(x, subject, select=\"first\", ignore.strand)\n            f <- follow(x, subject, select=\"last\", ignore.strand)\n        } else {\n            p <- precede(x, subject, select, ignore.strand)\n            f <- follow(x, subject, select, ignore.strand)\n        }\n\n        ## terminate if no results\n        if (!length(p) && !length(f)) {\n            if (is(olv, \"Hits\") && !length(olv) || all(is.na(olv))) {\n                if (select == \"all\")\n                    return(Hits(nLnode=length(x),\n                                nRnode=length(subject),\n                                sort.by.query=TRUE))\n                else if (select == \"arbitrary\")\n                    return (rep(NA, length(x)))\n            }\n        }\n\n        if (select == \"all\") {\n            p0 <- p\n            p <- selectHits(p, select=\"first\")\n            f0 <- f\n            f <- selectHits(f, select=\"last\")\n        }\n\n        ## choose nearest or not missing\n        pdist <- .nearestDistance(x, subject, p)\n        fdist <- .nearestDistance(x, subject, f)\n        pnearest <- ifelse(pdist == fdist, p < f, pdist < fdist)\n        isNA <- is.na(pnearest)\n        pnearest[isNA] <- is.na(f[isNA])\n\n        if (select == \"all\") {\n            map <- which(is.na(olv))\n            pnearest[pdist == fdist] <- TRUE\n            m <- rbind(as.matrix(ol), .filterHits(p0, pnearest, map),\n                                      .filterHits(f0, !pnearest, map))\n            m <- m[orderIntegerPairs(m[, 1L], m[, 2L]),, drop=FALSE]\n            ol@from <- unname(m[, 1L])\n            ol@to <- unname(m[, 2L])\n        } else {\n            olv[is.na(olv)] <- ifelse(pnearest, p, f)\n            ol <- olv\n        }\n    }\n    ol\n}\n\n.nearestDistance <- function(x, subject, index)\n{\n    if (length(index)) {\n        maxStart <- pmax.int(start(x), start(subject)[index])\n        minEnd <- pmin.int(end(x), end(subject)[index])\n        pmax.int(maxStart - minEnd - 1L, 0L)\n    } else NA\n}\n\nsetMethod(\"nearest\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, subject,\n             select=c(\"arbitrary\", \"all\"),\n             ignore.strand=FALSE)\n    {\n        select <- match.arg(select)\n        .nearest(x, subject, select=select, ignore.strand=ignore.strand)\n    }\n)\n\nsetMethod(\"nearest\", c(\"GenomicRanges\", \"missing\"),\n    function(x, subject,\n             select=c(\"arbitrary\", \"all\"),\n             ignore.strand=FALSE)\n    {\n        select <- match.arg(select)\n        .nearest(x, x, select=select, ignore.strand=ignore.strand,\n                 drop.self=TRUE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### distance()\n###\n\nsetMethod(\"distance\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, y, ignore.strand=FALSE, ...)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n\n        d <- distance(ranges(x), ranges(y))\n        mismtch <- as.character(seqnames(x)) != as.character(seqnames(y))\n        if (any(mismtch))\n            d[mismtch] <- NA\n        if (!ignore.strand) {\n            idx <- as.numeric(strand(x)) + as.numeric(strand(y))\n            if (any(idx == 3))\n                d[idx == 3] <- NA\n        }\n        d\n    }\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### distanceToNearest()\n###\n\nsetMethod(\"distanceToNearest\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, subject, ignore.strand=FALSE, ...)\n    {\n        x_nearest <- nearest(x, subject, ignore.strand=ignore.strand, ...)\n        .distanceToNearest(x_nearest, x, subject, ignore.strand=ignore.strand)\n    }\n)\n\nsetMethod(\"distanceToNearest\", c(\"GenomicRanges\", \"missing\"),\n    function(x, subject, ignore.strand=FALSE, ...)\n    {\n        x_nearest <- nearest(x, ignore.strand=ignore.strand, ...)\n        .distanceToNearest(x_nearest, x, x, ignore.strand=ignore.strand)\n    }\n)\n\n.distanceToNearest <- function(x_nearest, x, subject, ignore.strand)\n{\n    ## 'x_nearest' is Hits when select = all\n    if (is(x_nearest, \"Hits\")) {\n        queryHits <- queryHits(x_nearest)\n        subjectHits <- subjectHits(x_nearest)\n    } else {\n    ## 'x_nearest' is Integer vector when select = arbitrary\n        queryHits <- seq_along(x)[!is.na(x_nearest)]\n        subjectHits <- x_nearest[!is.na(x_nearest)]\n    }\n\n    if (!length(subjectHits) || all(is.na(subjectHits))) {\n        Hits(nLnode=length(x),\n             nRnode=length(subject),\n             distance=integer(0),\n             sort.by.query=TRUE)\n    } else {\n        distance <- distance(x[queryHits], subject[subjectHits],\n                             ignore.strand=ignore.strand)\n        Hits(queryHits, subjectHits, length(x), length(subject), distance,\n             sort.by.query=TRUE)\n    }\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### precedes() and follows()\n###\n\n.normBounds <- function(x, si) {\n    if (is(x, \"GRangesList\")) {\n        x <- range(x)\n        if (all(lengths(x) == 1L)) {\n            x <- unlist(x)\n        } else {\n            stop(\"operation undefined when ranges cross seqnames and strands\")\n        }\n    }\n    seqlevels(x) <- seqlevels(si)\n    x\n}\n\nprecedes <- function(x, y) {\n    si <- merge(seqinfo(x), seqinfo(y))\n    x <- .normBounds(x, si)\n    y <- .normBounds(y, si)\n    seqnames(x) == seqnames(y) &\n        ifelse(strand(y) == \"-\", start(x) > end(y), end(x) < start(y))\n}\n\nfollows <- function(x, y) {\n    si <- merge(seqinfo(x), seqinfo(y))\n    x <- .normBounds(x, si)\n    y <- .normBounds(y, si)\n    seqnames(x) == seqnames(y) &\n        ifelse(strand(y) == \"-\", end(x) < start(y), start(x) > end(y))\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Find 'k' nearest neighbors\n###\n\n.nearestKNeighbors_all_k <- function(x, k) {\n    ## the 'k' nearest neighbors in 'x', when all equally-distant\n    ## neighbors increment k by 1. Each element of 'x' is ordered. E.g.,\n    ##\n    ##   x = IntegerList(c(1, 1, 2), 1:2)\n    ##   k = 1\n    ##   return: c(2L, 1L)\n    ##\n    ans <- integer(length(x))\n    non_zero_lengths <- lengths(x) > 0\n    if (k == 0L || !any(non_zero_lengths))\n        return(ans)\n\n    x <- x[non_zero_lengths]\n    idx <- pmin(k, lengths(x))\n    value <- x[as.list(idx)]\n    ans[non_zero_lengths] <- sum(x <= value)\n    ans\n}\n\n.nearestKNeighbors <- function(x, subject, k, select, ignore.strand, drop.self=FALSE)\n{\n    seqlevels(subject) <- seqlevels(x)\n\n    starts <- with(subject, GRanges(seqnames, IRanges(start, width=1L), strand))\n    ends <- with(subject, GRanges(seqnames, IRanges(end, width=1L), strand))\n\n    if (ignore.strand) {\n        starts <- unstrand(starts)\n        ends <- unstrand(ends)\n    }\n\n    start_ord <- order(starts)\n    end_ord <- order(ends)\n\n    starts <- starts[start_ord]\n    ends <- ends[end_ord]\n\n    ## NOTE: select=\"all\" is needed in general for nearestKNeighbors here\n    if (drop.self) {\n        ol <- findOverlaps(x, maxgap=0L, select=\"all\",\n                           ignore.strand=ignore.strand, drop.self=TRUE)\n    } else {\n        ol <- findOverlaps(x, subject, maxgap=0L, select=\"all\",\n                           ignore.strand=ignore.strand)\n    }\n    ol_hits <- countLnodeHits(ol)\n    ol <- as(ol, \"List\")\n    overlaps <- IntegerList(lapply(ol_hits, rep, x=0L))\n\n    if (length(x)) {\n        phits <- precede(x, starts, ignore.strand=ignore.strand)\n        fhits <- follow(x, ends, ignore.strand=ignore.strand)\n    } else {\n        phits <- fhits <- integer()\n    }\n\n    if (!ignore.strand) {\n        exchange <- decode(strand(x) == \"-\")\n        tmp <- phits[exchange]\n        phits[exchange] <- fhits[exchange]\n        fhits[exchange] <- tmp\n    }\n\n    findPart <- function(x, w) {\n        S4Vectors:::findIntervalAndStartFromWidth(x, w)[[\"interval\"]]\n    }\n\n    b <- width(disjoin(c(ranges(seqnames(starts)), ranges(strand(starts)))))\n    width <- ifelse(select == \"all\", max(length(subject) - 1L, 1L), k)\n\n    seqends <- end(strand(starts))[findPart(phits, b)]\n    phits[is.na(phits)] <- 1L\n    seqends[is.na(seqends)] <- 0L\n    pwindows <- restrict(IRanges(phits, width = width), end=seqends)\n    pwindows_kept <- seqends >= phits\n\n    seqstarts <- start(strand(ends))[findPart(fhits, b)]\n    seqstarts[is.na(seqstarts)] <- 1L\n    fhits[is.na(fhits)] <- 0L\n    fwindows <- restrict(IRanges(end=fhits, width = width), seqstarts)\n    fwindows_kept <- seqstarts <= fhits\n\n    pdist <- extractList(start(starts), pwindows) - end(x)\n    pdist[!pwindows_kept] <- IntegerList(integer(0))\n    fdist <- start(x) - extractList(end(ends), fwindows)\n    fdist[!fwindows_kept] <- IntegerList(integer(0))\n\n    dist <- pc(pdist, fdist, overlaps)\n    dist <- abs(dist)\n\n    pans <- extractList(start_ord, pwindows)\n    pans[!pwindows_kept] <- IntegerList(integer(0))\n    fans <- extractList(end_ord, fwindows)\n    fans[!fwindows_kept] <- IntegerList(integer(0))\n\n    ans <- pc(pans, fans, ol)\n\n    o <- order(dist)\n    if (select == \"all\")\n        k <- .nearestKNeighbors_all_k(dist[o], k)\n    ans <- ans[heads(o, k)]\n    ans[lengths(ans) == 0L] <- NA\n    ans\n}\n\nsetGeneric(\"nearestKNeighbors\", function(x, subject, ...) standardGeneric(\"nearestKNeighbors\"))\n\nsetMethod(\"nearestKNeighbors\", c(\"GenomicRanges\", \"missing\"),\n    function(x, subject, k = 1L, select = c(\"arbitrary\", \"all\"),\n             ignore.strand = FALSE)\n{\n    select <- match.arg(select)\n    .nearestKNeighbors(x, x, k = k, select = select, ignore.strand = ignore.strand,\n             drop.self = TRUE)\n})\n\nsetMethod(\"nearestKNeighbors\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, subject, k = 1L, select = c(\"arbitrary\", \"all\"),\n             ignore.strand = FALSE)\n{\n    select <- match.arg(select)\n    .nearestKNeighbors(x, subject, k = k, select = select, ignore.strand = ignore.strand)\n})\n",
        "normarg-utils.R": "### =========================================================================\n### Utility functions for checking/normalizing user-supplied arguments\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n\n\n### Used in the GenomicAlignments package!\n### Return a factor-Rle with no NAs.\nnormarg_seqnames1 <- function(seqnames)\n{\n    if (is.null(seqnames))\n        return(Rle(factor()))\n    if (!is(seqnames, \"Rle\"))\n        seqnames <- Rle(seqnames)\n    run_vals <- runValue(seqnames)\n    if (anyNA(run_vals))\n        stop(wmsg(\"'seqnames' cannot contain NAs\"))\n    if (!is.factor(run_vals)) {\n        if (!is.character(run_vals))\n            run_vals <- as.character(run_vals)\n        runValue(seqnames) <- factor(run_vals, levels=unique(run_vals))\n    }\n    seqnames\n}\n\n### Used in the GenomicAlignments package!\n### 'seqnames' is assumed to be a factor-Rle with no NAs (which should\n### be the case if it went thru normarg_seqnames1()).\n### 'seqinfo' is assumed to be a Seqinfo object.\nnormarg_seqnames2 <- function(seqnames, seqinfo)\n{\n    ans_seqlevels <- seqlevels(seqinfo)\n    run_vals <- runValue(seqnames)\n    seqnames_levels <- levels(run_vals)\n    is_used <- tabulate(run_vals, nbins=length(seqnames_levels)) != 0L\n    seqnames_levels_in_use <- seqnames_levels[is_used]\n    if (!all(seqnames_levels_in_use %in% ans_seqlevels))\n        stop(wmsg(\"'seqnames' contains sequence names \",\n                  \"with no entries in 'seqinfo'\"))\n    if (!all(seqnames_levels %in% ans_seqlevels))\n        warning(wmsg(\"levels in 'seqnames' with no entries \",\n                     \"in 'seqinfo' were dropped\"))\n    runValue(seqnames) <- factor(run_vals, levels=ans_seqlevels)\n    seqnames\n}\n\n### Return NULL or a Seqinfo object.\nnormarg_seqinfo1 <- function(seqinfo)\n{\n    if (is.null(seqinfo) || is(seqinfo, \"Seqinfo\"))\n        return(seqinfo)\n    if (is.character(seqinfo))\n        return(Seqinfo(seqinfo))\n    if (is.numeric(seqinfo)) {\n        seqlevels <- names(seqinfo)\n        if (is.null(seqlevels))\n            stop(wmsg(\"when a numeric vector, 'seqinfo' must have names\"))\n        return(Seqinfo(seqlevels, seqlengths=seqinfo))\n    }\n    stop(wmsg(\"'seqinfo' must be NULL, or a Seqinfo object, \",\n              \"or a character vector of seqlevels, \",\n              \"or a named numeric vector of sequence lengths\"))\n}\n\n### Used in the GenomicAlignments package!\n### Return NULL or a Seqinfo object.\nnormarg_seqinfo2 <- function(seqinfo, seqlengths)\n{\n    seqinfo <- normarg_seqinfo1(seqinfo)\n    if (is.null(seqlengths))\n        return(seqinfo)\n    ## Just a loose sanity check on 'seqlengths' before we call names() on\n    ## it. The Seqinfo() constructor will take care of the full check and\n    ## normalization by passing it thru GenomeInfoDb:::.normarg_seqlengths().\n    if (!is.vector(seqlengths))\n        stop(wmsg(\"'seqlengths' must be NULL or a vector\"))\n    seqlengths_names <- names(seqlengths)\n    if (is.null(seqlengths_names))\n        stop(wmsg(\"'seqlengths' must have names\"))\n    seqinfo2 <- Seqinfo(seqlengths_names, seqlengths)\n    if (is.null(seqinfo))\n        return(seqinfo2)\n    suppressWarnings(merge(seqinfo, seqinfo2))\n}\n\n### Used in the GenomicAlignments package!\n### Return a factor-Rle with levels +|-|* and no NAs.\nnormarg_strand <- function(strand, ans_len)\n{\n    if (is.null(strand))\n        return(Rle(strand(\"*\"), ans_len))\n    if (!is(strand, \"Rle\"))\n        strand <- Rle(strand)\n    run_vals <- runValue(strand)\n    if (anyNA(run_vals)) {\n        warning(wmsg(\"missing values in 'strand' converted to \\\"*\\\"\"))\n        run_vals[is.na(run_vals)] <- \"*\"\n    }\n    if (!is.factor(run_vals) || !identical(levels(run_vals), levels(strand())))\n        run_vals <- strand(run_vals)\n    runValue(strand) <- run_vals\n    strand\n}\n\n### Used in the GenomicAlignments package!\n### TODO: Use this in GenomicFeatures::transcriptLocs2refLocs() and\n### remove GenomicFeatures:::.normargExonStartsOrEnds().\nnormarg_list_of_integers <- function(arg, sep, argname)\n{\n    if (is.list(arg))\n        return(arg)\n    if (is(arg, \"IntegerList\"))\n        return(as.list(arg))\n    if (is.character(arg))\n        return(toListOfIntegerVectors(arg, sep=sep))\n    stop(wmsg(\"'\", argname, \"' must be a list of integer vectors, \",\n              \"an IntegerList object,\\n  or a character vector where \",\n              \"each element is a comma-separated list of\\n  integers\"))\n}\n\n",
        "phicoef.R": "### Based on http://en.wikipedia.org/wiki/Phi_coefficient\n\nphicoef <- function(x, y=NULL)\n{\n    if (is.null(y)) {\n        if (!is.integer(x) || length(x) != 4L)\n            stop(\"when 'y' is not supplied, 'x' must be \",\n                 \"a 2x2 integer matrix or an integer vector of length 4\")\n        a <- x[1L]\n        c <- x[2L]\n        b <- x[3L]\n        d <- x[4L]\n    } else {\n        if (!is.logical(x) || !is.logical(y) || length(x) != length(y))\n            stop(\"when 'y' is supplied, 'x' and 'y' must be \",\n                 \"2 logical vectors of the same length\")\n        a <- sum(x  &  y)\n        b <- sum(x  & !y)\n        c <- sum(!x &  y)\n        d <- sum(!x & !y)\n    }\n    a <- as.double(a)\n    b <- as.double(b)\n    c <- as.double(c)\n    d <- as.double(d)\n    div <- sqrt((a + b) * (c + d) * (a + c) * (b + d))\n    (a * d - b * c) / div\n}\n\n",
        "setops-methods.R": "### =========================================================================\n### Set operations\n### -------------------------------------------------------------------------\n\n### TODO: What's the impact of circularity on the set operations?\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 3 low-level helper functions.\n###\n\n### A fast implementation of 'mendoapply(FUN, x, y)' for GRangesList objects.\n### Assume 'x' and 'y' are 2 GRangesList objects (not checked) of the same\n### length (checked).\n.fast_binary_mendoapply <- function(FUN, x, y, ...)\n{\n    FUN <- match.fun(FUN)\n    if (length(x) != length(y))\n        stop(\"'x' and 'y' must have the same length\")\n    seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n    seqlevels(y) <- seqlevels(x)\n    xgr <- deconstructGRLintoGR(x)\n    ygr <- deconstructGRLintoGR(y)\n    seqinfo(xgr) <- suppressWarnings(merge(seqinfo(xgr), seqinfo(ygr)))\n    seqlevels(ygr) <- seqlevels(xgr)\n    gr <- FUN(xgr, ygr, ...)\n    reconstructGRLfromGR(gr, x)\n}\n\n### Both return a named integer vector where the names are guaranteed to be\n### 'seqlevels(x)'.\n###\n\n.minStartPerGRangesSequence <- function(x)\n{\n    cil <- splitAsList(start(x), seqnames(x))  # CompressedIntegerList object\n    ## The 4 lines below are equivalent to:\n    ##   ans <- min(cil)\n    ##   ans[elementNROWS(v) == 0L] <- NA_integer_\n    ## but much faster!\n    ## TODO: Replace with the above, but only when the \"min\" method for\n    ## CompressedIntegerList objects (implemented in the IRanges package)\n    ## is as fast as the \"viewMins\" method for XIntegerViews objects\n    ## (implemented in C in the XVector package). Ideally, the 2 methods\n    ## should share the same underlying code.\n    v <- Views(cil@unlistData, cil@partitioning)  # XIntegerViews object\n    ans <- viewMins(v)\n    ans[width(v) == 0L] <- NA_integer_\n    names(ans) <- names(v)\n    ans\n}\n\n.maxEndPerGRangesSequence <- function(x)\n{\n    cil <- splitAsList(end(x), seqnames(x))  # CompressedIntegerList object\n    ## The 4 lines below are equivalent to:\n    ##   ans <- max(cil)\n    ##   ans[elementNROWS(v) == 0L] <- NA_integer_\n    ## but much faster!\n    ## TODO: Replace with the above, but only when the \"max\" method for\n    ## CompressedIntegerList objects (implemented in the IRanges package)\n    ## is as fast as the \"viewMaxs\" method for XIntegerViews objects\n    ## (implemented in C in the XVector package). Ideally, the 2 methods\n    ## should share the same underlying code.\n    v <- Views(cil@unlistData, cil@partitioning)  # XIntegerViews object\n    ans <- viewMaxs(v)\n    ans[width(v) == 0L] <- NA_integer_\n    names(ans) <- names(v)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### union(), intersect(), setdiff()\n###\n\n### Always return a GRanges *instance* whatever GenomicRanges derivatives are\n### passed to it (e.g. GPos or GNCList), so does NOT act like an endomorphism\n### in general.\nsetMethod(\"union\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, y, ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        x <- granges(x)\n        y <- granges(y)\n        if (ignore.strand)\n            strand(x) <- strand(y) <- \"*\"\n        reduce(c(x, y), drop.empty.ranges=TRUE)\n    }\n)\n\n.unsupported_union <- function(x, y)\n    stop(\"union() between a \", class(x), \" and a \", class(y), \" object \",\n         \"is not supported\")\n\nsetMethod(\"union\", c(\"GenomicRanges\", \"Vector\"), .unsupported_union)\nsetMethod(\"union\", c(\"Vector\", \"GenomicRanges\"), .unsupported_union)\n\nsetMethod(\"union\", c(\"GRangesList\", \"GRangesList\"),\n    function(x, y, ...) .fast_binary_mendoapply(\"union\", x, y, ...)\n)\n\n### Always return a GRanges *instance* whatever GenomicRanges derivatives are\n### passed to it (e.g. GPos or GNCList), so does NOT act like an endomorphism\n### in general.\nsetMethod(\"intersect\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, y, ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        x <- granges(x)\n        y <- granges(y)\n        if (ignore.strand)\n            strand(x) <- strand(y) <- \"*\"\n        seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n        ## If merge() is going to issue a warning, we don't want to get\n        ## it twice.\n        seqinfo(y) <- suppressWarnings(merge(seqinfo(y), seqinfo(x)))\n        seqlengths <- seqlengths(x)\n        ## If the length of a sequence is unknown (NA), then we use\n        ## the max end value found on that sequence in 'x' or 'y'.\n        seqlengths[is.na(seqlengths)] <-\n            .maxEndPerGRangesSequence(c(x, y))[is.na(seqlengths)]\n        setdiff(x, gaps(y, end=seqlengths))\n    }\n)\n\n.unsupported_intersect <- function(x, y)\n    stop(\"intersect() between a \", class(x), \" and a \", class(y), \" object \",\n         \"is not supported\")\n\nsetMethod(\"intersect\", c(\"GenomicRanges\", \"Vector\"), .unsupported_intersect)\nsetMethod(\"intersect\", c(\"Vector\", \"GenomicRanges\"), .unsupported_intersect)\n\nsetMethod(\"intersect\", c(\"GRangesList\", \"GRangesList\"),\n    function(x, y, ...) .fast_binary_mendoapply(\"intersect\", x, y, ...)\n)\n\n### Always return a GRanges *instance* whatever GenomicRanges derivatives are\n### passed to it (e.g. GPos or GNCList), so does NOT act like an endomorphism\n### in general.\nsetMethod(\"setdiff\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, y, ignore.strand=FALSE)\n    {\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        x <- granges(x)\n        y <- granges(y)\n        if (ignore.strand)\n            strand(x) <- strand(y) <- \"*\"\n        seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n        ## If merge() is going to issue a warning, we don't want to get\n        ## it twice.\n        seqinfo(y) <- suppressWarnings(merge(seqinfo(y), seqinfo(x)))\n        seqlengths <- seqlengths(x)\n        ## If the length of a sequence is unknown (NA), then we use\n        ## the max end value found on that sequence in 'x' or 'y'.\n        seqlengths[is.na(seqlengths)] <-\n            .maxEndPerGRangesSequence(c(x, y))[is.na(seqlengths)]\n        gaps(union(gaps(x, end=seqlengths), y), end=seqlengths)\n    }\n)\n\n.unsupported_setdiff <- function(x, y)\n    stop(\"setdiff() between a \", class(x), \" and a \", class(y), \" object \",\n         \"is not supported\")\n\nsetMethod(\"setdiff\", c(\"GenomicRanges\", \"Vector\"), .unsupported_setdiff)\nsetMethod(\"setdiff\", c(\"Vector\", \"GenomicRanges\"), .unsupported_setdiff)\n\nsetMethod(\"setdiff\", c(\"GRangesList\", \"GRangesList\"),\n    function(x, y, ...) .fast_binary_mendoapply(\"setdiff\", x, y, ...)\n)\n\n\n### =========================================================================\n### Parallel set operations\n### -------------------------------------------------------------------------\n\n## check for equality without requiring identical level sets\n## instead, one level set must be subset of the other, like merge,Seqinfo\ncompatibleSeqnames <- function(x, y) {\n  if (length(x) != length(y))\n    stop(\"'x' and 'y' must be of equal length\")\n  if (!is(x, \"Rle\") || !is(y, \"Rle\"))\n    stop(\"'x' and 'y' must be Rle objects\")\n  xLevels <- levels(x)\n  yLevels <- levels(y)\n  if (length(xLevels) > length(yLevels))\n    diffLevels <- setdiff(yLevels, xLevels)\n  else diffLevels <- setdiff(xLevels, yLevels)\n  if (length(diffLevels))\n    stop(\"Level set of 'x' must be subset of that of 'y', or vice versa\")\n  runValue(x) <- as.character(runValue(x))\n  runValue(y) <- as.character(runValue(y))\n  x == y\n}\n\nallCompatibleSeqnamesAndStrand <- function(x, y) {\n  all(compatibleSeqnames(seqnames(x), seqnames(y)) &\n      compatibleStrand(strand(x), strand(y)))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### punion()\n###\n\nsetMethod(\"punion\", c(\"GRanges\", \"GRanges\"),\n    function(x, y, fill.gap=FALSE, ignore.strand=FALSE)\n    {\n        if (length(x) != length(y)) \n            stop(\"'x' and 'y' must have the same length\")\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        if (ignore.strand) \n            strand(y) <- strand(x)\n        mcols(x) <- NULL\n        seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n        if (!allCompatibleSeqnamesAndStrand(x, y))\n            stop(\"'x' and 'y' elements must have compatible 'seqnames' \",\n                 \"and 'strand' values\")\n        ranges(x) <- punion(ranges(x), ranges(y), fill.gap=fill.gap)\n        x\n    }\n)\n\n### FIXME: This is currently not doing a \"punion\" at all. It just appends\n### the ranges in 'y' to their corresponding element in 'x'.\n### 2 proposals for a more punion-like semantic:\n###   (a) for (i in seq_len(length(x)))\n###         x[[i]] <- punion(x[[i]], y[rep.int(i, length(x[[i]]))])\n###   (b) for (i in seq_len(length(x)))\n###         x[[i]] <- union(x[[i]], y[i])\n### Note that behaviour (b) could also be considered a valid candidate for\n### a union,GRangesList,GRanges method (which we don't have at the moment).\nsetMethod(\"punion\", c(\"GRangesList\", \"GRanges\"),\n    function(x, y, fill.gap=FALSE)\n    {\n        n <- length(x)\n        if (n != length(y)) \n            stop(\"'x' and 'y' must have the same length\")\n        mcols(x@unlistData) <- NULL\n        mcols(y) <- NULL\n        ans <-\n          split(c(x@unlistData, y), \n                c(Rle(seq_len(n), elementNROWS(x)), Rle(seq_len(n))))\n        names(ans) <- names(x)\n        ans\n    }\n)\n\nsetMethod(\"punion\", c(\"GRanges\", \"GRangesList\"),\n    function(x, y, ...) callGeneric(y, x, ...)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pintersect()\n###\n\n### 'x' and 'y' must have the same length. An 'y' of length 1 is accepted and\n### is recycled to the length of 'x'.\n### Return a GRanges object. If 'drop.nohit.ranges' is FALSE (the default) the\n### returned object is parallel to 'x' with the original ranges modified\n### (seqnames, names, and metadata are untouched), so this can be seen as an\n### \"intra-range transformation\". The original metadata columns are propagated\n### and a new \"hit\" column added to them to indicate elements in 'x' that\n### intersect with the corresponding element in 'y'. For these elements the\n### range in the returned object is guaranteed to be a subrange of the\n### original ranges. If 'ignore.strand' or 'strict.strand' is TRUE, then the\n### returned GRanges has the same strand as 'x'. Otherwise, for elements in 'x'\n### that are on the \"*\" strand and hit the corresponding element in 'y', it\n### has the strand of 'y'.\n### If 'drop.nohit.ranges' is TRUE everything is the same except that elements\n### in 'x' that don't intersect with the corresponding element in 'y' are\n### removed from the result (so the result is no more parallel to the input)\n### and no \"hit\" metadata column is added to it.\n.pintersect_GRanges_GRanges <- function(x, y, drop.nohit.ranges=FALSE,\n                                              ignore.strand=FALSE,\n                                              strict.strand=FALSE)\n{\n    stopifnot(is(x, \"GRanges\"), is(y, \"GRanges\"))\n    if (length(y) != length(x)) {\n        if (length(y) != 1L)\n            stop(wmsg(\"'y' must have the length of 'x' or length 1\"))\n        y <- rep.int(y, length(x))\n    }\n    if (!isTRUEorFALSE(drop.nohit.ranges))\n        stop(wmsg(\"'drop.nohit.ranges' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(ignore.strand))\n        stop(wmsg(\"'ignore.strand' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(strict.strand))\n        stop(wmsg(\"'strict.strand' must be TRUE or FALSE\"))\n    if (ignore.strand) {\n        if (strict.strand)\n            warning(wmsg(\"'strict.strand' is ignored \",\n                         \"when 'ignore.strand' is TRUE\"))\n        strand(y) <- strand(x)\n    } else if (!strict.strand) {\n        x_strand <- strand(x)\n        idx <- strand(x) == \"*\" & strand(y) != \"*\"\n        strand(x)[idx] <- strand(y)[idx]\n        idx <- strand(y) == \"*\" & strand(x) != \"*\"\n        strand(y)[idx] <- strand(x)[idx]\n    }\n\n    x_seqlevels <- seqlevels(x)\n    ## Check compatibility of underlying genomes.\n    seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n    ## Align the seqlevels of 'y' to those of 'x' so that comparing the\n    ## seqnames of the 2 objects thru as.integer(seqnames()) is meaningful).\n    seqlevels(y) <- seqlevels(x)\n    ## Restore original seqlevels on 'x' (this preserves their order).\n    seqlevels(x) <- x_seqlevels\n\n    new_start <- pmax.int(start(x), start(y))\n    new_end <- pmin.int(end(x), end(y))\n\n    is_hit <- as.integer(seqnames(x)) == as.integer(seqnames(y)) &\n              strand(x) == strand(y) & new_end >= new_start - 1L\n\n    if (drop.nohit.ranges) {\n        x <- extractROWS(x, is_hit)\n        new_start <- extractROWS(new_start, is_hit)\n        new_end <- extractROWS(new_end, is_hit)\n        new_names <- names(x)\n    } else {\n        ## For elements in 'x' and 'y' that don't hit each other, we return\n        ## an artificial zero-width intersection that starts on 'start(x)'.\n        nohit_idx <- which(!is_hit)\n        nohit_start <- start(x)[nohit_idx]\n        new_start[nohit_idx] <- nohit_start\n        new_end[nohit_idx] <- nohit_start - 1L\n        new_names <- names(x)\n        mcols(x)$hit <- as.logical(is_hit)\n        if (!(ignore.strand || strict.strand))\n            strand(x)[nohit_idx] <- x_strand[nohit_idx]\n    }\n    ranges(x) <- IRanges(new_start, new_end, names=new_names)\n    x\n}\n\nsetMethod(\"pintersect\", c(\"GRanges\", \"GRanges\"),\n    function(x, y, drop.nohit.ranges=FALSE,\n                   ignore.strand=FALSE, strict.strand=FALSE)\n        .pintersect_GRanges_GRanges(x, y, drop.nohit.ranges=drop.nohit.ranges,\n                                          ignore.strand=ignore.strand,\n                                          strict.strand=strict.strand)\n)\n\n### This is equivalent to 'mendoapply(pintersect, x, y)'. Therefore the\n### returned GRangesList object has the same shape as 'x'.\n### To get the 'mendoapply(intersect, x, y)' behavior, the user should use\n### 'strict.strand=TRUE' and call 'reduce( , drop.empty.ranges=TRUE)' on\n### the returned object.\n.pintersect_GRangesList_GRanges <- function(x, y, drop.nohit.ranges=FALSE,\n                                                  ignore.strand=FALSE,\n                                                  strict.strand=FALSE)\n{\n    stopifnot(is(x, \"GRangesList\"), is(y, \"GRanges\"))\n    if (length(y) != length(x)) {\n        if (length(y) != 1L)\n            stop(wmsg(\"'y' must have the length of 'x' or length 1\"))\n        y <- rep.int(y, length(x))\n    }\n    if (!isTRUEorFALSE(drop.nohit.ranges))\n        stop(wmsg(\"'drop.nohit.ranges' must be TRUE or FALSE\"))\n    unlisted_x <- unlist(x, use.names=FALSE)\n    y2 <- rep.int(y, elementNROWS(x))\n    ## 'unlisted_ans' parallel to 'x'.\n    unlisted_ans <- .pintersect_GRanges_GRanges(unlisted_x, y2,\n                                        drop.nohit.ranges=FALSE,\n                                        ignore.strand=ignore.strand,\n                                        strict.strand=strict.strand)\n    if (drop.nohit.ranges) {\n        is_hit <- relist(mcols(unlisted_ans, use.names=FALSE)$hit, x)\n        mcols(unlisted_ans)$hit <- NULL\n        ans <- relist(unlisted_ans, x)[is_hit]\n    } else {\n        ans <- relist(unlisted_ans, x)\n    }\n    ans\n}\n\nsetMethod(\"pintersect\", c(\"GRangesList\", \"GRanges\"),\n    function(x, y, drop.nohit.ranges=FALSE,\n                   ignore.strand=FALSE, strict.strand=FALSE)\n        .pintersect_GRangesList_GRanges(x, y,\n                                        drop.nohit.ranges=drop.nohit.ranges,\n                                        ignore.strand=ignore.strand,\n                                        strict.strand=strict.strand)\n)\n\nsetMethod(\"pintersect\", c(\"GRanges\", \"GRangesList\"),\n    function(x, y, drop.nohit.ranges=FALSE,\n                   ignore.strand=FALSE, strict.strand=FALSE)\n        .pintersect_GRangesList_GRanges(y, x,\n                                        drop.nohit.ranges=drop.nohit.ranges,\n                                        ignore.strand=ignore.strand,\n                                        strict.strand=strict.strand)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### psetdiff()\n###\n\nsetMethod(\"psetdiff\", c(\"GRanges\", \"GRanges\"),\n    function(x, y, ignore.strand=FALSE)\n    {\n        if (length(x) != length(y)) \n            stop(\"'x' and 'y' must have the same length\")\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        if (ignore.strand)\n            strand(y) <- strand(x)\n        mcols(x) <- NULL\n        seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n        ok <- compatibleSeqnames(seqnames(x), seqnames(y)) &\n              compatibleStrand(strand(x), strand(y))\n        ## Update the ranges.\n        ansRanges <- ranges(x)\n        ansRanges <- replaceROWS(ansRanges, ok,\n                         callGeneric(extractROWS(ranges(x), ok),\n                                     extractROWS(ranges(y), ok)))\n        ranges(x) <- ansRanges\n        ## Update the strand.\n        ansStrand <- strand(x)\n        resolveStrand <- as(ansStrand == \"*\", \"IRanges\")\n        if (length(resolveStrand) > 0L)\n            ansStrand[IRanges:::unlist_as_integer(resolveStrand)] <-\n              extractROWS(strand(y), resolveStrand)\n        strand(x) <- ansStrand\n        x\n    }\n)\n\n### TODO: Review the semantic of this method (see previous TODO's for\n### \"punion\" and \"pintersect\" methods for GRanges,GRangesList).\nsetMethod(\"psetdiff\", c(\"GRanges\", \"GRangesList\"),\n    function(x, y, ignore.strand=FALSE)\n    {\n        ansSeqinfo <- merge(seqinfo(x), seqinfo(y))\n        if (length(x) != length(y)) \n            stop(\"'x' and 'y' must have the same length\")\n        ok <- compatibleSeqnames(rep(seqnames(x), elementNROWS(y)),\n                                 seqnames(y@unlistData))\n        if (!ignore.strand)\n          ok <- ok & compatibleStrand(rep(strand(x), elementNROWS(y)),\n                                      strand(y@unlistData))\n        if (!all(ok)) {\n            ok <-\n              new2(\"CompressedLogicalList\", unlistData=as.vector(ok),\n                   partitioning=y@partitioning)\n            y <- y[ok]\n        }\n        ansRanges <- gaps(ranges(y), start=start(x), end=end(x))\n        ansSeqnames <- rep(seqnames(x), elementNROWS(ansRanges))\n        ansStrand <- rep(strand(x), elementNROWS(ansRanges))\n        ansGRanges <-\n          GRanges(ansSeqnames, unlist(ansRanges, use.names=FALSE), ansStrand)\n        seqinfo(ansGRanges) <- ansSeqinfo\n        relist(ansGRanges, PartitioningByEnd(ansRanges))\n    }\n)\n\nsetMethod(\"pgap\", c(\"GRanges\", \"GRanges\"),\n    function(x, y, ignore.strand=FALSE, ...)\n    {\n        if (length(x) != length(y)) \n            stop(\"'x' and 'y' must have the same length\")\n        if (!isTRUEorFALSE(ignore.strand))\n            stop(\"'ignore.strand' must be TRUE or FALSE\")\n        if (ignore.strand) \n            strand(y) <- strand(x) \n        mcols(x) <- NULL\n        seqinfo(x) <- merge(seqinfo(x), seqinfo(y))\n        if (!allCompatibleSeqnamesAndStrand(x, y))\n            stop(\"'x' and 'y' elements must have compatible 'seqnames' \",\n                 \"and 'strand' values\")\n        ranges(x) <- callGeneric(ranges(x), ranges(y), ...)\n        x\n    }\n)\n\n",
        "strand-utils.R": "### =========================================================================\n### Strand utilities\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some \"strand\" methods\n###\n\nsetMethod(\"strand\", \"missing\", function(x) factor(levels=c(\"+\",\"-\",\"*\")))\nsetMethod(\"strand\", \"NULL\", function(x) strand())\n\nsetMethod(\"strand\", \"character\",\n    function(x)\n    {\n        lvls <- levels(strand())\n        if (!all(x %in% lvls))\n            stop(\"strand values must be in '\", paste(lvls, collapse=\"' '\"), \"'\")\n        factor(x, levels=lvls)\n    }\n)\n\nsetMethod(\"strand\", \"factor\",\n    function(x)\n    {\n        if (any(is.na(x)))\n            stop(\"NA not a valid strand value, use \\\"*\\\" instead\")\n        lvls <- levels(strand())\n        x_levels <- levels(x)\n        if (identical(x_levels, lvls))\n            return(x)\n        invalid_levels <- setdiff(x_levels, lvls)\n        if (length(invalid_levels) != 0L)\n            stop(\"invalid strand levels in 'x': \",\n                 paste(invalid_levels, collapse=\", \"))\n        factor(x, levels=lvls)\n    }\n)\n\nsetMethod(\"strand\", \"integer\",\n    function(x)\n    {\n        lvls <- c(1L, -1L, NA)\n        if (!all(x %in% lvls))\n            stop(\"strand values must be in '\", paste(lvls, collapse=\"' '\"), \"'\")\n        ans <- rep.int(strand(\"*\"), length(x))\n        ans[x ==  1L] <- \"+\"\n        ans[x == -1L] <- \"-\"\n        ans\n    }\n)\n\nsetMethod(\"strand\", \"logical\",\n    function(x)\n    {\n        ans <- rep.int(strand(\"*\"), length(x))\n        ans[!x] <- \"+\"\n        ans[ x] <- \"-\"\n        ans\n    }\n)\n\nsetMethod(\"strand\", \"Rle\",\n    function(x)\n    {\n        x_runValue <- runValue(x)\n        if (!(is.character(x_runValue) ||\n              is.factor(x_runValue) ||\n              is.integer(x_runValue) ||\n              is.logical(x_runValue)))\n            stop(\"\\\"strand\\\" method for Rle objects only works on a \",\n                 \"character-, factor-, integer-, or logical-Rle object\")\n        runValue(x) <- strand(x_runValue)\n        x\n    }\n)\n\nsetMethod(\"strand\", \"RleList\",\n    function(x) relist(strand(unlist(x, use.names=FALSE)), x)\n)\n\nsetMethod(\"strand\", \"DataFrame\",\n    function(x)\n    {\n        ans <- x[[\"strand\"]]\n        if (is.null(ans)) {\n            ans <- rep.int(strand(\"*\"), nrow(x))\n        } else {\n            ans <- strand(ans)\n        }\n        ans\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some \"strand<-\" methods\n###\n\nnormalize_strand_replacement_value <- function(value, x)\n{\n    if (!is(value, \"Rle\"))\n        value <- Rle(value)\n    if (!is.factor(runValue(value))\n     || !identical(levels(runValue(value)), levels(strand())))\n        runValue(value) <- strand(runValue(value))\n    S4Vectors:::V_recycle(value, x, x_what=\"value\", skeleton_what=\"x\")\n}\n\nsetReplaceMethod(\"strand\", \"DataFrame\",\n    function(x, value)\n    {\n        x$strand <- normalize_strand_replacement_value(value, seq_len(nrow(x)))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some \"invertStrand\" methods\n###\n\n.invert_strand_factor <- function(x)\n{\n    x_codes <- as.integer(x)\n    switch_idx <- which(x_codes <= 2L)\n    x[switch_idx] <- structure(3L - x_codes[switch_idx],\n                               levels=levels(x), class=class(x))\n    x\n}\n\n### One method for each of the \"strand\" methods defined above that return a\n### factor (except for the method for \"missing\").\nsetMethods(\"invertStrand\", list(\"NULL\",\n                                \"character\",\n                                \"factor\",\n                                \"integer\",\n                                \"logical\"),\n    function(x) .invert_strand_factor(strand(x))\n)\n\nsetMethod(\"invertStrand\", \"Rle\",\n    function(x)\n    {\n        ans <- strand(x)\n        runValue(ans) <- invertStrand(runValue(ans))\n        ans\n    }\n)\n\nsetMethod(\"invertStrand\", \"RleList\",\n    function(x) relist(invertStrand(unlist(x, use.names=FALSE)), x)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### compatibleStrand() generic and methods\n###\n\nsetGeneric(\"compatibleStrand\", signature=c(\"x\",\"y\"),  # not exported\n    function(x, y) standardGeneric(\"compatibleStrand\")\n)\n\nsetMethod(\"compatibleStrand\", c(\"factor\", \"factor\"),  # not exported\n    function(x, y)\n    {\n        lvls <- levels(strand())\n        if (length(x) != length(y))\n            stop(\"'x' and 'y' must be of equal length\")\n        if (!identical(levels(x), lvls) || !identical(levels(y), lvls))\n            stop(\"strand values must be in '\", paste(lvls, collapse=\"' '\"), \"'\")\n\n        levels(x) <- c(\"1\", \"-1\", \"0\")\n        x <- as.integer(as.character(x))\n\n        levels(y) <- c(\"1\", \"-1\", \"0\")\n        y <- as.integer(as.character(y))\n\n        ans <- x * y != -1L\n        if (S4Vectors:::anyMissing(ans)) {\n            fix <- which(is.na(ans))\n            ans[fix] <- (x[fix] == 0L) | (y[fix] == 0L)\n            if (S4Vectors:::anyMissing(ans))\n                ans[is.na(ans)] <- FALSE\n        }\n        ans\n    }\n)\n\nsetMethod(\"compatibleStrand\", c(\"Rle\", \"Rle\"),  # not exported\n    function(x, y)\n    {\n        lvls <- levels(strand())\n        if (length(x) != length(y))\n            stop(\"'x' and 'y' must be of equal length\")\n        if (!identical(levels(runValue(x)), lvls) ||\n            !identical(levels(runValue(y)), lvls))\n            stop(\"strand values must be in '\", paste(lvls, collapse=\"' '\"), \"'\")\n\n        levels(x) <- c(\"1\", \"-1\", \"0\")\n        runValue(x) <- as.integer(as.character(runValue(x)))\n\n        levels(y) <- c(\"1\", \"-1\", \"0\")\n        runValue(y) <- as.integer(as.character(runValue(y)))\n\n        ans <- x * y != -1L\n        if (S4Vectors:::anyMissing(runValue(ans))) {\n            fix <- which(is.na(runValue(ans)))\n            runValue(ans)[fix] <-\n              (runValue(x) == 0L)[fix] | (runValue(y)[fix] == 0L)\n            if (S4Vectors:::anyMissing(runValue(ans)))\n                runValue(ans)[is.na(runValue(ans))] <- FALSE\n        }\n        ans\n    }\n)\n\n",
        "subtract-methods.R": "### =========================================================================\n### subtract()\n### -------------------------------------------------------------------------\n\n\n### Similar to bedtools subtract.\n### TODO: Move definition of generic to IRanges package and implement method\n### for IntegerRanges objects.\nsetGeneric(\"subtract\", signature=c(\"x\", \"y\"),\n    function(x, y, minoverlap=1L, ...) standardGeneric(\"subtract\")\n)\n\n### Returns a GenomicRangesList object parallel to 'x'.\nsetMethod(\"subtract\", c(\"GenomicRanges\", \"GenomicRanges\"),\n    function(x, y, minoverlap=1L, ignore.strand=FALSE)\n    {\n        y <- reduce(y, ignore.strand=ignore.strand)\n        hits <- findOverlaps(x, y, minoverlap=minoverlap,\n                                   ignore.strand=ignore.strand)\n        ans <- psetdiff(x, extractList(y, as(hits, \"IntegerList\")))\n        mcols(ans) <- mcols(x)\n        setNames(ans, names(x))\n    }\n)\n\n",
        "tile-methods.R": "### =========================================================================\n### \"tile\" and \"slidingWindows\" methods\n### -------------------------------------------------------------------------\n###\n\nsetMethod(\"tile\", \"GenomicRanges\", function(x, n, width) {\n  sn <- seqnames(x)\n  strand <- strand(x)\n  x <- ranges(x)\n  tiles <- callGeneric()\n  gr <- GRanges(rep(sn, elementNROWS(tiles)), unlist(tiles),\n                rep(strand, elementNROWS(tiles)))\n  relist(gr, tiles)\n})\n\nsetMethod(\"slidingWindows\", \"GenomicRanges\", function(x, width, step = 1L) {\n    windows <- slidingWindows(ranges(x), width, step)\n    gr <- rep(granges(x), lengths(windows))\n    ranges(gr) <- unlist(windows)\n    relist(gr, windows)\n})\n",
        "tileGenome.R": "### =========================================================================\n### tileGenome()\n### -------------------------------------------------------------------------\n\n\n.make_breakpoints_for_cut_last_tile_in_chrom <- function(seqlengths, tilewidth)\n{\n    tile_relative_breakpoints <- lapply(seqlengths,\n        function(seqlength) {\n            nfulltile <- seqlength %/% tilewidth\n            if (nfulltile == 0L)\n                return(seqlength)\n            relative_breakpoints <- ceiling(tilewidth * seq_len(nfulltile))\n            if (relative_breakpoints[[nfulltile]] >= seqlength)\n                return(relative_breakpoints)\n            c(relative_breakpoints, seqlength)\n        })\n    chrom_breakpoints <- cumsum(as.numeric(seqlengths))\n    chrom_offsets <- c(0, head(chrom_breakpoints, n=-1L))\n    ntile_per_chrom <- elementNROWS(tile_relative_breakpoints)\n    unlist(tile_relative_breakpoints, use.names=FALSE) +\n        rep.int(chrom_offsets, ntile_per_chrom)\n}\n\n### 'old_breakpoints' and 'new_breakpoints' must be non-negative non-decreasing\n### numeric or integer vectors of length >= 1 with no NAs. In addition,\n### 'old_breakpoints' must be named. None of this is checked (we trust the\n### caller).\n### Returns a NumericList (or IntegerList) object with one list element per\n### unique new breakpoint.\n.superimpose_breakpoints <- function(old_breakpoints, new_breakpoints)\n{\n    ## Set names on 'new_breakpoints'.\n    new_breakpoints <- pmin.int(new_breakpoints, tail(old_breakpoints, 1))\n    new2old <- 1L + findInterval(new_breakpoints - 1L, old_breakpoints)\n    names(new_breakpoints) <- names(old_breakpoints)[new2old]\n\n    ## Compute 'all_breakpoints'.\n    all_breakpoints <- c(old_breakpoints, new_breakpoints)\n    unique_idx <- !duplicated(all_breakpoints)\n    all_breakpoints <- all_breakpoints[unique_idx]\n\n    ## Compute 'all2new' mapping.\n    old2new <- 1L + findInterval(old_breakpoints - 1L, new_breakpoints)\n    all2new <- c(old2new, seq_along(new_breakpoints))\n    all2new <- all2new[unique_idx]\n\n    ## Compute and return final result.\n    unname(splitAsList(all_breakpoints, all2new))\n}\n\n.get_relative_ends <- function(absolute_ends, chrom_breakpoints)\n{\n    chrom_offsets <- c(0, head(chrom_breakpoints, n=-1L))\n    names(chrom_offsets) <- names(chrom_breakpoints)\n    absolute_ends <- unlist(absolute_ends, use.names=FALSE)\n    absolute_ends - chrom_offsets[names(absolute_ends)]\n}\n\n.get_relative_starts <- function(relative_ends, seqnames)\n{\n    relative_starts <- rep.int(1L, length(relative_ends))\n    run_lens <- runLength(seqnames)\n    run_starts <- c(1L, cumsum(head(run_lens, n=-1L)) + 1L)\n    idx <- sequence(run_lens - 1L, from=run_starts+1L)\n    relative_starts[idx] <- relative_ends[idx - 1L] + 1L\n    relative_starts\n}\n\n### 'seqlengths' must be a non-negative numeric or integer vector of length\n### >= 1 with no NAs and with unique names.\n### Only one of 'ntile' and 'tilewidth' can be specified.\ntileGenome <- function(seqlengths, ntile, tilewidth,\n                       cut.last.tile.in.chrom=FALSE)\n{\n    if (!isTRUEorFALSE(cut.last.tile.in.chrom))\n        stop(\"'cut.last.tile.in.chrom' must be TRUE or FALSE\")\n\n    if (is(seqlengths, \"Seqinfo\")) {\n        gr_seqinfo <- seqlengths\n        seqlengths <- seqlengths(seqlengths)\n    } else {\n        gr_seqinfo <- NULL\n    }\n\n    ## Check 'seqlengths'.\n    if (!is.numeric(seqlengths) || length(seqlengths) == 0L)\n        stop(\"'seqlengths' must be a non-empty numeric vector\")\n    seqlengths_names <- names(seqlengths)\n    if (is.null(seqlengths_names))\n        stop(\"'seqlengths' must be named\")\n    if (any(seqlengths_names %in% c(NA_character_, \"\")))\n        stop(\"'seqlengths' has names that are NA or the empty string\")\n    if (any(duplicated(seqlengths_names)))\n        stop(\"'seqlengths' has duplicated names\")\n    if (!is.integer(seqlengths))\n        seqlengths <- setNames(as.integer(seqlengths), seqlengths_names)\n    if (S4Vectors:::anyMissingOrOutside(seqlengths, lower=0L))\n        stop(\"'seqlengths' contains NAs or negative values\")\n\n    chrom_breakpoints <- setNames(cumsum(as.numeric(seqlengths)),\n                                  seqlengths_names)\n    genome_size <- chrom_breakpoints[[length(chrom_breakpoints)]]\n\n    if (!missing(ntile)) {\n        if (!missing(tilewidth))\n            stop(\"only one of 'ntile' and 'tilewidth' can be specified\")\n        if (cut.last.tile.in.chrom)\n            stop(\"'cut.last.tile.in.chrom' must be FALSE \",\n                 \"when 'ntile' is supplied\")\n        ## Check 'ntile'.\n        if (!isSingleNumber(ntile))\n            stop(\"'ntile' must be a single number\")\n        if (ntile < 1 || ntile > genome_size)\n            stop(\"'ntile' must be >= 1 and <= genome size\")\n        if (!is.integer(ntile)) {\n            if (ntile > .Machine$integer.max)\n                stop(\"'ntile' must be <= .Machine$integer.max\")\n            ntile <- as.integer(ntile)\n        }\n    } else {\n        if (missing(tilewidth))\n            stop(\"one of 'ntile' and 'tilewidth' must be specified\")\n        ## Check 'tilewidth'.\n        if (!isSingleNumber(tilewidth))\n            stop(\"'tilewidth' must be a single number\")\n        if (tilewidth < 1 || tilewidth > genome_size)\n            stop(\"'tilewidth' must be >= 1 and <= genome size\")\n        if (cut.last.tile.in.chrom) {\n            tile_breakpoints <-\n                .make_breakpoints_for_cut_last_tile_in_chrom(seqlengths,\n                                                             tilewidth)\n        } else {\n            ntile <- ceiling(genome_size / tilewidth)\n            if (ntile > .Machine$integer.max)\n                stop(\"this 'tilewidth' is too small\")\n            ntile <- as.integer(ntile)\n        }\n    }\n    if (!cut.last.tile.in.chrom) {\n        tilewidth <- genome_size / ntile\n        tile_breakpoints <- ceiling(tilewidth * seq_len(ntile))\n    }\n    absolute_ends <- .superimpose_breakpoints(chrom_breakpoints,\n                                              tile_breakpoints)\n    gr_end <- .get_relative_ends(absolute_ends, chrom_breakpoints)\n    gr_seqnames <- Rle(factor(names(gr_end), levels=names(seqlengths)))\n    gr_start <- .get_relative_starts(gr_end, gr_seqnames)\n    if (is.null(gr_seqinfo))\n        gr_seqinfo <- Seqinfo(seqnames=names(seqlengths),\n                              seqlengths=seqlengths)\n    gr <- GRanges(gr_seqnames, IRanges(gr_start, gr_end), seqinfo=gr_seqinfo)\n    if (cut.last.tile.in.chrom)\n        return(gr)\n    relist(gr, absolute_ends)\n}\n\n",
        "transcript-utils.R": "### -------------------------------------------------------------------------\n### Some low-level (non exported) utility functions to operate on transcripts\n### represented as groups of exon ranges.\n###\n### These functions are implemented in C. This file only contains R wrappers\n### for the .Call2 entry points. Those wrappers are not doing any argument\n### checking and therefore are considered \"unsafe\". They are in turn called\n### by \"safe\" and user-friendly higher level wrappers defined in\n### GenomicFeatures. The reason why the \"unsafe\" wrappers are here and not in\n### the GenomicFeatures package was to keep GenomicFeatures free of native\n### code.\n###\n### For all the functions below:\n###   o 'exonStarts', 'exonEnds' are assumed to be lists of integer vectors.\n###     The two lists are assumed to have the \"same shape\" i.e.\n###     elementNROWS() returns identical vectors on them;\n###   o 'strand' is assumed to be a character vector with allowed values\n###     \"+\" and \"-\" only;\n###   o 'decreasing.rank.on.minus.strand' is assumed to be TRUE or FALSE.\n###   o 'error.if.out.of.bounds' is assumed to be TRUE or FALSE.\n\nunsafe.transcriptWidths <- function(exonStarts, exonEnds)\n{\n    .Call2(\"transcript_widths\",\n          exonStarts, exonEnds,\n          PACKAGE=\"GenomicRanges\")\n}\n\n### 'tlocs' is assumed to be a list of integer vectors of the same length (but\n### not necessarily the \"same shape\") as 'exonStarts' and 'exonEnds'.\nunsafe.transcriptLocs2refLocs <- function(tlocs,\n                exonStarts, exonEnds, strand,\n                decreasing.rank.on.minus.strand, error.if.out.of.bounds)\n{\n    .Call2(\"tlocs2rlocs\",\n          tlocs,\n          exonStarts, exonEnds, strand,\n          decreasing.rank.on.minus.strand,\n          error.if.out.of.bounds,\n          PACKAGE=\"GenomicRanges\")\n}\n\n",
        "utils.R": "### =========================================================================\n### Some low-level (non exported) utility functions.\n### -------------------------------------------------------------------------\n\n\nhasHead <- function(x, h) {\n  identical(head(x, length(h)), h)\n}\n\n",
        "zzz.R": ".onUnload <- function(libpath)\n{\n    library.dynam.unload(\"GenomicRanges\", libpath)\n}\n\n.test <- function() BiocGenerics:::testPackage(\"GenomicRanges\")\n\n"
    },
    "DelayedArray": {
        "AutoBlock-global-settings.R": "### =========================================================================\n### AutoBlock global settings\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### set/getAutoBlockSize()\n###\n### The automatic block size must be specified in bytes.\n###\n\n### We set the automatic block size to 100 Mb by default.\nset_auto.block.size <- function(size=1e8)\n{\n    S4Arrays:::set_user_option(\"auto.block.size\", size)\n}\n\nsetAutoBlockSize <- function(size=1e8)\n{\n    if (!isSingleNumber(size) || size < 1)\n        stop(wmsg(\"the block size must be a single number >= 1\"))\n    prev_size <- S4Arrays:::get_user_option(\"auto.block.size\")\n    set_auto.block.size(size)\n    message(\"automatic block size set to \", size, \" bytes \",\n            \"(was \", prev_size, \")\")\n    invisible(size)\n}\n\ngetAutoBlockSize <- function()\n{\n    size <- S4Arrays:::get_user_option(\"auto.block.size\")\n    if (!isSingleNumber(size) || size < 1)\n        stop(wmsg(\"DelayedArray user-controlled global option \",\n                  \"auto.block.size should be a single number >= 1. \",\n                  \"Fix it with setAutoBlockSize().\"))\n    size\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### getAutoBlockLength()\n###\n\n### The elements of a character vector or a list have a variable size.\n### For a character vector: the minimum size of an element is 8 bytes which\n### is the overhead of a CHARSXP object. This doesn't account for the string\n### data itself.\n### For a list: the minimum size of a list element is 8 bytes and is obtained\n### when the element is a NULL. However, assuming that a list will typically\n### contain more non-NULL than NULL elements and that the non-NULL elements\n### will typically be atomic vectors, the average element size is more likely\n### to be >= the overhead of an atomic vector which is 56 bytes.\nget_type_size <- function(type)\n{\n    ### Atomic type sizes in bytes.\n    TYPE_SIZES <- c(\n        logical=4L,\n        integer=4L,\n        numeric=8L,\n        double=8L,\n        complex=16L,\n        character=8L,  # overhead of a CHARSXP object\n        raw=1L,\n        list=56L       # overhead of an atomic vector\n    )\n    if (missing(type))\n        return(TYPE_SIZES)\n    if (is.factor(type)) {\n        type <- as.character(type)\n    } else if (!is.character(type)) {\n        stop(wmsg(\"'type' must be a character vector or factor\"))\n    }\n    if (any(type %in% \"\"))\n        stop(wmsg(\"'type' cannot contain empty strings\"))\n    idx <- which(!(type %in% c(names(TYPE_SIZES), NA_character_)))\n    if (length(idx) != 0L) {\n        unsupported_types <- unique(type[idx])\n        in1string <- paste0(unsupported_types, collapse=\", \")\n        stop(wmsg(\"unsupported type(s): \",  in1string))\n    }\n    TYPE_SIZES[type]\n}\n\ngetAutoBlockLength <- function(type)\n{\n    if (missing(type))\n        stop(wmsg(\"Please specify the type of the array data. \",\n                  \"See ?getAutoBlockLength\"))\n    if (!isSingleString(type))\n        stop(wmsg(\"'type' must be a single string\"))\n    type_size <- get_type_size(type)\n    block_size <- getAutoBlockSize()\n    ans <- block_size / type_size\n    if (ans > .Machine$integer.max)\n        stop(wmsg(\"Automatic block length is too big. Blocks of \",\n                  \"length > .Machine$integer.max are not supported yet. \",\n                  \"Please reduce the automatic block length by reducing \",\n                  \"the automatic block size with setAutoBlockSize().\"))\n    max(as.integer(ans), 1L)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### set/getAutoBlockShape()\n###\n\nSUPPORTED_BLOCK_SHAPES <- c(\"hypercube\",\n                            \"scale\",\n                            \"first-dim-grows-first\",\n                            \"last-dim-grows-first\")\n\n### We set the automatic block shape to \"hypercube\" by default.\nset_auto.block.shape <- function(shape=\"hypercube\")\n{\n    S4Arrays:::set_user_option(\"auto.block.shape\", shape)\n}\n\nsetAutoBlockShape <- function(shape=c(\"hypercube\",\n                                      \"scale\",\n                                      \"first-dim-grows-first\",\n                                      \"last-dim-grows-first\"))\n{\n    shape <- match.arg(shape)\n    prev_shape <- S4Arrays:::get_user_option(\"auto.block.shape\")\n    set_auto.block.shape(shape)\n    message(\"automatic block shape set to \\\"\", shape, \"\\\" \",\n             \"(was \\\"\", prev_shape, \"\\\")\")\n    invisible(shape)\n}\n\ngetAutoBlockShape <- function()\n{\n    shape <- S4Arrays:::get_user_option(\"auto.block.shape\")\n    if (!(isSingleString(shape) && shape %in% SUPPORTED_BLOCK_SHAPES)) {\n        in1string <- paste(paste0(\"\\\"\", SUPPORTED_BLOCK_SHAPES, \"\\\"\"),\n                           collapse=\", \")\n        stop(wmsg(\"DelayedArray user-controlled global option \",\n                  \"auto.block.shape should be one of: \", in1string, \". \",\n                  \"Fix it with setAutoBlockShape().\"))\n    }\n    shape\n}\n\n",
        "AutoGrid.R": "### =========================================================================\n### Automatic grids\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### defaultAutoGrid()\n###\n\n### Guaranteed to return an integer >= 1.\n.normarg_block.length <- function(block.length, type)\n{\n    if (is.null(block.length))\n        return(getAutoBlockLength(type))\n    if (!isSingleNumber(block.length))\n        stop(wmsg(\"'block.length' must be a single integer or NULL\"))\n    if (block.length < 1)\n        stop(wmsg(\"'block.length' must be >= 1\"))\n    if (block.length > .Machine$integer.max)\n        stop(wmsg(\"'block.length' is too big. Blocks of \",\n                  \"length > .Machine$integer.max are not supported yet. \",\n                  \"Please specify a smaller 'block.length'.\"))\n    as.integer(block.length)\n}\n\n.normarg_chunk.grid <- function(chunk.grid, x, what=\"'x'\")\n{\n    if (is.null(chunk.grid))\n        return(chunkGrid(x))\n    if (!is(chunk.grid, \"ArrayGrid\"))\n        stop(wmsg(\"'chunk.grid' must be an ArrayGrid object or NULL\"))\n    if (!identical(refdim(chunk.grid), dim(x)))\n        stop(wmsg(\"'chunk.grid' is incompatible with \", what))\n    chunk.grid\n}\n\n.normarg_block.shape <- function(block.shape)\n{\n    if (is.null(block.shape))\n        return(getAutoBlockShape())\n    if (!(isSingleString(block.shape) &&\n          block.shape %in% SUPPORTED_BLOCK_SHAPES))\n    {\n        in1string <- paste(paste0(\"\\\"\", SUPPORTED_BLOCK_SHAPES, \"\\\"\"),\n                           collapse=\", \")\n        stop(wmsg(\"'block.shape' must be one of \", in1string, \", or NULL\"))\n    }\n    block.shape\n}\n\n.block_grid <- function(x_dim, block_len, chunk_grid, block_shape)\n{\n    ## If 'x' is empty, we return a grid with a single (empty) block that\n    ## has the dimensions of 'x'.\n    if (any(x_dim == 0L))\n        return(RegularArrayGrid(x_dim))\n    if (is.null(chunk_grid)) {\n        ans <- makeRegularArrayGridOfCappedLengthViewports(x_dim,\n                                                           block_len,\n                                                           block_shape)\n        return(ans)\n    }\n    chunks_per_block <- max(block_len %/% maxlength(chunk_grid), 1L)\n    ratio <- makeCappedVolumeBox(chunks_per_block, dim(chunk_grid), block_shape)\n    downsample(chunk_grid, ratio)\n}\n\n### Return a grid that is \"optimal\" for block processing of array-like\n### object 'x'.\n### The grid is returned as an ArrayGrid object on reference array 'x'.\n### The grid elements define the blocks that will be used for processing 'x'\n### by block. The grid is \"optimal\" in the sense that:\n###  - It's \"compatible\" with the chunk grid (i.e. with 'chunkGrid(x)' or\n###    with the chunk grid supplied via the 'chunk.grid' argument), that is,\n###    the chunks are contained in the blocks. In other words, chunks never\n###    cross block boundaries.\n###  - Its \"resolution\" is such that the blocks have a length that is as\n###    close as possibe to (but does not exceed) 'block.length'.\n###    An exception is when some chunks are already >= 'block.length',\n###    in which case the returned grid is the same as the chunk grid.\n### Note that the returned grid is regular (i.e. RegularArrayGrid object)\n### unless the chunk grid is not regular (i.e. is an ArbitraryArrayGrid\n### object).\ndefaultAutoGrid <-\n    function(x, block.length=NULL, chunk.grid=NULL, block.shape=NULL)\n{\n    x_dim <- dim(x)\n    if (is.null(x_dim))\n        stop(wmsg(\"'x' must be an array-like object\"))\n    block_len <- .normarg_block.length(block.length, type(x))\n    chunk_grid <- .normarg_chunk.grid(chunk.grid, x)\n    block_shape <- .normarg_block.shape(block.shape)\n    .block_grid(x_dim, block_len, chunk_grid, block_shape)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### rowAutoGrid() and colAutoGrid()\n###\n\n.get_auto_nrow <- function(x_dim, block.length, x_type)\n{\n    x_nrow <- x_dim[[1L]]\n    x_ncol <- x_dim[[2L]]\n    block_len <- .normarg_block.length(block.length, x_type)\n    nrow <- block_len %/% x_ncol\n\n    if (is.na(nrow)) # NA if x_ncol=0.\n        return(x_nrow)\n    if (nrow < 1L)\n        nrow <- 1L\n    min(x_nrow, nrow)\n}\n\n### Return a RegularArrayGrid object describing a grid on matrix-like\n### object 'x' where the grid elements are blocks made of full rows of 'x'.\nrowAutoGrid <- function(x, nrow=NULL, block.length=NULL)\n{\n    x_dim <- dim(x)\n    if (length(x_dim) != 2L)\n        stop(wmsg(\"'x' must have exactly 2 dimensions\"))\n    x_nrow <- x_dim[[1L]]\n    x_ncol <- x_dim[[2L]]\n    if (is.null(nrow)) {\n        nrow <- .get_auto_nrow(x_dim, block.length, type(x))\n        spacings <- c(nrow, x_ncol)\n    } else {\n        if (!is.null(block.length))\n            warning(\"'block.length' is ignored when 'nrow' is not NULL\")\n        if (!isSingleNumber(nrow))\n            stop(wmsg(\"'nrow' must be a single integer or NULL\"))\n        nrow <- as.integer(nrow)\n        if (nrow < 1L || nrow > x_nrow)\n            stop(wmsg(\"'nrow' must be >= 1 and <= nrow(x)\"))\n        spacings <- c(nrow, x_ncol)\n        if (prod(spacings) > .Machine$integer.max)\n            stop(wmsg(\"'nrow' is too big. Blocks of length > \",\n                      \".Machine$integer.max are not supported yet. \",\n                      \"Please specify a smaller 'nrow'.\"))\n    }\n    RegularArrayGrid(x_dim, spacings)\n}\n\n### Return a RegularArrayGrid object describing a grid on matrix-like\n### object 'x' where the grid elements are blocks made of full columns of 'x'.\ncolAutoGrid <- function(x, ncol=NULL, block.length=NULL)\n{\n    x_dim <- dim(x)\n    if (length(x_dim) != 2L)\n        stop(wmsg(\"'x' must have exactly 2 dimensions\"))\n    x_nrow <- x_dim[[1L]]\n    x_ncol <- x_dim[[2L]]\n    if (is.null(ncol)) {\n        ncol <- .get_auto_nrow(rev(x_dim), block.length, type(x))\n        spacings <- c(x_nrow, ncol)\n    } else {\n        if (!is.null(block.length))\n            warning(\"'block.length' is ignored when 'ncol' is not NULL\")\n        if (!isSingleNumber(ncol))\n            stop(wmsg(\"'ncol' must be a single integer or NULL\"))\n        ncol <- as.integer(ncol)\n        if (ncol < 1L || ncol > x_ncol)\n            stop(wmsg(\"'ncol' must be >= 1 and <= ncol(x)\"))\n        spacings <- c(x_nrow, ncol)\n        if (prod(spacings) > .Machine$integer.max)\n            stop(wmsg(\"'ncol' is too big. Blocks of length > \",\n                      \".Machine$integer.max are not supported yet. \",\n                      \"Please specify a smaller 'ncol'.\"))\n    }\n    RegularArrayGrid(x_dim, spacings)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### set/getAutoGridMaker()\n###\n\n### We set the automatic grid maker to defaultAutoGrid() by default.\nsetAutoGridMaker <- function(GRIDMAKER=\"defaultAutoGrid\")\n{\n    match.fun(GRIDMAKER)  # sanity check\n    S4Arrays:::set_user_option(\"auto.grid.maker\", GRIDMAKER)\n}\n\ngetAutoGridMaker <- function() S4Arrays:::get_user_option(\"auto.grid.maker\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normarg_grid()\n###\n\nnormarg_grid <- function(grid, x)\n{\n    if (is.null(grid)) {\n        etc <- c(\"Please use setAutoGridMaker() \",\n                 \"to set a valid automatic grid maker.\")\n        GRIDMAKER <- match.fun(getAutoGridMaker())\n        grid <- try(GRIDMAKER(x), silent=TRUE)\n        if (is(grid, \"try-error\"))\n            stop(wmsg(\"The current automatic grid maker returned an \",\n                      \"error when called on 'x'. \", etc))\n        if (!is(grid, \"ArrayGrid\"))\n            stop(wmsg(\"The current automatic grid maker didn't return an \",\n                      \"ArrayGrid object. \", etc))\n        if (!identical(refdim(grid), dim(x)))\n            stop(wmsg(\"The current automatic grid maker returned a grid \",\n                      \"that is incompatible with 'x'. \", etc))\n    } else {\n        if (!is(grid, \"ArrayGrid\"))\n            stop(wmsg(\"'grid' must be NULL or an ArrayGrid object\"))\n        if (!identical(refdim(grid), dim(x)))\n            stop(wmsg(\"the supplied grid is incompatible with 'x'\"))\n    }\n    grid\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### defaultSinkAutoGrid()\n###\n### To create a grid that is \"optimal\" for use in sinkApply().\n###\n\ndefaultSinkAutoGrid <- function(sink, block.length=NULL, chunk.grid=NULL)\n{\n    sink_dim <- dim(sink)\n    if (is.null(sink_dim))\n        stop(wmsg(\"'sink_dim' must be an array-like object\"))\n    block_len <- .normarg_block.length(block.length, type(sink))\n    chunk_grid <- .normarg_chunk.grid(chunk.grid, sink, \"'sink'\")\n    .block_grid(sink_dim, block_len, chunk_grid, \"first-dim-grows-first\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normarg_sink_grid()\n###\n### For use in sinkApply().\n###\n### Like normarg_grid() except that it calls 'defaultSinkAutoGrid(sink)'\n### instead of:\n###     GRIDMAKER <- match.fun(getAutoGridMaker())\n###     grid <- GRIDMAKER(sink)\n### to create the grid when it's not supplied.\n###\n\nnormarg_sink_grid <- function(grid, sink)\n{\n    if (is.null(grid)) {\n        grid <- defaultSinkAutoGrid(sink)\n    } else {\n        if (!is(grid, \"ArrayGrid\"))\n            stop(wmsg(\"'grid' must be NULL or an ArrayGrid object\"))\n        if (!identical(refdim(grid), dim(sink)))\n            stop(wmsg(\"supplied 'grid' is incompatible with 'sink'\"))\n    }\n    grid\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### defaultMultAutoGrids()\n###\n\n### Performs the same checks as .check_chunkdim() (see chunkGrid.R).\n.normarg_z_chunkdim <- function(z_chunkdim, z_dim,\n                                what=\"z\", nrow_what=\"x\", ncol_what=\"y\")\n{\n    if (!is.numeric(z_chunkdim))\n        stop(wmsg(\"'\", what, \".chunkdim' must be NULL or an integer vector\"))\n    if (!is.integer(z_chunkdim))\n        z_chunkdim <- as.integer(z_chunkdim)\n    if (length(z_chunkdim) != 2L)\n        stop(wmsg(\"'\", what, \".chunkdim' must be of length 2\"))\n    if (S4Vectors:::anyMissingOrOutside(z_chunkdim, 0L))\n        stop(wmsg(\"'\", what, \".chunkdim' should not contain negative \",\n                  \"or NA values\"))\n    if (z_chunkdim[[1L]] > z_dim[[1L]])\n        stop(wmsg(\"'\", what, \".chunkdim[[1L]]' must be \",\n                  \"<= 'nrow(\", nrow_what, \")'\"))\n    if (z_chunkdim[[1L]] == 0L && z_dim[[1L]] != 0L)\n        stop(wmsg(\"'\", what, \".chunkdim[[1L]]' should not be 0 \",\n                  \"unless 'nrow(\", nrow_what, \")' is also 0\"))\n    if (z_chunkdim[[2L]] > z_dim[[2L]])\n        stop(wmsg(\"'\", what, \".chunkdim[[2L]]' must be \",\n                  \"<= 'ncol(\", ncol_what, \")'\"))\n    if (z_chunkdim[[2L]] == 0L && z_dim[[2L]] != 0L)\n        stop(wmsg(\"'\", what, \".chunkdim[[2L]]' should not be 0 \",\n                  \"unless 'ncol(\", ncol_what, \")' is also 0\"))\n    if (prod(z_chunkdim) > .Machine$integer.max)\n        stop(wmsg(\"The chunk dimensions specified in 'z.chunkdim' are too \",\n                  \"big. Their product must be <= .Machine$integer.max\"))\n    z_chunkdim\n}\n\n### Define grids for \"block matrix multiplication\".\n###\n### The problem\n### -----------\n### 'x' and 'y' being matrix-like objects that can be multiplied (i.e.\n### ncol(x) == nrow(y)), and 'z' being their product (i.e. z = x %*% y),\n### defaultMultAutoGrids() tries to solve the problem of finding 3 grids\n### (on 'x', 'y', and 'z', respectively) that can be used for \"block matrix\n### multiplication\" of 'x' by 'y'.\n### The grid triplet ('x_grid', 'y_grid', 'z_grid') must satisfy:\n###   - get_spacings_along(x_grid, 1L)' and 'get_spacings_along(z_grid, 1L)'\n###   - get_spacings_along(y_grid, 2L)' and 'get_spacings_along(z_grid, 2L)'\n###   - get_spacings_along(x_grid, 2L)' and 'get_spacings_along(y_grid, 1L)'\n###\n### Many grid triplets satisfy these constraints, from the triplet made of\n### the coarsest grids (i.e. each grid is made of a single block covering\n### the full matrix e.g. 'x_grid <- RegularArrayGrid(dim(x))') to the triplet\n### made of the finest grids (i.e. each grid is made of blocks that contain a\n### single matrix element e.g. 'x_grid <- RegularArrayGrid(dim(x), c(1, 1))').\n###\n### Between these 2 extremes, which would both lead to bad performance in\n### general, is a wide range solutions that cover the entire spectrum of\n### coarseness. Here is a notable solution with intermediate coarseness:\n###   - x_grid <- rowAutoGrid(x, nrow=1)  # blocks on 'x' are single rows\n###   - y_grid <- colAutoGrid(y, ncol=1)  # blocks on 'y' are single columns\n###   - z_grid <- RegularArrayGrid(dim(z), c(1, 1))\n###\n### We could also let rowAutoGrid() and colAutoGrid() automatically choose\n### the maximum number of rows and columns to put in a block based on the\n### \"automatic block size\" (see ?getAutoBlockSize) by not specifying the\n### 'nrow' or 'ncol' arguments:\n###  - x_grid <- rowAutoGrid(x)\n###  - y_grid <- colAutoGrid(y)\n###  - z_grid <- RegularArrayGrid(dim(z), c(a, c))\n###    where 'a' is 'nrow(x_grid[[1L]])' and 'c' is 'ncol(y_grid[[1L]])'\n###\n### Grids that will perform \"well\"\n### ------------------------------\n### Amongst all the possible grid triplets, we want to pick up one that will\n### perform \"well\". More precisely:\n###\n###   (1) In order to cap memory usage during multiplication of any 2 blocks\n###       (e.g. 'x_grid[[i, k]]' and 'y_grid[[k, j]]'), we decide (somewhat\n###       arbitrarily) that their cumulated length must be as close as possibe\n###       to (but must not exceed) half of 'block.length'. The length of the\n###       block corresponding to the product ('z_grid[[i, j]]') must also be\n###       as close as possibe (but must not exceed) half of 'block.length'.\n###\n###   (2) We want to minimize the number of times a given block from 'x'\n###       and/or 'y' will be loaded in memory. Note that the total number\n###       of block multiplications will be 'K * length(z_grid)' where 'K'\n###       is 'ncol(x_grid)' (or 'nrow(y_grid)', which is the same). Each\n###       block in 'x' will participate to 'ncol(z_grid)' multiplications\n###       and each block in 'y' will participate to 'nrow(z_grid)'\n###       multiplications. So assuming that blocks are loaded each time\n###       they need to participate to a multiplication and not kept in\n###       memory, the data in 'x' will be loaded 'ncol(z_grid)' times and\n###       the data in 'y' will be loaded 'nrow(z_grid)' times. This means\n###       that we want 'z_grid' to be as coarse as possible. Also,\n###       depending on which of 'x' or 'y' is bigger, we should try to\n###       reduce 'ncol(z_grid)' (i.e. increase coarseness along 'z' 2nd\n###       dimension) which would be to the detriment of 'nrow(z_grid)', or\n###       vice-versa.\n###\n###   (3) Ideally we'd want the 3 grids to be compatible with the underlying\n###       chunk geometry of the matrix-like object that they are on.\n###       Unfortunately this is in general impossible to achieve for the\n###       3 grids at the same time (the 3 coarsest grids would achieve this\n###       but to the detriment of memory usage) so we'll have to compromise.\n###       One thing we don't want to compromise  with though is compatibility\n###       of 'z_grid' with the underlying chunk geometry of 'z'. The reason\n###       this is that in practice 'z' will typically be a RealizationSink\n###       object where the output blocks will be written with write_block()\n###       and some realization backends like RleRealizationSink or\n###       TENxRealizationSink require write_block() to respect the chunk\n###       geometry.\n###\n### Simplifying the problem\n### -----------------------\n### In order to simplify the problem we restrict the search space to\n### **regular** grids (RegularArrayGrid objects), so no arbitrary grids\n### (ArbitraryArrayGrid) will be considered. This reduces the opportunity to\n### find the best possible grids but that's ok for now.\n### Thanks to this simplification, our problem is reduced to finding 3\n### non-negative integer numbers a, b, c from which the the 3 grids will\n### be defined as follow:\n###  - x_grid <- RegularArrayGrid(dim(x), c(a, b))\n###  - y_grid <- RegularArrayGrid(dim(x), c(b, c))\n###  - z_grid <- RegularArrayGrid(dim(z), c(a, c))\n###\n\n.find_abc <- function(A, B, C, half_block_len,\n                      x_chunkdim, y_chunkdim, z_chunkdim)\n{\n    is_a_multiple_of <- function(m, n) { m == 0L || m %% n == 0L }\n    a0 <- z_chunkdim[[1L]]\n    if (!is_a_multiple_of(a0, x_chunkdim[[1L]]))\n        warning(wmsg(\"The chunk geometry for 'z' is incompatible with \",\n                     \"the chunk geometry for 'x' (the number of rows of \",\n                     \"a chunk in 'z' should be a multiple of the number \",\n                     \"of rows of a chunk in 'x'). \",\n                     \"This will likely degrade performance of the block \",\n                     \"matrix multiplication.\"), immediate.=TRUE)\n    c0 <- z_chunkdim[[2L]]\n    if (!is_a_multiple_of(c0, y_chunkdim[[2L]]))\n        warning(wmsg(\"The chunk geometry for 'z' is incompatible with \",\n                     \"the chunk geometry for 'y' (the number of columns of \",\n                     \"a chunk in 'z' should be a multiple of the number \",\n                     \"of columns of a chunk in 'y'). \",\n                     \"This will likely degrade performance of the block \",\n                     \"matrix multiplication.\"), immediate.=TRUE)\n    if (C > A && A != 0L)\n        a0 <- a0 * as.integer(C / A)\n    if (A > C && C != 0L)\n        c0 <- c0 * as.integer(A / C)\n\n    ## Find 'a' and 'c'.\n    z_dim <- c(A, C)\n    z_tile_dim <- pmin(c(a0, c0), z_dim)\n    z_tile_grid <- RegularArrayGrid(z_dim, z_tile_dim)\n    z_grid <- .block_grid(z_dim, max(as.integer(half_block_len), 1L),\n                          z_tile_grid, \"scale\")\n    z_spacings <- dim(z_grid[[1L]])\n    a <- z_spacings[[1L]]\n    c <- z_spacings[[2L]]\n\n    ## Find 'b'.\n    ## TODO: Revisit this.\n    b <- max(as.integer(half_block_len / (a + c)), 1L)\n    b0 <- max(x_chunkdim[[2L]], y_chunkdim[[1L]])\n    r <- b %% b0\n    if (r != 0L)\n        b <- b + (b0 - r)  # increase 'b' to the next multiple of 'b0'\n    if (b > B)\n        b <- B\n\n    c(a=a, b=b, c=c)\n}\n\n### Return list(x_grid, y_grid, z_grid).\ndefaultMultAutoGrids <-\n    function(x, y, block.length=NULL,\n             x.chunkdim=NULL, y.chunkdim=NULL, z.chunkdim=NULL)\n{\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (length(x_dim) != 2L || length(y_dim) != 2L)\n        stop(wmsg(\"'x' and 'y' must have exactly 2 dimensions\"))\n    x_ncol <- x_dim[[2L]]\n    y_nrow <- y_dim[[1L]]\n    if (x_ncol != y_nrow)\n        stop(wmsg(\"'ncol(x)' must be equal to 'nrow(y)'\"))\n    A <- x_dim[[1L]]\n    B <- x_ncol  # same as 'y_nrow'\n    C <- y_dim[[2L]]\n    z_dim <- c(A, C)\n\n    ## Assuming that 'x', 'y', and 'z' are all of type \"double\". This could\n    ## be refined.\n    half_block_len <- .normarg_block.length(block.length, \"double\") / 2\n\n    if (is.null(x.chunkdim)) {\n        x_chunkdim <- chunkdim(x)\n        if (is.null(x_chunkdim))\n            x_chunkdim <- pmin(1L, x_dim)\n    } else {\n        x_chunkdim <- .normarg_z_chunkdim(x.chunkdim, x_dim,\n                                          what=\"x\", ncol_what=\"x\")\n    }\n    if (is.null(y.chunkdim)) {\n        y_chunkdim <- chunkdim(y)\n        if (is.null(y_chunkdim))\n            y_chunkdim <- pmin(1L, y_dim)\n    } else {\n        y_chunkdim <- .normarg_z_chunkdim(y.chunkdim, y_dim,\n                                          what=\"y\", nrow_what=\"y\")\n    }\n    if (is.null(z.chunkdim)) {\n        z_chunkdim <- pmin(1L, z_dim)\n    } else {\n        z_chunkdim <- .normarg_z_chunkdim(z.chunkdim, z_dim)\n    }\n\n    abc <- .find_abc(A, B, C, half_block_len,\n                     x_chunkdim, y_chunkdim, z_chunkdim)\n\n    x_grid <- RegularArrayGrid(x_dim, abc[-3L])\n    y_grid <- RegularArrayGrid(y_dim, abc[-1L])\n    z_grid <- RegularArrayGrid(z_dim, abc[-2L])\n    list(x_grid, y_grid, z_grid)\n}\n\n",
        "ConstantArray-class.R": "### =========================================================================\n### ConstantArraySeed and ConstantArray objects\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### ConstantArraySeed objects\n###\n\nsetClass(\"ConstantArraySeed\",\n    contains=\"Array\",\n    representation(\n        dim=\"integer\",  # This gives us dim() for free!\n        value=\"vector\"\n    ),\n    prototype(\n        dim=0L,\n        value=NA\n    )\n)\n\nsetValidity2(\"ConstantArraySeed\",\n    function(object)\n    {\n        msg <- S4Arrays:::validate_dim_slot(object, \"dim\")\n        if (!isTRUE(msg))\n            return(msg)\n        if (length(object@value) != 1L)\n            return(\"'value' must be a vector (atomic or list) of length 1\")\n        TRUE\n    }\n)\n\nsetMethod(\"extract_array\", \"ConstantArraySeed\",\n    function(x, index)\n        array(x@value, S4Arrays:::get_Nindex_lengths(index, dim(x)))\n)\n\nsetMethod(\"is_sparse\", \"ConstantArraySeed\",\n    function(x)\n    {\n        zero <- vector(type(x), length=1L)\n        identical(x@value, zero)\n    }\n)\n\nsetMethod(\"extract_sparse_array\", \"ConstantArraySeed\",\n    function(x, index)\n    {\n        stopifnot(is_sparse(x))\n        ans_dim <- S4Arrays:::get_Nindex_lengths(index, dim(x))\n        SparseArray:::new_SVT_SparseArray(ans_dim, type=type(x@value),\n                                          check=FALSE)\n    }\n)\n\nConstantArraySeed <- function(dim, value=NA)\n{\n    new2(\"ConstantArraySeed\", dim=as.integer(dim), value=value)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### ConstantArray and ConstantMatrix objects\n###\n\nsetClass(\"ConstantArray\",\n    contains=\"DelayedArray\",\n    representation(seed=\"ConstantArraySeed\")\n)\n\nsetClass(\"ConstantMatrix\", contains=c(\"ConstantArray\", \"DelayedMatrix\"))\n\nsetMethod(\"matrixClass\", \"ConstantArray\", function(x) \"ConstantMatrix\")\n\nsetMethod(\"DelayedArray\", \"ConstantArraySeed\",\n    function(seed) new_DelayedArray(seed, Class=\"ConstantArray\")\n)\n\nConstantArray <- function(dim, value=NA)\n{\n    DelayedArray(ConstantArraySeed(dim, value=value))\n}\n\n### Automatic coercion method from ConstantArray to ConstantMatrix silently\n### returns a broken object (unfortunately these dummy automatic coercion\n### methods don't bother to validate the object they return). So we overwrite\n### it.\nsetAs(\"ConstantArray\", \"ConstantMatrix\",\n    function(from) new2(\"ConstantMatrix\", from)\n)\n\n### The user should not be able to degrade a ConstantMatrix object to\n### a ConstantArray object so 'as(x, \"ConstantArray\", strict=TRUE)' should\n### fail or be a no-op when 'x' is ConstantMatrix object. Making this\n### coercion a no-op seems to be the easiest (and safest) way to go.\nsetAs(\"ConstantMatrix\", \"ConstantArray\", function(from) from)  # no-op\n\n",
        "DelayedAbind-class.R": "### =========================================================================\n### DelayedAbind objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed abind() operation.\n###\n\nsetClass(\"DelayedAbind\",\n    contains=\"DelayedNaryOp\",\n    representation(\n        along=\"integer\"  # Single integer indicating the dimension along\n                         # which to bind the input objects.\n    ),\n    prototype(\n        along=1L\n    )\n)\n\n.validate_DelayedAbind <- function(x)\n{\n    ## 'along' slot.\n    if (!(isSingleInteger(x@along) && x@along >= 1L))\n        return(\"'x@along' must be a single positive integer\")\n    ndim <- length(dim(x@seeds[[1L]]))\n    if (ndim < x@along)\n        return(paste0(\"the array-like objects to bind must have at least \",\n                      x@along, \" dimensions for this binding operation\"))\n\n    dims <- S4Arrays:::get_dims_to_bind(x@seeds, x@along)\n    if (is.character(dims))\n        return(dims)\n    TRUE\n}\n\nsetValidity2(\"DelayedAbind\", .validate_DelayedAbind)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nnew_DelayedAbind <- function(seeds, along)\n{\n    new2(\"DelayedAbind\", seeds=seeds, along=along)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_noop() method\n###\n\nsetMethod(\"is_noop\", \"DelayedAbind\",\n    function(x) length(x@seeds) == 1L\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedAbind\n\n.DelayedAbind_summary <-\n    function(object) sprintf(\"Abind (along=%d)\", object@along)\n\nsummary.DelayedAbind <-\n    function(object, ...) .DelayedAbind_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedAbind\", summary.DelayedAbind)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n\n.get_DelayedAbind_dim <- function(x)\n{\n    dims <- S4Arrays:::get_dims_to_bind(x@seeds, x@along)\n    S4Arrays:::combine_dims_along(dims, x@along)\n}\n\nsetMethod(\"dim\", \"DelayedAbind\", .get_DelayedAbind_dim)\n\n.get_DelayedAbind_dimnames <- function(x)\n{\n    dims <- S4Arrays:::get_dims_to_bind(x@seeds, x@along)\n    S4Arrays:::combine_dimnames_along(x@seeds, dims, x@along)\n}\n\nsetMethod(\"dimnames\", \"DelayedAbind\", .get_DelayedAbind_dimnames)\n\n.extract_array_from_DelayedAbind <- function(x, index)\n{\n    i <- index[[x@along]]\n\n    if (is.null(i)) {\n        ## This is the easy situation.\n        arrays <- lapply(x@seeds, extract_array, index)\n        ## Bind the ordinary arrays in 'arrays'.\n        ans <- do.call(S4Arrays:::simple_abind, c(arrays, list(along=x@along)))\n        return(ans)\n    }\n\n    ## From now on 'i' is a vector of positive integers.\n    dims <- S4Arrays:::get_dims_to_bind(x@seeds, x@along)\n    breakpoints <- cumsum(dims[x@along, ])\n    part_idx <- S4Arrays:::get_part_index(i, breakpoints)\n    split_part_idx <- S4Arrays:::split_part_index(part_idx, length(breakpoints))\n    FUN <- function(s) {\n        index[[x@along]] <- split_part_idx[[s]]\n        extract_array(x@seeds[[s]], index)\n    }\n    arrays <- lapply(seq_along(x@seeds), FUN)\n\n    ## Bind the ordinary arrays in 'arrays'.\n    ans <- do.call(S4Arrays:::simple_abind, c(arrays, list(along=x@along)))\n\n    ## Reorder the rows or columns in 'ans'.\n    Nindex <- vector(\"list\", length=length(index))\n    Nindex[[x@along]] <- S4Arrays:::get_rev_index(part_idx)\n    extract_array(ans, Nindex)\n}\n\nsetMethod(\"extract_array\", \"DelayedAbind\", .extract_array_from_DelayedAbind)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\nsetMethod(\"is_sparse\", \"DelayedAbind\",\n    function(x)\n    {\n        all(vapply(x@seeds, is_sparse, logical(1), USE.NAMES=FALSE))\n    }\n)\n\n.extract_sparse_array_DelayedAbind <- function(x, index)\n{\n    i <- index[[x@along]]\n\n    if (is.null(i)) {\n        ## This is the easy situation.\n        arrays <- lapply(x@seeds, extract_sparse_array, index)\n        ## Bind the SVT_SparseArray objects in 'arrays'.\n        ans <- SparseArray:::abind_SVT_SparseArray_objects(arrays, x@along)\n        return(ans)\n    }\n\n    ## From now on 'i' is a vector of positive integers.\n    dims <- S4Arrays:::get_dims_to_bind(x@seeds, x@along)\n    breakpoints <- cumsum(dims[x@along, ])\n    part_idx <- S4Arrays:::get_part_index(i, breakpoints)\n    split_part_idx <- S4Arrays:::split_part_index(part_idx, length(breakpoints))\n    FUN <- function(s) {\n        index[[x@along]] <- split_part_idx[[s]]\n        extract_sparse_array(x@seeds[[s]], index)\n    }\n    arrays <- lapply(seq_along(x@seeds), FUN)\n\n    ## Bind the SVT_SparseArray objects in 'arrays'.\n    ans <- SparseArray:::abind_SVT_SparseArray_objects(arrays, x@along)\n\n    ## Reorder the rows or columns in 'ans'.\n    Nindex <- vector(\"list\", length=length(index))\n    Nindex[[x@along]] <- S4Arrays:::get_rev_index(part_idx)\n    extract_sparse_array(ans, Nindex)\n}\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedAbind\",\n    .extract_sparse_array_DelayedAbind\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Backward compatibility with DelayedArray < 0.5.24\n###\n### In DelayedArray 0.5.24 the SeedBinder class got renamed DelayedAbind.\n### DelayedArray objects serialized with DelayedArray < 0.5.24 might contain\n### SeedBinder instances nested in their \"seed\" slot so we need to keep\n### the class around for now.\n###\n\nsetClass(\"SeedBinder\", contains=\"DelayedAbind\")\n\nsetMethod(\"updateObject\", \"SeedBinder\",\n    function(object, ..., verbose=FALSE)\n    {\n        class(object) <- \"DelayedAbind\"\n        callNextMethod()\n    }\n)\n\n",
        "DelayedAperm-class.R": "### =========================================================================\n### DelayedAperm objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed \"extended aperm()\" operation, that is, a\n### delayed aperm() that can drop and/or add **ineffective** dimensions.\n### Note that since only **ineffective** dimensions (i.e. dimensions with\n### an extent of 1) can be dropped or added, the length of the output array\n### is guaranteed to be the same as the length of the input array.\n###\n\nsetClass(\"DelayedAperm\",\n    contains=\"DelayedUnaryOp\",\n    representation(\n        perm=\"integer\"  # Index into 'dim(seed)' describing the\n                        # **rearrangement** of the dimensions i.e. which\n                        # dimensions of the input to keep and in which order.\n                        # Only ineffective dimensions can be dropped. Note\n                        # that NAs are allowed and indicate the addition of\n                        # an ineffective dimension. For example if 'dim(seed)'\n                        # is c(20, 1, 15, 2, 1) then a DelayedAperm object\n                        # where 'perm' is set to c(NA, NA, 3, 1, NA, 4, 5)\n                        # represents an operation that returns an array with\n                        # dimensions c(1, 1, 15, 20, 1, 2, 1).\n    ),\n    prototype(\n        perm=1L\n    )\n)\n\n.validate_DelayedAperm <- function(x)\n{\n    ## 'perm' slot.\n    msg <- S4Arrays:::validate_perm(x@perm, dim(x@seed))\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\n\nsetValidity2(\"DelayedAperm\", .validate_DelayedAperm)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nnew_DelayedAperm <- function(seed=new(\"array\"), perm=NULL)\n{\n    perm <- S4Arrays:::normarg_perm(perm, dim(seed))\n    new2(\"DelayedAperm\", seed=seed, perm=perm)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_noop() method\n###\n\nsetMethod(\"is_noop\", \"DelayedAperm\",\n    function(x) isSequence(x@perm, length(dim(x@seed)))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedAperm\n\n.DelayedAperm_summary <- function(object)\n{\n    perm <- as.character(object@perm)\n    if (length(perm) >= 2L)\n        perm <- sprintf(\"c(%s)\", paste0(perm, collapse=\",\"))\n    sprintf(\"Aperm (perm=%s)\", perm)\n}\n\nsummary.DelayedAperm <-\n    function(object, ...) .DelayedAperm_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedAperm\", summary.DelayedAperm)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n\n.get_DelayedAperm_dim <- function(x)\n{\n    seed_dim <- dim(x@seed)\n    ans <- seed_dim[x@perm]\n    ans[is.na(x@perm)] <- 1L\n    ans\n}\n\nsetMethod(\"dim\", \"DelayedAperm\", .get_DelayedAperm_dim)\n\n.get_DelayedAperm_dimnames <- function(x)\n{\n    seed_dimnames <- dimnames(x@seed)\n    if (is.null(seed_dimnames))\n        return(NULL)\n    S4Arrays:::simplify_NULL_dimnames(seed_dimnames[x@perm])\n}\n\nsetMethod(\"dimnames\", \"DelayedAperm\", .get_DelayedAperm_dimnames)\n\nproject_index_on_seed <- function(index, x)\n{\n    stopifnot(is(x, \"DelayedAperm\"),\n              is.list(index),\n              length(index) == length(x@perm))\n    nonNA_idx <- which(!is.na(x@perm))\n    perm0 <- x@perm[nonNA_idx]\n    index0 <- index[nonNA_idx]\n    seed_dim <- dim(x@seed)\n    seed_index <- vector(\"list\", length=length(seed_dim))\n    seed_index[perm0] <- index0\n    seed_index\n}\n\n.extract_array_from_DelayedAperm <- function(x, index)\n{\n    seed_index <- project_index_on_seed(index, x)\n    a <- extract_array(x@seed, seed_index)\n    a <- aperm2(a, x@perm)\n    index[!is.na(x@perm)] <- list(NULL)\n    S4Arrays:::subset_by_Nindex(a, index)\n}\n\nsetMethod(\"extract_array\", \"DelayedAperm\",\n    .extract_array_from_DelayedAperm\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\nsetMethod(\"is_sparse\", \"DelayedAperm\", function(x) is_sparse(x@seed))\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedAperm\",\n    function(x, index)\n    {\n        seed_index <- project_index_on_seed(index, x)\n        svt <- extract_sparse_array(x@seed, seed_index)\n        svt <- aperm(svt, x@perm)\n        index[!is.na(x@perm)] <- list(NULL)\n        extract_sparse_array(svt, index)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Backward compatibility with DelayedArray < 0.5.24\n###\n### In DelayedArray 0.5.24 the SeedDimPicker class got renamed DelayedAperm.\n### DelayedArray objects serialized with DelayedArray < 0.5.24 might contain\n### SeedDimPicker instances nested in their \"seed\" slot so we need to keep\n### the class around for now.\n###\n\nsetClass(\"SeedDimPicker\", contains=\"DelayedAperm\")\n\nsetMethod(\"updateObject\", \"SeedDimPicker\",\n    function(object, ..., verbose=FALSE)\n    {\n        object <- new2(\"DelayedAperm\", seed=object@seed,\n                                       perm=object@dim_combination)\n        callNextMethod()\n    }\n)\n\n",
        "DelayedArray-class.R": "### =========================================================================\n### DelayedArray objects\n### -------------------------------------------------------------------------\n\n\n### The \"root\" node of the tree of DelayedOp objects. Represents a no-op.\nsetClass(\"DelayedArray\", contains=\"DelayedUnaryIsoOp\")\n\n### Extending RectangularData gives us a few things for free (e.g. validity\n### method for RectangularData objects, head(), tail(), etc...). Note\n### that even though DelayedMatrix already extends Array (via DelayedArray,\n### DelayedUnaryOp, and DelayedOp) we need to make DelayedMatrix a *direct*\n### child of Array and to place Array *before* RectangularData in\n### the 'contains' field below. This ensures that method dispatch will pick\n### the method for Array in case a generic has methods defined for Array and\n### RectangularData. Furthermore, for some obscure reason, it seems that we\n### also need to place all the classes that are in the inheritance path\n### between DelayedArray and Array in the 'contains' field otherwise we get\n### the following error when trying to instantiate a DelayedMatrix object\n### with new(\"DelayedMatrix\"):\n###\n###     Error: C stack usage  7971652 is too close to the limit\n###\nsetClass(\"DelayedMatrix\",\n    contains=c(\"DelayedArray\",\n               \"DelayedUnaryIsoOp\", \"DelayedUnaryOp\", \"DelayedOp\",\n               \"Array\",\n               \"RectangularData\"),\n    prototype=prototype(\n        seed=new(\"matrix\")\n    )\n)\n\n### Automatic coercion method from DelayedArray to DelayedMatrix silently\n### returns a broken object (unfortunately these dummy automatic coercion\n### methods don't bother to validate the object they return). So we overwrite\n### it.\nsetAs(\"DelayedArray\", \"DelayedMatrix\",\n    function(from) new(\"DelayedMatrix\", from)\n)\n\n### The user should not be able to degrade a DelayedMatrix object to a\n### DelayedArray object so 'as(x, \"DelayedArray\", strict=TRUE)' should\n### fail or be a no-op when 'x' is a DelayedMatrix object. Making this\n### coercion a no-op seems to be the easiest (and safest) way to go.\nsetAs(\"DelayedMatrix\", \"DelayedArray\", function(from) from)  # no-op\n\n### For internal use only.\nsetGeneric(\"matrixClass\", function(x) standardGeneric(\"matrixClass\"))\n\nsetMethod(\"matrixClass\", \"DelayedArray\", function(x) \"DelayedMatrix\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Check the internals of a DelayedArray object\n###\n### Internal representation of DelayedArray objects has changed in\n### DelayedArray 0.5.11 (went from 5 slots to 3), then again in DelayedArray\n### 0.5.24 (went from 3 slots to only 1):\n###   - Internals v0: 5 slots (DelayedArray < 0.5.11)\n###   - Internals v1: 3 slots (DelayedArray >= 0.5.11 and < 0.5.24)\n###   - Internals v2: 1 slot  (DelayedArray >= 0.5.24)\n###\n### The helpers below detect the internals version used by an object. These\n### helpers are used in the validity and \"show\" methods for DelayedArray\n### objects.\n###\n\n.get_DelayedArray_internals_version <- function(object)\n{\n    if (.hasSlot(object, \"metaindex\") && .hasSlot(object, \"is_transposed\"))\n        return(0L)\n    if (.hasSlot(object, \"index\") && .hasSlot(object, \"delayed_ops\"))\n        return(1L)\n    return(2L)\n}\n\n.get_pkgversion_from_internals_version <- function(internals_version)\n{\n    switch(sprintf(\"v%d\", internals_version),\n           v0=\"< 0.5.11\",\n           v1=\">= 0.5.11 and < 0.5.24\",\n           v2=\"current\", # i.e. >= 0.5.24\n           stop(\"invalid internals version\"))\n}\n\n.get_DelayedArray_pkgversion <- function(object)\n{\n    internals_version <- .get_DelayedArray_internals_version(object)\n    .get_pkgversion_from_internals_version(internals_version)\n}\n\n.msg_for_old_internals <- function(object, pkgversion)\n{\n    paste0(class(object), \" object uses internal representation \",\n           \"from DelayedArray\\n  \", pkgversion, \" and cannot be \",\n           \"displayed or used. Please update it with:\\n\\n\",\n           \"      object <- updateObject(object, verbose=TRUE)\\n\\n\",\n           \"  and re-serialize it.\")\n}\n\n.check_DelayedArray_internals <- function(object)\n{\n    pkgversion <- .get_DelayedArray_pkgversion(object)\n    if (pkgversion != \"current\")\n        stop(.msg_for_old_internals(object, pkgversion))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n### Note that, because DelayedArray extends DelayedUnaryOp, validation of\n### a DelayedArray object is mostly taken care of by the validity method\n### for DelayedUnaryOp objects, which is defined in DelayedOp-class.R.\n.validate_DelayedArray <- function(x)\n{\n    pkgversion <- .get_DelayedArray_pkgversion(x)\n    if (pkgversion != \"current\")\n        return(.msg_for_old_internals(x, pkgversion))\n#    seed_dim <- dim(x@seed)\n#    seed_ndim <- length(seed_dim)\n#    ## In the context of validObject(), 'class(x)' is always \"DelayedArray\"\n#    ## and not the real class of 'x', which seems to be a bug in validObject().\n#    ## This prevents us from doing the check below.\n#    if (seed_ndim == 2L && !is(x, matrixClass(x)))\n#        return(paste0(\"'x' has 2 dimensions but is not a \",\n#                      matrixClass(x), \" derivative\"))\n    TRUE\n}\n\nsetValidity2(\"DelayedArray\", .validate_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n### We overwrite the methods for DelayedUnaryOp objects for the sole purpose\n### of detecting DelayedArray objects with old internals.\n###\n\nsetMethod(\"dim\", \"DelayedArray\",\n    function(x)\n    {\n        .check_DelayedArray_internals(x)\n        callNextMethod()\n    }\n)\n\nsetMethod(\"dimnames\", \"DelayedArray\",\n    function(x)\n    {\n        .check_DelayedArray_internals(x)\n        callNextMethod()\n    }\n)\n\nsetMethod(\"extract_array\", \"DelayedArray\",\n    function(x, index)\n    {\n        .check_DelayedArray_internals(x)\n        callNextMethod()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### Low-level constructor. Not intended to be used directly by the end user.\nnew_DelayedArray <- function(seed=new(\"array\"), Class=\"DelayedArray\")\n{\n    stopifnot(isSingleString(Class), extends(Class, \"DelayedArray\"))\n    seed_ndim <- length(dim(seed))\n    if (extends(Class, \"DelayedMatrix\")) {\n        if (seed_ndim != 2L)\n            stop(wmsg(\"the supplied seed must have exactly 2 dimensions \",\n                      \"when the specified class (\", Class, \") extends \",\n                      \"DelayedMatrix\"))\n    } else {\n        if (seed_ndim == 2L)\n            Class <- matrixClass(new(Class))\n    }\n    new2(Class, seed=seed)\n}\n\nsetGeneric(\"DelayedArray\", function(seed) standardGeneric(\"DelayedArray\"))\n\nsetMethod(\"DelayedArray\", \"ANY\", function(seed) new_DelayedArray(seed))\n\nsetMethod(\"DelayedArray\", \"DelayedArray\", function(seed) seed)\n\nsetMethod(\"DelayedArray\", \"DelayedOp\",\n    function(seed)\n    {\n        if (getOption(\"DelayedArray.simplify\", default=TRUE)) {\n            simplified_seed <- simplify(seed, incremental=TRUE)\n            if (!identical(simplified_seed, seed))  # avoid infinite recursion\n                return(DelayedArray(simplified_seed))\n            seed <- simplified_seed\n        }\n        new_DelayedArray(seed)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### simplify()\n###\n\nsetMethod(\"simplify\", \"DelayedArray\",\n    function(x, incremental=FALSE)\n        DelayedArray(simplify(x@seed, incremental=incremental))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### netSubsetAndAperm()\n###\n\nsetMethod(\"netSubsetAndAperm\", \"DelayedArray\",\n    function(x, as.DelayedOp=FALSE)\n    {\n        x <- x@seed\n        callGeneric()\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n### updateObject() must be able to update from internals v0 to v2 and from\n### internals v1 to v2.\n###\n\n### Reflect internals v1.\nsetClass(\"DelayedArray1\",\n    contains=\"DelayedArray\",\n    representation(\n        index=\"list\",       # List (possibly named) of subscripts as\n                            # positive integer vectors, one vector per\n                            # seed dimension. *Missing* list elements\n                            # are allowed and represented by NULLs.\n\n        delayed_ops=\"list\"  # List of delayed operations. See below\n                            # for the details.\n    ),\n    prototype(\n        seed=new(\"array\"),\n        index=list(NULL)\n    )\n)\n\n.from_internals_v1_to_v2 <- function(object1)\n{\n    seed <- object1@seed\n    ## 'dimnames(seed)' can fail e.g. if 'seed' is or contains an\n    ## HDF5ArraySeed object that points to a non-existing file, but we still\n    ## want to be able to update object1.\n    ## Our use case for this is ExperimentHub resource EH1656. This is a\n    ## SummarizedExperiment object (added to ExperimentHub on 2017-10-06\n    ## by the restfulSEData folks) where the assay is a very old DelayedMatrix\n    ## instance (predates DelayedArray 0.4) that binds together 14 old\n    ## HDF5ArraySeed instances that point to a non-existing file ('assays.h5').\n    seed_dimnames <- try(dimnames(seed), silent=TRUE)\n    if (inherits(seed_dimnames, \"try-error\"))\n        seed_dimnames <- NULL\n\n    ## Translate 'index' slot as DelayedOp objects (1 DelayedSubset and\n    ## 1 DelayedSetDimnames) and stash them inside 'seed'.\n\n    index <- lapply(unname(object1@index), unname)\n    op <- new2(\"DelayedSubset\", seed=seed, index=index)\n    if (!is_noop(op))\n        seed <- op\n\n    object1_dimnames <- lapply(seq_along(object1@index),\n        function(along) {\n            i <- object1@index[[along]]\n            if (is.null(i)) seed_dimnames[[along]] else names(i)\n        })\n    if (all(S4Vectors:::sapply_isNULL(object1_dimnames)))\n        object1_dimnames <- NULL\n\n    op <- new_DelayedSetDimnames(seed, object1_dimnames)\n    if (!is_noop(op))\n        seed <- op\n\n    ## Translate 'delayed_ops' slot as DelayedUnaryIsoOpWithArgs objects\n    ## and stash them inside 'seed'.\n\n    for (delayed_op in object1@delayed_ops) {\n        OP <- delayed_op[[1L]]\n        Largs <- delayed_op[[2L]]\n        Rargs <- delayed_op[[3L]]\n        Lalong <- Ralong <- NA\n        recycle_along_last_dim <- delayed_op[[4L]]\n        if (recycle_along_last_dim) {\n            if (length(Largs) == 1L) Lalong <- 1L else Ralong <- 1L\n        }\n        seed <- new_DelayedUnaryIsoOpWithArgs(seed, OP, Largs, Rargs,\n                                              Lalong, Ralong)\n    }\n\n    DelayedArray(seed)\n}\n\n.update_delayed_ops <- function(delayed_ops)\n{\n    for (i in seq_along(delayed_ops)) {\n        delayed_op <- delayed_ops[[i]]\n        recycle_along_last_dim <- delayed_op[[4L]]\n        if (is.na(recycle_along_last_dim)) {\n            recycle_along_first_dim <- FALSE\n        } else if (!recycle_along_last_dim) {\n            recycle_along_first_dim <- TRUE\n        } else {\n            stop(wmsg(\"object is too complex, sorry\"))\n        }\n        delayed_op[[4L]] <- recycle_along_first_dim\n        delayed_ops[[i]] <- delayed_op\n    }\n    delayed_ops\n}\n\n.from_internals_v0_to_v2 <- function(object0)\n{\n    delayed_ops <- .update_delayed_ops(object0@delayed_ops)\n    object1 <- new2(\"DelayedArray1\", seed=object0@seed,\n                                     index=object0@index,\n                                     delayed_ops=delayed_ops,\n                                     check=FALSE)\n    object2 <- .from_internals_v1_to_v2(object1)\n\n    if (identical(object0@metaindex, seq_along(object0@index)) &&\n        identical(object0@is_transposed, FALSE))\n        return(object2)\n\n    if (any(vapply(delayed_ops,\n                   function(delayed_op) delayed_op[[4L]],\n                   logical(1))))\n        stop(wmsg(\"object is too complex, sorry\"))\n\n    perm <- object0@metaindex\n    if (object0@is_transposed)\n        perm <- rev(perm)\n    aperm(object2, perm)\n}\n\n.updateObject_DelayedArray <- function(object, ..., verbose=FALSE)\n{\n    object@seed <- updateObject(object@seed, ..., verbose=verbose)\n\n    internals_version <- .get_DelayedArray_internals_version(object)\n    pkgversion <- .get_pkgversion_from_internals_version(internals_version)\n\n    if (pkgversion == \"current\") {\n        if (verbose)\n            message(\"[updateObject] Internal representation of \",\n                    class(object), \" object is current.\\n\",\n                    \"[updateObject] Nothing to update.\")\n        return(object)\n    }\n\n    if (verbose)\n        message(\"[updateObject] \", class(object), \" object uses \",\n                \"internal representation from\\n\",\n                \"[updateObject] DelayedArray \", pkgversion, \". \",\n                \"Updating it ...\")\n\n    if (internals_version == 1L)\n        return(.from_internals_v1_to_v2(object))\n\n    if (internals_version == 0L)\n        return(.from_internals_v0_to_v2(object))\n\n    object\n}\n\nsetMethod(\"updateObject\", \"DelayedArray\", .updateObject_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Stash delayed ops in a DelayedArray object\n###\n### Each \"stashing\" utility below:\n###   1) creates a new DelayedOp object representing a particular delayed\n###      operation,\n###   2) \"stashes\" the new DelayedOp object inside the input DelayedArray\n###      object 'x' by inserting it in the tree of DelayedOp objects (stored\n###      in 'x@seed') as the new root node.\n###\n### No \"stashing\" utility for nodes of type DelayedNaryIsoOp for now.\n### See DelayedOp-class.R for the list of all node types.\n###\n\nstash_DelayedSubset <- function(x, Nindex)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    op <- new_DelayedSubset(x@seed, Nindex)\n    DelayedArray(op)\n}\n\nstash_DelayedAperm <- function(x, perm)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    op <- new_DelayedAperm(x@seed, perm)\n    DelayedArray(op)\n}\n\nstash_DelayedUnaryIsoOpStack <- function(x, OP)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    op <- new_DelayedUnaryIsoOpStack(x@seed, OPS=list(OP), check.op=TRUE)\n    DelayedArray(op)\n}\n\nstash_DelayedUnaryIsoOpWithArgs <- function(x, OP,\n                                            Largs=list(), Rargs=list(),\n                                            Lalong=NA, Ralong=NA)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    op <- new_DelayedUnaryIsoOpWithArgs(x@seed, OP=OP,\n                                        Largs=Largs, Rargs=Rargs,\n                                        Lalong=Lalong, Ralong=Ralong,\n                                        check.op=TRUE)\n    DelayedArray(op)\n}\n\n### stash_DelayedUnaryIsoOp() was introduced in BioC 3.7 and renamed\n### stash_DelayedUnaryIsoOpWithArgs() in BioC 3.8. The alias below is for\n### backward compatibility with objects that were serialized with BioC 3.7.\n### For example, the 'BS.cancer.ex.fit' dataset (a BSseq instance from the\n### bsseqData package and used in the bsseq_analysis.Rmd vignette from the\n### bsseq package) contains the \"plogis\" method for DelayedArray objects in\n### its \"trans\" slot, and this method contains a reference to\n### stash_DelayedUnaryIsoOp. This is the sign that this BSseq instance was\n### serialized with BioC 3.7. Without the alias below, the bsseq_analysis.Rmd\n### vignette chokes on this line:\n###\n###   BS.cancer.ex.tstat <- BSmooth.tstat(BS.cancer.ex.fit, ...)\n###\n### with the following error:\n###\n###   Error: processing vignette 'bsseq_analysis.Rmd' failed with diagnostics:\n###   could not find function \"stash_DelayedUnaryIsoOp\"\n###\n### Note that 'BS.cancer.ex.fit' contains 3 DelayedMatrix objects in\n### its \"assays\" slot.\n### TODO: Remove this alias at some point (e.g. in BioC 3.10).\nstash_DelayedUnaryIsoOp <- stash_DelayedUnaryIsoOpWithArgs\n\nstash_DelayedSubassign <- function(x, Nindex, value)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    if (is(value, \"DelayedArray\"))\n        value <- value@seed\n    op <- new_DelayedSubassign(x@seed, Nindex, value)\n    DelayedArray(op)\n}\n\nstash_DelayedSetDimnames <- function(x, dimnames)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    op <- new_DelayedSetDimnames(x@seed, dimnames)\n    DelayedArray(op)\n}\n\nstash_DelayedAbind <- function(x, objects, along)\n{\n    stopifnot(is.list(objects))\n    all_objects <- unname(S4Vectors:::delete_NULLs(c(list(x), objects)))\n    ## All supplied objects must be DelayedArray objects or derivatives.\n    seeds <- lapply(all_objects,\n        function(object) {\n            if (!is(object, \"DelayedArray\"))\n                stop(wmsg(\"all the supplied objects must be DelayedArray \",\n                          \"objects or derivatives\"))\n            object@seed\n        })\n    op <- new_DelayedAbind(seeds, along)\n    DelayedArray(op)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### aperm()\n###\n### Like aperm2() in S4Arrays, extend base::aperm() by allowing dropping\n### and/or adding ineffective dimensions.\n###\n\n### S3/S4 combo for aperm.DelayedArray\naperm.DelayedArray <- function(a, perm, ...) stash_DelayedAperm(a, perm, ...)\nsetMethod(\"aperm\", \"DelayedArray\", aperm.DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### dim() setter\n###\n### On a DelayedArray object, the dim() setter can only be used to drop some\n### of the \"ineffective\" dimensions (i.e. dimensions equal to 1, so dropping\n### them preserves the length of the object).\n###\n\n### Return the mapping as an integer vector 'new2old' parallel to 'new_dim'.\n### 'new2old' has the following properties:\n### 1. It can contain NA's but it must have at least one non-NA element.\n### 2. Its non-NA elements must be >= 1 and <= 'length(old_dim)'.\n### 3. Its non-NA elements must be strictly sorted in ascending order.\n### 4. 'old_dim[new2old]' must be identical to 'new_dim' after replacing\n###    all NA's in it with 1's. That is, it must satisfy:\n###        new_dim2 <- old_dim[new2old]\n###        new_dim2[is.na(new_dim2)] <- 1L\n###        identical(new_dim, new_dim2)\n.map_new_to_old_dim <- function(new_dim, old_dim, x_class)\n{\n    cannot_map_msg <- c(\n        \"Cannot map the supplied dim vector to the current dimensions of \",\n        \"the object. On a \", x_class, \" object, the dim() setter can only \",\n        \"be used to drop and/or add \\\"ineffective dimensions\\\" (i.e. \",\n        \"dimensions equal to 1) to the object.\"\n    )\n    can_map_effective_dimensions <- function(effdim_idx1, effdim_idx2) {\n        if (length(effdim_idx1) != length(effdim_idx2))\n            return(FALSE)\n        if (length(effdim_idx1) == 0L)\n            return(TRUE)\n        all(new_dim[effdim_idx1] == old_dim[effdim_idx2])\n    }\n\n    ## Get index of new and old effective dimensions.\n    effdim_idx1 <- which(new_dim != 1L)\n    effdim_idx2 <- which(old_dim != 1L)\n\n    if (!can_map_effective_dimensions(effdim_idx1, effdim_idx2))\n        stop(wmsg(cannot_map_msg))\n\n    ## Map as much ineffective dimensions as possible.\n    ## This prevents from returning a mapping that contains only NA's, which\n    ## would otherwise happen in the rare situation where 'old_dim' (and\n    ## consequently 'new_dim') contains only 1's. So for example, in the\n    ## following situation:\n    ##     A <- DelayedArray(array(1:24, 4:2))\n    ##     A1 <- A[1, 1, 1, drop=FALSE]\n    ##     dim(A1) <- c(1, 1)\n    ## 'A1@seed@perm' will be set to 'c(1L, 2L)', which is ok, and not to\n    ## 'c(NA_integer_, NA_integer_)', which would NOT be ok.\n    map_ineffective_dimensions <- function(effdim_idx1, effdim_idx2) {\n        new2old <- rep.int(NA_integer_, length(new_dim))\n        idx1 <- c(effdim_idx1, length(new_dim) + 1L)\n        idx2 <- c(effdim_idx2, length(old_dim) + 1L)\n        i1 <- i2 <- 0L\n        for (k in seq_along(idx1)) {\n            prev_i1 <- i1\n            i1 <- idx1[[k]]\n            prev_i2 <- i2\n            i2 <- idx2[[k]]\n            n <- min(i1 - prev_i1, i2 - prev_i2) - 1L\n            new2old[prev_i1 + seq_len(n)] <- prev_i2 + seq_len(n)\n        }\n        new2old\n    }\n    new2old <- map_ineffective_dimensions(effdim_idx1, effdim_idx2)\n\n    ## Map **all** effective dimensions.\n    new2old[effdim_idx1] <- effdim_idx2\n    new2old\n}\n\n.set_DelayedArray_dim <- function(x, value)\n{\n    x_dim <- dim(x)\n    value <- unname(S4Arrays:::normalize_dim_replacement_value(value, x_dim))\n    new2old <- .map_new_to_old_dim(value, x_dim, class(x))\n    ans <- aperm(x, new2old)\n    stopifnot(identical(dim(ans), value))  # sanity check\n    ans\n}\n\nsetReplaceMethod(\"dim\", \"DelayedArray\", .set_DelayedArray_dim)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### dimnames() setter\n###\n\nsetReplaceMethod(\"dimnames\", \"DelayedArray\",\n    function(x, value) stash_DelayedSetDimnames(x, value)\n)\n\n### names() getter & setter.\n\n.get_DelayedArray_names <- function(x)\n{\n    if (length(dim(x)) != 1L)\n        return(NULL)\n    dimnames(x)[[1L]]\n}\n\nsetMethod(\"names\", \"DelayedArray\", .get_DelayedArray_names)\n\n.set_DelayedArray_names <- function(x, value)\n{\n    if (length(dim(x)) != 1L) {\n        if (!is.null(value))\n            stop(wmsg(\"setting the names of a \", class(x), \" object \",\n                      \"with more than 1 dimension is not supported\"))\n        return(x)\n    }\n    dimnames(x)[[1L]] <- value\n    x\n}\n\nsetReplaceMethod(\"names\", \"DelayedArray\", .set_DelayedArray_names)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Show\n###\n\nsetMethod(\"show\", \"DelayedArray\",\n    function(object)\n    {\n        .check_DelayedArray_internals(object)\n        S4Arrays:::show_compact_array(object)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Combining and splitting\n###\n### TODO: These methods are based on as.vector() so could be made methods\n### for Array objects (and moved to extract_array.R).\n###\n\n### Note that combining arrays with c() is NOT an endomorphism!\nsetMethod(\"c\", \"DelayedArray\",\n    function(x, ..., recursive=FALSE)\n    {\n        if (!identical(recursive, FALSE))\n            stop(wmsg(\"\\\"c\\\" method for DelayedArray objects \",\n                      \"does not support the 'recursive' argument\"))\n        if (missing(x)) {\n            objects <- list(...)\n        } else {\n            objects <- list(x, ...)\n        }\n        S4Arrays:::combine_array_objects(objects)\n    }\n)\n\nsetMethod(\"splitAsList\", \"DelayedArray\",\n    function(x, f, drop=FALSE, ...)\n        splitAsList(as.vector(x), f, drop=drop, ...)\n)\n\n### S3/S4 combo for split.DelayedArray\nsplit.DelayedArray <- function(x, f, drop=FALSE, ...)\n    splitAsList(x, f, drop=drop, ...)\nsetMethod(\"split\", c(\"DelayedArray\", \"ANY\"), split.DelayedArray)\n\n",
        "DelayedArray-stats.R": "### =========================================================================\n### Statistical methods for DelayedArray objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The Normal Distribution\n###\n### All these methods return a DelayedArray object of the same dimensions\n### as their first argument.\n###\n\nsetMethod(\"dnorm\", \"DelayedArray\",\n    function(x, mean=0, sd=1, log=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) dnorm(a, mean=mean, sd=sd, log=log))\n)\n\nsetMethod(\"pnorm\", \"DelayedArray\",\n    function(q, mean=0, sd=1, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(q,\n            function(a) pnorm(a, mean=mean, sd=sd,\n                                 lower.tail=lower.tail, log.p=log.p))\n)\n\nsetMethod(\"qnorm\", \"DelayedArray\",\n    function(p, mean=0, sd=1, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(p,\n            function(a) qnorm(a, mean=mean, sd=sd,\n                                 lower.tail=lower.tail, log.p=log.p))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The Binomial Distribution\n###\n### All these methods return a DelayedArray object of the same dimensions\n### as their first argument.\n###\n\nsetMethod(\"dbinom\", \"DelayedArray\",\n    function(x, size, prob, log=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) dbinom(a, size=size, prob=prob, log=log))\n)\n\nsetMethod(\"pbinom\", \"DelayedArray\",\n    function(q, size, prob, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(q,\n            function(a) pbinom(a, size=size, prob=prob,\n                                  lower.tail=lower.tail, log.p=log.p))\n)\n\nsetMethod(\"qbinom\", \"DelayedArray\",\n    function(p, size, prob, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(p,\n            function(a) qbinom(a, size=size, prob=prob,\n                                  lower.tail=lower.tail, log.p=log.p))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The Poisson Distribution\n###\n### All these methods return a DelayedArray object of the same dimensions\n### as their first argument.\n###\n\nsetMethod(\"dpois\", \"DelayedArray\",\n    function(x, lambda, log=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) dpois(a, lambda=lambda, log=log))\n)\n\nsetMethod(\"ppois\", \"DelayedArray\",\n    function(q, lambda, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(q,\n            function(a) ppois(a, lambda=lambda,\n                                 lower.tail=lower.tail, log.p=log.p))\n)\n\nsetMethod(\"qpois\", \"DelayedArray\",\n    function(p, lambda, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(p,\n            function(a) qpois(a, lambda=lambda,\n                                 lower.tail=lower.tail, log.p=log.p))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The Logistic Distribution\n###\n### All these methods return a DelayedArray object of the same dimensions\n### as their first argument.\n###\n\nsetMethod(\"dlogis\", \"DelayedArray\",\n    function(x, location=0, scale=1, log=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) dlogis(a, location=location, scale=scale, log=log))\n)\n\nsetMethod(\"plogis\", \"DelayedArray\",\n    function(q, location=0, scale=1, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(q,\n            function(a) plogis(a, location=location, scale=scale,\n                                  lower.tail=lower.tail, log.p=log.p))\n)\n\nsetMethod(\"qlogis\", \"DelayedArray\",\n    function(p, location=0, scale=1, lower.tail=TRUE, log.p=FALSE)\n        stash_DelayedUnaryIsoOpStack(p,\n            function(a) qlogis(a, location=location, scale=scale,\n                                  lower.tail=lower.tail, log.p=log.p))\n)\n\n",
        "DelayedArray-subsetting.R": "### =========================================================================\n### DelayedArray subsetting\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### BLOCK_which() and BLOCK_nzwhich()\n###\n### Both functions:\n### - return an L-index (if 'arr.ind=FALSE') or M-index (if 'arr.ind=TRUE');\n### - are directly used in the unit tests.\n\n.BLOCK_whichFUN <- function(x, whichFUN, arr.ind=FALSE, grid=NULL, as.sparse=NA)\n{\n    if (!isTRUEorFALSE(arr.ind))\n        stop(\"'arr.ind' must be TRUE or FALSE\")\n    whichFUN <- match.fun(whichFUN)\n    FUN <- function(block, whichFUN, arr.ind) {\n        bid <- currentBlockId()\n        ## 'block' is either an ordinary array or SparseArray derivative\n        ## (SVT_SparseArray or COO_SparseArray object).\n        minor <- whichFUN(block)\n        major <- rep.int(bid, length(minor))\n        grid <- effectiveGrid()\n        Mindex <- mapToRef(major, minor, grid, linear=TRUE)\n        if (arr.ind)\n            return(Mindex)\n        Mindex2Lindex(Mindex, refdim(grid))\n    }\n    block_results <- blockApply(x, FUN, whichFUN, arr.ind,\n                                grid=grid, as.sparse=as.sparse)\n    if (arr.ind) {\n        Mindex <- do.call(rbind, block_results)\n        oo <- S4Arrays:::Mindex_order(Mindex)\n        ans <- Mindex[oo, , drop=FALSE]\n    } else {\n        ans <- sort(unlist(block_results))\n    }\n    ans\n}\n\n### 'x' is trusted to be a logical array-like object.\nBLOCK_which <- function(x, arr.ind=FALSE, grid=NULL, as.sparse=NA)\n    .BLOCK_whichFUN(x, which, arr.ind=arr.ind, grid=grid, as.sparse=as.sparse)\n\n### 'x' is trusted to be an array-like object.\nBLOCK_nzwhich <- function(x, arr.ind=FALSE, grid=NULL, as.sparse=NA)\n    .BLOCK_whichFUN(x, nzwhich, arr.ind=arr.ind, grid=grid, as.sparse=as.sparse)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .BLOCK_subset_by_Mindex()\n###\n### Subset an array-like object with an M-index subscript.\n### Return an ordinary vector (atomic or list).\n###\n\n### 'Mindex' is **trusted** to be a 1-row matrix representing an M-index.\n### Extract a **single** array element.\n.extract_array_element <- function(x, Mindex)\n{\n    index <- as.list(Mindex)\n    a <- extract_array(x, index)\n    S4Arrays:::set_dim(a, NULL)\n}\n\n### 'x' is **trusted** to be an array-like object.\n### 'Mindex' is **trusted** to be an integer (or numeric) matrix\n### representing an M-index.\n.BLOCK_subset_by_Mindex <- function(x, Mindex, grid=NULL)\n{\n    ans_len <- nrow(Mindex)\n    if (ans_len == 0L)\n        return(vector(type(x)))\n    if (ans_len == 1L)\n        return(.extract_array_element(x, Mindex))\n\n    ## We don't want to use blockApply() here because it would visit all the\n    ## blocks in the grid, which is not necessary. We only need to visit the\n    ## blocks touched by the L-index.\n    grid <- normarg_grid(grid, x)\n    nblock <- length(grid)\n    majmin <- mapToGrid(Mindex, grid, linear=TRUE)\n    minor_by_block <- split(majmin$minor, majmin$major)\n    res <- S4Arrays:::bplapply2(seq_along(minor_by_block),\n        ## TODO: Not a pure function (because it refers to 'minor_by_block',\n        ## 'nblock', 'grid', and 'x') so will probably fail with\n        ## parallelization backends that don't use a fork (e.g. SnowParam on\n        ## Windows). Test and confirm this.\n        ## FIXME: The fix is to add arguments to the function so that the\n        ## objects can be passed to it.\n        function(k) {\n            bid <- as.integer(names(minor_by_block)[[k]])\n            if (get_verbose_block_processing()) {\n                message(\"Visiting block \", bid, \"/\", nblock, \" ... \",\n                        appendLF=FALSE)\n                on.exit(message(\"OK\"))\n            }\n            minor <- minor_by_block[[k]]\n            ## No need to load the entire block to extract a single value\n            ## from it.\n            if (length(minor) == 1L) {\n                Mindex1 <- mapToRef(bid, minor, grid, linear=TRUE)\n                block_ans <- .extract_array_element(x, Mindex1)\n            } else {\n                block <- read_block(x, grid[[bid]])\n                ## COO_SparseArray objects are not subsettable.\n                if (is(block, \"COO_SparseArray\"))\n                    block <- as(block, \"SVT_SparseArray\")\n                block_ans <- block[minor]\n            }\n            block_ans\n        },\n        BPPARAM=getAutoBPPARAM()\n    )\n    unsplit(res, majmin$major)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .BLOCK_subset_by_Lindex()\n###\n### Subset an array-like object with an L-index subscript.\n### Return an ordinary vector (atomic or list).\n###\n\n### We only accept numeric or logical subscripts at the moment.\n.normarg_Lindex <- function(Lindex, x_len)\n{\n    if (is.numeric(Lindex))\n        return(Lindex)\n    if (!is.logical(Lindex))\n        stop(wmsg(\"invalid subscript\"))\n    Lindex_len <- length(Lindex)\n    if (Lindex_len > x_len)\n        stop(wmsg(\"logical subscript is longer than array to subset\"))\n    ## Unlike base R, we don't support NAs in logical subscripts\n    ## (and if we were, we would probably just treat them as FALSE\n    ## to be consistent with which()).\n    if (anyNA(Lindex))\n        stop(wmsg(\"logical subscript contains NAs\"))\n    if (Lindex_len == x_len || Lindex_len == 0L)\n        return(which(Lindex))\n    if (x_len %% Lindex_len != 0L)\n        stop(wmsg(\"length of logical subscript (\", Lindex_len, \") \",\n                  \"must be a divisor of array length (\", x_len, \")\"))\n    ## Doing 'Lindex <- which(rep(Lindex, length.out=x_len))' would expand\n    ## the supplied logical subscript to the length of 'x' which would be\n    ## too expensive if 'Lindex' is short and 'x' is big!\n    n <- x_len %/% Lindex_len\n    idx <- which(Lindex)\n    offsets <- rep((0L:(n-1L)) * Lindex_len, each=length(idx))\n    rep.int(idx, n) + offsets\n}\n\n### 'x' must be an array-like object.\n### 'Lindex' must be a valid L-index, that is, a numeric vector containing\n### valid linear positions in 'x'. Logical vectors are also accepted and\n### turned into a valid L-index via .normarg_Lindex().\n.BLOCK_subset_by_Lindex <- function(x, Lindex, grid=NULL)\n{\n    x_dim <- dim(x)\n    stopifnot(!is.null(x_dim))\n    Lindex <- .normarg_Lindex(Lindex, prod(x_dim))\n    Mindex <- Lindex2Mindex(Lindex, x_dim)\n    .BLOCK_subset_by_Mindex(x, Mindex, grid=grid)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .subset_DelayedArray_by_logical_array()\n###\n### Subsetting DelayedArray object 'x' by a logical array-like object with\n### the same dimensions as 'x' e.g. 'x[x >= 0.9]'.\n### Note that we honor 'drop' in the 1D case. This diverges from base R\n### where, in the 1D case, 'x[x >= 0.9]' preserves the \"dim\" attribute,\n### even when 'drop=TRUE' (bug?).\n###\n\n### 'x' is **trusted** to be a DelayedArray object. Note that it's only\n### required to be a DelayedArray object in the 1D case and when 'drop=FALSE',\n### otherwise it can be any array-like object.\n### 'y' is **trusted** to be a logical array-like object of the same\n### dimensions as 'x'.\n.subset_DelayedArray_by_logical_array <- function(x, y, drop=TRUE)\n{\n    ## which() will trigger block processing (via BLOCK_which()) if 'y'\n    ## is a DelayedArray object.\n    if (length(dim(x)) != 1L || drop) {\n        ## Return an ordinary vector (atomic or list).\n        Mindex <- which(y, arr.ind=TRUE)\n        .BLOCK_subset_by_Mindex(x, Mindex)\n    } else {\n        ## Return a 1D object of the same class and type as 'x' (endomorphism).\n        Lindex <- which(y)\n        stash_DelayedSubset(x, list(Lindex))\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .subset_DelayedArray_by_Mindex()\n###\n### Subsetting DelayedArray object 'x' by an M-index.\n### Note that we honor 'drop' in the 1D case. This diverges from base R\n### where, in the 1D case, 'x[matrix(5:4)]' preserves the \"dim\" attribute,\n### even when 'drop=TRUE' (bug?).\n###\n\n### 'x' must be a DelayedArray object. Note that it's only required to be\n### a DelayedArray object in the 1D case and when 'drop=FALSE', otherwise\n### it can be any array-like object.\n### 'Mindex' must be an integer (or numeric) matrix representing an M-index.\n.subset_DelayedArray_by_Mindex <- function(x, Mindex, drop=FALSE)\n{\n    x_dim <- dim(x)\n    stopifnot(!is.null(x_dim), is.matrix(Mindex), is.numeric(Mindex))\n    if (ncol(Mindex) != length(x_dim))\n        stop(wmsg(\"when using a numeric matrix to subset an array-like \",\n                  \"object, the matrix must have one column per dimension \",\n                  \"in the array\"))\n    if (length(x_dim) != 1L || drop) {\n        ## Return an ordinary vector (atomic or list).\n        .BLOCK_subset_by_Mindex(x, Mindex)\n    } else {\n        ## Return a 1D object of the same class and type as 'x' (endomorphism).\n        Lindex <- Mindex2Lindex(Mindex, x_dim)\n        stash_DelayedSubset(x, list(Lindex))\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### [\n###\n\nsetMethod(\"drop\", \"DelayedArray\",\n    function(x)\n    {\n        perm <- which(dim(x) != 1L)\n        if (length(perm) >= 2L)\n            return(aperm(x, perm))\n        ## In-memory realization.\n        ## We want to propagate the names so we use 'as.array(x, drop=TRUE)'\n        ## rather than 'as.vector(x)' (both are equivalent on an Array\n        ## derivative with less than 2 effective dimensions except that\n        ## the former propagates the names and the latter doesn't).\n        as.array(x, drop=TRUE)\n    }\n)\n\n.subset_DelayedArray <- function(x, i, j, ..., drop=TRUE)\n{\n    if (missing(x))\n        stop(wmsg(\"'x' is missing\"))\n    if (!isTRUEorFALSE(drop))\n        stop(wmsg(\"'drop' must be TRUE or FALSE\"))\n    Nindex <- S4Arrays:::extract_Nindex_from_syscall(sys.call(), parent.frame())\n    nsubscript <- length(Nindex)\n    if (nsubscript == 0L)\n        return(x)  # no-op\n    x_dim <- dim(x)\n    x_ndim <- length(x_dim)\n    if (nsubscript == 1L) {\n        i <- Nindex[[1L]]\n        if (type(i) == \"logical\" && identical(x_dim, dim(i)))\n            return(.subset_DelayedArray_by_logical_array(x, i, drop=drop))\n        if (is.matrix(i) && is.numeric(i))\n            return(.subset_DelayedArray_by_Mindex(x, i, drop=drop))\n        ## Linear single bracket subsetting e.g. x[5:2].\n        ## If 'x' is mono-dimensional and 'drop' is FALSE, we fallback\n        ## to \"multi-dimensional single bracket subsetting\" which is\n        ## delayed.\n        if (x_ndim != 1L || drop)\n            return(.BLOCK_subset_by_Lindex(x, i))\n    }\n    if (nsubscript != x_ndim)\n        stop(wmsg(\"incorrect number of subscripts\"))\n    ## Multi-dimensional single bracket subsetting e.g. x[3:1, , 6].\n    ## Delayed, except when 'drop=TRUE' and the result has only one dimension,\n    ## in which case the result is realized as an ordinary vector (atomic or\n    ## list).\n    ## In the delayed case, the result is an array-like object of the same\n    ## class and type as 'x' (endomorphism), and with the same number of\n    ## dimensions as 'x' (if 'drop=FALSE') or possibly less dimensions (if\n    ## 'drop=TRUE').\n    ans <- stash_DelayedSubset(x, Nindex)\n    if (drop)\n        ans <- drop(ans)\n    ans\n}\n\nsetMethod(\"[\", \"DelayedArray\", .subset_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion to sparse matrix\n###\n\nsetAs(\"DelayedArray\", \"SparseArraySeed\",\n    function(from)\n    {\n        msg <- c(\"coercion from DelayedArray to SparseArraySeed \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\n.BLOCK_from_DelayedArray_to_COO_SparseArray <- function(x, grid=NULL)\n{\n    FUN <- function(block, arr.ind) {\n        bid <- currentBlockId()\n        minor <- nzwhich(block)\n        major <- rep.int(bid, length(minor))\n        grid <- effectiveGrid()\n        nzcoo <- mapToRef(major, minor, grid, linear=TRUE)\n        nzdata <- block[minor]\n        list(nzcoo, nzdata)\n    }\n    block_results <- blockApply(x, FUN, grid=grid)\n    nzcoo_list <- lapply(block_results, `[[`, 1L)\n    nzdata_list <- lapply(block_results, `[[`, 2L)\n    nzcoo <- do.call(rbind, nzcoo_list)\n    nzdata <- unlist(nzdata_list, recursive=FALSE)\n    SparseArray:::new_COO_SparseArray(dim(x), dimnames(x), nzcoo, nzdata,\n                                      check=FALSE)\n}\n\nsetAs(\"DelayedArray\", \"COO_SparseArray\",\n    function(from) .BLOCK_from_DelayedArray_to_COO_SparseArray(from)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### [<- (a.k.a. subassignment)\n###\n### Supported forms:\n###\n### - Multi-dimensional form (e.g. x[3:1, , 6] <- 0) is supported.\n###\n### - Linear form (i.e. x[i] <- value) is supported only when the\n###   subscript 'i' is a logical DelayedArray object of the same\n###   dimensions as 'x' and 'value' an ordinary vector of length 1.\n###   So for example x[x <= 0.05] <- 0 is supported but x[5:2] <- 0\n###   is not at the moment.\n###\n### - Filling (i.e. x[] <- value) is supported only when 'value' is an\n###   ordinary vector with a length that is a divisor of 'nrow(x)'.\n###\n### All these forms of subassignment are delayed.\n###\n\n\n.linear_subassign_error_msg <- c(\n    \"linear subassignment to a DelayedArray object 'x' (i.e. 'x[i] <- value') \",\n    \"is only supported when the subscript 'i' is a logical DelayedArray \",\n    \"object of the same dimensions as 'x' and 'value' an ordinary vector \",\n    \"of length 1)\"\n)\n\n.filling_error_msg <- c(\n    \"filling a DelayedArray object 'x' with a vector 'v' (i.e. 'x[] <- v') \",\n    \"is only supported if 'v' is an ordinary vector of length a divisor \",\n    \"of 'nrow(x)'\"\n)\n\n.fill_DelayedArray_with_vector <- function(x, v)\n{\n    stopifnot(is.vector(v))\n    x_len <- length(x)\n    v_len <- length(v)\n    if (v_len > x_len)\n        stop(wmsg(\"right value is longer than left value\"))\n    x_nrow <- nrow(x)\n    if (x_nrow != 0L) {\n        if (v_len == 0L || x_nrow %% v_len != 0L)\n            stop(wmsg(.filling_error_msg))\n        v <- rep(v, length.out=x_nrow)\n    }\n    stash_DelayedUnaryIsoOpWithArgs(x, `[<-`,\n                                    Rargs=list(value=v), Ralong=1L)\n}\n\n.subassign_DelayedArray <- function(x, i, j, ..., value)\n{\n    if (missing(x))\n        stop(\"'x' is missing\")\n    Nindex <- S4Arrays:::extract_Nindex_from_syscall(sys.call(), parent.frame())\n    nsubscript <- length(Nindex)\n    x_dim <- dim(x)\n    x_ndim <- length(x_dim)\n    if (nsubscript == 1L && x_ndim != 1L) {\n        ## Linear form.\n        i <- Nindex[[1L]]\n        if (!(is(i, \"DelayedArray\") &&\n              identical(x_dim, dim(i)) &&\n              type(i) == \"logical\"))\n            stop(wmsg(.linear_subassign_error_msg))\n        if (!(is.vector(value) && length(value) == 1L))\n            stop(wmsg(.linear_subassign_error_msg))\n        ans <- DelayedArray(new_DelayedNaryIsoOp(`[<-`, x@seed, i@seed,\n                                                 Rargs=list(value=value)))\n        return(ans)\n    }\n    ## Multi-dimensional form.\n    if (nsubscript == 0L) {\n        Nindex <- vector(\"list\", length=x_ndim)\n        fill_mode <- TRUE\n    } else {\n        if (nsubscript != x_ndim)\n            stop(\"incorrect number of subscripts\")\n        fill_mode <- all(S4Vectors:::sapply_isNULL(Nindex))\n    }\n    if (fill_mode && is.vector(value) && length(value) != 1L)\n        return(.fill_DelayedArray_with_vector(x, value))\n    stash_DelayedSubassign(x, Nindex, value)\n}\n\nsetReplaceMethod(\"[\", \"DelayedArray\", .subassign_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### [[\n###\n### TODO: Implement a \"getArrayElement\" method for Array objects (in\n### extract_array.R) that is based on extract_array() e.g it just needs\n### to do something like:\n###\n###     as.vector(extract_array(x, as.list(subscripts)))\n###\n### This will make multi-dimensional and linear [[ work on DelayedArray\n### objects. Then remove the method below and update DelayedArray-class.Rd\n###\n\n### Only support linear subsetting at the moment.\n### TODO: Support multi-dimensional subsetting e.g. x[[5, 15, 2]] or\n### x[[\"E\", 15, \"b\"]].\nsetMethod(\"[[\", \"DelayedArray\",\n    function(x, i, j, ...)\n    {\n        dots <- list(...)\n        if (length(dots) > 0L)\n            dots <- dots[names(dots) != \"exact\"]\n        if (!missing(j) || length(dots) > 0L)\n            stop(\"incorrect number of subscripts\")\n        if (!is.numeric(i))\n            stop(\"invalid [[ subscript type: \", class(i)[[1L]])\n        if (length(i) < 1L)\n            stop(\"attempt to extract less than one element\")\n        if (length(i) > 1L)\n            stop(\"attempt to extract more than one element\")\n        if (is.na(i))\n            stop(\"NA is not a valid [[ subscript\")\n        Mindex <- Lindex2Mindex(i, dim(x))\n        .extract_array_element(x, Mindex)[[1L]]\n    }\n)\n\n",
        "DelayedArray-utils.R": "### =========================================================================\n### Common operations on DelayedArray objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Binding\n###\n### We only support binding DelayedArray objects along the rows or the cols\n### at the moment. No binding along an arbitrary dimension yet! (i.e. no\n### \"abind\" method yet)\n###\n\n.DelayedArray_arbind <- function(...)\n{\n    objects <- list(...)\n    stash_DelayedAbind(objects[[1L]], objects[-1L], along=1L)\n}\n\n.DelayedArray_acbind <- function(...)\n{\n    objects <- list(...)\n    stash_DelayedAbind(objects[[1L]], objects[-1L], along=2L)\n}\n\nsetMethod(\"arbind\", \"DelayedArray\", .DelayedArray_arbind)\nsetMethod(\"acbind\", \"DelayedArray\", .DelayedArray_acbind)\n\n### Argument 'deparse.level' is ignored.\nsetMethod(\"rbind\", \"DelayedArray\", .DelayedArray_arbind)\nsetMethod(\"cbind\", \"DelayedArray\", .DelayedArray_acbind)\n\n### Arguments 'use.names', 'ignore.mcols', and 'check' are ignored.\nsetMethod(\"bindROWS\", \"DelayedArray\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n        stash_DelayedAbind(x, objects, along=1L)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"Ops\" group generics\n###\n### Arith members: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Compare members: ==, !=, <=, >=, <, >\n### Logic members: &, |\n###\n\n### Return TRUE if 'length(e)' is 1 or equal to 'nrow(x)', FALSE if it's a\n### divisor of 'nrow(x)', and an error otherwise.\n.check_Ops_vector_arg_length <- function(e, x_nrow,\n    e_what=\"the left operand\",\n    x_what=\"the first dimension of the right operand\",\n    x_what2=x_what)\n{\n    e_len <- length(e)\n    if (e_len == x_nrow || e_len == 1L)\n        return(TRUE)\n    if (is(e, \"DelayedArray\")) {\n        e_what <- paste0(\"the length of \", e_what)\n    } else {\n        e_what <- paste0(\"when \", e_what, \" is not a DelayedArray \",\n                         \"object (or derivative), its length\")\n    }\n    if (e_len > x_nrow)\n        stop(wmsg(e_what, \" (\", e_len, \") cannot be greater \",\n                        \"than \", x_what, \" (\", x_nrow, \")\"))\n    if (e_len == 0L || x_nrow %% e_len != 0L)\n        stop(wmsg(e_what, \" (\", e_len, \") must be a divisor \",\n                          \"of \", x_what2, \" (\", x_nrow, \")\"))\n    FALSE\n}\n\n.normarg_Ops_vector_arg <- function(e, x_nrow,\n    e_what=\"the left operand\",\n    x_what=\"the first dimension of the right operand\")\n{\n    ok <- .check_Ops_vector_arg_length(e, x_nrow, e_what=e_what, x_what=x_what)\n    if (!is.vector(e))\n        e <- as.vector(e)  # Will realize 'e' if it's a DelayedArray object.\n                           # It's important to keep the check on the length\n                           # (and to fail) **before** this potentially\n                           # expensive realization (e.g. if 'length(e)' is\n                           # very big and greater than 'x_nrow').\n    if (!ok)\n        e <- rep(e, length.out=x_nrow)\n    e\n}\n\n### Return a DelayedArray object of the same dimensions as 'e1'.\n.DelayedArray_Ops_with_right_vector <- function(.Generic, e1, e2)\n{\n    stopifnot(is(e1, \"DelayedArray\"))\n    e2 <- .normarg_Ops_vector_arg(e2, nrow(e1),\n                   e_what=\"the right operand\",\n                   x_what=\"the first dimension of the left operand\")\n    if (length(e2) == 1L) {\n        stash_DelayedUnaryIsoOpStack(e1,\n            function(a) match.fun(.Generic)(a, e2))\n    } else {\n        stash_DelayedUnaryIsoOpWithArgs(e1,\n            .Generic, Rargs=list(e2), Ralong=1L)\n    }\n}\n\n### Return a DelayedArray object of the same dimensions as 'e2'.\n.DelayedArray_Ops_with_left_vector <- function(.Generic, e1, e2)\n{\n    stopifnot(is(e2, \"DelayedArray\"))\n    e1 <- .normarg_Ops_vector_arg(e1, nrow(e2),\n                   e_what=\"the left operand\",\n                   x_what=\"the first dimension of the right operand\")\n    if (length(e1) == 1L) {\n        stash_DelayedUnaryIsoOpStack(e2,\n            function(a) match.fun(.Generic)(e1, a))\n    } else {\n        stash_DelayedUnaryIsoOpWithArgs(e2,\n            .Generic, Largs=list(e1), Lalong=1L)\n    }\n}\n\n### 'e1' and 'e2' must be DelayedArray objects. At least one of them must\n### be of length 1 (i.e. have all its dimensions equal to 1) so it can be\n### coerced to an ordinary vector of length 1 with as.vector(). Note that\n### this coercion triggers realization.\n.DelayedArray_Ops_with_a_length_one_arg <- function(.Generic, e1, e2)\n{\n    stopifnot(is(e1, \"DelayedArray\"))\n    stopifnot(is(e2, \"DelayedArray\"))\n    e1_len <- length(e1)\n    e2_len <- length(e2)\n    if (e1_len == 1L && e2_len == 1L) {\n        ## The object with most dimensions \"wins\".\n        e1_ndim <- length(dim(e1))\n        e2_ndim <- length(dim(e2))\n        if (e1_ndim > e2_ndim) {\n            ## 'e1' wins.\n            e2 <- as.vector(e2)  # realization\n        } else if (e2_ndim > e1_ndim) {\n            ## 'e2' wins.\n            e1 <- as.vector(e1)  # realization\n        } else {\n            ## 'dim(e1)' is identical to 'dim(e2)' ==> nobody wins.\n        }\n    } else if (e1_len == 1L) {\n        ## 'e2' wins.\n        e1 <- as.vector(e1)  # realization\n    } else if (e2_len == 1L) {\n        ## 'e1' wins.\n        e2 <- as.vector(e2)  # realization\n    } else {\n        ## Should never happen.\n        stop(wmsg(\"'e1' or 'e2' must be of length 1\"))\n    }\n    if (is.vector(e1)) {\n        ## 'e2' won.\n        stash_DelayedUnaryIsoOpStack(e2,\n            function(a) match.fun(.Generic)(e1, a))\n    } else if (is.vector(e2)) {\n        ## 'e1' won.\n        stash_DelayedUnaryIsoOpStack(e1,\n            function(a) match.fun(.Generic)(a, e2))\n    } else {\n        ## Nobody won and we know that this happened because 'dim(e1)'\n        ## is identical to 'dim(e2)' so 'e1' and 'e2' are conformable.\n        DelayedArray(new_DelayedNaryIsoOp(.Generic, e1@seed, e2@seed))\n    }\n}\n\n.DelayedArray_Ops <- function(.Generic, e1, e2)\n{\n    e1_dim <- dim(e1)\n    e2_dim <- dim(e2)\n    if (identical(e1_dim, e2_dim))\n        return(DelayedArray(new_DelayedNaryIsoOp(.Generic, e1@seed, e2@seed)))\n    ## If it has only 0 or 1 effective dimensions, 'e1' or 'e2' can\n    ## be treated as a vector-like argument (of length 1 if it has 0\n    ## effective dimensions).\n    e1_neffdim <- sum(e1_dim != 1L)\n    e2_neffdim <- sum(e2_dim != 1L)\n    if (e1_neffdim >= 2L && e2_neffdim >= 2L)\n        stop(wmsg(\"non-conformable array-like objects\"))\n    if (e1_neffdim == 0L || e2_neffdim == 0L)\n        return(.DelayedArray_Ops_with_a_length_one_arg(.Generic, e1, e2))\n    if (e1_neffdim == 1L && e2_neffdim == 1L)\n        stop(wmsg(\"non-conformable array-like objects\"))\n    ## The object with most effective dimensions \"wins\".\n    if (e1_neffdim == 1L) {\n        ## 'e2' wins\n        ans <- .DelayedArray_Ops_with_left_vector(.Generic, e1, e2)\n    } else {\n        ## 'e1' wins\n        ans <- .DelayedArray_Ops_with_right_vector(.Generic, e1, e2)\n    }\n    ans\n}\n\nsetMethod(\"Ops\", c(\"DelayedArray\", \"vector\"),\n    function(e1, e2)\n        .DelayedArray_Ops_with_right_vector(.Generic, e1, e2)\n)\nsetMethod(\"Ops\", c(\"DelayedArray\", \"array\"),\n    function(e1, e2)\n        stop(wmsg(\"'\", .Generic, \"' between a DelayedArray object and \",\n                  \"an array is not supported yet\"))\n)\n\nsetMethod(\"Ops\", c(\"vector\", \"DelayedArray\"),\n    function(e1, e2)\n        .DelayedArray_Ops_with_left_vector(.Generic, e1, e2)\n)\nsetMethod(\"Ops\", c(\"array\", \"DelayedArray\"),\n    function(e1, e2)\n        stop(wmsg(\"'\", .Generic, \"' between an array and \",\n                  \"a DelayedArray object is not supported yet\"))\n)\n\nsetMethod(\"Ops\", c(\"DelayedArray\", \"DelayedArray\"),\n    function(e1, e2)\n        .DelayedArray_Ops(.Generic, e1, e2)\n)\n\n### Support unary operators \"+\" and \"-\".\nsetMethod(\"+\", c(\"DelayedArray\", \"missing\"),\n    function(e1, e2)\n        stash_DelayedUnaryIsoOpStack(e1, function(a) match.fun(.Generic)(a))\n)\nsetMethod(\"-\", c(\"DelayedArray\", \"missing\"),\n    function(e1, e2)\n        stash_DelayedUnaryIsoOpStack(e1, function(a) match.fun(.Generic)(a))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### pmax2() and pmin2()\n###\n### TODO: Maybe move the pmax2() and pmin2() generics and their default\n### methods to the BiocGenerics package, like we did for paste2().\n###\n\nsetGeneric(\"pmax2\", function(e1, e2) standardGeneric(\"pmax2\"))\nsetGeneric(\"pmin2\", function(e1, e2) standardGeneric(\"pmin2\"))\n\n### Mimicking how the \"Ops\" members combine the \"dim\", \"names\", and \"dimnames\"\n### attributes of the 2 operands.\n.check_and_combine_dims <- function(e1, e2)\n{\n    dim1 <- dim(e1)\n    dim2 <- dim(e2)\n    if (is.null(dim1))\n        return(dim2)\n    if (is.null(dim2))\n        return(dim1)\n    if (!identical(dim1, dim2))\n        stop(\"non-conformable arrays\")\n    dim1\n}\n\n.combine_names <- function(e1, e2)\n{\n    len1 <- length(e1)\n    len2 <- length(e2)\n    names1 <- names(e1)\n    if (len1 > len2)\n        return(names1)\n    names2 <- names(e2)\n    if (len2 > len1 || is.null(names1))\n        return(names2)\n    names1\n}\n\nsetMethod(\"pmax2\", c(\"ANY\", \"ANY\"),\n    function(e1, e2)\n    {\n        ans_dim <- .check_and_combine_dims(e1, e2)\n        ans <- pmax(e1, e2)\n        if (is.null(ans_dim)) {\n            names(ans) <- .combine_names(e1, e2)\n        } else {\n            ans <- S4Arrays:::set_dim(ans, ans_dim)\n            ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(e1, e2))\n            ans <- S4Arrays:::set_dimnames(ans, ans_dimnames)\n        }\n        ans\n    }\n)\n\nsetMethod(\"pmin2\", c(\"ANY\", \"ANY\"),\n    function(e1, e2)\n    {\n        ans_dim <- .check_and_combine_dims(e1, e2)\n        ans <- pmin(e1, e2)\n        if (is.null(ans_dim)) {\n            names(ans) <- .combine_names(e1, e2)\n        } else {\n            ans <- S4Arrays:::set_dim(ans, ans_dim)\n            ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(e1, e2))\n            ans <- S4Arrays:::set_dimnames(ans, ans_dimnames)\n        }\n        ans\n    }\n)\n\n### We define the delayed pmax2() and pmin2() methods like the delayed \"Ops\"\n### methods.\nfor (.Generic in c(\"pmax2\", \"pmin2\")) {\n    setMethod(.Generic, c(\"DelayedArray\", \"vector\"),\n        function(e1, e2)\n            .DelayedArray_Ops_with_right_vector(.Generic, e1, e2)\n    )\n    setMethod(.Generic, c(\"DelayedArray\", \"array\"),\n        function(e1, e2)\n            stop(wmsg(.Generic, \"() between a DelayedArray object and \",\n                  \"an array is not supported yet\"))\n    )\n    setMethod(.Generic, c(\"vector\", \"DelayedArray\"),\n        function(e1, e2)\n            .DelayedArray_Ops_with_left_vector(.Generic, e1, e2)\n    )\n    setMethod(.Generic, c(\"array\", \"DelayedArray\"),\n        function(e1, e2)\n            stop(wmsg(.Generic, \"() between an array and \",\n                      \"a DelayedArray object is not supported yet\"))\n    )\n    setMethod(.Generic, c(\"DelayedArray\", \"DelayedArray\"),\n        function(e1, e2)\n            .DelayedArray_Ops(.Generic, e1, e2)\n    )\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Various \"unary isometric\" array transformations\n###\n### A \"unary isometric\" array transformation is a transformation that returns\n### an array-like object with the same dimensions as the input and where each\n### element is the result of applying a function to the corresponding element\n### in the input.\n###\n### These transformations can be implemented as delayed operations.\n###\n### All the \"unary isometric\" array transformations implemented in this\n### section return a DelayedArray object of the same dimensions as the\n### input DelayedArray object.\n###\n\n.UNARY_ISO_OPS <- c(\"is.na\", \"is.finite\", \"is.infinite\", \"is.nan\", \"!\",\n                    \"tolower\", \"toupper\")\n\nfor (.Generic in .UNARY_ISO_OPS) {\n    setMethod(.Generic, \"DelayedArray\",\n        function(x)\n            stash_DelayedUnaryIsoOpStack(x, function(a) match.fun(.Generic)(a))\n    )\n}\n\nsetReplaceMethod(\"type\", \"DelayedArray\",\n    function(x, value)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) `storage.mode<-`(a, value=value))\n)\n\nsetMethod(\"lengths\", \"DelayedArray\",\n    function(x, use.names=TRUE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) lengths(a, use.names=use.names))\n)\n\nsetMethod(\"nchar\", \"DelayedArray\",\n    function(x, type=\"chars\", allowNA=FALSE, keepNA=NA)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) nchar(a, type=type, allowNA=allowNA, keepNA=keepNA))\n)\n\nsetMethod(\"Math\", \"DelayedArray\",\n    function(x)\n        stash_DelayedUnaryIsoOpStack(x, function(a) match.fun(.Generic)(a))\n)\n\nsetMethod(\"log\", \"DelayedArray\",\n    function(x, base=exp(1))\n    {\n        if (!isSingleNumberOrNA(base))\n            stop(wmsg(\"'base' must be a single numeric\"))\n        stash_DelayedUnaryIsoOpStack(x, function(a) log(a, base=base))\n    }\n)\n\n.DelayedArray_Math2 <- function(.Generic, x, digits)\n{\n    stopifnot(is(x, \"DelayedArray\"))\n    if (!isSingleNumberOrNA(digits))\n        stop(wmsg(\"'digits' must be a single numeric\"))\n    if (!is.integer(digits))\n        digits <- as.integer(digits)\n    stash_DelayedUnaryIsoOpStack(x,\n        function(a) match.fun(.Generic)(a, digits=digits))\n}\n\n### Note that round() and signif() don't use the same default for 'digits'.\nsetMethod(\"round\", \"DelayedArray\",\n    function(x, digits=0) .DelayedArray_Math2(\"round\", x, digits)\n)\nsetMethod(\"signif\", \"DelayedArray\",\n    function(x, digits=6) .DelayedArray_Math2(\"signif\", x, digits)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### More \"unary isometric\" array transformations: grepl(), sub(), gsub()\n###\n\nsetMethod(\"grepl\", c(x=\"DelayedArray\"),\n    function(pattern, x,\n             ignore.case=FALSE, perl=FALSE, fixed=FALSE, useBytes=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) grepl(pattern, a,\n                              ignore.case=ignore.case, perl=perl,\n                              fixed=fixed, useBytes=useBytes))\n)\n\nsetMethod(\"sub\", c(x=\"DelayedArray\"),\n    function(pattern, replacement, x,\n             ignore.case=FALSE, perl=FALSE, fixed=FALSE, useBytes=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) sub(pattern, replacement, a,\n                            ignore.case=ignore.case, perl=perl,\n                            fixed=fixed, useBytes=useBytes))\n)\n\nsetMethod(\"gsub\", c(x=\"DelayedArray\"),\n    function(pattern, replacement, x,\n             ignore.case=FALSE, perl=FALSE, fixed=FALSE, useBytes=FALSE)\n        stash_DelayedUnaryIsoOpStack(x,\n            function(a) gsub(pattern, replacement, a,\n                             ignore.case=ignore.case, perl=perl,\n                             fixed=fixed, useBytes=useBytes))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### anyNA()\n###\n\n### Used in unit tests!\n.BLOCK_anyNA <- function(x, recursive=FALSE, grid=NULL, as.sparse=NA)\n{\n    FUN <- function(block, init) {\n        ## 'block' is either an ordinary array or SVT_SparseArray object.\n        anyNA(block) || init\n    }\n    init <- FALSE\n    BREAKIF <- identity\n    blockReduce(FUN, x, init, BREAKIF=BREAKIF, grid=grid, as.sparse=as.sparse)\n}\n\n.anyNA_DelayedArray <- function(x, recursive=FALSE) .BLOCK_anyNA(x, recursive)\nsetMethod(\"anyNA\", \"DelayedArray\", .anyNA_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### which() and nzwhich() methods\n###\n\n.which_DelayedArray <- function(x, arr.ind=FALSE, useNames=TRUE)\n{\n    if (!identical(useNames, TRUE))\n        warning(wmsg(\"'useNames' is ignored when 'x' is \",\n                     \"a DelayedArray object or derivative\"))\n    BLOCK_which(x, arr.ind=arr.ind)\n}\nsetMethod(\"which\", \"DelayedArray\", .which_DelayedArray)\n\nsetMethod(\"nzwhich\", \"DelayedArray\",\n    function(x, arr.ind=FALSE) BLOCK_nzwhich(x, arr.ind=arr.ind)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### unique() and table()\n###\n\n### We only support 1D arrays.\n### Semantically equivalent to 'unique(as.array(x), ...)' which, in the 1D\n### case, is also equivalent to 'unique(as.vector(x), ...)'.\n### Unlike unique.array(), does not support the 'MARGIN' or 'fromLast' args.\n### Return an **ordinary** 1D array.\n.BLOCK_unique <- function(x, incomparables=FALSE, grid=NULL)\n{\n    if (length(dim(x)) != 1L)\n        stop(wmsg(\"the \\\"unique\\\" method for DelayedArray objects \",\n                  \"supports 1D objects only\"))\n\n    block_results <- blockApply(x, unique, incomparables=incomparables,\n                                grid=grid)\n\n    ## Combine the block results.\n    unique(unlist(block_results))\n}\n\n### S3/S4 combo for unique.DelayedArray\nunique.DelayedArray <- function(x, incomparables=FALSE, ...)\n    .BLOCK_unique(x, incomparables=incomparables, ...)\nsetMethod(\"unique\", \"DelayedArray\", .BLOCK_unique)\n\n### table()\n\n.BLOCK_table <- function(..., grid=NULL)\n{\n    objects <- list(...)\n    if (length(objects) != 1L)\n        stop(wmsg(\"the \\\"table\\\" method for DelayedArray objects \",\n                  \"only works on a single object at the moment\"))\n    x <- objects[[1L]]\n\n    block_tables <- blockApply(x, table, grid=grid)\n\n    ## Combine the block tables.\n    levels <- unlist(lapply(block_tables, names))\n    storage.mode(levels) <- type(x)\n    ans_names <- as.character(unique(sort(levels)))\n    block_tabs <- lapply(block_tables,\n        function(block_table) {\n            block_tabs <- integer(length(ans_names))\n            block_tabs[match(names(block_table), ans_names)] <- block_table\n            block_tabs\n        })\n    tab <- as.integer(rowSums(matrix(unlist(block_tabs),\n                                     nrow=length(ans_names),\n                                     ncol=length(block_tabs))))\n\n    ## 'tab' is a naked integer vector. We need to decorate it (see\n    ## selectMethod(\"table\", \"Rle\")).\n    ans_dimnames <- list(ans_names)\n    names(ans_dimnames) <- S4Vectors:::.list.names(...)\n    ans <- array(tab, length(tab), dimnames=ans_dimnames)\n    class(ans) <- \"table\"\n    ans\n}\n\n### The table() S4 generic is defined in BiocGenerics with dispatch on the\n### ellipsis (...). Unfortunately specifying 'grid' when calling table()\n### breaks dispatch. For example:\n###   a <- array(sample(100L, 20000L, replace=TRUE), c(20, 4, 250))\n###   A <- DelayedArray(a)\n###   table(A)  # ok\n###   table(A, grid=defaultAutoGrid(A, 500))\n###   # Error in .BLOCK_unique(x, incomparables = incomparables, ...) :\n###   #   unused argument (nmax = nmax)\n### A workaround is to call .BLOCK_table():\n###   DelayedArray:::.BLOCK_table(A, grid=defaultAutoGrid(A, 500))  # ok\n.table_DelayedArray <- function(...) .BLOCK_table(...)\nsetMethod(\"table\", \"DelayedArray\", .table_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"Summary\" group generic\n###\n### Members: max(), min(), range(), sum(), prod(), any(), all()\n###\n### Gotcha with how base::prod() handles NAs/NaNs:\n###   > prod(c(NA, NaN))  # consistent with sum()\n###   [1] NA\n###   > prod(c(NaN, NA))  # consistent with sum()\n###   [1] NA\n### but:\n###   > prod(NA, NaN)     # consistent with sum()\n###   [1] NA\n###   > prod(NaN, NA)     # INCONSISTENT with sum()!\n###   [1] NaN\n\n.collect_objects <- function(...)\n{\n    objects <- unname(S4Vectors:::delete_NULLs(list(...)))\n    is_array_like <- function(x) is(x, \"Array\") || is.array(x)\n    if (!all(vapply(objects, is_array_like, logical(1))))\n        stop(\"the supplied objects must be array-like objects (or NULLs)\")\n    objects\n}\n\n### Used in unit tests!\n### An IMPORTANT RESTRICTION is that the specified grid must be compatible\n### with all the objects in '...', which means that the objects in '...'\n### must be conformable!\n.BLOCK_Summary <- function(.Generic, x, ..., na.rm=FALSE,\n                           grid=NULL, as.sparse=NA)\n{\n    GENERIC <- match.fun(.Generic)\n    objects <- .collect_objects(x, ...)\n\n    FUN <- function(block, init) {\n        ## We get a warning with max(), min(), and range() if 'block'\n        ## is empty (which should happen only when 'x' itself is empty,\n        ## in which case blockReduce() uses a single block that has the\n        ## dimensions of 'x'), or if 'na.rm' is TRUE and 'block' contains\n        ## only NA's or NaN's. How we handle this warning depends on\n        ## whether 'init' is NULL (i.e. we've seen no data yet) or not:\n        ##   - if 'init' is NULL: we use tryCatch() to catch the warning\n        ##   - otherwise: we just suppress (and ignore) the warning\n        if (is.null(init)) {\n            ## 'block' is either an ordinary array or SVT_SparseArray object.\n            reduced_block <- tryCatch(GENERIC(block, na.rm=na.rm),\n                                      warning=identity)\n            if (is(reduced_block, \"warning\"))\n                return(NULL)\n        } else {\n            ## 'block' is either an ordinary array or SVT_SparseArray object.\n            reduced_block <- suppressWarnings(GENERIC(block, na.rm=na.rm))\n        }\n        GENERIC(reduced_block, init)\n    }\n    init <- NULL\n    BREAKIF <- function(init) {\n        if (is.null(init))\n            return(FALSE)\n        if (na.rm) {\n            switch(.Generic,\n                max=             init ==  Inf,\n                min=             init == -Inf,\n                range=           all(init == c(-Inf, Inf)),\n                sum=, prod=      is.nan(init),\n                any=             init,\n                all=             !init,\n                FALSE)  # fallback (actually not needed)\n        } else {\n            switch(.Generic,\n                max=, min=, sum= is.na(init) && !is.nan(init),\n                range=           is.na(init[[1L]]) && !is.nan(init[[1L]]),\n                prod=            is.na(init),  # NA or NaN\n                any=             identical(init, TRUE),  # 'init' could be NA\n                all=             identical(init, FALSE), # 'init' could be NA\n                FALSE)  # fallback (actually not needed)\n        }\n    }\n\n    for (x in objects)\n        init <- blockReduce(FUN, x, init, BREAKIF=BREAKIF,\n                            grid=grid, as.sparse=as.sparse)\n    if (is.null(init))\n        init <- GENERIC()\n    init\n}\n\n.Summary_DelayedArray <- function(x, ..., na.rm=FALSE)\n    .BLOCK_Summary(.Generic, x, ..., na.rm=na.rm)\nsetMethod(\"Summary\", \"DelayedArray\", .Summary_DelayedArray)\n\n### We override the \"range\" method defined above via the \"Summary\" method\n### because we want to support the 'finite' argument like S3 method\n### base::range.default() does.\n### An IMPORTANT RESTRICTION is that the specified grid must be compatible\n### with all the objects in '...', which means that the objects in '...'\n### must be conformable!\n.BLOCK_range <- function(..., na.rm=FALSE, finite=FALSE,\n                              grid=NULL, as.sparse=NA)\n{\n    objects <- .collect_objects(...)\n\n    FUN <- function(block, init) {\n        ## We get a warning if 'block' is empty (which should happen only\n        ## when 'x' itself is empty, in which case blockReduce() uses a\n        ## single block that has the dimensions of 'x'), or if 'na.rm'\n        ## is TRUE and 'block' contains only NA's or NaN's.\n        ## We handle this warning like in .BLOCK_Summary() above.\n        if (is.null(init)) {\n            ## 'block' is either an ordinary array or SVT_SparseArray object.\n            reduced_block <- tryCatch(range(block, na.rm=na.rm, finite=finite),\n                                      warning=identity)\n            if (is(reduced_block, \"warning\"))\n                return(NULL)\n        } else {\n            ## 'block' is either an ordinary array or SVT_SparseArray object.\n            reduced_block <- suppressWarnings(range(block, na.rm=na.rm,\n                                                           finite=finite))\n        }\n        range(reduced_block, init)\n    }\n    init <- NULL\n    BREAKIF <- function(init) {\n        if (is.null(init))\n            return(FALSE)\n        if (na.rm) {\n            all(init == c(-Inf, Inf))\n        } else {\n            is.na(init[[1L]]) && !is.nan(init[[1L]])\n        }\n    }\n\n    for (object in objects)\n        init <- blockReduce(FUN, object, init, BREAKIF=BREAKIF,\n                            grid=grid, as.sparse=as.sparse)\n    if (is.null(init))\n        init <- range()\n    init\n}\n\n### S3/S4 combo for range.DelayedArray\nrange.DelayedArray <- function(..., na.rm=FALSE, finite=FALSE)\n    .BLOCK_range(..., na.rm=na.rm, finite=finite)\n### The signature of all the members of the S4 \"Summary\" group generic is\n### 'x, ..., na.rm' (see getGeneric(\"range\")) which means that the S4 methods\n### cannot add arguments after 'na.rm'. So we add the 'finite' argument before.\nsetMethod(\"range\", \"DelayedArray\",\n    function(x, ..., finite=FALSE, na.rm=FALSE)\n        .BLOCK_range(x, ..., na.rm=na.rm, finite=finite)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### mean()\n###\n### Gotcha with how base::mean() handles NAs/NaNs:\n###   > mean(c(NA, NaN))  # consistent with sum()\n###   [1] NA\n###   > mean(c(NaN, NA))  # INCONSISTENT with sum()!\n###   [1] NaN\n\n### Same arguments as base::mean.default().\n.BLOCK_mean <- function(x, trim=0, na.rm=FALSE, grid=NULL, as.sparse=NA)\n{\n    if (!identical(trim, 0))\n        stop(wmsg(\"mean() method for DelayedArray objects \",\n                  \"does not support the 'trim' argument yet\"))\n\n    FUN <- function(block, init) {\n        ## 'block' is either an ordinary array or SVT_SparseArray object.\n        block_sum <- sum(block, na.rm=na.rm)\n        block_nval <- length(block)\n        if (na.rm)\n            block_nval <- block_nval - sum(is.na(block))\n        c(block_sum, block_nval) + init\n    }\n    init <- numeric(2)  # sum and nval\n    BREAKIF <- function(init) is.na(init[[1L]])  # NA or NaN\n\n    ans <- blockReduce(FUN, x, init, BREAKIF=BREAKIF,\n                       grid=grid, as.sparse=as.sparse)\n    ans[[1L]] / ans[[2L]]\n}\n\n### S3/S4 combo for mean.DelayedArray\nmean.DelayedArray <- function(x, trim=0, na.rm=FALSE, ...)\n    .BLOCK_mean(x, trim=trim, na.rm=na.rm, ...)\nsetMethod(\"mean\", \"DelayedArray\", .BLOCK_mean)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### apply()\n###\n\nsetGeneric(\"apply\", signature=\"X\")\n\n.simplify_apply_answer <- function(ans)\n{\n    if (!all(vapply(ans, is.atomic, logical(1), USE.NAMES=FALSE)))\n        return(ans)  # won't simplify\n\n    ans_lens <- lengths(ans, use.names=FALSE)\n    mat_nrow <- ans_lens[[1L]]\n    if (!all(ans_lens == mat_nrow))\n        return(ans)  # won't simplify\n\n    mat_data <- unlist(unname(ans))\n    if (mat_nrow == 0L)\n        return(mat_data)  # zero-length atomic vector\n\n    mat_colnames <- names(ans)\n    if (mat_nrow == 1L)\n        return(setNames(mat_data, mat_colnames))  # atomic vector parallel\n                                                  # to 'ans'\n\n    ## Simplify as matrix.\n    mat_data_names <- names(mat_data)  # comes from the 'ans' inner names\n    if (is.null(mat_data_names)) {\n        mat_rownames <- NULL\n    } else {\n        mat_rownames <- head(mat_data_names, n=mat_nrow)\n        if (!all(mat_data_names == mat_rownames))\n            mat_rownames <- NULL\n    }\n    if (is.null(mat_rownames) && is.null(mat_colnames)) {\n        mat_dimnames <- NULL\n    } else {\n        mat_dimnames <- list(mat_rownames, mat_colnames)\n    }\n    matrix(mat_data, ncol=length(ans), dimnames=mat_dimnames)\n}\n\n### MARGIN must be a single integer.\n.apply_DelayedArray <- function(X, MARGIN, FUN, ...)\n{\n    FUN <- match.fun(FUN)\n    X_dim <- dim(X)\n    if (!isSingleNumber(MARGIN))\n        stop(\"'MARGIN' must be a single integer\")\n    if (!is.integer(MARGIN))\n        MARGIN <- as.integer(MARGIN)\n    if (MARGIN < 1L || MARGIN > length(X_dim))\n        stop(\"'MARGIN' must be >= 1 and <= length(dim(X))\")\n\n    if (X_dim[[MARGIN]] == 0L) {\n        ## base::apply seems to be doing something like that!\n        ans <- FUN(X, ...)\n        return(as.vector(ans[0L]))\n    }\n\n    ## TODO: Try using sapply() instead of lapply(). Maybe we're lucky\n    ## and it achieves the kind of simplification that we're doing with\n    ## .simplify_apply_answer() so we can get rid of .simplify_apply_answer().\n    ans_names <-  dimnames(X)[[MARGIN]]\n    ans <- lapply(setNames(seq_len(X_dim[[MARGIN]]), ans_names),\n        function(i) {\n            Nindex <- vector(\"list\", length=length(X_dim))\n            Nindex[[MARGIN]] <- i\n            slice <- S4Arrays:::subset_by_Nindex(X, Nindex, drop=FALSE)\n            slice <- S4Arrays:::set_dim(slice, dim(slice)[-MARGIN])\n            FUN(slice, ...)\n        })\n\n    ## Try to simplify the answer.\n    .simplify_apply_answer(ans)\n}\n\nsetMethod(\"apply\", \"DelayedArray\", .apply_DelayedArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### sweep()\n###\n\nsetGeneric(\"sweep\", signature=\"x\")\n\n### Only supports a MARGIN of length 1 for now.\n### Ignores 'check.margin'.\n### Works if 'FUN' is a member of the Ops group or, more generally, if 'FUN'\n### works on a DelayedArray object and preserves its dimensions (e.g. pmax2()\n### or pmin2() above).\nsetMethod(\"sweep\", \"DelayedArray\",\n    function(x, MARGIN, STATS, FUN=\"-\", check.margin=TRUE, ...)\n    {\n        FUN <- match.fun(FUN)\n        if (!identical(check.margin, TRUE))\n            warning(wmsg(\"'check.margin' is ignored when 'x' is \",\n                         \"a DelayedArray object or derivative\"))\n        x_dim <- dim(x)\n        x_ndim <- length(x_dim)\n        if (!isSingleNumber(MARGIN))\n            stop(wmsg(\"the \\\"sweep\\\" method for DelayedArray objects \",\n                      \"only supports a MARGIN of length 1 at the moment\"))\n        if (!is.integer(MARGIN))\n            MARGIN <- as.integer(MARGIN)\n        if (MARGIN < 1 || MARGIN > x_ndim)\n            stop(\"invalid 'MARGIN'\")\n\n        ## Check 'STATS' length.\n        ## If 'FUN' is a member of the Ops group, it will check the length\n        ## of 'STATS' and possibly reject it but it will display an obscure\n        ## error message (see .normarg_Ops_vector_arg() in this file). By\n        ## checking the length early, we can display a more appropriate\n        ## error message.\n        .check_Ops_vector_arg_length(STATS, x_dim[[MARGIN]],\n                                     e_what=\"'STATS'\",\n                                     x_what=\"the extent of 'dim(x)[MARGIN]'\",\n                                     x_what2=\"'dim(x)[MARGIN]'\")\n\n        perm <- c(MARGIN, seq_len(x_ndim)[-MARGIN])\n        x2 <- aperm(x, perm)\n        ans2 <- FUN(x2, STATS, ...)\n        aperm(ans2, order(perm))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### scale()\n###\n\nsetGeneric(\"scale\", signature=\"x\")\n\n### S3/S4 combo for scale.DelayedMatrix\nscale.DelayedMatrix <- function(x, center=TRUE, scale=TRUE)\n{\n    tx <- t(x)\n    if (!isFALSE(center)) {\n        if (isTRUE(center)) {\n            center <- colMeans(x, na.rm=TRUE)\n        } else if (!is.numeric(center)) {\n            stop(wmsg(\"'center' must be TRUE or FALSE or a numeric vector\"))\n        }\n        tx <- tx - center\n    }\n    if (!isFALSE(scale)) {\n        if (isTRUE(scale)) {\n            scale <- rowSds(tx, center=0, na.rm=TRUE)\n            ## Work around a bug in some DelayedMatrixStats methods (e.g.\n            ## row/colVars() and row/colSds()) where the method is not\n            ## propagating the row/colnames of the supplied DelayedMatrix\n            ## object in some situations e.g. when the object carries a\n            ## delayed transposition.\n            if (is.null(names(scale)))\n                names(scale) <- rownames(tx)\n        } else if (!is.numeric(scale)) {\n            stop(wmsg(\"'center' must be TRUE or FALSE or a numeric vector\"))\n        }\n        tx <- tx / scale\n    }\n    ans <- t(tx)\n    if (is.numeric(center))\n        attr(ans, \"scaled:center\") <- center\n    if (is.numeric(scale))\n        attr(ans, \"scaled:scale\") <- scale\n    ans\n}\nsetMethod(\"scale\", \"DelayedMatrix\", scale.DelayedMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### paste2()\n###\n\n### We define the delayed paste2() methods like the delayed \"Ops\" methods.\nsetMethod(\"paste2\", c(\"DelayedArray\", \"vector\"),\n    function(x, y)\n        .DelayedArray_Ops_with_right_vector(\"paste2\", x, y)\n)\nsetMethod(\"paste2\", c(\"DelayedArray\", \"array\"),\n    function(x, y)\n        stop(wmsg(\"paste2() between a DelayedArray object and \",\n                  \"an array is not supported yet\"))\n)\nsetMethod(\"paste2\", c(\"vector\", \"DelayedArray\"),\n    function(x, y)\n        .DelayedArray_Ops_with_left_vector(\"paste2\", x, y)\n)\nsetMethod(\"paste2\", c(\"array\", \"DelayedArray\"),\n    function(x, y)\n        stop(wmsg(\"paste2() between an array and \",\n                  \"a DelayedArray object is not supported yet\"))\n)\nsetMethod(\"paste2\", c(\"DelayedArray\", \"DelayedArray\"),\n    function(x, y)\n        .DelayedArray_Ops(\"paste2\", x, y)\n)\n\n",
        "DelayedMatrix-mult.R": "### =========================================================================\n### DelayedMatrix %*%, crossprod(), and tcrossprod()\n### -------------------------------------------------------------------------\n###\n### The %*%, crossprod(), and tcrossprod() methods for DelayedMatrix objects\n### are block processed.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helpers for BLOCK_mult_Lgrid() and BLOCK_mult_Rgrid()\n###\n\n.make_shared_sink_and_grid_for_Lgrid_apply <-\n    function(x, y, transpose.x, transpose.y, Lgrid, BPPARAM, BACKEND, ...)\n{\n    if (transpose.x) {\n        input_grid <- t(Lgrid)\n        sink_rownames <- colnames(x)\n    } else {\n        input_grid <- Lgrid\n        sink_rownames <- rownames(x)\n    }\n    if (transpose.y) {\n        sink_ncol <- nrow(y)\n        sink_colnames <- rownames(y)\n    } else {\n        sink_ncol <- ncol(y)\n        sink_colnames <- colnames(y)\n    }\n    make_shared_sink_and_grid_along_hstrips(BPPARAM,\n                         input_grid, sink_ncol,\n                         BACKEND, sink_rownames, sink_colnames, ...)\n}\n\n.make_shared_sink_and_grid_for_Rgrid_apply <-\n    function(x, y, transpose.x, transpose.y, Rgrid, BPPARAM, BACKEND, ...)\n{\n    if (transpose.y) {\n        input_grid <- t(Rgrid)\n        sink_colnames <- rownames(y)\n    } else {\n        input_grid <- Rgrid\n        sink_colnames <- colnames(y)\n    }\n    if (transpose.x) {\n        sink_nrow <- ncol(x)\n        sink_rownames <- colnames(x)\n    } else {\n        sink_nrow <- nrow(x)\n        sink_rownames <- rownames(x)\n    }\n    make_shared_sink_and_grid_along_vstrips(BPPARAM,\n                         input_grid, sink_nrow,\n                         BACKEND, sink_rownames, sink_colnames, ...)\n}\n\n### x, y: \"big\" and \"small\" operands, respectively (see BLOCK_mult_Lgrid()\n### below for the details).\n### INIT, BLOCK_OP: callback functions.\n### INIT() must take 3 arguments: i (or j), grid, y.\n### BLOCK_OP() must take 3 arguments: x_block, y, vp_ranges.\n### See BLOCK_mult_Lgrid() below for the other arguments.\n### Walks on the \"left grid\" which is defined on matrix-like object 'x'.\n.Lgrid_apply <- function(x, y, transpose.x, transpose.y,\n                               Lgrid, as.sparse, BPPARAM, verbose,\n                               INIT, BLOCK_OP, BACKEND, ..., dry.run)\n{\n    verbose <- normarg_verbose(verbose)\n\n    if (transpose.x) {\n        Lgrid <- best_grid_for_vstrip_apply(x, Lgrid)\n        ans_nrow <- ncol(x)\n    } else {\n        Lgrid <- best_grid_for_hstrip_apply(x, Lgrid)\n        ans_nrow <- nrow(x)\n    }\n    ans_ncol <- if (transpose.y) nrow(y) else ncol(y)\n    ans_dim <- c(ans_nrow, ans_ncol)\n\n    ## --- define FINAL() ---\n\n    if (is.null(BACKEND)) {\n        if (dry.run)\n            return(list(class=\"matrix\", dim=ans_dim, type=\"double\"))\n        if (verbose) {\n            FINAL <- if (transpose.x) final_vstrip_noop else final_hstrip_noop\n        } else {\n            FINAL <- NULL\n        }\n        FINAL_MoreArgs <- list()\n    } else {\n        ## The \"shared sink\" route consists in using a single realization sink\n        ## shared across all strips. Can we take this route?\n        ## .make_shared_sink_and_grid_for_Lgrid_apply() will figure it out and\n        ## return a RealizationSink + its associated grid in a named list if\n        ## it turns out that we can take the \"shared sink\" route, or NULL if\n        ## we can't.\n        sink_and_grid <- .make_shared_sink_and_grid_for_Lgrid_apply(x, y,\n                                               transpose.x, transpose.y,\n                                               Lgrid, BPPARAM, BACKEND, ...)\n        if (is.null(sink_and_grid)) {\n            if (dry.run) {\n                nseed <- if (transpose.x) ncol(Lgrid) else nrow(Lgrid)\n                return(list(class=\"DelayedMatrix\", dim=ans_dim, type=\"double\",\n                            nseed=nseed))\n            }\n            FINAL <- function(init, i, grid, BACKEND, verbose) {\n                realize_matrix(init, BACKEND, verbose)\n            }\n            FINAL_MoreArgs <- list(BACKEND=BACKEND, verbose=verbose)\n        } else {\n            ## \"shared sink\" route.\n            if (dry.run)\n                return(list(class=BACKEND, dim=ans_dim, type=\"double\",\n                            nseed=1L))\n            FINAL <- function(init, i, grid, sink, sink_grid, verbose) {\n                write_full_sink_rows(sink, sink_grid, i, init, verbose)\n            }\n            FINAL_MoreArgs <- c(sink_and_grid, list(verbose=verbose))\n        }\n    }\n\n    ## --- define FUN() ---\n\n    FUN <- function(init, block, y, BLOCK_OP) {\n        ## 'block' is either an ordinary matrix or SVT_SparseMatrix object.\n        vp <- currentViewport()\n        block_ans <- BLOCK_OP(block, y, ranges(vp))\n        if (!is.matrix(block_ans))\n            block_ans <- as.matrix(block_ans)\n        init + block_ans\n    }\n    FUN_MoreArgs <- list(y=y, BLOCK_OP=BLOCK_OP)\n\n    ## --- block processing ---\n\n    STRIP_APPLY <- if (transpose.x) vstrip_apply else hstrip_apply\n    INIT_MoreArgs <- list(y=y)\n    strip_results <- STRIP_APPLY(x, INIT, INIT_MoreArgs,\n                                    FUN, FUN_MoreArgs,\n                                    FINAL, FINAL_MoreArgs,\n                                    grid=Lgrid, as.sparse=as.sparse,\n                                    BPPARAM=BPPARAM, verbose=verbose)\n\n    ## --- turn output of block processing into object and return it ---\n\n    if (is.null(BACKEND) || is.null(sink_and_grid)) {\n        combine_strip_results(\"rbind\", strip_results, verbose)\n    } else {\n        ## \"shared sink\" route.\n        shared_sink_as_DelayedArray(sink_and_grid$sink, verbose)\n    }\n}\n\n### x, y: \"small\" and \"big\" operands, respectively (see BLOCK_mult_Rgrid()\n### below for the details).\n### INIT, BLOCK_OP: callback functions.\n### INIT() must take 3 arguments: j (or i), grid, x.\n### BLOCK_OP() must take 3 arguments: x, y_block, vp_ranges.\n### See BLOCK_mult_Rgrid() below for the other arguments.\n### Walks on the \"right grid\" which is defined on matrix-like object 'y'.\n.Rgrid_apply <- function(x, y, transpose.x, transpose.y,\n                               Rgrid, as.sparse, BPPARAM, verbose,\n                               INIT, BLOCK_OP, BACKEND, ..., dry.run)\n{\n    verbose <- normarg_verbose(verbose)\n\n    if (transpose.y) {\n        Rgrid <- best_grid_for_hstrip_apply(y, Rgrid)\n        ans_ncol <- nrow(y)\n    } else {\n        Rgrid <- best_grid_for_vstrip_apply(y, Rgrid)\n        ans_ncol <- ncol(y)\n    }\n    ans_nrow <- if (transpose.x) ncol(x) else nrow(x)\n    ans_dim <- c(ans_nrow, ans_ncol)\n\n    ## --- define FINAL() ---\n\n    if (is.null(BACKEND)) {\n        if (dry.run)\n            return(list(class=\"matrix\", dim=ans_dim, type=\"double\"))\n        if (verbose) {\n            FINAL <- if (transpose.y) final_hstrip_noop else final_vstrip_noop\n        } else {\n            FINAL <- NULL\n        }\n        FINAL_MoreArgs <- list()\n    } else {\n        ## The \"shared sink\" route consists in using a single realization sink\n        ## shared across all strips. Can we take this route?\n        ## .make_shared_sink_and_grid_for_Rgrid_apply() will figure it out and\n        ## return a RealizationSink + its associated grid in a named list if\n        ## it turns out that we can take the \"shared sink\" route, or NULL if\n        ## we can't.\n        sink_and_grid <- .make_shared_sink_and_grid_for_Rgrid_apply(x, y,\n                                               transpose.x, transpose.y,\n                                               Rgrid, BPPARAM, BACKEND, ...)\n        if (is.null(sink_and_grid)) {\n            if (dry.run) {\n                nseed <- if (transpose.y) nrow(Rgrid) else ncol(Rgrid)\n                return(list(class=\"DelayedMatrix\", dim=ans_dim, type=\"double\",\n                            nseed=nseed))\n            }\n            FINAL <- function(init, j, grid, BACKEND, verbose) {\n                realize_matrix(init, BACKEND=BACKEND, verbose)\n            }\n            FINAL_MoreArgs <- list(BACKEND=BACKEND, verbose=verbose)\n        } else {\n            ## \"shared sink\" route.\n            if (dry.run)\n                return(list(class=BACKEND, dim=ans_dim, type=\"double\",\n                            nseed=1L))\n            FINAL <- function(init, j, grid, sink, sink_grid, verbose) {\n                write_full_sink_cols(sink, sink_grid, j, init, verbose)\n            }\n            FINAL_MoreArgs <- c(sink_and_grid, list(verbose=verbose))\n        }\n    }\n\n    ## --- define FUN() ---\n\n    FUN <- function(init, block, x, BLOCK_OP) {\n        ## 'block' is either an ordinary matrix or SVT_SparseMatrix object.\n        vp <- currentViewport()\n        block_ans <- BLOCK_OP(x, block, ranges(vp))\n        if (!is.matrix(block_ans))\n            block_ans <- as.matrix(block_ans)\n        init + block_ans\n    }\n    FUN_MoreArgs <- list(x=x, BLOCK_OP=BLOCK_OP)\n\n    ## --- block processing ---\n\n    STRIP_APPLY <- if (transpose.y) hstrip_apply else vstrip_apply\n    INIT_MoreArgs <- list(x=x)\n    strip_results <- STRIP_APPLY(y, INIT, INIT_MoreArgs,\n                                    FUN, FUN_MoreArgs,\n                                    FINAL, FINAL_MoreArgs,\n                                    grid=Rgrid, as.sparse=as.sparse,\n                                    BPPARAM=BPPARAM, verbose=verbose)\n\n    ## --- turn output of block processing into object and return it ---\n\n    if (is.null(BACKEND) || is.null(sink_and_grid)) {\n        combine_strip_results(\"cbind\", strip_results, verbose)\n    } else {\n        ## \"shared sink\" route.\n        shared_sink_as_DelayedArray(sink_and_grid$sink, verbose)\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### BLOCK_mult_Lgrid() and BLOCK_mult_Rgrid()\n###\n### These are the 2 workhorses behind block matrix multiplication between\n### a \"big\" and a \"small\" matrix-like object. See BLOCK_mult_Lgrid() and\n### BLOCK_mult_Rgrid() below for the details.\n###\n### Should be able to handle any type() supported by base::`%*%`, that is,\n### integer, double, and complex. However, the realization backend specified\n### via `BACKEND` might introduce some restrictions e.g. will it support\n### realization of a matrix of type complex?\n###\n\n### We need to make sure to return a matrix-like object that supports [ as\n### well as native %*%, crossprod(), and tcrossprod() with the blocks returned\n### by read_block() (which are either ordinary matrices or SparseMatrix\n### derivatives).\n### See the BLOCK_OP() callback functions defined and used in\n### BLOCK_mult_Lgrid() and BLOCK_mult_Rgrid() below for what operations will\n### effectively be performed on the \"small operand\".\n.normalize_small_operand <- function(x, argname)\n{\n    if (is(x, \"COO_SparseMatrix\"))\n        return(as(x, \"SVT_SparseMatrix\"))\n    if (is.matrix(x) || is(x, \"sparseMatrix\") || is(x, \"SparseMatrix\"))\n        return(x)\n    stop(wmsg(\"this operation does not support '\", argname, \"' \",\n              \"of class \", class(x)[[1L]]))\n}\n\n### x: A matrix-like object (typically a DelayedMatrix) on which a grid will\n### be defined and from which blocks will get extracted. This will typically\n### be the biggest of the two operands of the binary matrix operation.\n### y: Typically an ordinary matrix or SVT_SparseMatrix object but other\n### matrix-like objects are supported (see .normalize_small_operand() above).\n### This will typically be the smallest of the two operands of the binary\n### matrix operation.\n### Lgrid: An array grid (ArrayGrid object) defined on 'x'.\n### Walks on the matrix blocks defined by 'Lgrid'.\n### If 'BACKEND' is NULL, returns an ordinary matrix. Otherwise, returns\n### a DelayedMatrix object that is either pristine or the result of rbind'ing\n### several pristine DelayedMatrix objects together (delayed rbind()).\n### Calling nseed() on the returned object will return 1 in the pristine case\n### or the number of objects bound together in the non-pristine case. In the\n### pristine case, arguments specified thru the ellipsis will be passed to the\n### RealizationSink constructor associated with 'BACKEND'. Note that the first\n### 3 arguments of **any** RealizationSink constructor are guaranteed to\n### be 'dim', 'dimnames', and 'type', and the arguments specified thru the\n### ellipsis here can not be any of these. 'as.sparse' is not allowed either.\nBLOCK_mult_Lgrid <- function(x, y, Lgrid=NULL, as.sparse=NA,\n                                   BPPARAM=getAutoBPPARAM(), verbose=NA,\n                                   op=c(\"mult\", \"crossprod\", \"tcrossprod\"),\n                                   BACKEND=getAutoRealizationBackend(), ...,\n                                   dry.run=FALSE)\n{\n    stopifnot(length(dim(x)) == 2L)\n    y <- .normalize_small_operand(y, argname=\"y\")\n    op <- match.arg(op)\n    transpose.x <- transpose.y <- FALSE\n\n    ## All INIT() callback functions must return a matrix of type \"double\"\n    ## rather than \"integer\". This is to avoid integer overflows during the\n    ## within-strip walks.\n    switch(op,\n        mult={\n            stopifnot(ncol(x) == nrow(y))\n            INIT <- function(i, grid, y) {\n                matrix(0.0, nrow=nrow(grid[[i, 1L]]), ncol=ncol(y))\n            }\n            BLOCK_OP <- function(x_block, y, vp_ranges) {\n                idx <- (start(vp_ranges)[[2L]]):(end(vp_ranges)[[2L]])\n                base::`%*%`(x_block, y[idx, , drop=FALSE])\n            }\n        },\n        crossprod={\n            transpose.x <- TRUE\n            stopifnot(nrow(x) == nrow(y))\n            INIT <- function(j, grid, y) {\n                matrix(0.0, nrow=ncol(grid[[1L, j]]), ncol=ncol(y))\n            }\n            BLOCK_OP <- function(x_block, y, vp_ranges) {\n                idx <- (start(vp_ranges)[[1L]]):(end(vp_ranges)[[1L]])\n                base::crossprod(x_block, y[idx, , drop=FALSE])\n            }\n        },\n        tcrossprod={\n            transpose.y <- TRUE\n            stopifnot(ncol(x) == ncol(y))\n            INIT <- function(i, grid, y) {\n                matrix(0.0, nrow=nrow(grid[[i, 1L]]), ncol=nrow(y))\n            }\n            BLOCK_OP <- function(x_block, y, vp_ranges) {\n                idx <- (start(vp_ranges)[[2L]]):(end(vp_ranges)[[2L]])\n                base::tcrossprod(x_block, y[ , idx, drop=FALSE])\n            }\n        },\n        stop(wmsg(\"invalid 'op'\"))  # should never happen\n    )\n\n    .Lgrid_apply(x, y, transpose.x, transpose.y,\n                       Lgrid, as.sparse, BPPARAM, verbose,\n                       INIT, BLOCK_OP, BACKEND, ..., dry.run=dry.run)\n}\n\n### x: Typically an ordinary matrix or SVT_SparseMatrix object but other\n### matrix-like objects are supported (see .normalize_small_operand() above).\n### This will typically be the smallest of the two operands of the binary\n### matrix operation.\n### y: A matrix-like object (typically a DelayedMatrix) on which a grid will\n### be defined and from which blocks will get extracted. This will typically\n### be the biggest of the two operands of the binary matrix operation.\n### Rgrid: An array grid (ArrayGrid object) defined on 'y'.\n### Walks on the matrix blocks defined by 'Rgrid'.\n### If 'BACKEND' is NULL, returns an ordinary matrix. Otherwise, returns\n### a DelayedMatrix object that is either pristine or the result of cbind'ing\n### several pristine DelayedMatrix objects together (delayed cbind()).\n### See BLOCK_mult_Lgrid() above for what arguments can be specified thru the\n### ellipsis.\nBLOCK_mult_Rgrid <- function(x, y, Rgrid=NULL, as.sparse=NA,\n                                   BPPARAM=getAutoBPPARAM(), verbose=NA,\n                                   op=c(\"mult\", \"crossprod\", \"tcrossprod\"),\n                                   BACKEND=getAutoRealizationBackend(), ...,\n                                   dry.run=FALSE)\n{\n    stopifnot(length(dim(y)) == 2L)\n    x <- .normalize_small_operand(x, argname=\"x\")\n    op <- match.arg(op)\n    transpose.x <- transpose.y <- FALSE\n\n    ## All INIT() callback functions must return a matrix of type \"double\"\n    ## rather than \"integer\". This is to avoid integer overflows during the\n    ## within-strip walks.\n    switch(op,\n        mult={\n            stopifnot(ncol(x) == nrow(y))\n            INIT <- function(j, grid, x) {\n                matrix(0.0, nrow=nrow(x), ncol=ncol(grid[[1L, j]]))\n            }\n            BLOCK_OP <- function(x, y_block, vp_ranges) {\n                idx <- (start(vp_ranges)[[1L]]):(end(vp_ranges)[[1L]])\n                base::`%*%`(x[ , idx, drop=FALSE], y_block)\n            }\n        },\n        crossprod={\n            transpose.x <- TRUE\n            stopifnot(nrow(x) == nrow(y))\n            INIT <- function(j, grid, x) {\n                matrix(0.0, nrow=ncol(x), ncol=ncol(grid[[1L, j]]))\n            }\n            BLOCK_OP <- function(x, y_block, vp_ranges) {\n                idx <- (start(vp_ranges)[[1L]]):(end(vp_ranges)[[1L]])\n                base::crossprod(x[idx, , drop=FALSE], y_block)\n            }\n        },\n        tcrossprod={\n            transpose.y <- TRUE\n            stopifnot(ncol(x) == ncol(y))\n            INIT <- function(i, grid, x) {\n                matrix(0.0, nrow=nrow(x), ncol=nrow(grid[[i, 1L]]))\n            }\n            BLOCK_OP <- function(x, y_block, vp_ranges) {\n                idx <- (start(vp_ranges)[[2L]]):(end(vp_ranges)[[2L]])\n                base::tcrossprod(x[ , idx, drop=FALSE], y_block)\n            }\n        },\n        stop(wmsg(\"invalid 'op'\"))  # should never happen\n    )\n\n    .Rgrid_apply(x, y, transpose.x, transpose.y,\n                       Rgrid, as.sparse, BPPARAM, verbose,\n                       INIT, BLOCK_OP, BACKEND, ..., dry.run=dry.run)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### %*%, crossprod(), and tcrossprod() methods between:\n###   - a DelayedMatrix object,\n###   - an ordinary matrix or vector (or other supported matrix-like\n###     object, see .normalize_small_operand() above)\n###\n\nsetMethod(\"%*%\", c(\"DelayedMatrix\", \"ANY\"),\n    function(x, y)\n    {\n        if (is.atomic(y) && is.vector(y)) {\n            ## Returns a 1-col ordinary matrix (like base::`%*%` does).\n            y <- cbind(y, deparse.level=0)\n            BLOCK_mult_Lgrid(x, y, BACKEND=NULL)\n        } else {\n            BLOCK_mult_Lgrid(x, y)\n        }\n    }\n)\nsetMethod(\"%*%\", c(\"ANY\", \"DelayedMatrix\"),\n    function(x, y)\n    {\n        if (is.atomic(x) && is.vector(x)) {\n            ## Returns a 1-row ordinary matrix (like base::`%*%` does).\n            x <- rbind(x, deparse.level=0)\n            BLOCK_mult_Rgrid(x, y, BACKEND=NULL)\n        } else {\n            BLOCK_mult_Rgrid(x, y)\n        }\n    }\n)\n\nsetMethod(\"crossprod\", c(\"DelayedMatrix\", \"ANY\"),\n    function(x, y)\n    {\n        if (is.atomic(y) && is.vector(y)) {\n            ## Returns a 1-col ordinary matrix (like base::crossprod() does).\n            y <- cbind(y, deparse.level=0)\n            BLOCK_mult_Lgrid(x, y, BACKEND=NULL, op=\"crossprod\")\n        } else {\n            BLOCK_mult_Lgrid(x, y, op=\"crossprod\")\n        }\n    }\n)\nsetMethod(\"crossprod\", c(\"ANY\", \"DelayedMatrix\"),\n    function(x, y)\n    {\n        if (is.atomic(x) && is.vector(x)) {\n            ## Returns a 1-row ordinary matrix (like base::crossprod() does).\n            x <- cbind(x, deparse.level=0)\n            BLOCK_mult_Rgrid(x, y, BACKEND=NULL, op=\"crossprod\")\n        } else {\n            BLOCK_mult_Rgrid(x, y, op=\"crossprod\")\n        }\n    }\n)\n\nsetMethod(\"tcrossprod\", c(\"DelayedMatrix\", \"ANY\"),\n    function(x, y)\n    {\n        if (is.atomic(y) && is.vector(y)) {\n            ## Note that base::tcrossprod() does not work with a vector on\n            ## the right!\n            ## Returns a 1-col ordinary matrix (like base::tcrossprod() would\n            ## probably do if it were supporting a vector on the right).\n            y <- rbind(y, deparse.level=0)\n            BLOCK_mult_Lgrid(x, y, BACKEND=NULL, op=\"tcrossprod\")\n        } else {\n            BLOCK_mult_Lgrid(x, y, op=\"tcrossprod\")\n        }\n    }\n)\nsetMethod(\"tcrossprod\", c(\"ANY\", \"DelayedMatrix\"),\n    function(x, y)\n    {\n        if (is.atomic(x) && is.vector(x)) {\n            ## Returns a 1-row ordinary matrix (like base::tcrossprod() does).\n            x <- rbind(x, deparse.level=0)\n            BLOCK_mult_Rgrid(x, y, BACKEND=NULL, op=\"tcrossprod\")\n        } else {\n            BLOCK_mult_Rgrid(x, y, op=\"tcrossprod\")\n        }\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Parallelized schemes for matrix multiplication.\n###\n### by Aaron Lun\n###\n### This splits one or both matrices into blocks according to the\n### desired parallelization scheme, and distributes them to workers.\n### This also requires care to respect the maximum block size.\n###\n\n.grid_by_dimension <- function(x, nworkers)\n# Splits a dimension of the matrix into at least 'nworkers' blocks.\n# If the block size is too large, it is reduced to obtain the desired\n# number of blocks in order for parallelization to be effective.\n{\n    old <- getAutoBlockLength(type(x))\n\n    ideal_size_by_row <- max(1, ceiling(nrow(x)/nworkers) * ncol(x))\n    if (old > ideal_size_by_row) {\n        row_grid <- rowAutoGrid(x, block.length=ideal_size_by_row)\n    } else {\n        row_grid <- rowAutoGrid(x)\n    }\n\n    ideal_size_by_col <- max(1, ceiling(ncol(x)/nworkers) * nrow(x))\n    if (old > ideal_size_by_col) {\n        col_grid <- colAutoGrid(x, block.length=ideal_size_by_col)\n    } else {\n        col_grid <- colAutoGrid(x)\n    }\n\n    list(row=row_grid, col=col_grid)\n}\n\n.left_mult <- function(bid, grid, x, y, MULT) {\n    # this, and all other calls, had better yield a non-DA, otherwise MULT will recurse endlessly.\n    block <- read_block(x, grid[[bid]])\n    MULT(block, y)\n}\n\n.right_mult <- function(bid, grid, x, y, MULT) {\n    block <- read_block(y, grid[[bid]])\n    MULT(x, block)\n}\n\n.super_BLOCK_mult <- function(x, y, MULT, transposed.x=FALSE, transposed.y=FALSE, BPPARAM=getAutoBPPARAM())\n# Controller function that split jobs for a multiplication function \"MULT\".\n# This accommodates %*%, crossprod and tcrossprod for two arguments.\n{\n    if (is.null(BPPARAM)) {\n        nworkers <- 1L\n    } else {\n        nworkers <- BiocParallel::bpnworkers(BPPARAM)\n    }\n\n    # Choosing the right dimension to iterate over, depending on MULT.\n    x_grid <- .grid_by_dimension(x, nworkers)\n    if (transposed.x) {\n        x_grid <- x_grid$col\n    } else {\n        x_grid <- x_grid$row\n    }\n\n    y_grid <- .grid_by_dimension(y, nworkers)\n    if (transposed.y) {\n        y_grid <- y_grid$row\n    } else {\n        y_grid <- y_grid$col\n    }\n\n    # Always iterating over the 'larger' matrix, to better split up the work.\n    # In the context of file-backed matrices, this operates under the heuristic\n    # that the larger matrix is the file-backed one.\n    if (length(x) > length(y)) {\n        chosen_scheme <- \"x\"\n    } else {\n        chosen_scheme <- \"y\"\n    }\n\n    # Switch to iteration over the other argument if the chosen one is\n    # single-block and non-DA (at which point you might as well iterate\n    # over the other argument anyway). This avoids infinite recursion\n    # when 'x' or 'y' fail to get realized via read_block().\n    if (chosen_scheme==\"x\" && length(x_grid)==1L && !is(x, \"DelayedMatrix\")) {\n        chosen_scheme <- \"y\"\n    } else if (chosen_scheme==\"y\" && length(y_grid)==1L && !is(y, \"DelayedMatrix\")) {\n        chosen_scheme <- \"x\"\n    }\n\n    old <- getAutoBPPARAM()\n    on.exit(setAutoBPPARAM(old))\n    setAutoBPPARAM(NULL) # Avoid re-parallelizing in further calls to 'MULT'.\n\n    if (chosen_scheme==\"x\") {\n        out <- S4Arrays:::bplapply2(seq_len(length(x_grid)),\n                         FUN=.left_mult,\n                         x=x, y=y, grid=x_grid,\n                         MULT=MULT,\n                         BPPARAM=BPPARAM)\n        ans <- do.call(rbind, out)\n    } else if (chosen_scheme==\"y\") {\n        out <- S4Arrays:::bplapply2(seq_len(length(y_grid)),\n                         FUN=.right_mult,\n                         x=x, y=y, grid=y_grid,\n                         MULT=MULT,\n                         BPPARAM=BPPARAM)\n        ans <- do.call(cbind, out)\n    }\n\n    realize(ans)\n}\n\nsetMethod(\"%*%\", c(\"DelayedMatrix\", \"DelayedMatrix\"), function(x, y) .super_BLOCK_mult(x, y, MULT=`%*%`))\n\nsetMethod(\"crossprod\", c(\"DelayedMatrix\", \"DelayedMatrix\"), function(x, y)\n    .super_BLOCK_mult(x, y, MULT=crossprod, transposed.x=TRUE)\n)\n\nsetMethod(\"tcrossprod\", c(\"DelayedMatrix\", \"DelayedMatrix\"), function(x, y)\n    .super_BLOCK_mult(x, y, MULT=tcrossprod, transposed.y=TRUE)\n)\n\n.solo_mult <- function(bid, grid, x, MULT) {\n    block <- read_block(x, grid[[bid]])\n    MULT(block)\n}\n\n.super_BLOCK_self <- function(x, MULT, transposed=FALSE, BPPARAM=getAutoBPPARAM())\n# Controller function that split jobs for a multiplication function \"MULT\".\n# This accommodates crossprod and tcrossprod for single arguments.\n{\n    if (is.null(BPPARAM)) {\n        nworkers <- 1L\n    } else {\n        nworkers <- BiocParallel::bpnworkers(BPPARAM)\n    }\n\n    # Choosing the right dimension to iterate over, depending on MULT.\n    grid <- .grid_by_dimension(x, nworkers)\n    if (transposed) {\n        fast <- grid$col\n        slow <- grid$row\n    } else {\n        fast <- grid$row\n        slow <- grid$col\n    }\n\n    old <- getAutoBPPARAM()\n    on.exit(setAutoBPPARAM(old))\n    setAutoBPPARAM(NULL) # Avoid re-parallelizing in further calls to 'MULT'.\n\n    if (getAutoMultParallelAgnostic()) {\n        out <- S4Arrays:::bplapply2(seq_len(length(slow)),\n                         FUN=.left_mult,\n                         x=x, y=x, grid=slow,\n                         MULT=MULT,\n                         BPPARAM=BPPARAM)\n        ans <- do.call(rbind, out)\n\n    } else {\n        ans <- S4Arrays:::bplapply2(seq_len(length(fast)),\n                         FUN=.solo_mult,\n                         x=x, grid=fast,\n                         MULT=MULT,\n                         BPPARAM=BPPARAM)\n        ans <- Reduce(\"+\", ans)\n    }\n\n    DelayedArray(realize(ans))\n}\n\nsetMethod(\"crossprod\", c(\"DelayedMatrix\", \"missing\"), function(x, y)\n    .super_BLOCK_self(x, MULT=crossprod)\n)\n\nsetMethod(\"tcrossprod\", c(\"DelayedMatrix\", \"missing\"), function(x, y)\n    .super_BLOCK_self(x, MULT=tcrossprod, transposed=TRUE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### User-visible global settings for parallelized matrix multiplication.\n###\n### by Aaron Lun\n###\n### This allows the user to specify whether or not they want to guarantee\n### the identical matrix products regardless of the number of workers.\n### This is because splitting by the common dimension does not preserve the\n### order of addition operations, which changes the output due to numerical\n### imprecision in the inner products of each vector.\n###\n\nsetAutoMultParallelAgnostic <- function(agnostic=TRUE) {\n    S4Arrays:::set_user_option(\"auto.mult.parallel.agnostic\", agnostic)\n}\n\ngetAutoMultParallelAgnostic <- function() {\n    S4Arrays:::get_user_option(\"auto.mult.parallel.agnostic\")\n}\n\n",
        "DelayedMatrix-rowsum.R": "### =========================================================================\n### rowsum() and colsum() methods for DelayedMatrix objects\n### -------------------------------------------------------------------------\n###\n### These methods are block processed.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Simple helpers to support verbose operations\n###\n\n.summarize_matrix <- function(x)\n{\n    ans <- paste0(\"<\", paste0(dim(x), collapse=\" x \"), \"> \", class(x)[[1L]])\n    if (is.object(x))\n        ans <- paste0(ans, \" object\")\n    ans\n}\n\nfinal_hstrip_noop <- function(init, i, grid) {\n    what <- .summarize_matrix(init)\n    #message(\"  \", wmsg(\"| result for horizontal strip \",\n    #                   i, \"/\", nrow(grid), \": \", what))\n    message(\"  \", wmsg(\"| result is a \", what, \" --> returning as-is\"))\n    init\n}\n\nfinal_vstrip_noop <- function(init, j, grid) {\n    what <- .summarize_matrix(init)\n    #message(\"  \", wmsg(\"| result for vertical strip \",\n    #                   j, \"/\", ncol(grid), \": \", what))\n    message(\"  \", wmsg(\"| result is a \", what, \" --> returning as-is\"))\n    init\n}\n\nrealize_matrix <- function(x, BACKEND, verbose)\n{\n    if (verbose) {\n        what <- .summarize_matrix(x)\n        message(\"  \", wmsg(\"| realizing \", what, \" as \",\n                           BACKEND, \" object ...\"),\n                \" \", appendLF=FALSE)\n    }\n    ans <- realize(x, BACKEND=BACKEND)\n    if (verbose)\n        message(\"ok\")\n    ans\n}\n\nwrite_full_sink_rows <- function(sink, sink_grid, i, block, verbose)\n{\n    if (verbose) {\n        what <- .summarize_matrix(block)\n        message(\"  \", wmsg(\"| writing \", what, \" to \",\n                           class(sink), \" object ...\"),\n                \" \", appendLF=FALSE)\n    }\n    sink <- write_block(sink, sink_grid[[i, 1L]], block)\n    if (verbose)\n        message(\"ok\")\n    sink\n}\n\nwrite_full_sink_cols <- function(sink, sink_grid, j, block, verbose)\n{\n    if (verbose) {\n        what <- .summarize_matrix(block)\n        message(\"  \", wmsg(\"| writing \", what, \" to \",\n                           class(sink), \" object ...\"),\n                \" \", appendLF=FALSE)\n    }\n    sink <- write_block(sink, sink_grid[[1L, j]], block)\n    if (verbose)\n        message(\"ok\")\n    sink\n}\n\n### 'strip_results' is guaranteed to be a list of length >= 1.\ncombine_strip_results <- function(fname, strip_results, verbose)\n{\n    res1 <- strip_results[[1L]]\n    if (length(strip_results) == 1L)\n        return(res1)\n    if (verbose) {\n        message(wmsg(\"=== FINAL STEP ===\"))\n        if (is.matrix(res1)) {\n            what <- \"matrices\"\n        } else {\n            what <- paste0(class(res1)[[1L]], \" objects\")\n        }\n        message(\"  \", wmsg(\"| \", fname, \"()'ing strip results \",\n                           \"(\", length(strip_results), \" \", what, \") \",\n                           \"together ...\"),\n                \" \", appendLF=FALSE)\n    }\n    FUN <- match.fun(fname)\n    ans <- do.call(FUN, strip_results)\n    if (verbose) {\n        message(\"ok\")\n        message(\"=== DONE ===\\n\")\n    }\n    ans\n}\n\nshared_sink_as_DelayedArray <- function(sink, verbose)\n{\n    if (verbose) {\n        message(wmsg(\"=== FINAL STEP ===\"))\n        message(\"  \", wmsg(\"| turning \", class(sink), \" object \",\n                           \"into DelayedArray object ...\"),\n                \" \", appendLF=FALSE)\n    }\n    close(sink)\n    ans <- as(sink, \"DelayedArray\")\n    if (verbose) {\n        message(\"ok\")\n        message(\"=== DONE ===\\n\")\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helpers for BLOCK_rowsum() and BLOCK_colsum()\n###\n\n### 'input_grid' must be a 2D grid.\n### Returns a 2D grid 'sink_grid' that verifies:\n###   (a) refdim(sink_grid)[[1]] == refdim(input_grid)[[1]];\n###   (b) refdim(sink_grid)[[2]] == sink_ncol;\n###   (c) the blocks on 'sink_grid' are made of full rows and they align\n###       with the horizontal strips on 'input_grid'.\n### The consequences of (c) are that ncol(sink_grid) == 1 and\n### nrow(sink_grid) == length(sink_grid) == nrow(input_grid).\n.make_sink_grid_of_hstrips <- function(input_grid, sink_ncol)\n{\n    stopifnot(is(input_grid, \"ArrayGrid\"),\n              length(dim(input_grid)) == 2L,\n              isSingleInteger(sink_ncol))\n    if (is(input_grid, \"ArbitraryArrayGrid\")) {\n        tickmarks <- list(input_grid@tickmarks[[1L]], sink_ncol)\n        ArbitraryArrayGrid(tickmarks)\n    } else {\n        refdim <- c(refdim(input_grid)[[1L]], sink_ncol)\n        spacings <- c(nrow(input_grid[[1L]]), sink_ncol)\n        RegularArrayGrid(refdim, spacings=spacings)\n    }\n}\n\n### 'input_grid' must be a 2D grid.\n### Returns a 2D grid 'sink_grid' that verifies:\n###   (a) refdim(sink_grid)[[1]] == sink_nrow;\n###   (b) refdim(sink_grid)[[2]] == refdim(input_grid)[[2]];\n###   (c) the blocks on 'sink_grid' are made of full columns and they align\n###       with the vertical strips on 'input_grid'.\n### The consequences of (c) are that nrow(sink_grid) == 1 and\n### ncol(sink_grid) == length(sink_grid) == ncol(input_grid).\n.make_sink_grid_of_vstrips <- function(input_grid, sink_nrow)\n{\n    stopifnot(is(input_grid, \"ArrayGrid\"),\n              length(dim(input_grid)) == 2L,\n              isSingleInteger(sink_nrow))\n    if (is(input_grid, \"ArbitraryArrayGrid\")) {\n        tickmarks <- list(sink_nrow, input_grid@tickmarks[[2L]])\n        ArbitraryArrayGrid(tickmarks)\n    } else {\n        refdim <- c(sink_nrow, refdim(input_grid)[[2L]])\n        spacings <- c(sink_nrow, ncol(input_grid[[1L]]))\n        RegularArrayGrid(refdim, spacings=spacings)\n    }\n}\n\n### Note that each block on 'sink_grid' is a horizontal strip made of one or\n### more rows.\n.sink_chunking_is_compatible_with_hstrips <- function(sink_chunkdim, sink_grid)\n{\n    stopifnot(is(sink_grid, \"ArrayGrid\"),\n              length(dim(sink_grid)) == 2L,\n              ncol(sink_grid) == 1L)\n    if (is.null(sink_chunkdim))  # no-chunking\n        return(TRUE)\n    stopifnot(is.integer(sink_chunkdim), length(sink_chunkdim) == 2L)\n    ## We treat the \"single big chunk\" case like the no-chunking case.\n    ## Note that the \"single big chunk\" situation only happens for very\n    ## small sinks in which case the chunking does not significantly impact\n    ## the writing performance. However, treating this situation as compatible\n    ## with horizontal sink strips is convenient when testing things like\n    ## BLOCK_colsum(..., BACKEND=\"HDF5Array\") on a small toy dataset.\n    if (all(sink_chunkdim == refdim(sink_grid)))\n        return(TRUE)\n    ## Dumb heuristic: We consider incompatible chunks that are taller than\n    ## the first block in 'sink_grid'.\n    ## FIXME: This could certainly be improved/refined.\n    ## Anyway, the most important thing for now is that it covers the\n    ## worst-case scenario, which is when the sink uses a storage layout\n    ## that is column-oriented (e.g. TENxRealizationSink object),\n    ## and 'sink_grid' has more than one horizontal strip.\n    ## So whatever heuristic we use, we want to make sure that it returns\n    ## FALSE in this case.\n    if (sink_chunkdim[[1L]] <= nrow(sink_grid[[1L]]))\n        return(TRUE)\n    FALSE\n}\n\n### Note that each block on 'sink_grid' is a vertical strip made of one or\n### more columns.\n.sink_chunking_is_compatible_with_vstrips <- function(sink_chunkdim, sink_grid)\n{\n    stopifnot(is(sink_grid, \"ArrayGrid\"),\n              length(dim(sink_grid)) == 2L,\n              nrow(sink_grid) == 1L)\n    if (is.null(sink_chunkdim))  # no-chunking\n        return(TRUE)\n    stopifnot(is.integer(sink_chunkdim), length(sink_chunkdim) == 2L)\n    if (all(sink_chunkdim == refdim(sink_grid)))\n        return(TRUE)\n    ## Dumb heuristic: We consider incompatible chunks that are wider than\n    ## the first block in 'sink_grid'.\n    ## FIXME: This could certainly be improved/refined.\n    ## Anyway, the most important thing for now is that it covers the\n    ## worst-case scenario, which is when the sink uses a storage layout\n    ## that is row-oriented (i.e. is the transposed of what is used by a\n    ## TENxRealizationSink object), and 'sink_grid' has more than one\n    ## vertical strip. Whatever heuristic we use, we want to make sure that\n    ## it returns FALSE in this case.\n    if (sink_chunkdim[[2L]] <= ncol(sink_grid[[1L]]))\n        return(TRUE)\n    FALSE\n}\n\n### Whether 'BACKEND' is compatible with the \"shared sink\" route (see below\n### in this file for what the \"shared sink\" route is).\n.compatible_BACKEND <- function(BACKEND)\n{\n    if (is.null(BACKEND))\n        return(FALSE)\n    ## Same check as in load_BACKEND_package().\n    if (!isSingleString(BACKEND))\n        stop(wmsg(\"'BACKEND' must be a single string or NULL\"))\n    ## write_block() method for RleRealizationSink objects is broken (it\n    ## ignores the 'viewport' argument!) so, until this is fixed, the\n    ## RleArray realization backend is not compatible.\n    BACKEND != \"RleArray\"\n}\n\n### Returns a \"shared sink\" if we can take the \"shared sink\" route, or NULL if\n### we can't. ALWAYS takes the \"shared sink\" route if 'nrow(input_grid)' is 1.\n.make_shared_sink_along_hstrips <- function(input_grid, sink_grid, BACKEND,\n                                            sink_rownames, sink_colnames, ...)\n{\n    stopifnot(nrow(sink_grid) == nrow(input_grid), ncol(sink_grid) == 1L)\n    if (nrow(input_grid) != 1L && !.compatible_BACKEND(BACKEND))\n        return(NULL)\n    sink_dimnames <- list(sink_rownames, sink_colnames)\n    sink <- RealizationSink(BACKEND, refdim(sink_grid), dimnames=sink_dimnames,\n                                     type=\"double\", ...)\n    if (nrow(input_grid) == 1L)\n        return(sink)\n    ## We take the \"shared sink\" route only if the chunks are \"compatible\"\n    ## with the writing of full sink rows by callback function FINAL()\n    ## below (this callback function will get called at the end of processing\n    ## each horizontal strip).\n    ok <- .sink_chunking_is_compatible_with_hstrips(chunkdim(sink), sink_grid)\n    if (ok) sink else NULL\n}\n\n### Returns a \"shared sink\" if we can take the \"shared sink\" route, or NULL if\n### we can't. ALWAYS takes the \"shared sink\" route if 'ncol(input_grid)' is 1.\n.make_shared_sink_along_vstrips <- function(input_grid, sink_grid, BACKEND,\n                                            sink_rownames, sink_colnames, ...)\n{\n    stopifnot(nrow(sink_grid) == 1L, ncol(sink_grid) == ncol(input_grid))\n    if (ncol(input_grid) != 1L && !.compatible_BACKEND(BACKEND))\n        return(NULL)\n    sink_dimnames <- list(sink_rownames, sink_colnames)\n    sink <- RealizationSink(BACKEND, refdim(sink_grid), dimnames=sink_dimnames,\n                                     type=\"double\", ...)\n    if (ncol(input_grid) == 1L)\n        return(sink)\n    ## We take the \"shared sink\" route only if the chunks are \"compatible\"\n    ## with the writing of full sink columns by callback function FINAL()\n    ## below (this callback function will get called at the end of processing\n    ## each vertical strip).\n    ok <- .sink_chunking_is_compatible_with_vstrips(chunkdim(sink), sink_grid)\n    if (ok) sink else NULL\n}\n\n### Returns a RealizationSink + its associated grid in a named list if we\n### can take the \"shared sink\" route, or NULL if we can't. Note that we MUST\n### ALWAYS take the \"shared sink\" route if 'nrow(input_grid)' is 1.\nmake_shared_sink_and_grid_along_hstrips <-\n    function(BPPARAM, input_grid, sink_ncol,\n             BACKEND, sink_rownames, sink_colnames, ...)\n{\n    ## Note that, at the moment, we don't try the \"shared sink\" route if\n    ## parallel processing is enabled because there's no guarantee that the\n    ## realization sink will support concurrent writes (e.g. HDF5 does not).\n    ## TODO (maybe):\n    ## - For registered realization backends, we could register\n    ##   their ability to do concurrent writes, and decide based on that.\n    ## - Alternatively, we could introduce a new generic (e.g.\n    ##   supports_concurrent_writing() or concurrent_writes(), to define\n    ##   in RealizationSink-class.R) with a method defined for RealizationSink\n    ##   objects that returns FALSE. Then concrete subclasses that support\n    ##   concurrent writes (e.g. TileDBRealizationSink?) would overwrite it\n    ##   with a method that returns TRUE.\n    if (nrow(input_grid) != 1L &&\n        !is.null(BPPARAM) && BiocParallel::bpnworkers(BPPARAM) >= 2L)\n        return(NULL)\n    sink_grid <- .make_sink_grid_of_hstrips(input_grid, sink_ncol)\n    sink <- .make_shared_sink_along_hstrips(input_grid, sink_grid, BACKEND,\n                                            sink_rownames, sink_colnames, ...)\n    if (is.null(sink))\n        return(NULL)\n    list(sink=sink, sink_grid=sink_grid)\n}\n\n### Returns a RealizationSink + its associated grid in a named list if we\n### can take the \"shared sink\" route, or NULL if we can't. Note that we MUST\n### ALWAYS take the \"shared sink\" route if 'ncol(input_grid)' is 1.\nmake_shared_sink_and_grid_along_vstrips <-\n    function(BPPARAM, input_grid, sink_nrow,\n             BACKEND, sink_rownames, sink_colnames, ...)\n{\n    if (ncol(input_grid) != 1L &&\n        !is.null(BPPARAM) && BiocParallel::bpnworkers(BPPARAM) >= 2L)\n        return(NULL)\n    sink_grid <- .make_sink_grid_of_vstrips(input_grid, sink_nrow)\n    sink <- .make_shared_sink_along_vstrips(input_grid, sink_grid, BACKEND,\n                                            sink_rownames, sink_colnames, ...)\n    if (is.null(sink))\n        return(NULL)\n    list(sink=sink, sink_grid=sink_grid)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### BLOCK_rowsum() and BLOCK_colsum()\n###\n\n### x: a matrix-like object (typically a DelayedMatrix).\n### grid: an array grid (ArrayGrid object) defined on 'x'.\n### Walks on the matrix blocks defined by 'grid'.\n### If 'BACKEND' is NULL, returns an ordinary matrix. Otherwise, returns\n### a DelayedMatrix object that is either pristine or the result of cbind'ing\n### several pristine DelayedMatrix objects together (delayed cbind()).\n### Calling nseed() on the returned object will return 1 in the pristine case\n### or the number of objects bound together in the non-pristine case. In the\n### pristine case, arguments specified thru the ellipsis will be passed to the\n### RealizationSink constructor associated with 'BACKEND'. Note that the first\n### 3 arguments of **any** RealizationSink constructor are guaranteed to\n### be 'dim', 'dimnames', and 'type', and the arguments specified thru the\n### ellipsis here can not be any of these. 'as.sparse' is not allowed either.\nBLOCK_rowsum <- function(x, group, reorder=TRUE, na.rm=FALSE,\n                         grid=NULL, as.sparse=NA,\n                         BPPARAM=getAutoBPPARAM(), verbose=NA,\n                         BACKEND=getAutoRealizationBackend(), ...,\n                         dry.run=FALSE)\n{\n    stopifnot(length(dim(x)) == 2L)  # matrix-like object\n    verbose <- normarg_verbose(verbose)\n\n    ugroup <- as.character(S4Arrays:::compute_ugroup(group, nrow(x), reorder))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(dry.run))\n        stop(wmsg(\"'dry.run' must be TRUE or FALSE\"))\n\n    ans_dim <- c(length(ugroup), ncol(x))\n\n    ## --- define INIT() ---\n\n    ## INIT() must return a matrix of type \"double\" rather than \"integer\".\n    ## This is to avoid integer overflows during the within-strip walks.\n    INIT <- function(j, grid, ugroup, x_colnames) {\n        vp <- grid[[1L, j]]\n        dn <- list(ugroup, extractROWS(x_colnames, ranges(vp)[2L]))\n        matrix(0.0, nrow=length(ugroup), ncol=ncol(vp), dimnames=dn)\n    }\n    INIT_MoreArgs <- list(ugroup=ugroup, x_colnames=colnames(x))\n\n    ## --- define FINAL() ---\n\n    if (is.null(BACKEND)) {\n        if (dry.run)\n            return(list(class=\"matrix\", dim=ans_dim, type=\"double\"))\n        FINAL <- if (verbose) final_vstrip_noop else NULL\n        FINAL_MoreArgs <- list()\n    } else {\n        ## The \"shared sink\" route consists in using a single realization sink\n        ## shared across all strips. Can we take this route?\n        ## make_shared_sink_and_grid_along_vstrips() will figure it out and\n        ## return a RealizationSink + its associated grid in a named list if\n        ## it turns out that we can take the \"shared sink\" route, or NULL if\n        ## we can't.\n        grid <- best_grid_for_vstrip_apply(x, grid)\n        sink_and_grid <- make_shared_sink_and_grid_along_vstrips(BPPARAM,\n                                              grid, ans_dim[[1L]],\n                                              BACKEND, ugroup, colnames(x), ...)\n        if (is.null(sink_and_grid)) {\n            if (dry.run)\n                return(list(class=\"DelayedMatrix\", dim=ans_dim, type=\"double\",\n                            nseed=ncol(grid)))\n            FINAL <- function(init, j, grid, BACKEND, verbose) {\n                realize_matrix(init, BACKEND, verbose)\n            }\n            FINAL_MoreArgs <- list(BACKEND=BACKEND, verbose=verbose)\n        } else {\n            ## \"shared sink\" route.\n            if (dry.run)\n                return(list(class=BACKEND, dim=ans_dim, type=\"double\",\n                            nseed=1L))\n            FINAL <- function(init, j, grid, sink, sink_grid, verbose) {\n                write_full_sink_cols(sink, sink_grid, j, init, verbose)\n            }\n            FINAL_MoreArgs <- c(sink_and_grid, list(verbose=verbose))\n        }\n    }\n\n    ## --- define FUN() ---\n\n    FUN <- function(init, block, group, ugroup, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SVT_SparseMatrix object.\n        vp <- currentViewport()\n        group2 <- extractROWS(group, ranges(vp)[1L])\n        block_ans <- rowsum(block, group2, reorder=FALSE, na.rm=na.rm)\n        if (!is.matrix(block_ans))\n            block_ans <- as.matrix(block_ans)\n        m <- match(rownames(block_ans), ugroup)\n        init[m, ] <- init[m, ] + block_ans\n        init\n    }\n    FUN_MoreArgs <- list(group=group, ugroup=ugroup, na.rm=na.rm)\n\n    ## --- block processing ---\n\n    strip_results <- vstrip_apply(x, INIT, INIT_MoreArgs,\n                                     FUN, FUN_MoreArgs,\n                                     FINAL, FINAL_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n\n    ## --- turn output of block processing into object and return it ---\n\n    if (is.null(BACKEND) || is.null(sink_and_grid)) {\n        combine_strip_results(\"cbind\", strip_results, verbose)\n    } else {\n        ## \"shared sink\" route.\n        shared_sink_as_DelayedArray(sink_and_grid$sink, verbose)\n    }\n}\n\n### x: a matrix-like object (typically a DelayedMatrix).\n### grid: an array grid (ArrayGrid object) defined on 'x'.\n### Walks on the matrix blocks defined by 'grid'.\n### If 'BACKEND' is NULL, returns an ordinary matrix. Otherwise, returns\n### a DelayedMatrix object that is either pristine or the result of rbind'ing\n### several pristine DelayedMatrix objects together (delayed rbind()).\n### See BLOCK_rowsum() above for what arguments can be specified thru the\n### ellipsis.\nBLOCK_colsum <- function(x, group, reorder=TRUE, na.rm=FALSE,\n                         grid=NULL, as.sparse=NA,\n                         BPPARAM=getAutoBPPARAM(), verbose=NA,\n                         BACKEND=getAutoRealizationBackend(), ...,\n                         dry.run=FALSE)\n{\n    stopifnot(length(dim(x)) == 2L)  # matrix-like object\n    verbose <- normarg_verbose(verbose)\n\n    ugroup <- as.character(S4Arrays:::compute_ugroup(group, ncol(x), reorder))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(dry.run))\n        stop(wmsg(\"'dry.run' must be TRUE or FALSE\"))\n\n    ans_dim <- c(nrow(x), length(ugroup))\n\n    ## --- define INIT() ---\n\n    ## INIT() must return a matrix of type \"double\" rather than \"integer\".\n    ## This is to avoid integer overflows during the within-strip walks.\n    INIT <- function(i, grid, ugroup, x_rownames) {\n        vp <- grid[[i, 1L]]\n        dn <- list(extractROWS(x_rownames, ranges(vp)[1L]), ugroup)\n        matrix(0.0, nrow=nrow(vp), ncol=length(ugroup), dimnames=dn)\n    }\n    INIT_MoreArgs <- list(ugroup=ugroup, x_rownames=rownames(x))\n\n    ## --- define FINAL() ---\n\n    if (is.null(BACKEND)) {\n        if (dry.run)\n            return(list(class=\"matrix\", dim=ans_dim, type=\"double\"))\n        FINAL <- if (verbose) final_hstrip_noop else NULL\n        FINAL_MoreArgs <- list()\n    } else {\n        ## The \"shared sink\" route consists in using a single realization sink\n        ## shared across all strips. Can we take this route?\n        ## make_shared_sink_and_grid_along_hstrips() will figure it out and\n        ## return a RealizationSink + its associated grid in a named list if\n        ## it turns out that we can take the \"shared sink\" route, or NULL if\n        ## we can't.\n        grid <- best_grid_for_hstrip_apply(x, grid)\n        sink_and_grid <- make_shared_sink_and_grid_along_hstrips(BPPARAM,\n                                              grid, ans_dim[[2L]],\n                                              BACKEND, rownames(x), ugroup, ...)\n        if (is.null(sink_and_grid)) {\n            if (dry.run)\n                return(list(class=\"DelayedMatrix\", dim=ans_dim, type=\"double\",\n                            nseed=nrow(grid)))\n            FINAL <- function(init, i, grid, BACKEND, verbose) {\n                realize_matrix(init, BACKEND, verbose)\n            }\n            FINAL_MoreArgs <- list(BACKEND=BACKEND, verbose=verbose)\n        } else {\n            ## \"shared sink\" route.\n            if (dry.run)\n                return(list(class=BACKEND, dim=ans_dim, type=\"double\",\n                            nseed=1L))\n            FINAL <- function(init, i, grid, sink, sink_grid, verbose) {\n                write_full_sink_rows(sink, sink_grid, i, init, verbose)\n            }\n            FINAL_MoreArgs <- c(sink_and_grid, list(verbose=verbose))\n        }\n    }\n\n    ## --- define FUN() ---\n\n    FUN <- function(init, block, group, ugroup, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SVT_SparseMatrix object.\n        vp <- currentViewport()\n        group2 <- extractROWS(group, ranges(vp)[2L])\n        block_ans <- colsum(block, group2, reorder=FALSE, na.rm=na.rm)\n        if (!is.matrix(block_ans))\n            block_ans <- as.matrix(block_ans)\n        m <- match(colnames(block_ans), ugroup)\n        init[ , m] <- init[ , m] + block_ans\n        init\n    }\n    FUN_MoreArgs <- list(group=group, ugroup=ugroup, na.rm=na.rm)\n\n    ## --- block processing ---\n\n    strip_results <- hstrip_apply(x, INIT, INIT_MoreArgs,\n                                     FUN, FUN_MoreArgs,\n                                     FINAL, FINAL_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n\n    ## --- turn output of block processing into object and return it ---\n\n    if (is.null(BACKEND) || is.null(sink_and_grid)) {\n        combine_strip_results(\"rbind\", strip_results, verbose)\n    } else {\n        ## \"shared sink\" route.\n        shared_sink_as_DelayedArray(sink_and_grid$sink, verbose)\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### rowsum(), describe_rowsum_result(),\n### colsum(), describe_colsum_result() methods\n###\n\n### S3/S4 combo for rowsum.DelayedMatrix\nrowsum.DelayedMatrix <- function(x, group, reorder=TRUE, ...)\n    BLOCK_rowsum(x, group, reorder, ...)\nsetMethod(\"rowsum\", \"DelayedMatrix\",\n    function(x, group, reorder=TRUE, na.rm=FALSE)\n        BLOCK_rowsum(x, group, reorder, na.rm)\n)\n\n### describe_rowsum_result().\nsetGeneric(\"describe_rowsum_result\", signature=\"x\",\n    function(x, group, reorder=TRUE, na.rm=FALSE)\n        standardGeneric(\"describe_rowsum_result\")\n)\nsetMethod(\"describe_rowsum_result\", \"ANY\",\n    function(x, group, reorder=TRUE, na.rm=FALSE) NULL\n)\nsetMethod(\"describe_rowsum_result\", \"DelayedMatrix\",\n    function(x, group, reorder=TRUE, na.rm=FALSE)\n        BLOCK_rowsum(x, group, reorder, na.rm, dry.run=TRUE)\n)\n\n### colsum() method.\nsetMethod(\"colsum\", \"DelayedMatrix\", BLOCK_colsum)\n\n",
        "DelayedNaryIsoOp-class.R": "### =========================================================================\n### DelayedNaryIsoOp objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed N-ary isometric operation.\n### The input arrays must be \"conformable\" i.e. they all must have the same\n### dimensions.\n###\n\nsetClass(\"DelayedNaryIsoOp\",\n    contains=\"DelayedNaryOp\",\n    representation(\n        OP=\"function\",  # The function to use to combine the input objects.\n                        # Should act as an isomorphism i.e. always return an\n                        # array-like object **parallel** to the input objects\n                        # (i.e. with the same dimensions).\n\n        Rargs=\"list\"    # Additional right arguments to OP.\n    ),\n    prototype(\n        OP=identity\n    )\n)\n\n.arrays_are_conformable <- function(objects)\n{\n    dims <- lapply(objects, dim)\n    ndims <- lengths(dims)\n    first_ndim <- ndims[[1L]]\n    if (!all(ndims == first_ndim))\n        return(FALSE)\n    tmp <- unlist(dims, use.names=FALSE)\n    if (is.null(tmp))\n        return(FALSE)\n    dims <- matrix(tmp, ncol=length(objects))\n    first_dim <- dims[ , 1L]\n    all(dims == first_dim)\n}\n\n.validate_DelayedNaryIsoOp <- function(x)\n{\n    ## 'seeds' slot.\n    if (!.arrays_are_conformable(x@seeds))\n        return(\"'x@seeds' must be a list of conformable array-like objects\")\n    TRUE\n}\n\nsetValidity2(\"DelayedNaryIsoOp\", .validate_DelayedNaryIsoOp)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nnew_DelayedNaryIsoOp <- function(OP=identity, seed=new(\"array\"), ...,\n                                 Rargs=list())\n{\n    OP <- match.fun(OP)\n    seeds <- unname(list(seed, ...))\n    if (!.arrays_are_conformable(seeds))\n        stop(wmsg(\"non-conformable array-like objects\"))\n    new2(\"DelayedNaryIsoOp\", seeds=seeds, OP=OP, Rargs=Rargs, check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedNaryIsoOp\n\n.DelayedNaryIsoOp_summary <- function(object) \"N-ary iso op\"\n\nsummary.DelayedNaryIsoOp <-\n    function(object, ...) .DelayedNaryIsoOp_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedNaryIsoOp\", summary.DelayedNaryIsoOp)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n\nsetMethod(\"dim\", \"DelayedNaryIsoOp\", function(x) dim(x@seeds[[1L]]))\n\nsetMethod(\"dimnames\", \"DelayedNaryIsoOp\",\n    function(x) S4Arrays:::get_first_non_NULL_dimnames(x@seeds)\n)\n\nsetMethod(\"extract_array\", \"DelayedNaryIsoOp\",\n    function(x, index)\n    {\n        arrays <- lapply(x@seeds, extract_array, index)\n        do.call(x@OP, c(arrays, x@Rargs))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\nsetMethod(\"is_sparse\", \"DelayedNaryIsoOp\",\n    function(x)\n    {\n        ok <- vapply(x@seeds, is_sparse, logical(1), USE.NAMES=FALSE)\n        if (!all(ok))\n            return(FALSE)\n        if (length(x@Rargs) != 0L)\n            return(FALSE)\n        ## Structural sparsity will be propagated if the operation in\n        ## x@OP preserves the zeros. To find out whether zeros are preserved\n        ## or not, we replace each current seed with an array of one \"zero\",\n        ## that is, with an ordinary array of the same number of dimensions\n        ## and type as the seed, but with a single \"zero\" element. Then we\n        ## apply the n-ary operation in x@OP to them and see whether the\n        ## zero were preserved or not.\n        seed_ndim <- length(dim(x@seeds[[1L]]))\n        x@seeds <- lapply(x@seeds,\n            function(seed) S4Arrays:::make_one_zero_array(type(seed), seed_ndim))\n        ## Same as 'as.array(x)' but doesn't try to propagate the dimnames.\n        a0 <- extract_array(x, vector(\"list\", length=seed_ndim))\n        S4Arrays:::is_filled_with_zeros(a0)\n    }\n)\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedNaryIsoOp\",\n    function(x, index)\n    {\n        stop(\"NOT IMPLEMENTED YET!\")\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Backward compatibility with DelayedArray < 0.5.24\n###\n### In DelayedArray 0.5.24 the ConformableSeedCombiner class got renamed\n### DelayedNaryIsoOp. DelayedArray objects serialized with DelayedArray <\n### 0.5.24 might contain ConformableSeedCombiner instances nested in their\n### \"seed\" slot so we need to keep the class around for now.\n###\n\nsetClass(\"ConformableSeedCombiner\", contains=\"DelayedNaryIsoOp\")\n\nsetMethod(\"updateObject\", \"ConformableSeedCombiner\",\n    function(object, ..., verbose=FALSE)\n    {\n        object <- new2(\"DelayedNaryIsoOp\", seeds=object@seeds,\n                                           OP=object@COMBINING_OP,\n                                           Rargs=object@Rargs)\n        callNextMethod()\n    }\n)\n\n",
        "DelayedOp-class.R": "### =========================================================================\n### DelayedOp objects\n### -------------------------------------------------------------------------\n###\n### In a DelayedArray object the delayed operations are stored as a tree of\n### DelayedOp objects. Each node in the tree is represented by a DelayedOp\n### object. 8 types of nodes are currently supported. Each type is a concrete\n### DelayedOp subclass:\n###\n###   Node type                        Represented operation\n###   -------------------------------------------------------------------\n###   DelayedOp (VIRTUAL)\n###   -------------------------------------------------------------------\n###   * DelayedUnaryOp (VIRTUAL)\n###     o DelayedSubset                Multi-dimensional single bracket\n###                                    subsetting.\n###     o DelayedAperm                 Extended aperm() (can drop and/or\n###                                    add ineffective dimensions).\n###     o DelayedUnaryIsoOp (VIRTUAL)  Unary op that preserves the\n###                                    geometry.\n###       - DelayedUnaryIsoOpStack     Simple ops stacked together.\n###       - DelayedUnaryIsoOpWithArgs  One op with vector-like arguments\n###                                    along the dimensions of the input.\n###       - DelayedSubassign           Multi-dimensional single bracket\n###                                    subassignment.\n###       - DelayedSetDimnames         Set/replace the dimnames.\n###   -------------------------------------------------------------------\n###   * DelayedNaryOp (VIRTUAL)\n###     o DelayedNaryIsoOp             N-ary op that preserves the\n###                                    geometry.\n###     o DelayedAbind                 abind()\n###   -------------------------------------------------------------------\n###\n### All DelayedOp objects must comply with the \"seed contract\" i.e. they must\n### support dim(), dimnames(), and extract_array(). This makes them de facto\n### array-like objects. However, end users will never interact with them\n### directly, except for the root of the tree which is the DelayedArray\n### object itself and the only node in the tree that they are able to see\n### and touch.\n###\n\n### This virtual class and its 8 concrete subclasses are for internal use\n### only and never exposed to the end user.\nsetClass(\"DelayedOp\", contains=\"Array\", representation(\"VIRTUAL\"))\n\n### NOT exported for now.\nsetGeneric(\"is_noop\", function(x) standardGeneric(\"is_noop\"))\n\n### S3/S4 combo for summary.DelayedOp\n\n.DelayedOp_summary <- function(object) sprintf(\"%s object\", class(object))\nsummary.DelayedOp <- function(object, ...) .DelayedOp_summary(object, ...)\nsetMethod(\"summary\", \"DelayedOp\", summary.DelayedOp)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### DelayedUnaryOp objects\n###\n\nsetClass(\"DelayedUnaryOp\",\n    contains=\"DelayedOp\",\n    representation(\n        \"VIRTUAL\",\n        seed=\"ANY\"    # The input array-like object. Expected to comply\n                      # with the \"seed contract\".\n    ),\n    prototype(\n        seed=new(\"array\")\n    )\n)\n\n.validate_DelayedUnaryOp <- function(x)\n{\n    if (length(dim(x@seed)) == 0L)\n        return(\"the supplied seed must have dimensions\")\n    res <- try(S4Arrays:::extract_empty_array(x@seed), silent=TRUE)\n    if (inherits(res, \"try-error\"))\n        return(\"the supplied seed must support extract_array()\")\n    TRUE\n}\n\nsetValidity2(\"DelayedUnaryOp\", .validate_DelayedUnaryOp)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### DelayedUnaryIsoOp objects\n###\n### Representation of a delayed unary isometric operation.\n###\n\nsetClass(\"DelayedUnaryIsoOp\",\n    contains=\"DelayedUnaryOp\",\n    representation(\"VIRTUAL\")\n)\n\n### Seed contract.\n### The 3 default methods below give DelayedUnaryIsoOp derivatives a no-op\n### semantic by default.\n### DelayedUnaryIsoOpStack and DelayedUnaryIsoOpWithArgs objects overwrite\n### this default \"extract_array\" method.\n### DelayedSetDimnames objects overwrite this default \"dimnames\" method.\n### Note that a DelayedArray object is also a DelayedUnaryIsoOp derivative\n### and is considered to be the root node of the tree of DelayedOp objects\n### contained in it. From a DelayedOp point of view, this root node must\n### represent a no-op so DelayedArray objects inherit the 3 default methods\n### below.\n\nsetMethod(\"dim\", \"DelayedUnaryIsoOp\", function(x) dim(x@seed))\n\nsetMethod(\"dimnames\", \"DelayedUnaryIsoOp\", function(x) dimnames(x@seed))\n\nsetMethod(\"extract_array\", \"DelayedUnaryIsoOp\",\n    function(x, index) extract_array(x@seed, index)\n)\n\n### is_sparse() and extract_sparse_array().\n### Like the 3 default methods above (seed contract), the 2 default methods\n### below also implement a no-op semantic and are also inherited by\n### DelayedArray objects.\n\nsetMethod(\"is_sparse\", \"DelayedUnaryIsoOp\", function(x) is_sparse(x@seed))\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedUnaryIsoOp\",\n    function(x, index) extract_sparse_array(x@seed, index)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### DelayedNaryOp objects\n###\n\nsetClass(\"DelayedNaryOp\",\n    contains=\"DelayedOp\",\n    representation(\n        \"VIRTUAL\",\n        seeds=\"list\"  # The input array-like objects. Each object is\n                      # expected to comply with the \"seed contract\".\n    ),\n    prototype(\n        seeds=list(new(\"array\"))\n    )\n)\n\n.validate_DelayedNaryOp <- function(x)\n{\n    if (!is.list(x@seeds))\n        return(\"'x@seeds' must be a list\")\n    if (length(x@seeds) == 0L)\n        return(\"'x@seeds' cannot be empty\")\n    for (i in seq_along(x@seeds)) {\n        seed <- x@seeds[[i]]\n        if (length(dim(seed)) == 0L)\n            return(paste0(\"x@seeds[[\", i, \"]] has no dimensions \",\n                          \"(all the supplied seeds must have dimensions)\"))\n        res <- try(S4Arrays:::extract_empty_array(seed), silent=TRUE)\n        if (inherits(res, \"try-error\"))\n            return(paste0(\"x@seeds[[\", i, \"]] does not support \",\n                          \"extract_array() (all the supplied seeds \",\n                          \"must support extract_array())\"))\n    }\n    TRUE\n}\n\nsetValidity2(\"DelayedNaryOp\", .validate_DelayedNaryOp)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### updateObject()\n###\n\nsetMethod(\"updateObject\", \"DelayedOp\",\n    function(object, ..., verbose=FALSE)\n    {\n        if (.hasSlot(object, \"seed\")) {\n            object@seed <- updateObject(object@seed, ..., verbose=verbose)\n        }\n        if (.hasSlot(object, \"seeds\")) {\n            object@seeds <- lapply(object@seeds,\n                function(seed) updateObject(seed, ..., verbose=verbose))\n        }\n        object\n    }\n)\n\n",
        "DelayedSetDimnames-class.R": "### =========================================================================\n### DelayedSetDimnames objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed \"set dimnames\" operation.\n###\n\n### Used in unit tests!\n.INHERIT_FROM_SEED <- -1L\n\nsetClass(\"DelayedSetDimnames\",\n    contains=\"DelayedUnaryIsoOp\",\n    representation(\n        dimnames=\"list\"  # List with one list element per dimension in\n                         # the input. Each list element must be NULL,\n                         # or a character vector, or special value\n                         # .INHERIT_FROM_SEED\n    ),\n    prototype(\n        dimnames=list(.INHERIT_FROM_SEED)\n    )\n)\n\n.validate_DelayedSetDimnames <- function(x)\n{\n    seed_dim <- dim(x@seed)\n    seed_ndim <- length(seed_dim)\n\n    ## 'dimnames' slot.\n    if (length(x@dimnames) != seed_ndim)\n        return(paste0(\"'x@dimnames' must have one list element per \",\n                      \"dimension in 'x@seed'\"))\n    ok <- mapply(function(dn, d) {\n                     identical(dn, .INHERIT_FROM_SEED) ||\n                     is.null(dn) ||\n                     is.character(dn) && length(dn) == d\n                 },\n                 x@dimnames, seed_dim,\n                 SIMPLIFY=FALSE, USE.NAMES=FALSE)\n    if (!all(unlist(ok)))\n        return(paste0(\"each list element in 'x@dimnames' must be NULL, \",\n                      \"or a character vector of length the extent of \",\n                      \"the corresponding dimension, or special value \",\n                      .INHERIT_FROM_SEED))\n    TRUE\n}\n\nsetValidity2(\"DelayedSetDimnames\", .validate_DelayedSetDimnames)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nnew_DelayedSetDimnames <-\n    function(seed=new(\"array\"), dimnames=.INHERIT_FROM_SEED)\n{\n    seed_dim <- dim(seed)\n    seed_ndim <- length(seed_dim)\n    if (identical(dimnames, .INHERIT_FROM_SEED)) {\n        dimnames <- rep.int(list(.INHERIT_FROM_SEED), seed_ndim)\n    } else {\n        dimnames <- S4Arrays:::normarg_dimnames(dimnames, seed_dim)\n        ## 'dimnames(seed)' can fail e.g. if 'seed' is or contains an\n        ## HDF5ArraySeed object that points to a non-existing file, but we\n        ## still want new_DelayedSetDimnames() to work on such seed.\n        ## Our use case for this is ExperimentHub resource EH1656. This is a\n        ## SummarizedExperiment object (added to ExperimentHub on 2017-10-06\n        ## by the restfulSEData folks) where the assay is a very old\n        ## DelayedMatrix instance (predates DelayedArray 0.4) that binds\n        ## together 14 old HDF5ArraySeed instances that point to a non-existing\n        ## file ('assays.h5'). When updateObject( , check=FALSE) is called on\n        ## EH1656, new_DelayedSetDimnames() gets called on a seed that contains\n        ## an HDF5ArraySeed object that points to a non-existing file.\n        seed_dimnames <- try(dimnames(seed), silent=TRUE)\n        if (inherits(seed_dimnames, \"try-error\"))\n            seed_dimnames <- NULL\n        dimnames <- lapply(setNames(seq_len(seed_ndim), names(dimnames)),\n                           function(along) {\n                               dn <- dimnames[[along]]\n                               seed_dn <- seed_dimnames[[along]]\n                               ## Let's play nice with seeds that return\n                               ## dimnames() that are not NULL or a character\n                               ## vector e.g.\n                               ##   library(GDSArray)\n                               ##   gds <- seqExampleFileName(\"gds\")\n                               ##   ga1 <- GDSArray(gds, \"genotype/data\")\n                               ##   sapply(dimnames(ga1), class)\n                               ##   #  variant.id   sample.id   ploidy.id\n                               ##   # \"character\" \"character\"   \"integer\"\n                               if (!(is.null(seed_dn) || is.character(seed_dn)))\n                                   seed_dn <- as.character(seed_dn)\n                               if (identical(dn, seed_dn))\n                                   return(.INHERIT_FROM_SEED)\n                               dn\n                           })\n    }\n    new2(\"DelayedSetDimnames\", seed=seed, dimnames=dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_noop() method\n###\n\nsetMethod(\"is_noop\", \"DelayedSetDimnames\",\n    function(x)\n    {\n        ok <- vapply(x@dimnames, identical, logical(1), .INHERIT_FROM_SEED,\n                     USE.NAMES=FALSE)\n        ## 'dimnames(x@seed)' can fail e.g. if 'x@seed' is or contains an\n        ## HDF5ArraySeed object that points to a non-existing file, but we\n        ## still want is_noop() to work on such DelayedSetDimnames object.\n        ## See new_DelayedSetDimnames() above for our use case.\n        x_seed_dimnames <- try(dimnames(x@seed), silent=TRUE)\n        if (inherits(x_seed_dimnames, \"try-error\"))\n            x_seed_dimnames <- NULL\n        all(ok) && identical(names(x@dimnames), names(x_seed_dimnames))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedSetDimnames\n\n.DelayedSetDimnames_summary <- function(object) \"Set dimnames\"\n\nsummary.DelayedSetDimnames <-\n    function(object, ...) .DelayedSetDimnames_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedSetDimnames\", summary.DelayedSetDimnames)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n### We inherit the default dim() and extract_array() methods defined for\n### DelayedUnaryIsoOp derivatives, but overwite their dimnames() method.\n\n.get_DelayedSetDimnames_dimnames <- function(x)\n{\n    x_dimnames <- x@dimnames\n    seed_dimnames <- dimnames(x@seed)\n    ans <- lapply(setNames(seq_along(x_dimnames), names(x_dimnames)),\n                  function(along) {\n                      dn <- x_dimnames[[along]]\n                      if (identical(dn, .INHERIT_FROM_SEED))\n                          dn <- seed_dimnames[[along]]\n                      dn\n                  })\n    S4Arrays:::simplify_NULL_dimnames(ans)\n}\n\nsetMethod(\"dimnames\", \"DelayedSetDimnames\", .get_DelayedSetDimnames_dimnames)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Backward compatibility with DelayedArray < 0.17.6\n###\n### In DelayedArray 0.17.6 the DelayedDimnames class got renamed\n### DelayedSetDimnames. DelayedArray objects serialized with DelayedArray <\n### 0.17.6 might contain DelayedDimnames instances nested in their \"seed\"\n### slot so we need to keep the class around for now.\n###\n\nsetClass(\"DelayedDimnames\", contains=\"DelayedSetDimnames\")\n\nsetMethod(\"updateObject\", \"DelayedDimnames\",\n    function(object, ..., verbose=FALSE)\n    {\n        class(object) <- \"DelayedSetDimnames\"\n        callNextMethod()\n    }\n)\n\n",
        "DelayedSubassign-class.R": "### =========================================================================\n### DelayedSubassign objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed multi-dimensional single bracket\n### subassignment.\n###\n\n### Even though strictly speaking DelayedSubassign nodes are binary nodes\n### (subassigment operates on 2 array-like objects, the \"left value\" and the\n### \"right value\"), it turns out to be more convenient (and natural) to treat\n### them as unary nodes (e.g. in nseed() and seed()). This is why we make\n### DelayedSubassign extend DelayedUnaryOp (via DelayedUnaryIsoOp).\nsetClass(\"DelayedSubassign\",\n    contains=\"DelayedUnaryIsoOp\",\n    representation(\n        Lindex=\"list\",    # The \"left index\". List of subscripts as positive\n                          # integer vectors, one per dimension in the input.\n                          # **Missing** list elements are allowed and\n                          # represented by NULLs.\n                          # Allowed to contain duplicates BUT NO NAs when the\n                          # \"Rvalue\" slot is an ordinary vector (atomic or\n                          # list) of length 1.\n                          # Allowed to contain NAs BUT NO DUPLICATES when the\n                          # \"Rvalue\" slot is an array-like object.\n\n        Rvalue=\"ANY\",     # The \"right value\" i.e. the array-like object on the\n                          # right side of the subassignment. Expected to comply\n                          # with the \"seed contract\". Alternatively, it can be\n                          # an ordinary vector (atomic or list) of length 1.\n\n        .nogap=\"logical\"  # One logical per dimension in the input indicating\n                          # whether the corresponding subscript in the \"left\n                          # index\" reaches all valid positions along the\n                          # seed dimension associated with it.\n    ),\n    prototype(\n        Lindex=list(NULL),\n        Rvalue=NA,\n        .nogap=TRUE\n    )\n)\n\n.validate_DelayedSubassign <- function(x)\n{\n    ## TODO!\n    TRUE\n}\n\nsetValidity2(\"DelayedSubassign\", .validate_DelayedSubassign)\n\n\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.normarg_Rvalue <- function(Rvalue, selection_dim)\n{\n    Rvalue_dim <- dim(Rvalue)\n    if (is.null(Rvalue_dim) && !is.vector(Rvalue))\n        stop(wmsg(\"replacement value must be an array-like object \",\n                  \"or an ordinary vector\"))\n    ## 'Rvalue' is an array-like object or an ordinary vector (atomic or list).\n    if (length(Rvalue) != prod(selection_dim))\n        stop(wmsg(\"length of replacement value must equal the number \",\n                  \"of array elements to replace\"))\n    if (is.null(Rvalue_dim)) {\n        ## 'x@Rvalue' is an ordinary vector (atomic or list).\n        dim(Rvalue) <- selection_dim\n        return(Rvalue)\n    }\n    same_dims <- function(dim1, dim2) length(dim1) == length(dim2) &&\n                                      all(dim1 == dim2)\n    if (same_dims(Rvalue_dim, selection_dim))\n        return(Rvalue)\n    ## We're going to reshape 'Rvalue' but only if its effective dimensions\n    ## are the same as the effective dimensions of the selection.\n    Rvalue_effdim <- Rvalue_dim[Rvalue_dim != 1L]\n    selection_effdim <- selection_dim[selection_dim != 1L]\n    if (!same_dims(Rvalue_effdim, selection_effdim))\n        stop(wmsg(\"dimensions of replacement value are incompatible \",\n                  \"with the selection of the subassignment\"))\n    dim(Rvalue) <- selection_dim\n    Rvalue\n}\n\n### 'Nindex' must be a \"multidimensional subsetting Nindex\" (see\n### R/Nindex-utils.R in the S4Arrays package) or NULL.\nnew_DelayedSubassign <- function(seed=new(\"array\"), Nindex=NULL, Rvalue=NA)\n{\n    Lindex <- S4Arrays:::normalize_Nindex(Nindex, seed)\n    seed_dim <- dim(seed)\n    nogap <- S4Arrays:::subscript_has_nogap(Lindex, seed_dim)\n    if (!(is.null(dim(Rvalue)) && is.vector(Rvalue) && length(Rvalue) == 1L)) {\n        selection_dim <- S4Arrays:::get_Nindex_lengths(Lindex, seed_dim)\n        Rvalue <- .normarg_Rvalue(Rvalue, selection_dim)\n        ## For each non-NULL subscript, keep **last** duplicate only and\n        ## replace all previous duplicates with NAs.\n        Lindex <- lapply(Lindex,\n            function(Li) {\n                if (is.null(Li))\n                    return(NULL)\n                Li[duplicated(Li, fromLast=TRUE)] <- NA_integer_\n                Li\n            })\n    }\n    new2(\"DelayedSubassign\", seed=seed, Lindex=Lindex, Rvalue=Rvalue,\n                             .nogap=nogap)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_noop() method\n###\n\n### Is the subassignment a no-op with respect to its \"seed\" slot? Note that\n### even when zero array elements are being replaced, the subassignment can\n### still alter the type.\nsetMethod(\"is_noop\", \"DelayedSubassign\",\n    function(x)\n    {\n        ## Is any array element being replaced by this subassignment?\n        if (all(S4Arrays:::get_Nindex_lengths(x@Lindex, dim(x@seed)) != 0L))\n            return(FALSE)\n        type(x) == type(x@seed)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedSubassign\n\n.DelayedSubassign_summary <- function(object) \"Subassign\"\n\nsummary.DelayedSubassign <-\n    function(object, ...) .DelayedSubassign_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedSubassign\", summary.DelayedSubassign)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### make_Mindex() and subset_DelayedSubassign()\n###\n\n### Do NOT use if 'x@Lindex' might contain duplicates! NAs are ok.\n### The returned index won't contain NAs along the dimensions with no gap\n### (i.e. along the dimensions for which 'x@.nogap' is TRUE).\nmake_Mindex <- function(index, x)\n{\n    stopifnot(is(x, \"DelayedSubassign\"),\n              is.list(index),\n              length(index) == length(x@Lindex))\n    x_dim <- dim(x)\n    lapply(seq_along(index),\n        function(along) {\n            i <- index[[along]]\n            Li <- x@Lindex[[along]]\n            if (is.null(Li))\n                return(i)\n            if (!is.null(i)) {\n                ## match() will do the right thing if 'Li' contains NAs but\n                ## NOT if it contains duplicates! This is because it will\n                ## find the match to the first duplicate when we need the\n                ## match to the last one.\n                return(match(i, Li))\n            }\n            d <- x_dim[[along]]\n            ## A slightly faster version of 'match(seq_len(d), Li)'. All the\n            ## non-NA values in 'Li' are supposed to be >= 1 and <= d.\n            m <- rep.int(NA_integer_, d)\n            nonNA_idx <- which(!is.na(Li))\n            m[Li[nonNA_idx]] <- seq_along(Li)[nonNA_idx]\n            m\n        })\n}\n\n### The returned index should never contain NAs!\n.get_Lindex2_from_Mindex <- function(Mindex, nogap)\n{\n    lapply(seq_along(Mindex),\n        function(along) {\n            if (nogap[[along]])\n                return(NULL)\n            m <- Mindex[[along]]\n            Li2 <- which(!is.na(m))\n            if (length(Li2) == length(m))\n                return(NULL)\n            Li2\n        })\n}\n\n### A more efficient version of .get_Lindex2_from_Mindex(make_Mindex(...))\n### that can only be used when the right value of the subassignment is an\n### ordinary vector of length 1.\n### Assume that 'x@Lindex' does NOT contain NAs. Duplicates are ok.\n### The returned index should never contain NAs!\n.make_Lindex2 <- function(index, x)\n{\n    stopifnot(is(x, \"DelayedSubassign\"),\n              is.list(index),\n              length(index) == length(x@Lindex))\n    lapply(seq_along(index),\n        function(along) {\n            if (x@.nogap[[along]])\n                return(NULL)\n            i <- index[[along]]\n            Li <- x@Lindex[[along]]\n            if (is.null(i))\n                return(Li)\n            Li2 <- which(i %in% Li)\n            if (length(Li2) == length(i))\n                return(NULL)\n            Li2\n        })\n}\n\n### The returned index should never contain NAs!\n.get_Rindex_from_Mindex <- function(Mindex, Lindex2)\n{\n    lapply(seq_along(Mindex),\n        function(along) {\n            m <- Mindex[[along]]\n            if (is.null(Lindex2[[along]]))\n                return(m)\n            m[!is.na(m)]\n        })\n}\n\n### 'index' is assumed to be a normalized Nindex compatible with\n### DelayedSubassign object 'x'.\n### Return a DelayedSubassign object that represents the action of subsetting\n### 'x' with 'index'. This new DelayedSubassign object is obtained by:\n### - replacing 'x@Lindex' with a left index that contains strictly sorted\n###   subscripts with no NAs;\n### - replacing 'x@seed' with a DelayedSubset object that represents the\n###   action of subsetting it with 'index';\n### - if 'x@Rvalue' is an array-like object, replacing it with a DelayedSubset\n###   object that represents the action of subsetting it with the index\n###   returned by .get_Rindex_from_Mindex().\nsubset_DelayedSubassign <- function(x, index=NULL)\n{\n    stopifnot(is(x, \"DelayedSubassign\"))\n    if (is.null(index))\n        index <- vector(\"list\", length=length(x@Lindex))\n    ans_seed <- new2(\"DelayedSubset\", seed=x@seed, index=index, check=FALSE)\n    if (is.null(dim(x@Rvalue))) {\n        ## 'x@Rvalue' is an ordinary vector (atomic or list) of length 1\n        ans_Lindex <- .make_Lindex2(index, x)\n        ans_Rvalue <- x@Rvalue\n    } else {\n        ## 'x@Rvalue' is an array-like object\n        Mindex <- make_Mindex(index, x)\n        ans_Lindex <- .get_Lindex2_from_Mindex(Mindex, x@.nogap)\n        Rindex <- .get_Rindex_from_Mindex(Mindex, ans_Lindex)\n        ans_Rvalue <- new2(\"DelayedSubset\", seed=x@Rvalue, index=Rindex,\n                                            check=FALSE)\n    }\n    ans_nogap <- S4Arrays:::subscript_has_nogap(ans_Lindex, dim(ans_seed))\n    new2(\"DelayedSubassign\", seed=ans_seed,\n                             Lindex=ans_Lindex,\n                             Rvalue=ans_Rvalue,\n                             .nogap=ans_nogap,\n                             check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n### We inherit the default dim() and dimnames() methods defined for\n### DelayedUnaryIsoOp derivatives, but overwite their extract_array() method.\n\n.extract_array_from_DelayedSubassign <- function(x, index)\n{\n    x2 <- subset_DelayedSubassign(x, index)\n    if (is.null(dim(x2@Rvalue))) {\n        ## 'x2@Rvalue' is an ordinary vector (atomic or list) of length 1\n        a2 <- x2@Rvalue\n    } else {\n        ## 'x2@Rvalue' is an array-like object\n        a2 <- extract_array(x2@Rvalue@seed, x2@Rvalue@index)\n    }\n    if (all(x2@.nogap)) {\n        if (is.null(dim(x2@Rvalue))) {\n            a_dim <- S4Arrays:::get_Nindex_lengths(index, dim(x2@seed))\n            a2 <- array(a2, a_dim)\n        }\n        return(a2)\n    }\n    a <- extract_array(x2@seed@seed, x2@seed@index)\n    S4Arrays:::replace_by_Nindex(a, x2@Lindex, a2)\n}\n\nsetMethod(\"extract_array\", \"DelayedSubassign\",\n    .extract_array_from_DelayedSubassign\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\nsetMethod(\"is_sparse\", \"DelayedSubassign\",\n    function(x) {\n        ## We return FALSE for now.\n        ## TODO: Implement this.\n        FALSE\n    }\n)\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedSubassign\",\n    function(x, index)\n    {\n        stop(\"NOT IMPLEMENTED YET!\")\n    }\n)\n\n",
        "DelayedSubset-class.R": "### =========================================================================\n### DelayedSubset objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed multi-dimensional single bracket subsetting\n### operation.\n###\n\nsetClass(\"DelayedSubset\",\n    contains=\"DelayedUnaryOp\",\n    representation(\n        index=\"list\"  # List of subscripts as positive integer vectors,\n                      # one per dimension in the input. **Missing** list\n                      # elements are allowed and represented by NULLs.\n    ),\n    prototype(\n        index=list(NULL)\n    )\n)\n\n.validate_DelayedSubset <- function(x)\n{\n    ## 'index' slot.\n    if (length(x@index) != length(dim(x@seed)))\n        return(\"'x@index' must have one list element per dimension in 'x@seed'\")\n    if (!is.null(names(x@index)))\n        return(\"'x@index' should not have names\")\n    ok <- lapply(x@index,\n              function(i) {is.null(i) || is.integer(i) && is.null(names(i))})\n    if (!all(unlist(ok)))\n        return(paste0(\"each list element in 'x@index' must be NULL \",\n                      \"or an integer vector with no names on it\"))\n    TRUE\n}\n\nsetValidity2(\"DelayedSubset\", .validate_DelayedSubset)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n### 'Nindex' must be a \"multidimensional subsetting Nindex\" (see\n### R/Nindex-utils.R in the S4Arrays package) or NULL.\nnew_DelayedSubset <- function(seed=new(\"array\"), Nindex=NULL)\n{\n    index <- S4Arrays:::normalize_Nindex(Nindex, seed)\n    new2(\"DelayedSubset\", seed=seed, index=index)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_noop() method\n###\n\nsetMethod(\"is_noop\", \"DelayedSubset\",\n    function(x) all(S4Vectors:::sapply_isNULL(x@index))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedSubset\n\n.DelayedSubset_summary <- function(object) \"Subset\"\n\nsummary.DelayedSubset <-\n    function(object, ...) .DelayedSubset_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedSubset\", summary.DelayedSubset)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n\nsetMethod(\"dim\", \"DelayedSubset\",\n    function(x) S4Arrays:::get_Nindex_lengths(x@index, dim(x@seed))\n)\n\nsetMethod(\"dimnames\", \"DelayedSubset\",\n    function(x) S4Arrays:::subset_dimnames_by_Nindex(dimnames(x@seed), x@index)\n)\n\nsubset_DelayedSubset <- function(x, index)\n{\n    stopifnot(is(x, \"DelayedSubset\"))\n    x_ndim <- length(x@index)\n    stopifnot(is.list(index), length(index) == x_ndim)\n    seed_dim <- dim(x@seed)\n    ## Would mapply() be faster here?\n    x@index <- lapply(seq_len(x_ndim),\n        function(along) {\n            i0 <- x@index[[along]]\n            i <- index[[along]]\n            if (is.null(i))\n                return(i0)\n            if (is.null(i0))\n                return(i)\n            ans <- i0[i]\n            if (isSequence(ans, of.length=seed_dim[[along]]))\n                return(NULL)\n            ans\n        })\n    x\n}\n\nsetMethod(\"extract_array\", \"DelayedSubset\",\n    function(x, index)\n    {\n        x2 <- subset_DelayedSubset(x, index)\n        extract_array(x2@seed, x2@index)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\nsetMethod(\"is_sparse\", \"DelayedSubset\",\n    function(x)\n    {\n        if (!is_sparse(x@seed))\n            return(FALSE)\n        ## Duplicates in x@index break structural sparsity.\n        !any(vapply(x@index, anyDuplicated,\n                    integer(1), USE.NAMES=FALSE))\n    }\n)\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedSubset\",\n    function(x, index)\n    {\n        x2 <- subset_DelayedSubset(x, index)\n        ## Assuming that the caller respected the \"extract_sparse_array()\n        ## contract\", 'is_sparse(x)' should be TRUE and the subscripts\n        ## in 'index' should not contain duplicates. This in turn means\n        ## that the subscripts in 'x2@index' should not contain\n        ## duplicates either so the call below should also respect\n        ## the \"extract_sparse_array() contract\".\n        extract_sparse_array(x2@seed, x2@index)\n    }\n)\n\n",
        "DelayedUnaryIsoOpStack-class.R": "### =========================================================================\n### DelayedUnaryIsoOpStack objects\n### -------------------------------------------------------------------------\n###\n### Representation of delayed unary isometric operations stacked (a.k.a.\n### piped) together.\n### That is:\n###\n###     out <- a |> OP1 |> OP2 |> ... |> OPk\n###\n### where:\n###   - OP1, OP2, ..., OPk are isometric array transformations i.e.\n###     operations that return an array with the same dimensions as\n###     the input array,\n###   - 'a' is the input array,\n###   - the output ('out') is an array of same dimensions as 'a'.\n###\n### In addition, each operation in the pipe must satisfy the property that\n### each value in the output array must be determined **solely** by the\n### corresponding value in the input array. In other words:\n###\n###     OP(a)[i_1, i_2, ..., i_n]\n###\n### must be equal to:\n###\n###     OP(a[i_1, i_2, ..., i_n])\n###\n### for any valid multidimensional index (i_1, i_2, ..., i_n).\n###\n### We refer to this property as the \"locality principle\".\n###\n### Concrete examples:\n###\n### 1. Things like is.na(), is.finite(), logical negation (!), nchar(),\n###    tolower().\n###\n### 2. Most functions in the Math and Math2 groups e.g. log(), sqrt(), abs(),\n###    ceiling(), round(), etc...\n###    Notable exceptions are the cum*() functions (cummin(), cummax(),\n###    cumsum(), and cumprod()): they don't satisfy the \"locality principle\".\n###\n### 3. Operations in the Ops group when one operand is an array and the\n###    other a scalar e.g. 'a + 10', '2 ^ a', 'a <= 1', etc...\n###\n\nsetClass(\"DelayedUnaryIsoOpStack\",\n    contains=\"DelayedUnaryIsoOp\",\n    representation(\n        OPS=\"list\"  # The functions to apply to the input i.e. to the\n                    # incoming array-like object. For example log\n                    # or function(x) log(x + 1). It should act as an\n                    # isomorphism i.e. always output an array-like\n                    # object **parallel** to the input (i.e. with the\n                    # same dimensions as the input).\n    ),\n    prototype(\n        OPS=list()\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nnew_DelayedUnaryIsoOpStack <- function(seed=new(\"array\"), OPS=list(),\n                                       check.op=FALSE)\n{\n    seed_dim <- dim(seed)\n    if (length(seed_dim) == 0L)\n        stop(wmsg(\"'seed' must have dimensions\"))\n\n    if (!is.list(OPS))\n        stop(wmsg(\"'OPS' must be a list\"))\n    OPS <- lapply(OPS, match.fun)\n\n    ans <- new2(\"DelayedUnaryIsoOpStack\", seed=seed, OPS=OPS)\n    if (check.op) {\n        ## We quickly test the validity of the operation by calling type()\n        ## on the returned object. This will fail if the operation cannot\n        ## be applied e.g. if the user does something like:\n        ##   M <- DelayedArray(matrix(character(12), ncol=3))\n        ##   M2 <- log(M)\n        ## The test is cheap and type() will be called anyway by show()\n        ## later when the user tries to display M2. Better fail early than\n        ## late!\n        type(ans)  # we ignore the returned value\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedUnaryIsoOpStack\n\n.DelayedUnaryIsoOpStack_summary <- function(object)\n{\n    sprintf(\"Stack of %d unary iso op(s)\", length(object@OPS))\n}\n\nsummary.DelayedUnaryIsoOpStack <-\n    function(object, ...) .DelayedUnaryIsoOpStack_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedUnaryIsoOpStack\", summary.DelayedUnaryIsoOpStack)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n### We inherit the default dim() and dimnames() methods defined for\n### DelayedUnaryIsoOp derivatives, but overwite their extract_array() method.\n\nsetMethod(\"extract_array\", \"DelayedUnaryIsoOpStack\",\n    function(x, index)\n    {\n        a <- extract_array(x@seed, index)\n        a_dim <- dim(a)\n        for (OP in x@OPS) {\n            a <- OP(a)\n            ## Some operations (e.g. dnorm()) don't propagate the \"dim\"\n            ## attribute if the input array is empty.\n            a <- S4Arrays:::set_or_check_dim(a, a_dim)\n        }\n        a\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\nsetMethod(\"is_sparse\", \"DelayedUnaryIsoOpStack\",\n    function(x)\n    {\n        if (!is_sparse(x@seed))\n            return(FALSE)\n        ## Structural sparsity will be propagated if the operations in\n        ## x@OPS preserve the zeros. To find out whether zeros are preserved\n        ## or not, we replace the current seed with an array of one \"zero\",\n        ## that is, with an ordinary array of the same number of dimensions\n        ## and type as the seed, but with a single \"zero\" element. Then we\n        ## apply the operations in x@OPS to it and see whether the zero was\n        ## preserved or not.\n        seed_ndim <- length(dim(x@seed))\n        x@seed <- S4Arrays:::make_one_zero_array(type(x@seed), seed_ndim)\n        ## Same as 'as.array(x)' but doesn't try to propagate the dimnames.\n        a0 <- extract_array(x, vector(\"list\", length=seed_ndim))\n        S4Arrays:::is_filled_with_zeros(a0)\n    }\n)\n\n### 'is_sparse(x)' is assumed to be TRUE and 'index' is assumed to\n### not contain duplicates. See \"extract_sparse_array() contract\"\n### in SparseArray/R/extract_sparse_array.R (SparseArray package).\nsetMethod(\"extract_sparse_array\", \"DelayedUnaryIsoOpStack\",\n    function(x, index)\n    {\n        ## Assuming that the caller respected the \"extract_sparse_array()\n        ## contract\", 'is_sparse(x)' should be TRUE so we can assume that\n        ## the operations in 'x@OPS' preserve the zeros which means that we\n        ## only need to apply them to the nonzero values.\n        svt <- extract_sparse_array(x@seed, index)\n        svt_nzvals <- nzvals(svt)\n        for (OP in x@OPS)\n            svt_nzvals <- OP(svt_nzvals)\n        nzvals(svt) <- svt_nzvals\n        type(svt) <- type(svt_nzvals)\n        svt\n    }\n)\n\n",
        "DelayedUnaryIsoOpWithArgs-class.R": "### =========================================================================\n### DelayedUnaryIsoOpWithArgs objects\n### -------------------------------------------------------------------------\n###\n### Representation of a delayed unary isometric operation with vector-like\n### arguments going along the dimensions of the input array.\n### That is:\n###\n###     out <- OP(L1, L2, ..., a, R1, R2, ...)\n###\n### where:\n###   - OP is an isometric array transformation i.e. an operation that\n###     returns an array with the same dimensions as the input array,\n###   - 'a' is the input array,\n###   - 'L1', 'L2', ..., are the left arguments,\n###   - 'R1', 'R2', ..., are the right arguments,\n###   - the output ('out') is an array of same dimensions as 'a'.\n###\n### Some of the arguments (left or right) can be vector-like arguments that\n### go along the dimensions of the input array. For example if 'a' is a\n### 12 x 150 x 5 array, argument 'L2' is considered to go along the 3rd\n### dimension if its length is 5 and if the result of:\n###\n###     OP(L1, L2[k], ..., a[ , , k, drop=FALSE], R1, R2, ...)\n###\n### is the same as 'out[ , , k, drop=FALSE]' for any index 'k'.\n###\n### More generally speaking, if, say, arguments 'L2', 'L3', 'R1', and 'R2'\n### go along the 3rd, 1st, 2nd, and 1st dimensions, respectively, then each\n### value in the output array ('out[i, j, k]') must be determined **solely**\n### by the corresponding values in the input array ('a[i, j, k]') and\n### arguments ('L2[k]', 'L3[i]', 'R1[j]', 'R2[i]').\n### In other words, 'out[i, j, k]' must be equal to:\n###\n###     OP(L1, L2[k], L3[i], ..., a[i, j, k], R1[j], R2[i], ...)\n###\n### for any 1 <= 'i' <= 12, 1 <= 'j' <= 150, and 1 <= 'k' <= 5.\n###\n### We refer to this property as the \"locality principle\".\n###\n### Concrete examples:\n###\n### 1. Addition (or any operation in the Ops group) of an array 'a' and an\n###    atomic vector 'v' of length 'dim(a)[[1]]':\n###    - `+`(a, v):  OP is `+`, right argument goes along the 1st dimension.\n###    - `<=`(a, v): OP is `<=`, right argument goes along the 1st dimension.\n###    - `&`(v, a):  OP is `&`, left argument goes along the 1st dimension.\n###\n### 2. scale(x, center=v1, scale=v2): OP is `scale`, right arguments 'center'\n###    and 'scale' go along the 2nd dimension.\n###\n### Note that if OP has no argument that goes along a dimension of\n### the input array, then the delayed operation is better represented with\n### a DelayedUnaryIsoOpStack object.\n###\n\nsetClass(\"DelayedUnaryIsoOpWithArgs\",\n    contains=\"DelayedUnaryIsoOp\",\n    representation(\n        ## 'OP' is the function to apply to the input array. For example `+`\n        ## or `<=`. Must be an isometric array transformation that satisfies\n        ## the \"locality principle\" (see above).\n        OP=\"function\",\n\n        ## 'Largs' and 'Rargs' are the left and right arguments to 'OP()',\n        ## respectively, i.e. the arguments to place before and after the\n        ## input array in the function call.\n        Largs=\"list\",\n        Rargs=\"list\",\n\n        ## 'Lalong' and 'Ralong' are integer vectors parallel to 'Largs' and\n        ## 'Rargs' respectively. 'Lalong[i]' indicates which dimension of\n        ## the input array the i-th left-argument ('Largs[[i]]') goes along.\n        ## An NA means that the argument doesn't go along any dimension.\n        Lalong=\"integer\",\n        Ralong=\"integer\"\n    ),\n    prototype(\n        OP=identity\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.normarg_Lalong_or_Ralong <- function(Lalong, Largs, seed_dim)\n{\n    if (identical(Lalong, NA))\n        return(rep.int(NA_integer_, length(Largs)))\n    if (!(is.numeric(Lalong) && length(Lalong) == length(Largs)))\n        stop(wmsg(\"'Lalong' and 'Ralong' must be integer vectors \",\n                  \"parallel to 'Largs' and 'Rargs', respectively\"))\n    if (!is.integer(Lalong))\n        Lalong <- as.integer(Lalong)\n    nonNA_idx <- which(!is.na(Lalong))\n    nonNA_Lalong <- Lalong[nonNA_idx]\n    if (S4Vectors:::anyMissingOrOutside(nonNA_Lalong, 1L, length(seed_dim)))\n        stop(wmsg(\"all non-NA values in 'Lalong' and 'Ralong' must \",\n                  \"be >= 1 and <= 'length(dim(seed))'\"))\n    if (any(Lalong != 1L, na.rm=TRUE))\n        stop(wmsg(\"arguments in 'Largs' and 'Rargs' can only go along \",\n                  \"the first dimension of the input array at the moment\"))\n    ok <- elementNROWS(Largs[nonNA_idx]) == seed_dim[nonNA_Lalong]\n    if (!all(ok))\n        stop(wmsg(\"some arguments in 'Largs' and/or 'Rargs' are not \",\n                  \"parallel to the dimension that they go along with\"))\n    Lalong\n}\n\nnew_DelayedUnaryIsoOpWithArgs <- function(seed=new(\"array\"),\n                                          OP=identity,\n                                          Largs=list(), Rargs=list(),\n                                          Lalong=NA, Ralong=NA,\n                                          check.op=FALSE)\n{\n    seed_dim <- dim(seed)\n    if (length(seed_dim) == 0L)\n        stop(wmsg(\"'seed' must have dimensions\"))\n\n    stopifnot(is.list(Largs), is.list(Rargs))\n    Lalong <- .normarg_Lalong_or_Ralong(Lalong, Largs, seed_dim)\n    Ralong <- .normarg_Lalong_or_Ralong(Ralong, Rargs, seed_dim)\n\n    OP <- match.fun(OP)\n\n    ans <- new2(\"DelayedUnaryIsoOpWithArgs\", seed=seed,\n                                             OP=OP,\n                                             Largs=Largs, Rargs=Rargs,\n                                             Lalong=Lalong, Ralong=Ralong)\n    if (check.op)\n        type(ans)  # we ignore the returned value\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Display\n###\n\n### S3/S4 combo for summary.DelayedUnaryIsoOpWithArgs\n\n.DelayedUnaryIsoOpWithArgs_summary <- function(object) \"Unary iso op with args\"\n\nsummary.DelayedUnaryIsoOpWithArgs <-\n    function(object, ...) .DelayedUnaryIsoOpWithArgs_summary(object, ...)\n\nsetMethod(\"summary\", \"DelayedUnaryIsoOpWithArgs\",\n    summary.DelayedUnaryIsoOpWithArgs\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Seed contract\n###\n### We inherit the default dim() and dimnames() methods defined for\n### DelayedUnaryIsoOp derivatives, but overwite their extract_array() method.\n\nsubset_args <- function(args, along, index)\n{\n    subset_arg <- function(arg, MARGIN) {\n        if (is.na(MARGIN))\n            return(arg)\n        i <- index[[MARGIN]]\n        if (is.null(i))\n            return(arg)\n        extractROWS(arg, i)\n    }\n    mapply(subset_arg, args, along, SIMPLIFY=FALSE, USE.NAMES=FALSE)\n}\n\nsetMethod(\"extract_array\", \"DelayedUnaryIsoOpWithArgs\",\n    function(x, index)\n    {\n        a <- extract_array(x@seed, index)\n\n        ## Subset the left and right arguments that go along a dimension.\n        Largs <- subset_args(x@Largs, x@Lalong, index)\n        Rargs <- subset_args(x@Rargs, x@Ralong, index)\n\n        ans <- do.call(x@OP, c(Largs, list(a), Rargs))\n\n        ## Some operations (e.g. dnorm()) don't propagate the \"dim\" attribute\n        ## if the input array is empty.\n        S4Arrays:::set_or_check_dim(ans, dim(a))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Propagation of sparsity\n###\n\n### DelayedUnaryIsoOpWithArgs object 'x' is considered to propagate sparsity\n### iff the zeros in 'x@seed' are realized as zeros in 'as.array(x)'.\n### For example if 'x@seed' is a 12 x 150 x 5 array and 'x@Larg[[2]]',\n### 'x@Larg[[3]]', 'x@Rarg[[1]]', and 'x@Rarg[[2]]', are vectors that go\n### along the 3rd, 1st, 2nd, and 1st dimensions, respectively, then by virtue\n### of the \"locality principle\" (see at top of this file), 'x' is considered\n### to propagate sparsity iff:\n###\n###    x@OP(x@Larg[[1]], x@Larg[[2]][k], x@Larg[[3]][i], ...,\n###         x@seed[i, j, k],\n###         x@Rarg[[1]][j], x@Rarg[[2]][i], ...)\n###\n### is a zero for any valid 3D index (i, j, k) for which 'a[i, j, k]' is a\n### zero. However, performing a test like this is equivalent to computing\n### the full output array which is not an option in general as it would\n### defeat the purpose of using delayed operations.\n###\n### So we use the following simplified test instead:\n###\n###   1. If 'x' has arguments that go along more than one dimension, we give\n###      up and declare that sparsity is not propagated.\n###\n###   2. Assuming that all the arguments in 'x' that go along a dimension go\n###      along **the same dimension**, say, the p-th dimension, then we can\n###      create a zero-filled ordinary array 'seed0' with the same number of\n###      dimensions as 'x@seed' but where all the dimensions are set to 1\n###      except the p-th dimension which we set to 'dim(x@seed)[[along]]'.\n###      Note that 'seed0' is parallel to all the vector-like arguments that\n###      go along the p-th dimension. Then if:\n###\n###        x@OP(x@Larg[[1]], x@Larg[[2]], ...,\n###             seed0,\n###             x@Rarg[[1]], x@Rarg[[2]], ...)\n###\n###      is an array (of the same geometry as 'seed0') filled with zeros,\n###      then we know that 'x' propagates zeros.\n###\n### Note that this test is simple and fast BUT it can produce false negatives,\n### that is, it cannot detect all the situations where sparsity is propagated.\nsetMethod(\"is_sparse\", \"DelayedUnaryIsoOpWithArgs\",\n    function(x)\n    {\n        if (!is_sparse(x@seed))\n            return(FALSE)\n        p <- setdiff(c(x@Lalong, x@Ralong), NA_integer_)\n        if (length(p) >= 2L)\n            return(FALSE)\n        seed_ndim <- length(dim(x@seed))\n        dim0 <- rep.int(1L, seed_ndim)\n        if (length(p) == 1L)\n            dim0[[p]] <- dim(x@seed)[[p]]\n        x@seed <- S4Arrays:::make_zero_filled_array(type(x@seed), dim0)\n        ## Same as 'as.array(x)' but doesn't try to propagate the dimnames.\n        a0 <- extract_array(x, vector(\"list\", length=seed_ndim))\n        S4Arrays:::is_filled_with_zeros(a0)\n    }\n)\n\nsetMethod(\"extract_sparse_array\", \"DelayedUnaryIsoOpWithArgs\",\n    function(x, index)\n    {\n        svt <- extract_sparse_array(x@seed, index)\n\n        ## Subset the left and right arguments that go along a dimension.\n        Largs <- subset_args(x@Largs, x@Lalong, index)\n        Rargs <- subset_args(x@Rargs, x@Ralong, index)\n\n        ans <- do.call(x@OP, c(Largs, list(svt), Rargs))\n    }\n)\n\n",
        "RealizationSink-class.R": "### =========================================================================\n### RealizationSink objects\n### -------------------------------------------------------------------------\n\n\n### Virtual class with no slots. Intended to be extended to support specific\n### realization backends. Concrete subclasses must implement the \"sink\n### contract\", that is:\n###   1) A constructor function where the first 3 arguments are 'dim',\n###      'dimnames', and 'type', in that order. Optionally it can have\n###      the 'as.sparse' argument, in which case this **must** be the 4th\n###      argument. It can have any additional argument.\n###   2) A dim(), dimnames(), and type() method.\n###   3) A write_block() method. It must return the modified array-like\n###      object 'sink'.\n###   4) A close() method (optional).\n###   5) Coercion to DelayedArray.\n###\n### Examples of RealizationSink concrete subclasses: arrayRealizationSink\n### (see below), RleRealizationSink (see RleArray-class.R),\n### HDF5RealizationSink and TENxRealizationSink (see HDF5Array package).\n\nsetClass(\"RealizationSink\", representation(\"VIRTUAL\"))\n\nsetGeneric(\"close\")\n\n### The default \"close\" method for RealizationSink objects is a no-op.\nsetMethod(\"close\", \"RealizationSink\", function(con) invisible(NULL))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### arrayRealizationSink objects\n###\n### The arrayRealizationSink class is a concrete RealizationSink subclass that\n### implements an in-memory realization sink.\n###\n\nsetClass(\"arrayRealizationSink\",\n    contains=\"RealizationSink\",\n    representation(\n        result_envir=\"environment\"\n    )\n)\n\n.get_arrayRealizationSink_result <- function(sink)\n{\n    get(\"result\", envir=sink@result_envir)\n}\n\n.set_arrayRealizationSink_result <- function(sink, result)\n{\n    assign(\"result\", result, envir=sink@result_envir)\n}\n\nsetMethod(\"dim\", \"arrayRealizationSink\",\n    function(x) dim(.get_arrayRealizationSink_result(x))\n)\n\narrayRealizationSink <- function(dim, dimnames=NULL, type=\"double\")\n{\n    result <- array(get(type)(0), dim=dim, dimnames=dimnames)\n    result_envir <- new.env(parent=emptyenv())\n    sink <- new(\"arrayRealizationSink\", result_envir=result_envir)\n    .set_arrayRealizationSink_result(sink, result)\n    sink\n}\n\nsetMethod(\"write_block\", \"arrayRealizationSink\",\n    function(sink, viewport, block)\n    {\n        result <- .get_arrayRealizationSink_result(sink)\n        result <- write_block(result, viewport, block)\n        .set_arrayRealizationSink_result(sink, result)\n    }\n)\n\nsetAs(\"arrayRealizationSink\", \"DelayedArray\",\n    function(from) DelayedArray(.get_arrayRealizationSink_result(from))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Get/set the \"realization backend\" for the current session\n###\n\n.auto_realization_backend_envir <- new.env(parent=emptyenv())\n\ngetAutoRealizationBackend <- function()\n{\n    S4Arrays:::get_user_option(\"auto.realization.backend\")\n}\n\n.REGISTERED_REALIZATION_BACKENDS <- data.frame(\n    BACKEND=c(\"RleArray\", \"HDF5Array\", \"TENxMatrix\"),\n    package=c(\"DelayedArray\", \"HDF5Array\", \"HDF5Array\"),\n    realization_sink_class=c(\"RleRealizationSink\",\n                             \"HDF5RealizationSink\",\n                             \"TENxRealizationSink\"),\n    stringsAsFactors=FALSE\n)\n\nregisteredRealizationBackends <- function()\n{\n    ans <- .REGISTERED_REALIZATION_BACKENDS[ , c(\"BACKEND\", \"package\")]\n    backend <- getAutoRealizationBackend()\n    Lcol <- ifelse(ans[ , \"BACKEND\"] %in% backend, \"->\", \"\")\n    Rcol <- ifelse(ans[ , \"BACKEND\"] %in% backend, \"<-\", \"\")\n    cbind(data.frame(` `=Lcol, check.names=FALSE),\n          ans,\n          data.frame(` `=Rcol, check.names=FALSE))\n}\n\nsupportedRealizationBackends <- function()\n{\n    .Deprecated(\"registeredRealizationBackends\")\n    registeredRealizationBackends()\n}\n\n### NOT exported.\nload_BACKEND_package <- function(BACKEND)\n{\n    if (!isSingleString(BACKEND))\n        stop(wmsg(\"'BACKEND' must be a single string or NULL\"))\n    backends <- .REGISTERED_REALIZATION_BACKENDS\n    m <- match(BACKEND, backends[ , \"BACKEND\"])\n    if (is.na(m))\n        stop(wmsg(\"Realization backend \", BACKEND, \" is not registered \",\n                  \"in the DelayedArray package. Please use \",\n                  \"registeredRealizationBackends() to get the list of \",\n                  \"realization backends that are currently registered \",\n                  \"in the package.\"))\n    package <- backends[ , \"package\"][[m]]\n    class_package <- attr(BACKEND, \"package\")\n    if (is.null(class_package)) {\n        attr(BACKEND, \"package\") <- package\n    } else if (!identical(package, class_package)) {\n        stop(wmsg(\"\\\"package\\\" attribute on supplied 'BACKEND' is \",\n                  \"inconsistent with package normally associated with \",\n                  \"this realization backend\"))\n    }\n    S4Arrays:::load_package_gracefully(package, \"using the \",\n                                       BACKEND, \" realization backend\")\n    stopifnot(getClass(BACKEND)@package == package)\n}\n\n.check_realization_sink_constructor <- function(realization_sink_constructor)\n{\n    stopifnot(is.function(realization_sink_constructor))\n    ok <- identical(head(formalArgs(realization_sink_constructor), n=3L),\n                    c(\"dim\", \"dimnames\", \"type\"))\n    if (!ok)\n        stop(wmsg(\"the first 3 arguments of a RealizationSink constructor \",\n                  \"function must be 'dim', 'dimnames', and 'type', in \",\n                  \"that order\"))\n    ## Either 'realization_sink_constructor' has the 'as.sparse' argument,\n    ## in which case it **must** be in 4th position, or it does not have it.\n    m <- match(\"as.sparse\", formalArgs(realization_sink_constructor))\n    if (!(m %in% c(4L, NA_integer_)))\n        stop(wmsg(\"RealizationSink constructor functions with an 'as.sparse' \",\n                  \"argument must have it in 4th position\"))\n}\n\n.get_realization_sink_constructor <- function(BACKEND)\n{\n    backends <- .REGISTERED_REALIZATION_BACKENDS\n    m <- match(BACKEND, backends[ , \"BACKEND\"])\n    realization_sink_class <- backends[ , \"realization_sink_class\"][[m]]\n    package <- backends[ , \"package\"][[m]]\n    realization_sink_constructor <- get(realization_sink_class,\n                                        envir=.getNamespace(package),\n                                        inherits=FALSE)\n    .check_realization_sink_constructor(realization_sink_constructor)\n    realization_sink_constructor\n}\n\nsetAutoRealizationBackend <- function(BACKEND=NULL)\n{\n    if (is.null(BACKEND)) {\n        remove(list=ls(envir=.auto_realization_backend_envir),\n               envir=.auto_realization_backend_envir)\n    } else {\n        load_BACKEND_package(BACKEND)\n        auto_realization_sink_constructor <-\n            .get_realization_sink_constructor(BACKEND)\n        assign(\"AUTO_REALIZATION_SINK_CONSTRUCTOR\",\n               auto_realization_sink_constructor,\n               envir=.auto_realization_backend_envir)\n    }\n    S4Arrays:::set_user_option(\"auto.realization.backend\", BACKEND)\n    return(invisible(NULL))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Backend-agnostic RealizationSink constructor\n###\n\n.get_auto_realization_sink_constructor <- function()\n{\n    if (is.null(getAutoRealizationBackend()))\n        return(arrayRealizationSink)\n    auto_realization_sink_constructor <-\n        try(get(\"AUTO_REALIZATION_SINK_CONSTRUCTOR\",\n                envir=.auto_realization_backend_envir),\n                silent=TRUE)\n    if (is(auto_realization_sink_constructor, \"try-error\"))\n        stop(wmsg(\"This operation requires a \\\"realization backend\\\". \",\n                  \"Please see '?setAutoRealizationBackend' for how \",\n                  \"to set one.\"))\n    auto_realization_sink_constructor\n}\n\n.AutoRealizationSink <- function(dim, dimnames=NULL, type=\"double\",\n                                 as.sparse=FALSE, ...)\n{\n    realization_sink_constructor <- .get_auto_realization_sink_constructor()\n    args <- list(dim, dimnames, type)\n    formal_args <- formalArgs(realization_sink_constructor)\n    if (length(formal_args) >= 4L && formal_args[[4L]] == \"as.sparse\")\n        args <- c(args, list(as.sparse=as.sparse))\n    args <- c(args, list(...))\n    do.call(realization_sink_constructor, args)\n}\n\nAutoRealizationSink <- function(dim, dimnames=NULL, type=\"double\",\n                                as.sparse=FALSE)\n{\n    .AutoRealizationSink(dim, dimnames, type, as.sparse)\n}\n\n### Not exported.\nRealizationSink <- function(BACKEND, ...)\n{\n    OLD_BACKEND <- getAutoRealizationBackend()\n    setAutoRealizationBackend(BACKEND)\n    on.exit(setAutoRealizationBackend(OLD_BACKEND))\n    .AutoRealizationSink(...)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### sinkApply()\n###\n### Thin wrapper around gridReduce().\n###\n### Note that, despite its name, this is actually a convenience wrapper\n### around gridReduce(), and **not** around gridApply(). However, we call it\n### sinkApply() and make its interface look similar to the gridApply/blockApply\n### interface because this seems more user-friendly.\n### Finally note that an important difference with gridReduce() is that the\n### first two arguments of callback function 'FUN' are expected to be 'sink'\n### and 'viewport' (in that order) rather than 'viewport' and 'init'.\n\nsinkApply <- function(sink, FUN, ..., grid=NULL, verbose=NA)\n{\n    if (!is(sink, \"RealizationSink\"))\n        stop(wmsg(\"'sink' must be a RealizationSink derivative\"))\n    FUN <- match.fun(FUN)\n    grid <- normarg_sink_grid(grid, sink)\n    verbose <- normarg_verbose(verbose)\n\n    ## Only purpose of this wrapper is to swap the order of the first\n    ## two arguments.\n    FUN_WRAPPER <- function(viewport, init, FUN, ...)\n    {\n        effective_grid <- effectiveGrid()\n        current_block_id <- currentBlockId()\n        set_grid_context(effective_grid, current_block_id, viewport)\n        FUN(init, viewport, ...)\n    }\n    gridReduce(FUN_WRAPPER, grid, sink, FUN, ..., verbose=verbose)\n}\n\n",
        "RleArray-class.R": "### =========================================================================\n### RleArray objects\n### -------------------------------------------------------------------------\n###\n### Note that we could just wrap an RleArraySeed object in a DelayedArray\n### object to represent and manipulate an Rle-encoded array as a DelayedArray\n### object. So, strictly speaking, we don't really need the RleArray and\n### RleMatrix classes. However, we define these classes mostly for cosmetic\n### reasons, that is, to hide the DelayedArray and DelayedMatrix classes\n### from the user. So the user will see and manipulate RleArray and\n### RleMatrix objects instead of DelayedArray and DelayedMatrix objects.\n###\n\nsetClass(\"RleArray\",\n    contains=\"DelayedArray\",\n    representation(seed=\"RleArraySeed\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nsetMethod(\"DelayedArray\", \"RleArraySeed\",\n    function(seed) new_DelayedArray(seed, Class=\"RleArray\")\n)\n\n### 'data' must be an Rle object or a list-like object where all the list\n### elements are Rle objects. In the former case, and if 'chunksize' is\n### not specified, the returned RleArray will be a \"solid\" RleArray i.e.\n### its seed will be a SolidRleArraySeed object. Otherwise it will be\n### \"chunked\" i.e. its seed will be a ChunkedRleArraySeed object.\n### In addition RleArray() also works directly on an RleArraySeed object,\n### in which case it must be called with a single argument.\nRleArray <- function(data, dim, dimnames, chunksize=NULL)\n{\n    if (is(data, \"RleArraySeed\")) {\n        if (!(missing(dim) && missing(dimnames) && is.null(chunksize)))\n            stop(wmsg(\"RleArray() must be called with a single argument \",\n                      \"when passed an RleArraySeed object\"))\n        seed <- data\n    } else {\n        seed <- RleArraySeed(data, dim, dimnames, chunksize=chunksize)\n    }\n    DelayedArray(seed)\n}\n\n### Deconstruction.\n### The returned Rle has the length of the RleArray object.\nsetAs(\"RleArray\", \"Rle\", function(from) as(from@seed, \"Rle\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### RleMatrix objects\n###\n\nsetClass(\"RleMatrix\", contains=c(\"RleArray\", \"DelayedMatrix\"))\n\n### Required for DelayedArray internal business.\nsetMethod(\"matrixClass\", \"RleArray\", function(x) \"RleMatrix\")\n\n### Automatic coercion method from RleArray to RleMatrix silently returns\n### a broken object (unfortunately these dummy automatic coercion methods\n### don't bother to validate the object they return). So we overwrite it.\nsetAs(\"RleArray\", \"RleMatrix\", function(from) new2(\"RleMatrix\", from))\n\n### The user should not be able to degrade an RleMatrix object to\n### an RleArray object so 'as(x, \"RleArray\", strict=TRUE)' should\n### fail or be a no-op when 'x' is an RleMatrix object. Making this\n### coercion a no-op seems to be the easiest (and safest) way to go.\nsetAs(\"RleMatrix\", \"RleArray\", function(from) from)  # no-op\n\nsetAs(\"ANY\", \"RleMatrix\",\n    function(from) as(as(from, \"RleArray\"), \"RleMatrix\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Switching between RleList and RleMatrix\n###\n\n### From RleList to RleMatrix.\n### Return an RleMatrix object with 1 column per list element in the RleList\n### object. More precisely, when the RleList object has at least 1 column,\n### the returned RleMatrix object is \"chunked\" and has 1 chunk per column\n### (so 1 chunk per list element in the original RleList object).\n.from_RleList_to_RleMatrix <- function(from)\n{\n    if (length(from) != 0L) {\n        from_lens <- lengths(from, use.names = FALSE)\n        from1_len <- from_lens[[1L]]\n        if (!all(from_lens == from1_len))\n            stop(wmsg(\"all the list elements in the RleList object \",\n                      \"to coerce must have the same length\"))\n    }\n    RleArray(from)\n}\n\nsetAs(\"RleList\", \"RleArray\", .from_RleList_to_RleMatrix)\n\n### From RleMatrix to RleList.\n### Return an RleList object with 1 list element per column in the RleMatrix\n### object. More precisely, when the length of the RleMatrix object is < 2^31,\n### then a CompressedRleList object is returned. Otherwise, a SimpleRleList\n### object is returned. Note that in this case, the current implementation\n### only knows how to handle the situation where the RleMatrix has 1 chunk\n### per column.\n.from_RleMatrix_to_RleList <- function(from)\n{\n    if (length(from) <= .Machine$integer.max) {\n        unlisted_ans <- as(from, \"Rle\")\n        ans_breakpoints <- seq_len(ncol(from)) * nrow(from)\n        ans_partitioning <- PartitioningByEnd(ans_breakpoints,\n                                              names=colnames(from))\n        return(relist(unlisted_ans, ans_partitioning))\n    }\n    ## 'from@seed' is guaranteed to be a ChunkedRleArraySeed object.\n    chunk_lens <- get_chunk_lengths(from@seed@chunks)\n    if (!all(chunk_lens == nrow(from)))\n        stop(wmsg(\"coercing this RleMatrix object to an RleArray object \",\n                  \"is not supported at the moment\"))\n    setNames(as(from@seed, \"RleList\"), colnames(from))\n}\n\nsetAs(\"RleMatrix\", \"RleList\", .from_RleMatrix_to_RleList)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Switching between DataFrame and RleMatrix\n###\n\n### From DataFrame to RleMatrix.\n.from_DataFrame_to_RleMatrix <- function(from)\n{\n    as(DelayedArray(from), \"RleMatrix\")\n}\n\nsetAs(\"DataFrame\", \"RleArray\", .from_DataFrame_to_RleMatrix)\n\n### From RleMatrix to DataFrame.\n.from_RleMatrix_to_DataFrame <- function(from)\n{\n    listData <- as.list(as(from, \"RleList\"))\n    ans <- S4Vectors:::new_DataFrame(listData, nrows=nrow(from))\n    rownames(ans) <- rownames(from)\n    ans\n}\n\nsetAs(\"RleMatrix\", \"DataFrame\", .from_RleMatrix_to_DataFrame)\n\n### From DelayedMatrix to DataFrame.\nsetAs(\"DelayedMatrix\", \"DataFrame\",\n    function(from) as(as(from, \"RleMatrix\"), \"DataFrame\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Realization as an RleArray object\n###\n\n### WARNING: This method assumes that the blocks are \"linear\" and being\n### written in order. Even though this is still the case, this will change\n### soon and this change will break it!\n### FIXME: The method below must write the block to 'sink' at the location\n### specified by the supplied 'viewport'.\nsetMethod(\"write_block\", \"RleRealizationSink\",\n    function(sink, viewport, block)\n    {\n        ## 'block' is either an ordinary array or SparseArray derivative\n        ## (SVT_SparseArray or COO_SparseArray object).\n        ## 'viewport' is ignored!\n        append_Rle_to_sink(Rle(as.vector(block)), sink)\n        sink\n    }\n)\n\nsetAs(\"RleRealizationSink\", \"RleArray\",\n    function(from) DelayedArray(as(from, \"ChunkedRleArraySeed\"))\n)\n\nsetAs(\"RleRealizationSink\", \"DelayedArray\", function(from) as(from, \"RleArray\"))\n\n.as_RleArray <- function(from)\n{\n    sink <- RleRealizationSink(dim(from), dimnames(from), type(from))\n    BLOCK_write_to_sink(sink, from)\n    as(sink, \"RleArray\")\n}\n\nsetAs(\"ANY\", \"RleArray\", .as_RleArray)\n\n### Automatic coercion methods from DelayedArray to RleArray and from\n### DelayedMatrix to RleMatrix silently return broken objects (unfortunately\n### these dummy automatic coercion methods don't bother to validate the object\n### they return). So we overwrite them.\nsetAs(\"DelayedArray\", \"RleArray\", .as_RleArray)\nsetAs(\"DelayedMatrix\", \"RleMatrix\", .as_RleArray)\n\n",
        "RleArraySeed-class.R": "### =========================================================================\n### RleArraySeed objects\n### -------------------------------------------------------------------------\n\n\nsetClass(\"RleArraySeed\",\n    contains=\"Array\",\n    representation(\n        \"VIRTUAL\",\n        ## Must use upper case or won't be able to extend the class.\n        ## See https://stat.ethz.ch/pipermail/r-devel/2017-June/074383.html\n        DIM=\"integer\",\n        DIMNAMES=\"list\"\n    )\n)\n\n### We don't support long SolidRleArraySeed objects yet! This would first\n### require that S4Vectors:::extract_positions_from_Rle() accepts 'pos' as\n### a numeric vector.\nsetClass(\"SolidRleArraySeed\",\n    contains=\"RleArraySeed\",\n    representation(\n        rle=\"Rle\"\n    )\n)\n\n### The RleRealizationSink class is a concrete RealizationSink subclass that\n### implements realization of an array-like object as an RleArray object.\n### Once writing the array data to the RleRealizationSink object is complete,\n### the object will be turned into a ChunkedRleArraySeed object that will be\n### used as the seed of the RleArray object.\nsetClass(\"RleRealizationSink\",\n    contains=c(\"RleArraySeed\", \"RealizationSink\"),\n    representation(\n        type=\"character\",                     # Single string.\n        ## TODO: Add the 2 slots below to make RleRealizationSink\n        ## support a RegularArrayGrid of chunks.\n        #chunk_grid=\"RegularArrayGrid\",        # Of length N.\n        #chunk_runs_along_last_dim=\"logical\",  # Of length N.\n        chunks=\"environment\"                  # Of length N (once all the\n                                              # chunks are written).\n    )\n)\n\nsetMethod(\"type\", \"RleRealizationSink\", function(x) x@type)\n\n#setMethod(\"chunkdim\", \"RleRealizationSink\",\n#    function(x) dim(x@chunk_grid[[1L]])\n#)\n\n### We support long ChunkedRleArraySeed objects but the chunks cannot be long.\n### Note that supporting long chunks would require (at least) that:\n###   1) we support long ArrayViewport objects,\n###   2) S4Vectors:::extract_positions_from_Rle() accepts 'pos' as a numeric\n###      vector.\nsetClass(\"ChunkedRleArraySeed\",\n    contains=\"RleRealizationSink\",\n    representation(\n        ## A numeric vector of length the nb of chunks. Contains the cumulated\n        ## lengths of the chunks so must be \"numeric\" (and not \"integer\") to\n        ## support long objects. A chunk cannot be empty so 'breakpoints' must\n        ## contain *strictly* sorted positive values.\n        ## If the object is of length 0, then 'breakpoints' is empty.\n        ## Otherwise, its last element must equal the length of the object.\n        breakpoints=\"numeric\"\n    )\n)\n\n## TODO: Replace ChunkedRleArraySeed above definition with definition below\n## to make ChunkedRleArraySeed support a RegularArrayGrid of chunks.\n#setClass(\"ChunkedRleArraySeed\", contains=\"RleRealizationSink\")\n\n#setMethod(\"vertical_slot_names\", \"ChunkedRleArraySeed\",\n#    function(x) c(\"chunk_grid\", \"chunk_runs_along_last_dim\", \"chunks\")\n#)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level chunk accessors\n###\n\n.get_chunk <- function(envir, k)\n{\n    name <- sprintf(\"%06d\", k)\n    stopifnot(nchar(name) == 6L)\n    get(name, envir=envir, inherits=FALSE)\n}\n\nget_chunk_lengths <- function(envir)\n{\n    ## Too bad we can't just do 'lengths(envir)' for this.\n    ## Also would have been nice to be able to just do\n    ## 'unlist(eapply(envir, length))' but the list returned by eapply()\n    ## is not guaranteed to be sorted and eapply() does not have a 'sorted'\n    ## argument. So would need to manually sort it.\n    ## Another possibility would be to vapply() on the sorted symbols\n    ## returned by 'ls(envir, sorted=TRUE)'.\n    vapply(seq_len(length(envir)),\n           function(k) length(.get_chunk(envir, k)),\n           numeric(1))\n}\n\n.set_chunk <- function(envir, k, chunk)\n{\n    name <- sprintf(\"%06d\", k)\n    stopifnot(nchar(name) == 6L)\n    assign(name, chunk, envir=envir)\n}\n\n.append_chunk <- function(envir, chunk)\n{\n    .set_chunk(envir, length(envir) + 1L, chunk)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.validate_RleArraySeed <- function(x)\n{\n    msg <- S4Arrays:::validate_dim_slot(x, \"DIM\")\n    if (!isTRUE(msg))\n        return(msg)\n    msg <- S4Arrays:::validate_dimnames_slot(x, x@DIM, \"DIMNAMES\")\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\nsetValidity2(\"RleArraySeed\", .validate_RleArraySeed)\n\n.validate_SolidRleArraySeed <- function(x)\n{\n    ## 'rle' slot.\n    if (!is(x@rle, \"Rle\"))\n        return(\"'rle' slot must be an Rle object\")\n    x_len <- length(x)\n    data_len <- length(x@rle)\n    if (x_len != data_len)\n        return(paste0(\"object dimensions [product \", x_len, \"] do not \",\n                      \"match the length of its data [\" , data_len, \"]\"))\n    ## Until S4Vectors:::extract_positions_from_Rle() accepts 'pos' as a\n    ## numeric vector, we cannot support long SolidRleArraySeed objects.\n    if (x_len > .Machine$integer.max)\n        return(\"long SolidRleArraySeed objects are not supported yet\")\n    TRUE\n}\nsetValidity2(\"SolidRleArraySeed\", .validate_SolidRleArraySeed)\n\n.validate_RleRealizationSink <- function(x)\n{\n    ## 'type' slot.\n    if (!isSingleString(x@type))\n        return(\"'type' slot must be a single string\")\n\n    ## TODO: Add the 2 checks below when RleRealizationSink supports a\n    ## RegularArrayGrid of chunks.\n    ## 'chunk_grid' slot.\n    #if (!is(x@chunk_grid, \"RegularArrayGrid\"))\n    #    return(\"'chunk_grid' slot must be a RegularArrayGrid object\")\n    #if (!identical(x@DIM, refdim(x@chunk_grid)))\n    #    return(\"'chunk_grid' slot must be a grid that fits the object\")\n    ## 'chunk_runs_along_last_dim' slot.\n    #if (!is.logical(x@chunk_runs_along_last_dim))\n    #    return(\"'chunk_runs_along_last_dim' slot must be a logical vector\")\n\n    ## 'chunks' slot.\n    if (!is.environment(x@chunks))\n        return(\"'chunks' slot must be an environment\")\n    # TODO: Validate the content of 'chunks'.\n    TRUE\n}\nsetValidity2(\"RleRealizationSink\", .validate_RleRealizationSink)\n\n.get_data_length_from_breakpoints <- function(breakpoints)\n{\n    breakpoints_len <- length(breakpoints)\n    if (breakpoints_len == 0L) 0L else breakpoints[[breakpoints_len]]\n}\n\n.validate_ChunkedRleArraySeed <- function(x)\n{\n    ## 'breakpoints' slot.\n    if (!is.numeric(x@breakpoints)\n     || S4Vectors:::anyMissing(x@breakpoints)\n     || is.unsorted(x@breakpoints, strictly=TRUE)\n     || length(x@breakpoints) != 0L && x@breakpoints[[1L]] <= 0L)\n        return(paste0(\"'x@breakpoints' must be a numeric vector containing \",\n                      \"strictly sorted positive values\"))\n    x_len <- length(x)\n    data_len <- .get_data_length_from_breakpoints(x@breakpoints)\n    if (data_len != x_len)\n        return(paste0(\"length of object data [\" , data_len, \"] does not \",\n                      \"match object dimensions [product \", x_len, \"]\"))\n    chunk_lens <- diff(c(0, x@breakpoints))  # chunk lengths as inferred\n                                             # from 'breakpoints'\n    ## Until S4Vectors:::extract_positions_from_Rle() accepts 'pos' as a\n    ## numeric vector, the chunks cannot be long Rle objects.\n    if (any(chunk_lens > .Machine$integer.max))\n        return(\"ChunkedRleArraySeed objects do not support long chunks yet\")\n    # TODO: Check that the chunk lengths as inferred from 'breakpoints'\n    # actually match the real ones.\n    TRUE\n}\n\n### TODO: Replace validity method above with simpler method below when\n### ChunkedRleArraySeed supports a RegularArrayGrid of chunks.\n#.validate_ChunkedRleArraySeed <- function(x)\n#{\n#    ## 'chunk_runs_along_last_dim' slot.\n#    if (anyNA(x@chunk_runs_along_last_dim))\n#        return(paste0(\"'chunk_runs_along_last_dim' slot must \",\n#                      \"be a logical vector with no NAs\"))\n#    ## 'chunks' slot.\n#    if (!identical(lengths(x@chunk_grid), get_chunk_lengths(x@chunks)))\n#        return(\"chunk lengths don't match chunking grid element lengths\")\n#    TRUE\n#}\nsetValidity2(\"ChunkedRleArraySeed\", .validate_ChunkedRleArraySeed)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"dim\", \"RleArraySeed\", function(x) x@DIM)\n\nsetMethod(\"dimnames\", \"RleArraySeed\",\n    function(x) S4Arrays:::simplify_NULL_dimnames(x@DIMNAMES)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going from RleArraySeed to Rle or RleList\n###\n\nsetAs(\"SolidRleArraySeed\", \"Rle\", function(from) from@rle)\n\n### Return an unnamed RleList object with 1 list element per chunk in 'from'.\nsetAs(\"RleRealizationSink\", \"RleList\",\n    function(from)\n    {\n        ## When the object is empty, return a CompressedRleList, NOT a\n        ## SimpleRleList object, so unlist() can be used on it.\n        if (length(from@chunks) == 0L)\n            return(as(Rle(vector(from@type)), \"CompressedRleList\"))\n        chunks <- unname(as.list(from@chunks, sorted=TRUE))\n        chunks <- lapply(chunks,\n               function(chunk) {\n                   chunk_vals <- runValue(chunk)\n                   if (typeof(chunk_vals) != from@type) {\n                       storage.mode(chunk_vals) <- from@type\n                       runValue(chunk) <- chunk_vals\n                   }\n                   chunk\n               })\n        as(chunks, \"SimpleRleList\")\n    }\n)\n\n### In practice this coercion is not used on an RleRealizationSink instance\n### but on a *ChunkedRleArraySeed* instance (e.g. by coercion methods from\n### ChunkedRleArraySeed to SolidRleArraySeed or from RleArray to Rle defined\n### below in this file).\nsetAs(\"RleRealizationSink\", \"Rle\",\n    function(from) unlist(as(from, \"RleList\"), use.names=FALSE)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_array()\n###\n\n.extract_array_from_SolidRleArraySeed <- function(x, index)\n{\n    x_dim <- dim(x)\n    i <- S4Arrays:::to_linear_index(index, x_dim)\n    ans <- S4Vectors:::extract_positions_from_Rle(x@rle, i, decoded=TRUE)\n    S4Arrays:::set_dim(ans, S4Arrays:::get_Nindex_lengths(index, x_dim))\n}\nsetMethod(\"extract_array\", \"SolidRleArraySeed\",\n    .extract_array_from_SolidRleArraySeed\n)\n\n.extract_array_from_ChunkedRleArraySeed <- function(x, index)\n{\n    x_dim <- dim(x)\n    i <- S4Arrays:::to_linear_index(index, x_dim)\n    ans <- vector(x@type)\n    if (length(i) != 0L) {\n        part_idx <- S4Arrays:::get_part_index(i, x@breakpoints)\n        split_part_idx <- S4Arrays:::split_part_index(part_idx,\n                                                      length(x@breakpoints))\n        chunk_idx <- which(lengths(split_part_idx) != 0L)  # chunks to visit\n        res <- lapply(chunk_idx, function(i1) {\n            chunk <- .get_chunk(x@chunks, i1)\n            ## Because a valid ChunkedRleArraySeed object is guaranteed to not\n            ## contain long chunks at the moment, 'i2' can be represented as\n            ## an integer vector.\n            i2 <- as.integer(split_part_idx[[i1]])\n            S4Vectors:::extract_positions_from_Rle(chunk, i2, decoded=TRUE)\n        })\n        res <- c(list(ans), res)\n        ans <- unlist(res, use.names=FALSE)[S4Arrays:::get_rev_index(part_idx)]\n    }\n    S4Arrays:::set_dim(ans, S4Arrays:::get_Nindex_lengths(index, x_dim))\n}\nsetMethod(\"extract_array\", \"ChunkedRleArraySeed\",\n    .extract_array_from_ChunkedRleArraySeed\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### RleRealizationSink constructor\n###\n\n### NOT exported!\nRleRealizationSink <- function(dim, dimnames=NULL, type=\"double\")\n{\n    dim <- S4Arrays:::normarg_dim(dim)\n    dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    chunks <- new.env(hash=TRUE, parent=emptyenv())\n    new2(\"RleRealizationSink\", DIM=dim, DIMNAMES=dimnames,\n                               type=type, chunks=chunks)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SolidRleArraySeed and ChunkedRleArraySeed low-level constructors\n###\n\n.new_SolidRleArraySeed <- function(data, dim, dimnames)\n{\n    if (!is(data, \"Rle\"))\n        stop(wmsg(\"invalid 'data'\"))\n    new2(\"SolidRleArraySeed\", DIM=dim, DIMNAMES=dimnames, rle=data)\n}\n\nappend_Rle_to_sink <- function(x, sink)\n{\n    stopifnot(is(x, \"Rle\"))\n    if (length(x) == 0L)\n        return()  # nothing to do\n    if (sink@type == \"integer\") {\n        x_vals <- runValue(x)\n        ## Replace integer-Rle with raw-Rle if this doesn't loose\n        ## information.\n        if (!S4Vectors:::anyMissingOrOutside(x_vals, 0L, 255L))\n            runValue(x) <- as.raw(x_vals)\n    }\n    .append_chunk(sink@chunks, x)\n}\n\n### This coercion is used by .new_ChunkedRleArraySeed() and by the\n### coercion method from RleRealizationSink to RleArray.\nsetAs(\"RleRealizationSink\", \"ChunkedRleArraySeed\",\n    function(from)\n    {\n        breakpoints <- cumsum(as.double(get_chunk_lengths(from@chunks)))\n        new2(\"ChunkedRleArraySeed\", from, breakpoints=breakpoints)\n    }\n)\n\n### 'data' is assumed to be a list-like object where all the list elements\n### are Rle objects of type 'type'. This is NOT checked!\n.new_ChunkedRleArraySeed <- function(data, dim, dimnames, type)\n{\n    sink <- RleRealizationSink(dim, dimnames, type)\n    for (k in seq_along(data))\n        append_Rle_to_sink(data[[k]], sink)\n    as(sink, \"ChunkedRleArraySeed\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### RleArraySeed high-level constructor\n###\n\n### 'data' must be an Rle object. This is not checked.\n### If 'chunksize' is not specified, return a SolidRleArraySeed instance.\n### Otherwise return a ChunkedRleArraySeed instance.\n.make_RleArraySeed_from_Rle <- function(data, dim, dimnames, chunksize=NULL)\n{\n    dim <- S4Arrays:::normarg_dim(dim)\n    dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    ans_len <- length(data)\n    if (ans_len != prod(dim))\n        stop(wmsg(\"length of input data [\" , ans_len, \"] does not \",\n                  \"match object dimensions [product \", prod(dim), \"]\"))\n    if (ans_len > .Machine$integer.max)\n        stop(wmsg(\"Input data is too long (>= 2^31). Please supply an \",\n                  \"ordinary list of Rle objects instead, or an RleList \",\n                  \"object, or a DataFrame object where all the columns \",\n                  \"are Rle objects.\"))\n    if (is.null(chunksize))\n        return(.new_SolidRleArraySeed(data, dim, dimnames))\n    ans_type <- typeof(runValue(data))\n    ## FIXME: breakInChunks() does not accept a 'totalsize' >= 2^31 at\n    ## the moment so this won't work on a long Rle.\n    partitioning <- breakInChunks(ans_len, chunksize=chunksize)\n    data <- relist(data, partitioning)\n    .new_ChunkedRleArraySeed(data, dim, dimnames, ans_type)\n}\n\n### 'data' is assumed to be a list-like object.\n.infer_dim <- function(data)\n{\n    data_dim <- dim(data)\n    if (!is.null(data_dim)) {\n        ## Potecting against objects with a weird dim().\n        if (!is.integer(data_dim))\n            stop(wmsg(\"Please specify the 'dim' argument. \",\n                      \"'dim(data)' is not an integer vector so \",\n                      \"cannot be used as a fallback for 'dim'.\"))\n        return(data_dim)\n    }\n    data_ncol <- length(data)\n    if (data_ncol == 0L)\n        return(c(0L, 0L))\n    data_lens <- lengths(data, use.names=FALSE)\n    data_nrow <- data_lens[[1L]]\n    if (!all(data_lens == data_nrow))\n        stop(wmsg(\"Please specify the 'dim' argument. \",\n                  \"The dimensions of the object to \",\n                  \"construct cannot be inferred from 'data'.\"))\n    c(data_nrow, data_ncol)\n}\n\n.infer_dimnames <- function(data)\n{\n    data_dimnames <- dimnames(data)\n    if (!is.null(data_dimnames))\n        return(data_dimnames)\n    data_names <- names(data)\n    if (!is.null(data_names))\n        return(list(NULL, data_names))\n    NULL\n}\n\n### 'data' must be a list-like object where all the list elements are\n### Rle objects.\n.normalize_data_as_list_of_Rles <- function(data)\n{\n    if (length(data) == 0L)\n        return(list())\n    if (is(data, \"CompressedRleList\"))\n        return(as.list(data))\n    if (!is(data, \"RleList\")) {\n        ok <- vapply(data, is, logical(1), \"Rle\", USE.NAMES=FALSE)\n        if (!all(ok))\n            stop(wmsg(\"all the list elements in the input object \",\n                      \"must be Rle objects\"))\n    }\n    ## Turn 'data' into an ordinary list where all the list elements are\n    ## Rle objects of the same type.\n    data0 <- lapply(data, function(x) runValue(x)[integer(0)])\n    data_type <- typeof(unlist(data0, use.names=FALSE))\n    lapply(data,\n        function(x) {\n            x_vals <- runValue(x)\n            if (typeof(x_vals) != data_type) {\n                storage.mode(x_vals) <- data_type\n                runValue(x) <- x_vals\n            }\n            x\n        })\n}\n\n### 'data' must be a list-like object where all the list elements are Rle\n### objects. If 'data' has length 0, return a SolidRleArraySeed instance.\n### Otherwise return a ChunkedRleArraySeed instance.\n.make_RleArraySeed_from_list_or_List <- function(data, dim, dimnames)\n{\n    if (missing(dim)) {\n        dim <- .infer_dim(data)\n        if (missing(dimnames))\n            dimnames <- .infer_dimnames(data)\n    } else {\n        dim <- S4Arrays:::normarg_dim(dim)\n        ans_len <- sum(lengths(data))  # can be >= 2^31\n        if (ans_len != prod(dim))\n            stop(wmsg(\"total length of input data [\" , ans_len, \"] does not \",\n                      \"match object dimensions [product \", prod(dim), \"]\"))\n    }\n    dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    if (length(data) == 0L) {\n        unlisted_data <- unlist(data, use.names=FALSE)\n        if (is.null(unlisted_data))\n            unlisted_data <- Rle()\n        return(.new_SolidRleArraySeed(unlisted_data, dim, dimnames))\n    }\n    data <- .normalize_data_as_list_of_Rles(data)\n    ans_type <- typeof(runValue(data[[1L]]))\n    .new_ChunkedRleArraySeed(data, dim, dimnames, ans_type)\n}\n\n### 'data' must be an Rle object or a list-like object where all the list\n### elements are Rle objects. In the former case, and if 'chunksize' is\n### not specified, a SolidRleArraySeed object is returned. Otherwise a\n### ChunkedRleArraySeed object is returned.\n### NOT exported!\nRleArraySeed <- function(data, dim, dimnames, chunksize=NULL)\n{\n    if (is(data, \"Rle\"))\n        return(.make_RleArraySeed_from_Rle(data, dim, dimnames, chunksize))\n    if (is(data, \"list_OR_List\")) {\n        if (!is.null(chunksize))\n            warning(wmsg(\"'chunksize' is currently ignored \",\n                         \"when the input is a list-like object\"))\n        return(.make_RleArraySeed_from_list_or_List(data, dim, dimnames))\n    }\n    stop(wmsg(\"'data' must be an Rle object or a list-like object \",\n              \"where all the list elements are Rle objects\"))\n}\n\nsetAs(\"ChunkedRleArraySeed\", \"SolidRleArraySeed\",\n    function(from) RleArraySeed(as(from, \"Rle\"), dim(from), dimnames(from))\n)\n\n",
        "SparseArraySeed-class.R": "### =========================================================================\n### SparseArraySeed objects\n### -------------------------------------------------------------------------\n\n### Everything in this file is defunct in BioC >= 3.21!\n\nsetClass(\"SparseArraySeed\",\n    contains=\"Array\",\n    representation(\n        dim=\"integer\",     # This gives us dim() for free!\n        nzindex=\"matrix\",  # M-index of the nonzero data.\n        nzdata=\"vector\",   # A vector (atomic or list) of length\n                           # 'nrow(nzindex)' containing the nonzero data.\n        dimnames=\"list\"    # List with one list element per dimension. Each\n                           # list element must be NULL or a character vector.\n    ),\n    prototype(\n        dim=0L,\n        nzindex=matrix(integer(0), ncol=1L),\n        dimnames=list(NULL)\n    )\n)\n\nsetGeneric(\"nzindex\",\n    function(x)\n    {\n        msg <- \"nzindex() is defunct in BioC >= 3.21\"\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"nzdata\", \"SparseArraySeed\",\n    function(x)\n    {\n        msg <- c(\"nzdata() getter for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"dim\", \"SparseArraySeed\",\n    function(x)\n    {\n        msg <- c(\"dim() getter for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"dimnames\", \"SparseArraySeed\",\n    function(x)\n    {\n        msg <- c(\"dimnames() getter for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetReplaceMethod(\"dimnames\", \"SparseArraySeed\",\n    function(x, value)\n    {\n        msg <- c(\"dimnames() setter for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nSparseArraySeed <- function(dim, nzindex=NULL, nzdata=NULL, dimnames=NULL,\n                            check=TRUE)\n{\n    msg <- \"SparseArraySeed objects are defunct in BioC >= 3.21\"\n    .Defunct(msg=wmsg(msg))\n}\n\ndense2sparse <- function(x)\n{\n    msg <- \"dense2sparse() is defunct in BioC >= 3.21\"\n    .Defunct(msg=wmsg(msg))\n}\n\n### 'sas' must be a SparseArraySeed object.\n### Return an ordinary array.\nsparse2dense <- function(sas)\n{\n    if (!is(sas, \"SparseArraySeed\"))\n        stop(wmsg(\"'sas' must be a SparseArraySeed object\"))\n    msg <- \"SparseArraySeed objects are defunct in BioC >= 3.21\"\n    .Defunct(msg=wmsg(msg))\n}\n\nsetGeneric(\"OLD_extract_sparse_array\",\n    function(x, index)\n    {\n        msg <- c(\"OLD_extract_sparse_array() is defunct in BioC >= 3.21. \",\n                 \"Please use SparseArray::extract_sparse_array() instead.\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"is_sparse\", \"SparseArraySeed\",\n    function(x)\n    {\n        msg <- c(\"is_sparse() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"extract_array\", \"SparseArraySeed\",\n    function(x, index)\n    {\n        msg <- c(\"extract_array() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\n### S3/S4 combo for as.array.SparseArraySeed\nas.array.SparseArraySeed <- function(x, ...)\n{\n    msg <- c(\"as.array() method for SparseArraySeed objects \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\nsetMethod(\"as.array\", \"SparseArraySeed\", as.array.SparseArraySeed)\n\n### S3/S4 combo for as.matrix.SparseArraySeed\n.from_SparseArraySeed_to_matrix <- function(x)\n{\n    msg <- c(\"as.matrix() method for SparseArraySeed objects \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\nas.matrix.SparseArraySeed <-\n    function(x, ...) .from_SparseArraySeed_to_matrix(x, ...)\nsetMethod(\"as.matrix\", \"SparseArraySeed\", .from_SparseArraySeed_to_matrix)\n\nsetAs(\"ANY\", \"SparseArraySeed\",\n    function(from)\n    {\n        msg <- \"coercion to SparseArraySeed is defunct in BioC >= 3.21\"\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\n.from_SparseArraySeed_to_CsparseMatrix <- function(from)\n{\n    msg <- c(\"coercion from SparseArraySeed to sparseMatrix or CsparseMatrix \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\n\n.from_SparseArraySeed_to_RsparseMatrix <- function(from)\n{\n    msg <- c(\"coercion from SparseArraySeed to RsparseMatrix \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\n\nsetAs(\"SparseArraySeed\", \"CsparseMatrix\",\n    .from_SparseArraySeed_to_CsparseMatrix\n)\nsetAs(\"SparseArraySeed\", \"RsparseMatrix\",\n    .from_SparseArraySeed_to_RsparseMatrix\n)\nsetAs(\"SparseArraySeed\", \"sparseMatrix\",\n    .from_SparseArraySeed_to_CsparseMatrix\n)\nsetAs(\"SparseArraySeed\", \"dgCMatrix\",\n    function(from) as(as(from, \"CsparseMatrix\"), \"dgCMatrix\")\n)\nsetAs(\"SparseArraySeed\", \"dgRMatrix\",\n    function(from) as(as(from, \"RsparseMatrix\"), \"dgRMatrix\")\n)\nsetAs(\"SparseArraySeed\", \"lgCMatrix\",\n    function(from) as(as(from, \"CsparseMatrix\"), \"lgCMatrix\")\n)\nsetAs(\"SparseArraySeed\", \"lgRMatrix\",\n    function(from) as(as(from, \"RsparseMatrix\"), \"lgRMatrix\")\n)\n\nsetAs(\"SparseArraySeed\", \"COO_SparseArray\",\n    function(from)\n    {\n        msg <- c(\"coercion from SparseArraySeed to COO_SparseArray \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetAs(\"sparseMatrix\", \"SparseArraySeed\",\n    function(from)\n    {\n        msg <- c(\"coercion from \", class(from)[[1L]], \" to SparseArraySeed \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n\n    }\n)\n\n.aperm.SparseArraySeed <- function(a, perm)\n{\n    msg <- c(\"aperm() method for SparseArraySeed objects \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\n\n### S3/S4 combo for aperm.SparseArraySeed\naperm.SparseArraySeed <-\n    function(a, perm, ...) .aperm.SparseArraySeed(a, perm, ...)\nsetMethod(\"aperm\", \"SparseArraySeed\", aperm.SparseArraySeed)\n\n",
        "SparseArraySeed-utils.R": "### =========================================================================\n### Operate natively on SparseArraySeed objects\n### -------------------------------------------------------------------------\n\n### Everything in this file is defunct in BioC >= 3.21!\n\nsetMethod(\"rbind\", \"SparseArraySeed\",\n    function(...)\n    {\n        msg <- c(\"rbind() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"cbind\", \"SparseArraySeed\",\n    function(...)\n    {\n        msg <- c(\"cbind() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\n.UNARY_ISO_OPS <- c(\"is.na\", \"is.infinite\", \"is.nan\", \"tolower\", \"toupper\")\n\nfor (.Generic in .UNARY_ISO_OPS) {\n    setMethod(.Generic, \"SparseArraySeed\",\n        function(x)\n        {\n            msg <- c(.Generic, \"() method for SparseArraySeed objects \",\n                     \"is defunct in BioC >= 3.21\")\n            .Defunct(msg=wmsg(msg))\n        }\n    )\n}\n\nsetMethod(\"nchar\", \"SparseArraySeed\",\n    function(x, type=\"chars\", allowNA=FALSE, keepNA=NA)\n    {\n        msg <- c(\"nchar() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"anyNA\", \"SparseArraySeed\",\n    function(x, recursive=FALSE)\n    {\n        msg <- c(\"anyNA() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"which\", \"SparseArraySeed\",\n    function(x, arr.ind=FALSE, useNames=TRUE)\n    {\n        msg <- c(\"which() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\nsetMethod(\"Summary\", \"SparseArraySeed\",\n    function(x, ..., na.rm=FALSE)\n    {\n        msg <- c(.Generic, \"() method for SparseArraySeed objects \",\n                 \"is defunct in BioC >= 3.21\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\n### S3/S4 combo for range.SparseArraySeed\nrange.SparseArraySeed <- function(..., na.rm=FALSE, finite=FALSE)\n{\n    msg <- c(\"range() method for SparseArraySeed objects \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\nsetMethod(\"range\", \"SparseArraySeed\",\n    function(x, ..., finite=FALSE, na.rm=FALSE)\n        range.SparseArraySeed(x, ..., na.rm=na.rm, finite=finite)\n\n)\n\n.mean_SparseArraySeed <- function(x, na.rm=FALSE)\n{\n    msg <- c(\"mean() method for SparseArraySeed objects \",\n             \"is defunct in BioC >= 3.21\")\n    .Defunct(msg=wmsg(msg))\n}\n\n### S3/S4 combo for mean.SparseArraySeed\nmean.SparseArraySeed <- function(x, na.rm=FALSE, ...)\n    .mean_SparseArraySeed(x, na.rm=na.rm, ...)\nsetMethod(\"mean\", \"SparseArraySeed\", .mean_SparseArraySeed)\n\n",
        "blockApply.R": "### =========================================================================\n### blockApply() and family\n### -------------------------------------------------------------------------\n###\n\n\n### NOT exported but used in the HDF5Array package!\nget_verbose_block_processing <- function()\n{\n    getOption(\"DelayedArray.verbose.block.processing\", default=FALSE)\n}\n\n### NOT exported but used in the HDF5Array package!\nset_verbose_block_processing <- function(verbose)\n{\n    if (!isTRUEorFALSE(verbose))\n        stop(\"'verbose' must be TRUE or FALSE\")\n    old_verbose <- get_verbose_block_processing()\n    options(DelayedArray.verbose.block.processing=verbose)\n    old_verbose\n}\n\nnormarg_verbose <- function(verbose)\n{\n    if (!(is.logical(verbose) && length(verbose) == 1L))\n        stop(wmsg(\"'verbose' must be FALSE, TRUE, or NA\"))\n    if (is.na(verbose))\n        verbose <- get_verbose_block_processing()\n    verbose\n}\n\n.realize_what_as_what <- function(x_is_sparse, as.sparse)\n{\n    if (is.na(as.sparse) || as.sparse == x_is_sparse) {\n        what <- if (x_is_sparse) \"sparse block\" else \"block\"\n        as_what <- \"\"\n    } else {\n        if (x_is_sparse) {\n            what <- \"sparse block\"\n            as_what <- \"dense block\"\n        } else {\n            what <- \"dense block\"\n            as_what <- \"sparse block\"\n        }\n        as_what <- paste0(\" as \", as_what)\n    }\n    list(what=what, as_what=as_what)\n}\n\n### For use in blockApply() and family.\nverbose_read_block <- function(x, viewport, x_is_sparse, as.sparse, bid, nblock)\n{\n    what_as_what <- .realize_what_as_what(x_is_sparse, as.sparse)\n    message(wmsg(\"/ reading and realizing \", what_as_what$what, \" \",\n                 bid, \"/\", nblock, what_as_what$as_what, \" ...\"),\n            \" \", appendLF=FALSE)\n    block <- read_block(x, viewport, as.sparse=as.sparse)\n    message(\"ok\")\n    block\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### set/getAutoBPPARAM()\n###\n\n### By default (i.e. when no argument is specified), no BiocParallel backend\n### is set and evaluation is sequential.\n### Beware that SnowParam() on Windows is quite inefficient for block\n### processing (it introduces **a lot** of overhead) so it's better to stick\n### to sequential evaluation on this platform.\n### See https://github.com/Bioconductor/BiocParallel/issues/78\nsetAutoBPPARAM <- function(BPPARAM=NULL)\n{\n    if (!is.null(BPPARAM)) {\n        if (!requireNamespace(\"BiocParallel\", quietly=TRUE))\n            stop(wmsg(\"Couldn't load the BiocParallel package. Please \",\n                      \"install the BiocParallel package and try again.\"))\n        if (!is(BPPARAM, \"BiocParallelParam\"))\n            stop(wmsg(\"'BPPARAM' must be a BiocParallelParam \",\n                      \"object from the BiocParallel package\"))\n    }\n    S4Arrays:::set_user_option(\"auto.BPPARAM\", BPPARAM)\n}\n\ngetAutoBPPARAM <- function() S4Arrays:::get_user_option(\"auto.BPPARAM\")\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Set/get grid context for the current block of a gridApply(), blockApply(),\n### gridReduce(), or blockReduce() loop\n###\n\nset_grid_context <- function(effective_grid,\n                             current_block_id,\n                             current_viewport=NULL,\n                             envir=parent.frame(1))\n{\n    if (!is.null(effective_grid))\n        assign(\".effective_grid\", effective_grid, envir=envir)\n    if (!is.null(current_block_id))\n        assign(\".current_block_id\", current_block_id, envir=envir)\n    if (!is.null(current_viewport))\n        assign(\".current_viewport\", current_viewport, envir=envir)\n}\n\n.grid_context_not_found <- c(\n    \"Grid context not found for the current block. \",\n    \"Are we in a blockApply(), blockReduce(), gridApply(), \",\n    \"or gridReduce() loop?\"\n)\n\n.explain_proper_use <- function(funname)\n    paste0(\"Note that \", funname, \"() can only be called from **within** \",\n           \"the callback functions 'FUN' and/or 'BREAKIF' passed to \",\n           \"blockApply() and family.\")\n\n.suggest_set_grid_context <- c(\n    \"If you need to be able to test/debug your callback function 'FUN' \",\n    \"(or 'BREAKIF') as a standalone function, set an arbitrary grid context \",\n    \"by calling set_grid_context() **right before** calling the callback \",\n    \"function.\"\n)\n\neffectiveGrid <- function(envir=parent.frame(2))\n{\n    effective_grid <- try(get(\".effective_grid\", envir=envir,\n                              inherits=FALSE), silent=TRUE)\n    if (inherits(effective_grid, \"try-error\"))\n        stop(wmsg(.grid_context_not_found),\n             \"\\n\\n  \",\n             wmsg(.explain_proper_use(\"effectiveGrid\")),\n             \"\\n\\n  \",\n             wmsg(.suggest_set_grid_context))\n    effective_grid\n}\n\ncurrentBlockId <- function(envir=parent.frame(2))\n{\n    current_block_id <- try(get(\".current_block_id\", envir=envir,\n                                inherits=FALSE), silent=TRUE)\n    if (inherits(current_block_id, \"try-error\"))\n        stop(wmsg(.grid_context_not_found),\n             \"\\n\\n  \",\n             wmsg(.explain_proper_use(\"currentBlockId\")),\n             \"\\n\\n  \",\n             wmsg(.suggest_set_grid_context))\n    current_block_id\n}\n\ncurrentViewport <- function(envir=parent.frame(2))\n{\n    current_viewport <- try(get(\".current_viewport\", envir=envir,\n                                inherits=FALSE), silent=TRUE)\n    if (!inherits(current_viewport, \"try-error\"))\n        return(current_viewport)\n    effective_grid <- try(effectiveGrid(envir), silent=TRUE)\n    if (inherits(effective_grid, \"try-error\"))\n        stop(wmsg(.grid_context_not_found),\n             \"\\n\\n  \",\n             wmsg(.explain_proper_use(\"currentViewport\")),\n             \"\\n\\n  \",\n             wmsg(.suggest_set_grid_context))\n    effective_grid[[currentBlockId(envir)]]\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### gridApply() and blockApply()\n###\n### TODO: In theory, the best performance should be obtained when bplapply()\n### uses a post office queue model. According to\n### https://support.bioconductor.org/p/96856/#96888, this can be\n### achieved by setting the nb of tasks to the nb of blocks (i.e. with\n### BPPARAM=MulticoreParam(tasks=length(grid))). However, in practice, that\n### seems to be slower than using tasks=0 (the default). Investigate this!\n###\n\ngridApply <- function(grid, FUN, ..., BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!is(grid, \"ArrayGrid\"))\n        stop(wmsg(\"'grid' must be an ArrayGrid object\"))\n    FUN <- match.fun(FUN)\n    verbose <- normarg_verbose(verbose)\n\n    FUN_WRAPPER <- function(bid, grid, verbose, FUN, ...)\n    {\n        if (verbose) {\n            nblock <- length(grid)\n            message(wmsg(\"\\\\ processing viewport \", bid, \"/\", nblock, \" ...\"),\n                    \" \", appendLF=FALSE)\n        }\n        viewport <- grid[[bid]]\n        set_grid_context(grid, bid, viewport)\n        ans <- FUN(viewport, ...)\n        if (verbose)\n            message(\"ok\")\n        ans\n    }\n    S4Arrays:::bplapply2(seq_along(grid), FUN_WRAPPER, grid, verbose,\n                                          FUN, ..., BPPARAM=BPPARAM)\n}\n\nblockApply <- function(x, FUN, ..., grid=NULL, as.sparse=FALSE,\n                                    BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    FUN <- match.fun(FUN)\n    grid <- normarg_grid(grid, x)\n    if (!(is.logical(as.sparse) && length(as.sparse) == 1L))\n        stop(wmsg(\"'as.sparse' must be FALSE, TRUE, or NA\"))\n    verbose <- normarg_verbose(verbose)\n\n    FUN_WRAPPER <- function(viewport,\n                            FUN, x, as.sparse, verbose, verbose_read_block, ...)\n    {\n        effective_grid <- effectiveGrid()\n        current_block_id <- currentBlockId()\n        if (verbose) {\n            x_is_sparse <- is_sparse(x)\n            nblock <- length(effective_grid)\n            block <- verbose_read_block(x, viewport, x_is_sparse,\n                                        as.sparse, current_block_id, nblock)\n        } else {\n            block <- read_block(x, viewport, as.sparse=as.sparse)\n        }\n        set_grid_context(effective_grid, current_block_id, viewport)\n        if (verbose)\n            message(wmsg(\"\\\\ processing it ...\"), \" \", appendLF=FALSE)\n        ans <- FUN(block, ...)\n        if (verbose)\n            message(\"ok\")\n        ans\n    }\n    gridApply(grid, FUN_WRAPPER,\n              FUN, x, as.sparse, verbose, verbose_read_block, ...,\n              BPPARAM=BPPARAM, verbose=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### gridReduce() and blockReduce()\n###\n### Two Reduce-like functions.\n###\n\ngridReduce <- function(FUN, grid, init, ..., BREAKIF=NULL, verbose=NA)\n{\n    FUN <- match.fun(FUN)\n    if (!is(grid, \"ArrayGrid\"))\n        stop(wmsg(\"'grid' must be an ArrayGrid object\"))\n    if (!is.null(BREAKIF))\n        BREAKIF <- match.fun(BREAKIF)\n    verbose <- normarg_verbose(verbose)\n\n    nblock <- length(grid)\n    for (bid in seq_len(nblock)) {\n        viewport <- grid[[bid]]\n        set_grid_context(grid, bid, viewport)\n        if (verbose)\n            message(wmsg(\"\\\\ processing viewport \", bid, \"/\", nblock, \" ...\"),\n                    \" \", appendLF=FALSE)\n        init <- FUN(viewport, init, ...)\n        if (verbose)\n            message(\"ok\")\n        if (!is.null(BREAKIF) && BREAKIF(init)) {\n            if (verbose)\n                message(\"BREAK condition encountered\")\n            break\n        }\n    }\n    init\n}\n\nblockReduce <- function(FUN, x, init, ..., BREAKIF=NULL,\n                        grid=NULL, as.sparse=FALSE, verbose=NA)\n{\n    FUN <- match.fun(FUN)\n    if (!is.null(BREAKIF))\n        BREAKIF <- match.fun(BREAKIF)\n    grid <- normarg_grid(grid, x)\n    if (!(is.logical(as.sparse) && length(as.sparse) == 1L))\n        stop(wmsg(\"'as.sparse' must be FALSE, TRUE, or NA\"))\n    verbose <- normarg_verbose(verbose)\n\n    FUN_WRAPPER <- function(viewport, init,\n                            FUN, x, as.sparse, verbose, verbose_read_block, ...)\n    {\n        effective_grid <- effectiveGrid()\n        current_block_id <- currentBlockId()\n        if (verbose) {\n            x_is_sparse <- is_sparse(x)\n            nblock <- length(effective_grid)\n            block <- verbose_read_block(x, viewport, x_is_sparse,\n                                        as.sparse, current_block_id, nblock)\n        } else {\n            block <- read_block(x, viewport, as.sparse=as.sparse)\n        }\n        set_grid_context(effective_grid, current_block_id, viewport)\n        if (verbose)\n            message(wmsg(\"\\\\ processing it ...\"), \" \", appendLF=FALSE)\n        init <- FUN(block, init, ...)\n        if (verbose)\n            message(\"ok\")\n        init\n    }\n    if (!is.null(BREAKIF) && verbose) {\n        BREAKIF_WRAPPER <- function(init)\n        {\n            ok <- BREAKIF(init)\n            if (ok)\n                message(\"BREAK condition encountered\")\n            ok\n        }\n    } else {\n        BREAKIF_WRAPPER <- BREAKIF\n    }\n    gridReduce(FUN_WRAPPER, grid, init,\n               FUN, x, as.sparse, verbose, verbose_read_block, ...,\n               BREAKIF=BREAKIF_WRAPPER, verbose=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Specialized internal helpers for the 2D case\n###\n\n### We give our preference to \"full width\" blocks because they avoid walking\n### twice on each \"horizontal strip\" e.g. in the case of BLOCK_rowVars()\n### when 'center' is not supplied.\n### However we only go for \"full width\" blocks when we are **absolutely\n### certain** that this is going to play well with the chunk geometry.\n### If \"full width\" blocks are not possible or too risky, our second choice\n### is to go for the most \"horizontally elongated\" blocks, because, it's\n### better to have a high number of narrow strips than a small number of\n### thick strips from a parallelization point of view (we can efficiently\n### use more workers).\n### In case of any uncertainty about the physical layout of the data (i.e.\n### if 'chunkdim(x)' is NULL), we just use square blocks to lower the risk\n### of using completely inappropriate block geometry.\n### The returned grid should always have at least one row.\nbest_grid_for_hstrip_apply <- function(x, grid=NULL)\n{\n    if (!is.null(grid)) {\n        grid <- normarg_grid(grid, x)  # sanity checks on supplied 'grid'\n        if (nrow(grid) == 0L)\n            stop(wmsg(\"the supplied grid must have at least one row\"))\n        return(grid)\n    }\n    if (length(x) == 0L)\n        return(defaultAutoGrid(x))  # one empty block\n    x_chunkdim <- chunkdim(x)\n    if (is.null(x_chunkdim)) {\n        if (is.matrix(x))\n            return(rowAutoGrid(x))  # \"full width\" blocks\n        ## We're in doubt about how \"full width\" blocks are going to play\n        ## with the physical layout of the data (e.g. 'x' is a TENxMatrix\n        ## object that was subsetted by row).\n        return(defaultAutoGrid(x, block.shape=\"hypercube\"))  # square blocks\n    }\n    chunk_nrow <- x_chunkdim[[1L]]\n    n <- getAutoBlockSize() /\n         (as.double(get_type_size(type(x))) * chunk_nrow * ncol(x))\n    if (n < 1)\n        return(defaultAutoGrid(x, block.shape=\"last-dim-grows-first\"))\n    block_nrow <- min(as.integer(n) * chunk_nrow, nrow(x))\n    rowAutoGrid(x, nrow=block_nrow)  # \"full width\" blocks\n}\n\n### The returned grid should always have at least one column.\nbest_grid_for_vstrip_apply <- function(x, grid=NULL)\n{\n    if (!is.null(grid)) {\n        grid <- normarg_grid(grid, x)  # sanity checks on supplied 'grid'\n        if (ncol(grid) == 0L)\n            stop(wmsg(\"the supplied grid must have at least one column\"))\n        return(grid)\n    }\n    if (length(x) == 0L)\n        return(defaultAutoGrid(x))  # one empty block\n    x_chunkdim <- chunkdim(x)\n    if (is.null(x_chunkdim)) {\n        if (is.matrix(x))\n            return(colAutoGrid(x))  # \"full height\" blocks\n        ## We're in doubt about how \"full height\" blocks are going to play\n        ## with the physical layout of the data (e.g. 'x' is a TENxMatrix\n        ## object that was subsetted by row and then transposed).\n        return(defaultAutoGrid(x, block.shape=\"hypercube\"))  # square blocks\n    }\n    chunk_ncol <- x_chunkdim[[2L]]\n    n <- getAutoBlockSize() /\n         (as.double(get_type_size(type(x))) * nrow(x) * chunk_ncol)\n    if (n < 1)\n        return(defaultAutoGrid(x, block.shape=\"first-dim-grows-first\"))\n    block_ncol <- min(as.integer(n) * chunk_ncol, ncol(x))\n    colAutoGrid(x, ncol=block_ncol)  # \"full height\" blocks\n}\n\n.message_2Dwalk_progress <- function(block, grid, i, j)\n{\n    what <- paste0(\"<\", paste0(dim(block), collapse=\" x \"), \">\")\n    if (is_sparse(block))\n        what <- paste0(what, \" sparse\")\n    what <- paste0(what, \" block from grid position \",\n                   \"[[\", i, \"/\", nrow(grid), \", \", j, \"/\", ncol(grid), \"]]\")\n    message(\"  \", wmsg(\"| processing \", what, \" ...\"), \" \", appendLF=FALSE)\n}\n\nreduce_grid_hstrip <- function(i, grid, x, INIT, INIT_MoreArgs,\n                                           FUN, FUN_MoreArgs,\n                                           FINAL, FINAL_MoreArgs,\n                                           as.sparse, verbose)\n{\n    INIT <- match.fun(INIT)\n    FUN <- match.fun(FUN)\n    if (!is.null(FINAL))\n        FINAL <- match.fun(FINAL)\n    verbose <- normarg_verbose(verbose)\n    grid_nrow <- nrow(grid)\n    grid_ncol <- ncol(grid)\n    init <- do.call(INIT, c(list(i, grid), INIT_MoreArgs))\n    if (verbose)\n        message(wmsg(\"=== START walking on horizontal strip \",\n                     i, \"/\", grid_nrow, \" ===\"))\n    ## Walk on the blocks of the i-th horizontal strip. Sequential.\n    for (j in seq_len(grid_ncol)) {\n        viewport <- grid[[i, j]]\n        block <- read_block(x, viewport, as.sparse=as.sparse)\n        set_grid_context(grid, NULL, viewport)\n        if (verbose)\n            .message_2Dwalk_progress(block, grid, i, j)\n        init <- do.call(FUN, c(list(init, block), FUN_MoreArgs))\n        if (verbose)\n            message(\"ok\")\n    }\n    if (verbose)\n        message(wmsg(\"=== DONE walking on horizontal strip \",\n                     i, \"/\", grid_nrow, \" ===\"))\n    if (!is.null(FINAL)) {\n        if (verbose)\n            message(wmsg(\"--- START finalizing result for \",\n                         \"horizonal strip \", i, \"/\", grid_nrow, \" ---\"))\n        init <- do.call(FINAL, c(list(init, i, grid), FINAL_MoreArgs))\n        if (verbose)\n            message(wmsg(\"--- DONE finalizing result for \",\n                         \"horizonal strip \", i, \"/\", grid_nrow, \" ---\"))\n    }\n    if (verbose)\n        message()\n    init\n}\n\nreduce_grid_vstrip <- function(j, grid, x, INIT, INIT_MoreArgs,\n                                           FUN, FUN_MoreArgs,\n                                           FINAL, FINAL_MoreArgs,\n                                           as.sparse, verbose)\n{\n    INIT <- match.fun(INIT)\n    FUN <- match.fun(FUN)\n    if (!is.null(FINAL))\n        FINAL <- match.fun(FINAL)\n    verbose <- normarg_verbose(verbose)\n    grid_nrow <- nrow(grid)\n    grid_ncol <- ncol(grid)\n    init <- do.call(INIT, c(list(j, grid), INIT_MoreArgs))\n    if (verbose)\n        message(wmsg(\"=== START walking on vertical strip \",\n                     j, \"/\", grid_ncol, \" ===\"))\n    ## Walk on the blocks of the j-th vertical strip. Sequential.\n    for (i in seq_len(grid_nrow)) {\n        viewport <- grid[[i, j]]\n        block <- read_block(x, viewport, as.sparse=as.sparse)\n        set_grid_context(grid, NULL, viewport)\n        if (verbose)\n            .message_2Dwalk_progress(block, grid, i, j)\n        init <- do.call(FUN, c(list(init, block), FUN_MoreArgs))\n        if (verbose)\n            message(\"ok\")\n    }\n    if (verbose)\n        message(wmsg(\"=== DONE walking on vertical strip \",\n                     j, \"/\", grid_ncol, \" ===\"))\n    if (!is.null(FINAL)) {\n        if (verbose)\n            message(wmsg(\"--- START finalizing result for \",\n                         \"vertical strip \", j, \"/\", grid_ncol, \" ---\"))\n        init <- do.call(FINAL, c(list(init, j, grid), FINAL_MoreArgs))\n        if (verbose)\n            message(wmsg(\"--- DONE finalizing result for \",\n                         \"vertical strip \", j, \"/\", grid_ncol, \" ---\"))\n    }\n    if (verbose)\n        message()\n    init\n}\n\n### Walk on the horizontal grid strips:\n### - strips are processed in parallel;\n### - blocks within each strip are processed sequentially from left to right.\n### Returns a list of length >= 1 with one list element per strip.\nhstrip_apply <- function(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                            FINAL=NULL, FINAL_MoreArgs=list(),\n                            grid=NULL, as.sparse=FALSE,\n                            BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    grid <- best_grid_for_hstrip_apply(x, grid)\n    if (!(is.logical(as.sparse) && length(as.sparse) == 1L))\n        stop(wmsg(\"'as.sparse' must be a FALSE, TRUE, or NA\"))\n\n    ## Outer loop on the horizontal grid strips. Parallelized.\n    S4Arrays:::bplapply2(seq_len(nrow(grid)),\n        reduce_grid_hstrip, grid, x,\n        INIT, INIT_MoreArgs,\n        FUN, FUN_MoreArgs,\n        FINAL, FINAL_MoreArgs,\n        as.sparse, verbose,\n        BPPARAM=BPPARAM\n    )\n}\n\n### Walk on the vertical grid strips:\n### - strips are processed in parallel;\n### - blocks within each strip are processed sequentially from top to bottom.\n### Returns a list of length >= 1 with one list element per strip.\nvstrip_apply <- function(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                            FINAL=NULL, FINAL_MoreArgs=list(),\n                            grid=NULL, as.sparse=FALSE,\n                            BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    grid <- best_grid_for_vstrip_apply(x, grid)\n    if (!(is.logical(as.sparse) && length(as.sparse) == 1L))\n        stop(wmsg(\"'as.sparse' must be a FALSE, TRUE, or NA\"))\n\n    ## Outer loop on the vertical grid strips. Parallelized.\n    S4Arrays:::bplapply2(seq_len(ncol(grid)),\n        reduce_grid_vstrip, grid, x,\n        INIT, INIT_MoreArgs,\n        FUN, FUN_MoreArgs,\n        FINAL, FINAL_MoreArgs,\n        as.sparse, verbose,\n        BPPARAM=BPPARAM\n    )\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### OLD - Walking on the blocks\n### OLD -\n### OLD - 3 utility functions to process array-like objects by block.\n### OLD -\n### OLD - Still used by the DelayedMatrixStats package.\n\n### An lapply-like function.\nblock_APPLY <- function(x, APPLY, ..., sink=NULL, block_maxlen=NULL)\n{\n    APPLY <- match.fun(APPLY)\n    x_dim <- dim(x)\n    if (any(x_dim == 0L)) {\n        chunk_grid <- NULL\n    } else {\n        ## Using chunks of length 1 (i.e. max resolution chunk grid) is just\n        ## a trick to make sure that defaultAutoGrid() returns linear blocks.\n        chunk_grid <- RegularArrayGrid(x_dim, rep.int(1L, length(x_dim)))\n    }\n    grid <- defaultAutoGrid(x, block_maxlen, chunk_grid,\n                               block.shape=\"first-dim-grows-first\")\n    nblock <- length(grid)\n    lapply(seq_len(nblock),\n        function(bid) {\n            if (get_verbose_block_processing())\n                message(wmsg(\"- processing block \", bid, \"/\", nblock, \" ...\"),\n                        \" \", appendLF=FALSE)\n            viewport <- grid[[bid]]\n            block <- read_block(x, viewport)\n            block_ans <- APPLY(block, ...)\n            if (!is.null(sink)) {\n                write_block(sink, viewport, block_ans)\n                block_ans <- NULL\n            }\n            if (get_verbose_block_processing())\n                message(\"ok\")\n            block_ans\n        })\n}\n\n### A convenience wrapper around block_APPLY() to process a matrix-like\n### object by block of columns.\ncolblock_APPLY <- function(x, APPLY, ..., sink=NULL)\n{\n    x_dim <- dim(x)\n    if (length(x_dim) != 2L)\n        stop(\"'x' must be a matrix-like object\")\n    APPLY <- match.fun(APPLY)\n    ## We're going to walk along the columns so need to increase the block\n    ## length so each block is made of at least one column.\n    block_maxlen <- max(getAutoBlockLength(type(x)), x_dim[[1L]])\n    block_APPLY(x, APPLY, ..., sink=sink, block_maxlen=block_maxlen)\n}\n\n",
        "chunkGrid.R": "### =========================================================================\n### chunkGrid()\n### -------------------------------------------------------------------------\n###\n\n\n### For use in *Seed classes that use a slot to store the chunkdim. See for\n### example the \"chunkdim\" slot of the HDF5ArraySeed class defined in the\n### HDF5Array package.\nsetClassUnion(\"integer_OR_NULL\", c(\"integer\", \"NULL\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### chunkdim() generic and methods\n###\n### chunkdim(x) must return NULL or an integer vector compatible with dim(x).\n###\n\n### Performs the same checks as .normarg_z_chunkdim() (see AutoGrid.R).\n.check_chunkdim <- function(chunkdim, x_dim)\n{\n    ## The relationship between 'chunkdim' and 'x_dim' must be the same\n    ## as the relationship between the 'spacings' and 'refdim' slots of\n    ## a RegularArrayGrid object. This guarantees that\n    ## 'RegularArrayGrid(dim(x), chunkdim(x))' will always work (note\n    ## that this always returns a grid with at least 1 element, even\n    ## when 'x' is empty).\n    if (!is.integer(chunkdim))\n        return(c(\"didn't return an integer vector (or NULL). \",\n                 \"chunkdim() should always return an integer vector \",\n                 \"or NULL.\"))\n    if (length(chunkdim) != length(x_dim))\n        return(c(\"returned an integer vector of length != length(dim(x)).\"))\n    if (S4Vectors:::anyMissingOrOutside(chunkdim, 0L))\n        return(\"returned an integer vector with negative or NA values.\")\n    if (!all(chunkdim <= x_dim))\n        return(c(\"returned chunk dimensions that are not <= their \",\n                 \"corresponding dimension in 'x'.\"))\n    if (any(chunkdim == 0L & x_dim != 0L))\n        return(c(\"returned an integer vector with illegal zeros. \",\n                 \"chunkdim() should always return an integer vector with \",\n                 \"nonzero values unless the zero values correspond to \",\n                 \"dimensions in 'x' that are also zero.\"))\n    if (prod(chunkdim) > .Machine$integer.max)\n        return(c(\"returned chunk dimensions that are too big. The \",\n                 \"product of the chunk dimensions should always be <= \",\n                 \".Machine$integer.max\"))\n    TRUE\n}\n\n.contact_author_msg <- function(Class)\n{\n    msg <- c(\"Please contact the author of the \", Class, \" class\")\n    class_package <- attr(Class, \"package\")\n    if (!is.null(class_package))\n        msg <- c(msg, \" (defined in the \", class_package, \" package)\")\n    c(msg, \" about this and point him/her to the man page for \",\n           \"extract_array() in the DelayedArray package (?extract_array).\")\n}\n\nsetGeneric(\"chunkdim\",\n    function(x)\n    {\n        x_dim <- dim(x)\n        if (is.null(x_dim))\n            stop(wmsg(\"argument to chunkdim() must be an array-like object\"))\n        ans <- standardGeneric(\"chunkdim\")\n        if (is.null(ans))\n            return(ans)\n        msg <- .check_chunkdim(ans, x_dim)\n        if (!isTRUE(msg))\n            stop(wmsg(\"The \\\"chunkdim\\\" method for \", class(x), \" objects \",\n                      msg, .contact_author_msg(class(x))))\n        ans\n    }\n)\n\nsetMethod(\"chunkdim\", \"ANY\", function(x) NULL)\n\nsetMethod(\"chunkdim\", \"DelayedUnaryOp\", function(x) chunkdim(x@seed))\n\n.get_DelayedSubset_chunkdim <- function(x)\n{\n    seed_chunkdim <- chunkdim(x@seed)\n    if (is.null(seed_chunkdim))\n        return(NULL)\n    ok <- lapply(seq_along(seed_chunkdim),\n              function(i) {seed_chunkdim[[i]] <= 1L || is.null(x@index[[i]])})\n    if (!all(unlist(ok)))\n        return(NULL)\n    pmin(seed_chunkdim, dim(x))\n}\n\nsetMethod(\"chunkdim\", \"DelayedSubset\", .get_DelayedSubset_chunkdim)\n\n.get_DelayedAperm_chunkdim <- function(x)\n{\n    seed_chunkdim <- chunkdim(x@seed)\n    if (is.null(seed_chunkdim))\n        return(NULL)\n    ans <- seed_chunkdim[x@perm]\n    ans[is.na(x@perm)] <- 1L\n    ans\n}\n\nsetMethod(\"chunkdim\", \"DelayedAperm\", .get_DelayedAperm_chunkdim)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### chunkGrid() generic and methods\n###\n### chunkGrid(x) must return NULL or an ArrayGrid object defining a grid on\n### reference array x.\n###\n\nsetGeneric(\"chunkGrid\", function(x) standardGeneric(\"chunkGrid\"))\n\nsetMethod(\"chunkGrid\", \"ANY\",\n    function(x)\n    {\n        x_chunkdim <- chunkdim(x)\n        if (is.null(x_chunkdim))\n            return(NULL)\n        RegularArrayGrid(dim(x), x_chunkdim)\n    }\n)\n\n",
        "compat.R": "setMethod(\"t\", \"DelayedArray\", S4Arrays::t.Array)\ncolsum <- S4Arrays::colsum\nmakeNindexFromArrayViewport <- S4Arrays::makeNindexFromArrayViewport\nDummyArrayGrid <- S4Arrays::DummyArrayGrid\nRegularArrayGrid <- S4Arrays::RegularArrayGrid\nArbitraryArrayGrid <- S4Arrays::ArbitraryArrayGrid\nextract_array <- S4Arrays::extract_array\nis_sparse <- S4Arrays::is_sparse\nread_block <- S4Arrays::read_block\nwrite_block <- S4Arrays::write_block\n\n### Non-exported stuff (but used in some DelayedArray rev deps).\nget_Nindex_lengths <- S4Arrays:::get_Nindex_lengths\nset_dim <- S4Arrays:::set_dim\nset_dimnames <- S4Arrays:::set_dimnames\nsubset_by_Nindex <- S4Arrays:::subset_by_Nindex\nto_linear_index <- S4Arrays:::to_linear_index\nbplapply2 <- S4Arrays:::bplapply2\nsimplify_NULL_dimnames <- S4Arrays:::simplify_NULL_dimnames\n",
        "compress_atomic_vector.R": "### =========================================================================\n### compress_atomic_vector()\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n\n.RAW_OVERHEAD <- object.size(raw(0L))  # 48 bytes on a 64-bit system\n\n### Word size should be 8 on a 64-bit system and 4 on a 32-bit system.\n.WORD_SIZE <- object.size(raw(1L)) - .RAW_OVERHEAD\n\n### Predict the size of 'raw(length)' without creating the vector (which can\n### be expensive).\n### Note that the predicted size is almost always accurate (i.e. almost\n### always equal to 'object.size(raw(length))') except for some vector\n### lengths for which the raw() constructor strangely tends to \"over allocate\"\n### memory. For example, on my laptop (64-bit Ubuntu 16.04.5 LTS, R 3.5.1)\n### 'object.size(raw(64))' is 112, as predicted, but 'object.size(raw(65))'\n### is 176 so more than the predicted 120 bytes.\n.predict_raw_size <- function(length)\n    .RAW_OVERHEAD + ((length - 1L) %/% .WORD_SIZE + 1L) * .WORD_SIZE\n\n.LIST2_OVERHEAD <- object.size(list(NULL, NULL))  # 64 bytes on a 64-bit system\n\n.predict_compressed_size <- function(x_len, ux)\n    .LIST2_OVERHEAD + .predict_raw_size(x_len) + object.size(ux)\n\n### If encoding is successful, the compressed vector is returned as a list\n### with 2 elements:\n###   1) A raw vector of the same length as input vector 'x'.\n###   2) A vector of levels (obtained with 'unique(x)').\n### Will only compress if encoding with a raw vector is possible (i.e. if\n### 'x' contains <= 256 unique values) and worth it (i.e. if compressing\n### reduces the object size). Otherwise the input vector is returned\n### unmodified (no-op).\ncompress_atomic_vector <- function(x)\n{\n    stopifnot(is.atomic(x))\n    ## Should we compress?\n    if (is.raw(x))\n        return(x)  # nothing to gain\n    x_len <- length(x)\n    if (x_len <= 2L)\n        return(x)  # not worth it\n    ux <- unique(x)\n    ux_len <- length(ux)\n    if (ux_len > 256L)\n        return(x)  # not possible\n    if (.predict_compressed_size(x_len, ux) >= object.size(x))\n        return(x)  # not worth it\n    ## Encoding is possible and worth it (based on predicted size).\n    ans <- list(as.raw(match(x, ux) - 1L), ux)\n    if (object.size(ans) >= object.size(x))\n        return(x)  # not worth it\n    ans\n}\n\n### 'decompress_atomic_vector(compress_atomic_vector(x))' should be a no-op\n### for any unnamed atomic vector 'x'.\ndecompress_atomic_vector <- function(x)\n{\n    if (is.atomic(x))\n        return(x)\n    stopifnot(is.list(x), length(x) == 2L)\n    x[[2L]][as.integer(x[[1L]]) + 1L]\n}\n\n",
        "makeCappedVolumeBox.R": "### =========================================================================\n### Utilities to make capped volume boxes\n### -------------------------------------------------------------------------\n###\n### TODO: Move to S4Arrays\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### makeCappedVolumeBox()\n###\n\n### 'maxvol' is assumed to be a single integer >= 2 and < 'prod(maxdim)'.\n.make_capped_volume_hypercube_box <- function(maxvol, maxdim)\n{\n    ans <- maxdim\n    L <- max(ans)\n    while (TRUE) {\n        is_max <- ans == L\n        not_max_ans <- ans[!is_max]\n        L <- (maxvol / prod(not_max_ans)) ^ (1 / sum(is_max))\n        if (length(not_max_ans) == 0L)\n            break\n        L2 <- max(not_max_ans)\n        if (L >= L2)\n            break\n        L <- L2\n        ans[is_max] <- L\n    }\n    ans[is_max] <- as.integer(L)\n    q <- S4Arrays:::get_RegularArrayGrid_dim(maxdim, ans + 1L) /\n         S4Arrays:::get_RegularArrayGrid_dim(maxdim, ans)\n    for (along in which(is_max)[order(q[is_max])]) {\n        ans[[along]] <- ans[[along]] + 1L\n        p <- prod(ans)\n        if (p == maxvol)\n            break\n        if (p > maxvol) {\n            ans[[along]] <- ans[[along]] - 1L\n            break\n        }\n    }\n    ans\n}\n\n### 'maxvol' is assumed to be a single integer >= 2 and < 'prod(maxdim)'.\n### The algo used below could be improved. For exampe it does some weird\n### things like:\n###     > .make_capped_volume_scale_box(11, c(3, 50, 10))\n###     [1] 1 9 1\n###     > .make_capped_volume_scale_box(12, c(3, 50, 10))\n###     [1] 1 8 1\n.make_capped_volume_scale_box <- function(maxvol, maxdim)\n{\n    ## Some good properties of shrinkbox():\n    ## - The output dims are always >= 1.\n    ## - If r is < 1, then input dims that are > 1 will decrease and those\n    ##   at 1 will remain at 1.\n    shrinkbox <- function(bdim, r) pmax(as.integer(bdim * r), 1L)\n\n    p <- 1 / length(maxdim)\n    bdim <- maxdim                  # all(maxdim >= 1) is TRUE\n    ## Loop will typically go thru 2 to 18 iterations before it breaks.\n    ## An example that requires 18 iterations:\n    ## - maxvol <- 70000\n    ## - maxdim <- c(30, 15000000)\n    while (TRUE) {\n        bvol <- prod(bdim)          # can't be 0\n        if (bvol <= maxvol)\n            break\n        r <- (maxvol / bvol)^p      # < 1\n        bdim <- shrinkbox(bdim, r)  # reduce all dims (except those already\n                                    # at 1) so volume is guaranteed to reduce\n                                    # at each loop\n    }\n    bdim\n}\n\n### 'maxvol' is assumed to be a single integer >= 2 and < 'prod(maxdim)'.\n.make_capped_volume_FDGF_box <- function(maxvol, maxdim)\n{\n    p <- cumprod(maxdim)\n    w <- which(p <= maxvol)\n    N <- if (length(w) == 0L) 1L else w[[length(w)]] + 1L\n    if (N == 1L) {\n        by <- maxvol\n    } else {\n        by <- maxvol %/% as.integer(p[[N - 1L]])\n    }\n    c(head(maxdim, n=N-1L), by, rep.int(1L, length(maxdim)-N))\n}\n\n.make_capped_volume_LDGF_box <- function(maxvol, maxdim)\n{\n    rev(.make_capped_volume_FDGF_box(maxvol, rev(maxdim)))\n}\n\n### Return the dimensions of a box that satisfies the following properties:\n###   1. Has a volume as close as possibe to (but not bigger than) 'maxvol'.\n###   2. Fits in the \"constraining box\" i.e. in the box of dimensions 'maxdim'.\n###   3. Has a non-zero volume if the \"constraining box\" has a non-zero volume.\n###   4. Has a shape that is as close as possible to the requested shape.\nmakeCappedVolumeBox <- function(maxvol, maxdim, shape=c(\"hypercube\",\n                                                        \"scale\",\n                                                        \"first-dim-grows-first\",\n                                                        \"last-dim-grows-first\"))\n{\n    if (!isSingleNumber(maxvol))\n        stop(\"'maxvol' must be a single integer\")\n    if (!is.integer(maxvol))\n        maxvol <- as.integer(maxvol)\n    if (maxvol < 0L)\n        stop(\"'maxvol' must be a non-negative integer\")\n\n    if (!is.numeric(maxdim))\n        stop(wmsg(\"'maxdim' must be an integer vector\"))\n    if (!is.integer(maxdim))\n        maxdim <- as.integer(maxdim)\n\n    shape <- match.arg(shape)\n\n    if (maxvol >= prod(maxdim))\n        return(maxdim)\n\n    if (maxvol == 0L)\n        return(integer(length(maxdim)))\n\n    if (maxvol == 1L)\n        return(rep.int(1L, length(maxdim)))\n\n    FUN <- switch(shape,\n                  hypercube=.make_capped_volume_hypercube_box,\n                  scale=.make_capped_volume_scale_box,\n                  `first-dim-grows-first`=.make_capped_volume_FDGF_box,\n                  `last-dim-grows-first`=.make_capped_volume_LDGF_box,\n                  stop(\"unsupported 'shape'\"))\n    FUN(maxvol, maxdim)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### makeRegularArrayGridOfCappedLengthViewports()\n###\n\n### A capped-volume box related utility.\n### If 'viewport_shape' is \"first-dim-grows-first\", return a linear grid.\nmakeRegularArrayGridOfCappedLengthViewports <-\n    function(refdim, viewport_len, viewport_shape=c(\"hypercube\",\n                                                       \"scale\",\n                                                       \"first-dim-grows-first\",\n                                                       \"last-dim-grows-first\"))\n{\n    spacings <- makeCappedVolumeBox(viewport_len, refdim, viewport_shape)\n    RegularArrayGrid(refdim, spacings)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Linear viewports and grids\n###\n### An array viewport is \"linear\" if it is made of reference array elements\n### that would be contiguous in memory if the reference array was an ordinary\n### R array (where the fastest changing dimension is the first one).\n###\n\nsetGeneric(\"isLinear\", function(x) standardGeneric(\"isLinear\"))\n\nsetMethod(\"isLinear\", \"ArrayViewport\",\n    function(x)\n    {\n        x_width <- width(x)\n        idx <- which(x_width != refdim(x))\n        if (length(idx) == 0L)\n            return(TRUE)\n        all(tail(x_width, n=-idx[[1L]]) == 1L)\n    }\n)\n\n### If the 1st grid element is linear, then they all are.\nsetMethod(\"isLinear\", \"ArrayGrid\",\n    function(x)\n    {\n        if (length(x) == 0L)\n            return(TRUE)\n        isLinear(x[[1L]])\n    }\n)\n\n",
        "matrixStats-methods.R": "### =========================================================================\n### Row and column summarization methods for DelayedMatrix objects\n### -------------------------------------------------------------------------\n###\n\n\n### Raise an error if invalid input type. Otherwise return \"integer\",\n### \"numeric\", \"double\", or \"complex\".\n### NOTE: No longer used in this file but used in DelayedMatrixStats.\n.get_ans_type <- function(x, must.be.numeric=FALSE)\n{\n    x_type <- type(x)\n    ans_type <- switch(x_type,\n        logical=\"integer\",\n        integer=, numeric=, double=, complex=x_type,\n        stop(wmsg(\"operation not supported on matrices of type \", x_type)))\n    if (must.be.numeric && !is.numeric(get(ans_type)(0)))\n        stop(wmsg(\"operation not supported on matrices of type \", x_type))\n    ans_type\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### row/colSums()\n###\n### The methods for ordinary matrices are defined in the base package.\n###\n\nBLOCK_rowSums <- function(x, na.rm=FALSE, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    INIT <- function(i, grid) numeric(nrow(grid[[i, 1L]]))\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        init + MatrixGenerics::rowSums(block, na.rm=na.rm)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- hstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- rownames(x)\n    ans\n}\n\nBLOCK_colSums <- function(x, na.rm=FALSE, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    INIT <- function(j, grid) numeric(ncol(grid[[1L, j]]))\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        init + MatrixGenerics::colSums(block, na.rm=na.rm)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- vstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\n.check_dims <- function(dims, method)\n{\n    if (!identical(dims, 1))\n        stop(wmsg(\"\\\"\", method, \"\\\" method for DelayedMatrix objects \",\n                  \"does not support the 'dims' argument\"))\n}\n\n### base::rowSums() has a 'dims' argument. We do NOT support it.\n.rowSums_DelayedMatrix <- function(x, na.rm=FALSE, dims=1)\n{\n    .check_dims(dims, \"rowSums\")\n    BLOCK_rowSums(x, na.rm=na.rm)\n}\nsetMethod(\"rowSums\", \"DelayedMatrix\", .rowSums_DelayedMatrix)\n\n### base::colSums() has a 'dims' argument. We do NOT support it.\n.colSums_DelayedMatrix <- function(x, na.rm=FALSE, dims=1)\n{\n    .check_dims(dims, \"colSums\")\n    BLOCK_colSums(x, na.rm=na.rm)\n}\nsetMethod(\"colSums\", \"DelayedMatrix\", .colSums_DelayedMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### row/colMeans()\n###\n### The methods for ordinary matrices are defined in the base package.\n###\n\n.row_sums_and_nvals <- function(x, na.rm=FALSE)\n{\n    ## 'x' is either an ordinary matrix or SparseMatrix derivative\n    ## (SVT_SparseMatrix or COO_SparseMatrix object).\n    row_sums <- MatrixGenerics::rowSums(x, na.rm=na.rm)\n    row_nvals <- rep.int(ncol(x), nrow(x))\n    if (na.rm)\n        row_nvals <- row_nvals - MatrixGenerics::rowSums(is.na(x))\n    data.frame(sum=row_sums, nval=row_nvals)\n}\n\n.col_sums_and_nvals <- function(x, na.rm=FALSE)\n{\n    ## 'x' is either an ordinary matrix or SparseMatrix derivative\n    ## (SVT_SparseMatrix or COO_SparseMatrix object).\n    col_sums <- MatrixGenerics::colSums(x, na.rm=na.rm)\n    col_nvals <- rep.int(nrow(x), ncol(x))\n    if (na.rm)\n        col_nvals <- col_nvals - MatrixGenerics::colSums(is.na(x))\n    data.frame(sum=col_sums, nval=col_nvals)\n}\n\nBLOCK_rowMeans <- function(x, na.rm=FALSE, useNames=TRUE,\n                           grid=NULL, as.sparse=NA,\n                           BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    INIT <- function(i, grid) {\n        n <- nrow(grid[[i, 1L]])\n        .row_sums_and_nvals(matrix(nrow=n, ncol=0L))\n    }\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        init + .row_sums_and_nvals(block, na.rm=na.rm)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    FINAL <- function(init, i, grid) { init$sum / init$nval }\n\n    strip_results <- hstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     FINAL=FINAL,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- rownames(x)\n    ans\n}\n\nBLOCK_colMeans <- function(x, na.rm=FALSE, useNames=TRUE,\n                           grid=NULL, as.sparse=NA,\n                           BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    INIT <- function(j, grid) {\n        n <- ncol(grid[[1L, j]])\n        .col_sums_and_nvals(matrix(nrow=0L, ncol=n))\n    }\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        init + .col_sums_and_nvals(block, na.rm=na.rm)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    FINAL <- function(init, j, grid) { init$sum / init$nval }\n\n    strip_results <- vstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     FINAL=FINAL,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\n### base::rowMeans() has a 'dims' argument. We do NOT support it.\n.rowMeans_DelayedMatrix <- function(x, na.rm=FALSE, dims=1)\n{\n    .check_dims(dims, \"rowMeans\")\n    BLOCK_rowMeans(x, na.rm=na.rm)\n}\nsetMethod(\"rowMeans\", \"DelayedMatrix\", .rowMeans_DelayedMatrix)\n\n### base::colMeans() has a 'dims' argument. We do NOT support it.\n.colMeans_DelayedMatrix <- function(x, na.rm=FALSE, dims=1)\n{\n    .check_dims(dims, \"colMeans\")\n    BLOCK_colMeans(x, na.rm=na.rm)\n}\nsetMethod(\"colMeans\", \"DelayedMatrix\", .colMeans_DelayedMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### row/colMins()\n###\n### The methods for ordinary matrices are defined in the matrixStats package.\n###\n\nBLOCK_rowMins <- function(x, na.rm=FALSE, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (ncol(x) == 0L) {\n        ans <- rep.int(Inf, nrow(x))\n        if (useNames)\n            names(ans) <- rownames(x)\n        return(ans)\n    }\n\n    INIT <- function(i, grid) NULL\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_rowmins <- MatrixGenerics::rowMins(block, na.rm=na.rm,\n                                                 useNames=FALSE)\n        if (is.null(init))\n            return(block_rowmins)\n        pmin(init, block_rowmins)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- hstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- rownames(x)\n    ans\n}\n\nBLOCK_colMins <- function(x, na.rm=FALSE, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (nrow(x) == 0L) {\n        ans <- rep.int(Inf, ncol(x))\n        if (useNames)\n            names(ans) <- colnames(x)\n        return(ans)\n    }\n\n    INIT <- function(j, grid) NULL\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_colmins <- MatrixGenerics::colMins(block, na.rm=na.rm,\n                                                 useNames=FALSE)\n        if (is.null(init))\n            return(block_colmins)\n        pmin(init, block_colmins)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- vstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\n.check_rows_cols <- function(rows, cols, method)\n{\n    if (!(is.null(rows) && is.null(cols)))\n        stop(wmsg(\"\\\"\", method, \"\\\" method for DelayedMatrix objects \",\n                  \"does not support arguments 'rows' and 'cols'\"))\n}\n\n### MatrixGenerics::rowMins() has the 'rows' and 'cols' arguments.\n### We do NOT support them.\n.rowMins_DelayedMatrix <- function(x, rows=NULL, cols=NULL, na.rm=FALSE,\n                                   useNames=TRUE)\n{\n    .check_rows_cols(rows, cols, \"rowMins\")\n    BLOCK_rowMins(x, na.rm=na.rm, useNames=useNames)\n}\nsetMethod(\"rowMins\", \"DelayedMatrix\", .rowMins_DelayedMatrix)\n\n### MatrixGenerics::colMins() has the 'rows' and 'cols' arguments.\n### We do NOT support them.\n.colMins_DelayedMatrix <- function(x, rows=NULL, cols=NULL, na.rm=FALSE,\n                                   useNames=TRUE)\n{\n    .check_rows_cols(rows, cols, \"colMins\")\n    BLOCK_colMins(x, na.rm=na.rm, useNames=useNames)\n}\nsetMethod(\"colMins\", \"DelayedMatrix\", .colMins_DelayedMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### row/colMaxs()\n###\n### The methods for ordinary matrices are defined in the matrixStats package.\n###\n\nBLOCK_rowMaxs <- function(x, na.rm=FALSE, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (ncol(x) == 0L) {\n        ans <- rep.int(-Inf, nrow(x))\n        if (useNames)\n            names(ans) <- rownames(x)\n        return(ans)\n    }\n\n    INIT <- function(i, grid) NULL\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_rowmaxs <- MatrixGenerics::rowMaxs(block, na.rm=na.rm,\n                                                 useNames=FALSE)\n        if (is.null(init))\n            return(block_rowmaxs)\n        pmax(init, block_rowmaxs)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- hstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- rownames(x)\n    ans\n}\n\nBLOCK_colMaxs <- function(x, na.rm=FALSE, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (nrow(x) == 0L) {\n        ans <- rep.int(-Inf, ncol(x))\n        if (useNames)\n            names(ans) <- colnames(x)\n        return(ans)\n    }\n\n    INIT <- function(j, grid) NULL\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_colmaxs <- MatrixGenerics::colMaxs(block, na.rm=na.rm,\n                                                 useNames=FALSE)\n        if (is.null(init))\n            return(block_colmaxs)\n        pmax(init, block_colmaxs)\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- vstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\n### MatrixGenerics::rowMaxs() has the 'rows' and 'cols' arguments.\n### We do NOT support them.\n.rowMaxs_DelayedMatrix <- function(x, rows=NULL, cols=NULL, na.rm=FALSE,\n                                   useNames=TRUE)\n{\n    .check_rows_cols(rows, cols, \"rowMaxs\")\n    BLOCK_rowMaxs(x, na.rm=na.rm, useNames=useNames)\n}\nsetMethod(\"rowMaxs\", \"DelayedMatrix\", .rowMaxs_DelayedMatrix)\n\n### MatrixGenerics::colMaxs() has the 'rows' and 'cols' arguments.\n### We do NOT support them.\n.colMaxs_DelayedMatrix <- function(x, rows=NULL, cols=NULL, na.rm=FALSE,\n                                   useNames=TRUE)\n{\n    .check_rows_cols(rows, cols, \"colMaxs\")\n    BLOCK_colMaxs(x, na.rm=na.rm, useNames=useNames)\n}\nsetMethod(\"colMaxs\", \"DelayedMatrix\", .colMaxs_DelayedMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### row/colRanges()\n###\n### The methods for ordinary matrices are defined in the matrixStats package.\n###\n\nBLOCK_rowRanges <- function(x, na.rm=FALSE, useNames=TRUE,\n                            grid=NULL, as.sparse=NA,\n                            BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(\"'na.rm' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (ncol(x) == 0L) {\n        ans <- cbind(rep.int(Inf, nrow(x)), rep.int(-Inf, nrow(x)))\n        if (useNames)\n            rownames(ans) <- rownames(x)\n        return(ans)\n    }\n\n    INIT <- function(i, grid) NULL\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_rowranges <- MatrixGenerics::rowRanges(block, na.rm=na.rm,\n                                                     useNames=FALSE)\n        if (is.null(init))\n            return(block_rowranges)\n        cbind(pmin(init[ , 1L], block_rowranges[ , 1L]),\n              pmax(init[ , 2L], block_rowranges[ , 2L]))\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- hstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- do.call(rbind, strip_results)\n    if (useNames)\n        rownames(ans) <- rownames(x)\n    ans\n}\n\nBLOCK_colRanges <- function(x, na.rm=FALSE, useNames=TRUE,\n                            grid=NULL, as.sparse=NA,\n                            BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(\"'na.rm' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (nrow(x) == 0L) {\n        ans <- cbind(rep.int(Inf, ncol(x)), rep.int(-Inf, ncol(x)))\n        if (useNames)\n            rownames(ans) <- colnames(x)\n        return(ans)\n    }\n\n    INIT <- function(i, grid) NULL\n    INIT_MoreArgs <- list()\n\n    FUN <- function(init, block, na.rm=FALSE) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_colranges <- MatrixGenerics::colRanges(block, na.rm=na.rm,\n                                                     useNames=FALSE)\n        if (is.null(init))\n            return(block_colranges)\n        cbind(pmin(init[ , 1L], block_colranges[ , 1L]),\n              pmax(init[ , 2L], block_colranges[ , 2L]))\n    }\n    FUN_MoreArgs <- list(na.rm=na.rm)\n\n    strip_results <- vstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                                     grid=grid, as.sparse=as.sparse,\n                                     BPPARAM=BPPARAM, verbose=verbose)\n    ans <- do.call(rbind, strip_results)\n    if (useNames)\n        rownames(ans) <- colnames(x)\n    ans\n}\n\n### MatrixGenerics::rowRanges() has the 'rows' and 'cols' arguments.\n### We do NOT support them.\n.rowRanges_DelayedMatrix <- function(x, rows=NULL, cols=NULL, na.rm=FALSE,\n                                     useNames=TRUE)\n{\n    .check_rows_cols(rows, cols, \"rowRanges\")\n    BLOCK_rowRanges(x, na.rm=na.rm, useNames=useNames)\n}\nsetMethod(\"rowRanges\", \"DelayedMatrix\", .rowRanges_DelayedMatrix)\n\n### MatrixGenerics::colRanges() has the 'rows' and 'cols' arguments.\n### We do NOT support them.\n.colRanges_DelayedMatrix <- function(x, rows=NULL, cols=NULL, na.rm=FALSE,\n                                     useNames=TRUE)\n{\n    .check_rows_cols(rows, cols, \"colRanges\")\n    BLOCK_colRanges(x, na.rm=na.rm, useNames=useNames)\n}\nsetMethod(\"colRanges\", \"DelayedMatrix\", .colRanges_DelayedMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### row/colVars()\n###\n### The methods for ordinary matrices are defined in the matrixStats package.\n###\n\n.compute_rowVars_for_full_width_blocks <-\n    function(grid, x, na.rm=FALSE, center=NULL,\n             as.sparse=NA, BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    stopifnot(ncol(grid) == 1L)\n    stopifnot(is.null(center) ||\n              (is.numeric(center) && length(center) == nrow(x)))\n\n    blockApply(x,\n        function(block, na.rm, center) {\n            if (is.null(center)) {\n                block_center <- NULL\n            } else {\n                viewport_range1 <- ranges(currentViewport())[1L]\n                block_center <- extractROWS(center, viewport_range1)\n            }\n            ## 'block' is either an ordinary matrix or SparseMatrix derivative\n            ## (SVT_SparseMatrix or COO_SparseMatrix object).\n            MatrixGenerics::rowVars(block, na.rm=na.rm, center=block_center,\n                                    useNames=FALSE)\n        },\n        na.rm, center,\n        grid=grid, as.sparse=as.sparse,\n        BPPARAM=BPPARAM, verbose=verbose\n    )\n}\n\n.compute_colVars_for_full_height_blocks <-\n    function(grid, x, na.rm=FALSE, center=NULL,\n             as.sparse=NA, BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    stopifnot(nrow(grid) == 1L)\n    stopifnot(is.null(center) ||\n              (is.numeric(center) && length(center) == ncol(x)))\n\n    blockApply(x,\n        function(block, na.rm, center) {\n            if (is.null(center)) {\n                block_center <- NULL\n            } else {\n                viewport_range2 <- ranges(currentViewport())[2L]\n                block_center <- extractROWS(center, viewport_range2)\n            }\n            ## 'block' is either an ordinary matrix or SparseMatrix derivative\n            ## (SVT_SparseMatrix or COO_SparseMatrix object).\n            MatrixGenerics::colVars(block, na.rm=na.rm, center=block_center,\n                                    useNames=FALSE)\n        },\n        na.rm, center,\n        grid=grid, as.sparse=as.sparse,\n        BPPARAM=BPPARAM, verbose=verbose\n    )\n}\n\n.compute_rowVars_for_horizontal_strips <-\n    function(grid, x, na.rm=FALSE, center=NULL,\n             as.sparse=NA, BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    stopifnot(is.null(center) ||\n              (is.numeric(center) && length(center) == nrow(x)))\n\n    INIT <- function(i, grid, x, na.rm=FALSE, center=NULL,\n                              as.sparse=NA, verbose=NA)\n    {\n        n <- nrow(grid[[i, 1L]])\n        if (!is.null(center))\n            return(data.frame(sum2=numeric(n), nval=integer(n)))\n        reduce_grid_hstrip(i, grid, x,\n            INIT=function(i, grid, n) {\n                    .row_sums_and_nvals(matrix(nrow=n, ncol=0L))\n            },\n            INIT_MoreArgs=list(n=n),\n            FUN=function(init, block, na.rm) {\n                    init + .row_sums_and_nvals(block, na.rm=na.rm)\n            },\n            FUN_MoreArgs=list(na.rm=na.rm),\n            FINAL=function(init, i, grid, n) {\n                    center <- init$sum / init$nval\n                    data.frame(sum2=numeric(n), nval=init$nval, center=center)\n            },\n            FINAL_MoreArgs=list(n=n),\n            as.sparse,\n            verbose\n        )\n    }\n    INIT_MoreArgs <- list(x=x, na.rm=na.rm, center=center,\n                          as.sparse=as.sparse, verbose=verbose)\n\n    FINAL <- function(init, i, grid) { init$sum2 / (init$nval - 1L) }\n\n    FUN <- function(init, block, na.rm, center) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        if (is.null(center)) {\n            block_center <- init$center\n        } else {\n            viewport_range1 <- ranges(currentViewport())[1L]\n            block_center <- extractROWS(center, viewport_range1)\n            block_nvals <- rep.int(ncol(block), nrow(block))\n            if (na.rm)\n                block_nvals <- block_nvals -\n                               MatrixGenerics::rowSums(is.na(block))\n        }\n        delta <- block\n        ## 'delta' could be a SparseMatrix derivative. However\n        ## adding/subtracting an ordinary vector to/from it is not\n        ## supported so we first turn it into an ordinary matrix.\n        if (length(nzwhich(block_center)) != 0L)\n            delta <- as.matrix(delta) - block_center\n        ## 'delta' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_sums2 <- MatrixGenerics::rowSums(delta * delta, na.rm=na.rm)\n        if (is.null(center)) {\n            init$sum2 <- init$sum2 + block_sums2\n            init\n        } else {\n            init + data.frame(sum2=block_sums2, nval=block_nvals)\n        }\n    }\n    FUN_MoreArgs <- list(na.rm, center)\n\n    hstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                    FINAL=FINAL,\n                    grid=grid, as.sparse=as.sparse,\n                    BPPARAM=BPPARAM, verbose=verbose)\n}\n\n.compute_colVars_for_vertical_strips <-\n    function(grid, x, na.rm=FALSE, center=NULL,\n             as.sparse=NA, BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    stopifnot(is.null(center) ||\n              (is.numeric(center) && length(center) == ncol(x)))\n\n    INIT <- function(j, grid, x, na.rm=FALSE, center=NULL,\n                              as.sparse=NA, verbose=NA)\n    {\n        n <- ncol(grid[[1L, j]])\n        if (!is.null(center))\n            return(data.frame(sum2=numeric(n), nval=integer(n)))\n        reduce_grid_vstrip(j, grid, x,\n            INIT=function(j, grid, n) {\n                    .col_sums_and_nvals(matrix(nrow=0L, ncol=n))\n            },\n            INIT_MoreArgs=list(n=n),\n            FUN=function(init, block, na.rm) {\n                    init + .col_sums_and_nvals(block, na.rm=na.rm)\n            },\n            FUN_MoreArgs=list(na.rm=na.rm),\n            FINAL=function(init, j, grid, n) {\n                    center <- init$sum / init$nval\n                    data.frame(sum2=numeric(n), nval=init$nval, center=center)\n            },\n            FINAL_MoreArgs=list(n=n),\n            as.sparse,\n            verbose\n        )\n    }\n    INIT_MoreArgs <- list(x=x, na.rm=na.rm, center=center,\n                          as.sparse=as.sparse, verbose=verbose)\n\n    FINAL <- function(init, j, grid) { init$sum2 / (init$nval - 1L) }\n\n    FUN <- function(init, block, na.rm, center) {\n        ## 'block' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        if (is.null(center)) {\n            block_center <- init$center\n        } else {\n            viewport_range2 <- ranges(currentViewport())[2L]\n            block_center <- extractROWS(center, viewport_range2)\n            block_nvals <- rep.int(nrow(block), ncol(block))\n            if (na.rm)\n                block_nvals <- block_nvals -\n                               MatrixGenerics::colSums(is.na(block))\n        }\n        delta <- block\n        ## 'delta' could be a SparseMatrix derivative. However\n        ## adding/subtracting an ordinary vector to/from it is not\n        ## supported so we first turn it into an ordinary matrix.\n        if (length(nzwhich(block_center)) != 0L)\n            delta <- as.matrix(delta) - rep(block_center, each=nrow(block))\n        ## 'delta' is either an ordinary matrix or SparseMatrix derivative\n        ## (SVT_SparseMatrix or COO_SparseMatrix object).\n        block_sums2 <- MatrixGenerics::colSums(delta * delta, na.rm=na.rm)\n        if (is.null(center)) {\n            init$sum2 <- init$sum2 + block_sums2\n            init\n        } else {\n            init + data.frame(sum2=block_sums2, nval=block_nvals)\n        }\n    }\n    FUN_MoreArgs <- list(na.rm, center)\n\n    vstrip_apply(x, INIT, INIT_MoreArgs, FUN, FUN_MoreArgs,\n                    FINAL=FINAL,\n                    grid=grid, as.sparse=as.sparse,\n                    BPPARAM=BPPARAM, verbose=verbose)\n}\n\nBLOCK_rowVars <- function(x, na.rm=FALSE, center=NULL, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (!is.null(center)) {\n        if (!is.numeric(center))\n            stop(wmsg(\"'center' must be NULL or a numeric vector\"))\n        x_nrow <- nrow(x)\n        if (length(center) != x_nrow) {\n            if (length(center) != 1L)\n                stop(wmsg(\"'center' must have length 1 or nrow(x)\"))\n            center <- rep.int(center, x_nrow)\n        }\n    }\n\n    grid <- best_grid_for_hstrip_apply(x, grid=grid)\n    if (ncol(grid) == 1L) {\n        fun <- .compute_rowVars_for_full_width_blocks\n    } else {\n        fun <- .compute_rowVars_for_horizontal_strips\n    }\n    strip_results <- fun(grid, x, na.rm=na.rm, center=center,\n                               as.sparse=as.sparse,\n                               BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- rownames(x)\n    ans\n}\n\nBLOCK_colVars <- function(x, na.rm=FALSE, center=NULL, useNames=TRUE,\n                          grid=NULL, as.sparse=NA,\n                          BPPARAM=getAutoBPPARAM(), verbose=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(useNames))\n        stop(wmsg(\"'useNames' must be TRUE or FALSE\"))\n\n    if (!is.null(center)) {\n        if (!is.numeric(center))\n            stop(wmsg(\"'center' must be NULL or a numeric vector\"))\n        x_ncol <- ncol(x)\n        if (length(center) != x_ncol) {\n            if (length(center) != 1L)\n                stop(wmsg(\"'center' must have length 1 or ncol(x)\"))\n            center <- rep.int(center, x_ncol)\n        }\n    }\n\n    grid <- best_grid_for_vstrip_apply(x, grid=grid)\n    if (nrow(grid) == 1L) {\n        fun <- .compute_colVars_for_full_height_blocks\n    } else {\n        fun <- .compute_colVars_for_vertical_strips\n    }\n    strip_results <- fun(grid, x, na.rm=na.rm, center=center,\n                               as.sparse=as.sparse,\n                               BPPARAM=BPPARAM, verbose=verbose)\n    ans <- unlist(strip_results, recursive=FALSE, use.names=FALSE)\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\nsetMethod(\"rowVars\", \"DelayedMatrix\",\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL, useNames=TRUE)\n    {\n        .check_rows_cols(rows, cols, \"rowVars\")\n        BLOCK_rowVars(x, na.rm=na.rm, center=center, useNames=useNames)\n    }\n)\n\nsetMethod(\"colVars\", \"DelayedMatrix\",\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL, useNames=TRUE)\n    {\n        .check_rows_cols(rows, cols, \"colVars\")\n        BLOCK_colVars(x, na.rm=na.rm, center=center, useNames=useNames)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### TODO: Add more row/column summarization generics/methods\n###\n\n",
        "read_sparse_block.R": "### =========================================================================\n### read_sparse_block()\n### -------------------------------------------------------------------------\n###\n\nsetGeneric(\"read_sparse_block\", signature=\"x\",\n    function(x, viewport)\n    {\n        msg <- c(\"read_sparse_block() is defunct in BioC >= 3.21. \",\n                 \"Please use SparseArray::read_block_as_sparse() instead.\")\n        .Defunct(msg=wmsg(msg))\n    }\n)\n\n",
        "realize.R": "### =========================================================================\n### realize()\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Internal helper to support block by block realization\n###\n### Used by coercion to RleArray, HDF5Array::writeHDF5Array(), and\n### HDF5Array::writeTENxMatrix().\n###\n\nBLOCK_write_to_sink <- function(sink, x, verbose=NA)\n{\n    stopifnot(identical(dim(x), dim(sink)))\n    verbose <- normarg_verbose(verbose)\n\n    ## 'x' and 'sink' might both have their physical chunks but we must\n    ## choose a grid that is compatible with the physical chunks of 'sink'.\n    ## Calling 'defaultSinkAutoGrid()' on 'sink' will produce such grid.\n    ## TODO: Note that it might be beneficial to use a grid that is **also**\n    ## compatible with the physical chunks of 'x' so we might want to add\n    ## that kind of capability to 'defaultSinkAutoGrid()'.\n    grid <- defaultSinkAutoGrid(sink)\n\n    FUN <- function(sink, viewport, x, verbose, verbose_read_block)\n    {\n        effective_grid <- effectiveGrid()\n        current_block_id <- currentBlockId()\n        if (verbose) {\n            x_is_sparse <- is_sparse(x)\n            nblock <- length(effective_grid)\n            block <- verbose_read_block(x, viewport, x_is_sparse,\n                                        as.sparse=NA, current_block_id, nblock)\n        } else {\n            block <- read_block(x, viewport, as.sparse=NA)\n        }\n        ## 'block' is either an ordinary array or SparseArray derivative\n        ## (SVT_SparseArray or COO_SparseArray object).\n        if (verbose)\n            message(\"\\\\ Writing it ... \", appendLF=FALSE)\n        sink <- write_block(sink, viewport, block)\n        if (verbose)\n            message(\"OK\")\n        sink\n    }\n    sinkApply(sink, FUN, x, verbose, verbose_read_block,\n              grid=grid, verbose=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### realize()\n###\n\nsetGeneric(\"realize\", function(x, ...) standardGeneric(\"realize\"))\n\n### Realize an array-like object in memory if 'BACKEND' is NULL, otherwise\n### on disk.\n### Note that, when 'BACKEND' is not NULL, 'x' gets realized as a \"pristine\"\n### DelayedArray object (e.g. an HDF5Array object), that is, as a DelayedArray\n### object that carries no delayed operations. This means that if 'x' is a\n### DelayedArray object, the returned object is another DelayedArray object\n### that is semantically equivalent to 'x' but where the delayed operations\n### carried by 'x' have been realized.\n### Will raise an error if 'x' is not an array-like object. Non array-like\n### objects (e.g. SummarizedExperiment objects) need to have their own\n### realize() method.\nsetMethod(\"realize\", \"ANY\",\n    function(x, BACKEND=getAutoRealizationBackend())\n    {\n        if (is.null(dim(x)))\n            stop(wmsg(\"realization of \", class(x)[[1L]], \" objects \",\n                      \"is not supported\"))\n        if (!is.null(BACKEND)) {\n            load_BACKEND_package(BACKEND)\n            return(as(x, BACKEND))\n        }\n        if (is_sparse(x)) {\n            as(x, \"SVT_SparseArray\")\n        } else {\n            ## When 'BACKEND' is NULL, realize() will act as a no-op on an\n            ## ordinary matrix or array.\n            as.array(x)\n        }\n    }\n)\n\n",
        "showtree.R": "### =========================================================================\n### Visualize and access the leaves of a tree of delayed operations\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### showtree()\n###\n### A much more condensed version of str().\n###\n\n.node_as_one_line_summary <- function(x, show.node.dim=TRUE)\n{\n    if (is(x, \"DelayedOp\")) {\n        ans <- summary(x)\n    } else {\n        ans <- sprintf(\"[seed] %s object\", classNameForDisplay(x))\n    }\n    if (show.node.dim) {\n        dim_in1string <- paste0(dim(x), collapse=\"x\")\n        sparse <- if (is_sparse(x)) \", sparse\" else \"\"\n        ans <- sprintf(\"%s %s%s: %s\", dim_in1string, type(x), sparse, ans)\n    }\n    ans\n}\n\n### Avoid use of non-ASCII characters in R source code. There must be a\n### better way to do this.\n.VBAR  <- rawToChar(as.raw(c(0xe2, 0x94, 0x82)))\n.TEE   <- rawToChar(as.raw(c(0xe2, 0x94, 0x9c)))\n.ELBOW <- rawToChar(as.raw(c(0xe2, 0x94, 0x94)))\n.HBAR  <- rawToChar(as.raw(c(0xe2, 0x94, 0x80)))\n\n### 'last.child' can be NA, TRUE, or FALSE. NA means 'x' is the root of the\n### tree.\n.rec_showtree <- function(x, indent=\"\", last.child=NA,\n                             prefix=\"\", show.node.dim=TRUE)\n{\n    stopifnot(isSingleString(indent))\n    stopifnot(is.logical(last.child), length(last.child) == 1L)\n\n    if (!is.list(x) || is.array(x)) {\n        ## Display summary line.\n\n        if (is.na(last.child)) {\n            ## No Tprefix.\n            Tprefix <- \"\"\n        } else {\n            ## 3-char Tprefix\n            Tprefix <- paste0(if (last.child) .ELBOW else .TEE, .HBAR, \" \")\n        }\n        x_as1line <- .node_as_one_line_summary(x, show.node.dim=show.node.dim)\n        cat(indent, Tprefix, prefix, x_as1line, \"\\n\", sep=\"\")\n        if (!is(x, \"DelayedOp\"))\n            return(invisible(NULL))\n    }\n\n    ## Display children.\n\n    if (!is.na(last.child)) {\n        ## Increase indent by 3 chars.\n        indent <- paste0(indent,\n                         if (last.child) \" \" else .VBAR,\n                         strrep(\" \", 2 + nchar(prefix)))\n    }\n    if (is(x, \"DelayedUnaryOp\")) {\n        if (is(x, \"DelayedSubassign\") && !is.null(dim(x@Rvalue))) {\n            ## 'x@Rvalue' is an array-like object.\n            .rec_showtree(x@seed, indent, last.child=FALSE,\n                          show.node.dim=show.node.dim)\n            .rec_showtree(x@Rvalue, indent, last.child=TRUE,\n                          prefix=\"right value: \", show.node.dim=show.node.dim)\n        } else {\n            .rec_showtree(x@seed, indent, last.child=TRUE,\n                          show.node.dim=show.node.dim)\n        }\n    } else {\n        if (is(x, \"DelayedNaryOp\"))\n            x <- x@seeds\n        nchildren <- length(x)\n        for (i in seq_len(nchildren))\n            .rec_showtree(x[[i]], indent, last.child=(i==nchildren),\n                          show.node.dim=show.node.dim)\n    }\n}\n\nshowtree <- function(x, show.node.dim=TRUE)\n{\n    if (!isTRUEorFALSE(show.node.dim))\n        stop(\"'show.node.dim' must be TRUE or FALSE\")\n    .rec_showtree(x, show.node.dim=show.node.dim)\n}\n\nsetMethod(\"show\", \"DelayedOp\", function(object) .rec_showtree(object))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nseed()\n###\n### Return the number of leaves in the tree of DelayedOp nodes represented\n### by 'x'. Note that nseed(x) == 1 means that the tree is linear.\n###\n\nsetGeneric(\"nseed\", function(x) standardGeneric(\"nseed\"))\n\nsetMethod(\"nseed\", \"ANY\",\n    function(x)\n    {\n        if (is(x, \"DelayedUnaryOp\"))\n            return(nseed(x@seed))\n        if (is(x, \"DelayedNaryOp\"))\n            x <- x@seeds\n        if (is.list(x) && !is.array(x)) {\n            ans <- sum(vapply(x, nseed, integer(1), USE.NAMES=FALSE))\n            return(ans)\n        }\n        return(1L)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seedApply() and modify_seeds()\n###\n\nseedApply <- function(x, FUN, ...)\n{\n    if (is(x, \"DelayedUnaryOp\"))\n        return(seedApply(x@seed, FUN, ...))\n    if (is(x, \"DelayedNaryOp\"))\n        x <- x@seeds\n    if (is.list(x) && !is.array(x)) {\n        ans <- lapply(x, seedApply, FUN, ...)\n        return(unlist(ans, recursive=FALSE, use.names=FALSE))\n    }\n    list(FUN(x, ...))\n}\n\n### 'FUN' must take a seed and return a seed of the same dimensions.\n### Dangerous so not intended for the end user.\n### Used in HDF5Array!\nmodify_seeds <- function(x, FUN, ...)\n{\n    if (is(x, \"DelayedUnaryOp\")) {\n        x@seed <- modify_seeds(x@seed, FUN, ...)\n    } else  if (is(x, \"DelayedNaryOp\")) {\n        x@seeds <- lapply(x@seeds, modify_seeds, FUN, ...)\n    } else {\n        x <- FUN(x, ...)\n    }\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### seed() getter/setter\n###\n### If nseed(x) == 1 (i.e. if 'x' is a linear tree) then the seed() getter\n### and setter MUST work on 'x'.\n###\n\nIS_NOT_SUPPORTED_IF_MULTIPLE_SEEDS <- c(\n    \"is not supported on a DelayedArray object with multiple seeds at the \",\n    \"moment. Note that you can check the number of seeds with nseed().\"\n)\n\nsetGeneric(\"seed\", function(x) standardGeneric(\"seed\"))\n\nsetMethod(\"seed\", \"DelayedOp\",\n    function(x)\n    {\n        if (is(x, \"DelayedNaryOp\")) {\n            ## Tree is not linear.\n            stop(wmsg(\"seed() \", IS_NOT_SUPPORTED_IF_MULTIPLE_SEEDS,\n                      \" You can use 'seedApply(x, identity)' to extract \",\n                      \"all the seeds as a list.\"))\n        }\n        x1 <- x@seed\n        if (!is(x1, \"DelayedOp\"))\n            return(x1)  # found the leaf seed\n        x <- x1\n        callGeneric()  # recursive call\n    }\n)\n\nsetGeneric(\"seed<-\", signature=\"x\",\n    function(x, ..., value) standardGeneric(\"seed<-\")\n)\n\n.normalize_seed_replacement_value <- function(value, x_seed)\n{\n    x_seed_class <- class(x_seed)[[1L]]\n    if (!is(value, x_seed_class))\n        stop(wmsg(\"supplied seed must be a \", x_seed_class, \" object\"))\n    if (!identical(dim(value), dim(x_seed)))\n        stop(wmsg(\"supplied seed must have the same dimensions \",\n                  \"as current seed\"))\n    if (!identical(dimnames(value), dimnames(x_seed)))\n        stop(wmsg(\"supplied seed must have the same dimnames \",\n                  \"as current seed\"))\n    value\n}\n\nsetReplaceMethod(\"seed\", \"DelayedOp\",\n    function(x, value)\n    {\n        if (is(x, \"DelayedNaryOp\")) {\n            ## Tree is not linear.\n            stop(wmsg(\"the seed() setter \", IS_NOT_SUPPORTED_IF_MULTIPLE_SEEDS))\n        }\n        x1 <- x@seed\n        if (!is(x1, \"DelayedOp\")) {\n            ## Replace the leaf seed.\n            x@seed <- .normalize_seed_replacement_value(value, x1)\n            return(x)\n        }\n        seed(x1) <- value  # recursive call\n        x@seed <- x1\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### path() getter/setter\n###\n\n### The path of a DelayedOp object is the path of its **immediate** seed\n### (recursive definition). Raises an error if:\n### - the DelayedOp object has more than one **immediate** seed, that is,\n###   if the object is a DelayedNaryOp object;\n### - or calling path() on the **leaf** seed (innermost call to path())\n###   fails, typically because no path() method is defined for the **leaf**\n###   seed.\n### For example, path() will work on an HDF5Array object but not on an\n### RleArray object (will raise an error).\nsetMethod(\"path\", \"DelayedOp\",\n    function(object, ...)\n    {\n        if (is(object, \"DelayedNaryOp\")) {\n            ## Tree is not linear.\n            stop(wmsg(\"path() \", IS_NOT_SUPPORTED_IF_MULTIPLE_SEEDS,\n                      \" You can use 'seedApply(object, path)' to extract \",\n                      \"all the seed paths as a list.\"))\n        }\n        object <- object@seed\n        callGeneric()\n    }\n)\n\nsetReplaceMethod(\"path\", \"DelayedOp\",\n    function(object, ..., value)\n    {\n        if (is(object, \"DelayedNaryOp\")) {\n            ## Tree is not linear.\n            stop(wmsg(\"the path() setter \",\n                      IS_NOT_SUPPORTED_IF_MULTIPLE_SEEDS))\n        }\n        object <- object@seed\n        callGeneric()\n    }\n)\n\n",
        "simplify.R": "### =========================================================================\n### Simplify a tree of delayed operations\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### simplify()\n###\n\n.normarg_incremental <- function(incremental)\n{\n    if (!isTRUEorFALSE(incremental))\n        stop(\"'incremental' must be TRUE or FALSE\")\n    incremental\n}\n\nsetGeneric(\"simplify\", signature=\"x\",\n    function(x, incremental=FALSE) standardGeneric(\"simplify\")\n)\n\nsetMethod(\"simplify\", \"ANY\",\n    function(x, incremental=FALSE)\n    {\n        .normarg_incremental(incremental)\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedSubset\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seed <- simplify(x@seed)\n        x1 <- x@seed\n        if (is_noop(x))\n            return(x1)\n        if (is(x1, \"DelayedSubset\")) {\n            ## ACTION: merge ops + remove if no-op.\n            x1 <- subset_DelayedSubset(x1, x@index)\n            if (is_noop(x1))\n                return(x1@seed)\n            return(x1)\n        }\n        if (is(x1, \"DelayedAperm\")) {\n            ## ACTION: swap ops.\n            index2 <- project_index_on_seed(x@index, x1)\n            x2 <- new_DelayedSubset(x1@seed, index2)\n            x2 <- simplify(x2, incremental=TRUE)\n            x1 <- BiocGenerics:::replaceSlots(x1, seed=x2, check=FALSE)\n            return(x1)\n        }\n        if (is(x1, \"DelayedUnaryIsoOpStack\")) {\n            ## ACTION: swap ops.\n            x2 <- x\n            x2@seed <- x1@seed\n            x2 <- simplify(x2, incremental=TRUE)\n            x1 <- BiocGenerics:::replaceSlots(x1, seed=x2, check=FALSE)\n            return(x1)\n        }\n        if (is(x1, \"DelayedUnaryIsoOpWithArgs\")) {\n            ## ACTION: swap ops.\n            x2 <- x\n            x2@seed <- x1@seed\n            x2 <- simplify(x2, incremental=TRUE)\n            Largs <- subset_args(x1@Largs, x1@Lalong, x@index)\n            Rargs <- subset_args(x1@Rargs, x1@Ralong, x@index)\n            x1 <- BiocGenerics:::replaceSlots(x1, seed=x2,\n                                                  Largs=Largs,\n                                                  Rargs=Rargs,\n                                                  check=FALSE)\n            return(x1)\n        }\n        if (is(x1, \"DelayedSubassign\")) {\n            ## ACTION: swap ops.\n            x1 <- subset_DelayedSubassign(x1, x@index)\n            x1@seed <- simplify(x1@seed, incremental=TRUE)\n            x1@Rvalue <- simplify(x1@Rvalue, incremental=TRUE)\n            return(x1)\n        }\n        if (is(x1, \"DelayedSetDimnames\")) {\n            ## ACTION: swap ops.\n            x2 <- x\n            x2@seed <- x1@seed\n            x2 <- simplify(x2, incremental=TRUE)\n            x1 <- new_DelayedSetDimnames(x2, dimnames(x))\n            return(x1)\n        }\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedAperm\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seed <- simplify(x@seed)\n        x1 <- x@seed\n        if (is_noop(x))\n            return(x1)\n        if (is(x1, \"DelayedAperm\")) {\n            ## ACTION: merge ops + remove if no-op.\n            x1@perm <- x1@perm[x@perm]\n            if (is_noop(x1))\n                return(x1@seed)\n            return(simplify(x1, incremental=TRUE))\n        }\n        if (is(x1, \"DelayedUnaryIsoOpStack\")) {\n            ## ACTION: swap ops.\n            x@seed <- x1@seed\n            x1@seed <- simplify(x, incremental=TRUE)\n            return(x1)\n        }\n        if (is(x1, \"DelayedUnaryIsoOpWithArgs\")) {\n            perm0 <- x@perm[!is.na(x@perm)]\n            set_Lalong_to_NA <- !(x1@Lalong %in% perm0)\n            set_Ralong_to_NA <- !(x1@Ralong %in% perm0)\n            if (all(set_Lalong_to_NA) && all(set_Ralong_to_NA)) {\n                ## ACTION: swap ops.\n                x1@Lalong[set_Lalong_to_NA] <- NA_integer_\n                x1@Ralong[set_Ralong_to_NA] <- NA_integer_\n                x@seed <- x1@seed\n                x1@seed <- simplify(x, incremental=TRUE)\n                return(x1)\n            }\n        }\n        if (is(x1, \"DelayedSetDimnames\")) {\n            ## ACTION: swap ops.\n            x2 <- x\n            x2@seed <- x1@seed\n            x2 <- simplify(x2, incremental=TRUE)\n            x1 <- new_DelayedSetDimnames(x2, dimnames(x))\n            return(x1)\n        }\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedUnaryIsoOpStack\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seed <- simplify(x@seed)\n        x1 <- x@seed\n        if (is(x1, \"DelayedUnaryIsoOpStack\")) {\n            ## ACTION: merge ops.\n            x1@OPS <- c(x1@OPS, x@OPS)\n            return(x1)\n        }\n        if (is(x1, \"DelayedSetDimnames\")) {\n            ## ACTION: swap ops.\n            x@seed <- x1@seed\n            x1@seed <- simplify(x, incremental=TRUE)\n            return(x1)\n        }\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedUnaryIsoOpWithArgs\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seed <- simplify(x@seed)\n        x1 <- x@seed\n        if (is(x1, \"DelayedSetDimnames\")) {\n            ## ACTION: swap ops.\n            x@seed <- x1@seed\n            x1@seed <- simplify(x, incremental=TRUE)\n            return(x1)\n        }\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedSubassign\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental)) {\n            x@seed <- simplify(x@seed)\n            x@Rvalue <- simplify(x@Rvalue)\n        }\n        x1 <- x@seed\n        if (is_noop(x))\n            return(x1)\n        if (all(x@.nogap) && !is.null(dim(x@Rvalue))) {\n            ## \"Full replacement\" case with an array-like object on the right.\n            ## 'x' represents a subassignment that replaces all the array\n            ## elements in the left value. This is a degenerate case of\n            ## subassignment where we never need to extract any array element\n            ## from 'x@seed'.\n            if (all(S4Vectors:::sapply_isNULL(x@Lindex))) {\n                ## \"Filling\" case (a special case of \"Full replacement\") with\n                ## an array-like object on the right.\n                ## ACTION: replace DelayedSubassign op with right value.\n                x1 <- x@Rvalue\n            } else {\n                ## ACTION: replace DelayedSubassign op with a subset of\n                ## right value.\n                index <- vector(\"list\", length=length(x@Lindex))\n                Mindex <- make_Mindex(index, x)\n                x1 <- new_DelayedSubset(x@Rvalue, Mindex)\n                x1 <- simplify(x1, incremental=TRUE)\n            }\n            ## Propagate dimnames of left value.\n            x <- new_DelayedSetDimnames(x1, dimnames(x@seed))\n            x <- simplify(x, incremental=TRUE)\n            return(x)\n        }\n        Rvalue <- x@Rvalue\n        if (is(Rvalue, \"DelayedSetDimnames\")) {\n            ## ACTION: remove DelayedSetDimnames op from right value.\n            x@Rvalue <- Rvalue@seed\n        }\n        if (is(x1, \"DelayedSetDimnames\")) {\n            ## ACTION: swap ops.\n            x@seed <- x1@seed\n            x1@seed <- x\n            return(x1)\n        }\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedSetDimnames\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seed <- simplify(x@seed)\n        x1 <- x@seed\n        if (is_noop(x))\n            return(x1)\n        if (is(x1, \"DelayedSetDimnames\")) {\n            ## ACTION: merge ops + remove if no-op.\n            x <- new_DelayedSetDimnames(x1@seed, dimnames(x))\n            if (is_noop(x))\n                return(x@seed)\n            return(x)\n        }\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedNaryIsoOp\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seeds <- lapply(x@seeds, simplify)\n        x\n    }\n)\n\nsetMethod(\"simplify\", \"DelayedAbind\",\n    function(x, incremental=FALSE)\n    {\n        if (!.normarg_incremental(incremental))\n            x@seeds <- lapply(x@seeds, simplify)\n        if (is_noop(x))\n            return(x@seeds[[1L]])\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### isPristine()\n###\n### A pristine DelayedArray object is an object that carries no delayed\n### operation. Note that an object that carries delayed operations that\n### do nothing (e.g. A + 0) is not considered pristine.\n###\n\nisPristine <- function(x, ignore.dimnames=FALSE)\n{\n    if (!is(x, \"DelayedArray\"))\n        stop(wmsg(\"'x' must be a DelayedArray object\"))\n    if (!isTRUEorFALSE(ignore.dimnames))\n        stop(wmsg(\"'ignore.dimnames' should be TRUE or FALSE\"))\n    if (ignore.dimnames && is(x@seed, \"DelayedSetDimnames\"))\n        x@seed <- x@seed@seed  # drop DelayedSetDimnames op\n    !is(x@seed, \"DelayedOp\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### contentIsPristine()\n###\n\n### Return FALSE if the tree contains delayed operations that modify\n### the \"original array values\" (i.e. the values contained in the seeds).\n### The value-modifying nodes are:\n###   - DelayedUnaryIsoOpStack, DelayedUnaryIsoOpWithArgs, and\n###     DelayedNaryIsoOp nodes;\n###   - DelayedSubassign nodes that are not no-ops.\ncontentIsPristine <- function(x)\n{\n    if (!is.list(x) || is.array(x)) {\n        if (!is(x, \"DelayedOp\"))\n            return(TRUE)\n        if (is(x, \"DelayedUnaryIsoOpStack\") ||\n            is(x, \"DelayedUnaryIsoOpWithArgs\") ||\n            is(x, \"DelayedNaryIsoOp\"))\n            return(FALSE)\n        if (is(x, \"DelayedUnaryOp\")) {\n            if (is(x, \"DelayedSubassign\") && !is_noop(x))\n                return(FALSE)\n            x <- list(x@seed)\n        } else {\n            x <- x@seeds\n        }\n    }\n    nchildren <- length(x)\n    for (i in seq_len(nchildren)) {\n        if (!contentIsPristine(x[[i]]))\n            return(FALSE)\n    }\n    TRUE\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### netSubsetAndAperm()\n###\n### Only supported if nseed() == 1\n###\n\n### Remove DelayedUnaryIsoOp nodes from a linear tree.\n### Raise an error if the tree is not linear.\n.remove_unary_iso_ops <- function(x)\n{\n    if (!is(x, \"DelayedOp\"))\n        return(x)\n    if (is(x, \"DelayedNaryOp\")) {\n        ## Tree is not linear.\n        stop(wmsg(\"netSubsetAndAperm() \",\n                  IS_NOT_SUPPORTED_IF_MULTIPLE_SEEDS))\n    }\n    x1 <- .remove_unary_iso_ops(x@seed)\n    if (is(x, \"DelayedUnaryIsoOp\")) {\n        x <- x1\n    } else {\n        x@seed <- x1\n    }\n    x\n}\n\nsetGeneric(\"netSubsetAndAperm\", signature=\"x\",\n    function(x, as.DelayedOp=FALSE) standardGeneric(\"netSubsetAndAperm\")\n)\n\nsetMethod(\"netSubsetAndAperm\", \"ANY\",\n    function(x, as.DelayedOp=FALSE)\n    {\n        if (!isTRUEorFALSE(as.DelayedOp))\n            stop(\"'as.DelayedOp' must be TRUE or FALSE\")\n        reduced <- simplify(.remove_unary_iso_ops(x))\n        if (!is(reduced, \"DelayedAperm\"))\n            reduced <- new_DelayedAperm(reduced)\n        x1 <- reduced@seed\n        if (!is(x1, \"DelayedSubset\"))\n            reduced@seed <- new_DelayedSubset(x1)\n        if (as.DelayedOp)\n            return(reduced)\n        ans <- reduced@seed@index\n        if (!is_noop(reduced))\n            attr(ans, \"dimmap\") <- reduced@perm\n        ans\n    }\n)\n\n",
        "zzz.R": ".onLoad <- function(libname, pkgname)\n{\n    options(DelayedArray.simplify=TRUE)\n    #user_options_file_exists <- S4Arrays:::user_options_file_exists\n    #if (!user_options_file_exists()) {\n    #    ## Initialize DelayedArray user controlled global options (setting\n    #    ## the 1st option creates the file where the options are stored).\n    #    setAutoGridMaker()\n    #    set_auto.block.size()\n    #    set_auto.block.shape()\n    #    setAutoBPPARAM()\n    #}\n    user_option_is_set <- S4Arrays:::user_option_is_set\n    if (!user_option_is_set(\"auto.grid.maker\"))\n        setAutoGridMaker()\n    if (!user_option_is_set(\"auto.block.size\"))\n        set_auto.block.size()\n    if (!user_option_is_set(\"auto.block.shape\"))\n        set_auto.block.shape()\n    if (!user_option_is_set(\"auto.BPPARAM\"))\n        setAutoBPPARAM()\n    if (!user_option_is_set(\"auto.mult.parallel.agnostic\"))\n        setAutoMultParallelAgnostic()\n}\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"DelayedArray\", libpath)\n}\n\n.test <- function()\n{\n    ## Unit tests temporarily disabled on merida1 and kjohnson3 ...\n    slow_build_machine <- function() {\n        isTRUE(as.logical(Sys.getenv(\"IS_BIOC_BUILD_MACHINE\"))) &&\n            (tolower(Sys.info()[[\"nodename\"]]) %in% c(\"merida1\", \"kjohnson3\"))\n    }\n    if (!slow_build_machine()) {\n        setAutoRealizationBackend(\"RleArray\")\n        on.exit(setAutoRealizationBackend())\n        BiocGenerics:::testPackage(\"DelayedArray\")\n    }\n}\n\n"
    },
    "BiocParallel": {
        "AllGenerics.R": "setGeneric(\"bplapply\", signature=c(\"X\", \"BPPARAM\"),\n    function(X, FUN, ...,\n             BPREDO=list(), BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n    standardGeneric(\"bplapply\"))\n\nsetGeneric(\"bpmapply\", signature=c(\"FUN\", \"BPPARAM\"),\n    function(FUN, ..., MoreArgs=NULL, SIMPLIFY=TRUE, USE.NAMES=TRUE,\n             BPREDO=list(), BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n    standardGeneric(\"bpmapply\"))\n\nsetGeneric(\"bpiterate\", signature=c(\"ITER\", \"FUN\", \"BPPARAM\"),\n    function(ITER, FUN, ..., BPREDO=list(), BPPARAM=bpparam(),\n             BPOPTIONS = bpoptions())\n    standardGeneric(\"bpiterate\"))\n\nsetGeneric(\"bpvec\", signature=c(\"X\", \"BPPARAM\"),\n    function(X, FUN, ..., AGGREGATE=c, BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n    standardGeneric(\"bpvec\"))\n\nsetGeneric(\"bpvectorize\",\n    function(FUN, ...,\n             BPREDO=list(), BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n    standardGeneric(\"bpvectorize\"))\n\nsetGeneric(\"bpaggregate\", signature=c(\"x\", \"BPPARAM\"),\n    function(x, ..., BPREDO=list(), BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n    standardGeneric(\"bpaggregate\"))\n\n##\n## accessors\n##\n\nsetGeneric(\"bpworkers\",\n    function(x) standardGeneric(\"bpworkers\"))\n\nsetGeneric(\"bpworkers<-\",\n    function(x, value) standardGeneric(\"bpworkers<-\"))\n\nsetGeneric(\"bptasks\",\n    function(x) standardGeneric(\"bptasks\"))\n\nsetGeneric(\"bptasks<-\",\n    function(x, value) standardGeneric(\"bptasks<-\"))\n\nsetGeneric(\"bpjobname\",\n    function(x) standardGeneric(\"bpjobname\"))\n\nsetGeneric(\"bpjobname<-\",\n    function(x, value) standardGeneric(\"bpjobname<-\"))\n\nsetGeneric(\"bpRNGseed\",\n    function(x) standardGeneric(\"bpRNGseed\"))\n\nsetGeneric(\"bpRNGseed<-\",\n    function(x, value) standardGeneric(\"bpRNGseed<-\"))\n\nsetGeneric(\"bpforceGC\",\n    function(x) standardGeneric(\"bpforceGC\"))\n\nsetGeneric(\"bpforceGC<-\",\n    function(x, value) standardGeneric(\"bpforceGC<-\"))\n\nsetGeneric(\"bpfallback\",\n    function(x) standardGeneric(\"bpfallback\"))\n\nsetGeneric(\"bpfallback<-\",\n    function(x, value) standardGeneric(\"bpfallback<-\"))\n\n## errors\n\nsetGeneric(\"bpstopOnError\",\n    function(x) standardGeneric(\"bpstopOnError\"))\n\nsetGeneric(\"bpstopOnError<-\",\n    function(x, value) standardGeneric(\"bpstopOnError<-\"))\n\n## logging / progress\n\nsetGeneric(\"bpprogressbar\",\n    function(x) standardGeneric(\"bpprogressbar\"))\n\nsetGeneric(\"bpprogressbar<-\",\n    function(x, value) standardGeneric(\"bpprogressbar<-\"))\n\nsetGeneric(\"bptimeout\",\n    function(x) standardGeneric(\"bptimeout\"))\n\nsetGeneric(\"bptimeout<-\",\n    function(x, value) standardGeneric(\"bptimeout<-\"))\n\nsetGeneric(\"bpexportglobals\",\n    function(x) standardGeneric(\"bpexportglobals\"))\n\nsetGeneric(\"bpexportglobals<-\",\n    function(x, value) standardGeneric(\"bpexportglobals<-\"))\n\nsetGeneric(\"bpexportvariables\",\n    function(x) standardGeneric(\"bpexportvariables\"))\n\nsetGeneric(\"bpexportvariables<-\",\n    function(x, value) standardGeneric(\"bpexportvariables<-\"))\n\nsetGeneric(\"bplog\",\n    function(x) standardGeneric(\"bplog\"))\n\nsetGeneric(\"bplog<-\",\n    function(x, value) standardGeneric(\"bplog<-\"))\n\nsetGeneric(\"bplogdir\",\n    function(x) standardGeneric(\"bplogdir\"))\n\nsetGeneric(\"bplogdir<-\",\n    function(x, value) standardGeneric(\"bplogdir<-\"))\n\nsetGeneric(\"bpthreshold\",\n    function(x) standardGeneric(\"bpthreshold\"))\n\nsetGeneric(\"bpthreshold<-\",\n    function(x, value) standardGeneric(\"bpthreshold<-\"))\n\nsetGeneric(\"bpresultdir\",\n    function(x) standardGeneric(\"bpresultdir\"))\n\nsetGeneric(\"bpresultdir<-\",\n    function(x, value) standardGeneric(\"bpresultdir<-\"))\n\n## control\n\nsetGeneric(\"bpstart\",\n    function(x, ...) standardGeneric(\"bpstart\"))\n\nsetGeneric(\"bpstop\",\n    function(x) standardGeneric(\"bpstop\"))\n\nsetGeneric(\"bpisup\",\n    function(x) standardGeneric(\"bpisup\"))\n\nsetGeneric(\"bpbackend\",\n    function(x) standardGeneric(\"bpbackend\"))\n\nsetGeneric(\"bpbackend<-\",\n    function(x, value) standardGeneric(\"bpbackend<-\"))\n\n## scheduling\n\nsetGeneric(\"bpschedule\",\n    function(x) standardGeneric(\"bpschedule\"))\n",
        "BatchtoolsParam-class.R": "### ================================================================\n### BatchtoolsParam objects\n### ----------------------------------------------------------------\n\n.BATCHTOOLS_CLUSTERS <- c(\n    \"socket\", \"multicore\", \"interactive\", \"sge\", \"slurm\", \"lsf\", \"openlava\",\n    \"torque\"\n)\n\n### -------------------------------------------------\n###  Helper functions\n###\n\nbatchtoolsWorkers <-\n    function(cluster = batchtoolsCluster())\n{\n    switch(\n        match.arg(cluster, .BATCHTOOLS_CLUSTERS),\n        interactive = 1L,\n        socket = snowWorkers(\"SOCK\"),\n        multicore = multicoreWorkers(),\n        stop(\"specify number of workers for '\", cluster, \"'\")\n    )\n}\n\nbatchtoolsCluster <-\n    function(cluster)\n{\n    if (missing(cluster)) {\n        if (.Platform$OS.type == \"windows\") {\n            cluster <- \"socket\"\n        } else {\n            cluster <- \"multicore\"\n        }\n    } else {\n        cluster <- match.arg(cluster, .BATCHTOOLS_CLUSTERS)\n    }\n    cluster\n}\n\n.batchtoolsClusterAvailable <-\n    function(cluster)\n{\n    switch(\n        cluster,\n        socket = TRUE,\n        multicore = .Platform$OS.type != \"windows\",\n        interactive = TRUE,\n        sge = suppressWarnings(system2(\"qstat\", stderr=NULL, stdout=NULL) != 127L),\n        slurm = suppressWarnings(system2(\"squeue\", stderr=NULL, stdout=NULL) != 127L),\n        lsf = suppressWarnings(system2(\"bjobs\", stderr=NULL, stdout=NULL) != 127L),\n        openlava = suppressWarnings(system2(\"bjobs\", stderr=NULL, stdout=NULL) != 127L),\n        torque = suppressWarnings(system2(\"qselect\", stderr=NULL, stdout=NULL) != 127L),\n        .stop(\n            \"unsupported cluster type '\", cluster, \"'; \",\n            \"supported types (when available):\\n\",\n            \"  \", paste0(\"'\", .BATCHTOOLS_CLUSTERS, \"'\", collapse = \", \")\n        )\n    )\n}\n\nbatchtoolsTemplate <-\n    function(cluster)\n{\n    if (!cluster %in% .BATCHTOOLS_CLUSTERS)\n        stop(\"unsupported cluster type '\", cluster, \"'\")\n    if (cluster %in% c(\"socket\", \"multicore\", \"interactive\"))\n        return(NA_character_)\n\n    message(\"using default '\", cluster, \"' template in batchtools.\")\n    if (cluster == \"torque\")\n        tmpl <- \"torque-lido.tmpl\"\n    else\n        tmpl <- sprintf(\"%s-simple.tmpl\", tolower(cluster))\n    ## return template\n    system.file(\"templates\", tmpl, package=\"batchtools\")\n}\n\nbatchtoolsRegistryargs <- function(...) {\n    args <- list(...)\n\n    ## our defaults...\n    registryargs <- as.list(formals(batchtools::makeRegistry))\n    registryargs$file.dir <- tempfile(tmpdir=getwd())\n    registryargs$conf.file <- registryargs$seed <- NULL\n    registryargs$make.default <- FALSE\n\n    ## ...modified by user\n    registryargs[names(args)] <- args\n\n    registryargs\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nsetOldClass(\"Registry\")\n\nsetOldClass(c(\"NULLRegistry\", \"Registry\"))\n\n.NULLRegistry <-\n    function()\n{\n    structure(list(), class=c(\"NULLRegistry\", \"Registry\"))\n}\n\nprint.NULLRegistry <-\n    function(x, ...)\n{\n    cat(\"NULL Job Registry\\n\")\n}\n\nsetOldClass(\"ClusterFunctions\")\n\n.BatchtoolsParam_prototype <- c(\n    list(\n        cluster = NA_character_,\n        template = NA_character_,\n        registry = .NULLRegistry(),\n        registryargs = list(),\n        saveregistry = FALSE,\n        resources = list()\n    ),\n    .BiocParallelParam_prototype\n)\n\n.BatchtoolsParam <- setRefClass(\n    \"BatchtoolsParam\",\n    contains=\"BiocParallelParam\",\n    fields = list(\n        cluster = \"character\",\n        template = \"character\",\n        registry = \"Registry\",\n        registryargs = \"list\",\n        saveregistry = \"logical\",\n        resources = \"list\"\n    ),\n    methods = list(\n        show = function() {\n            callSuper()\n            .registryargs <- .bpregistryargs(.self)\n            .resources <- .bpresources(.self)\n            cat(\"  cluster type: \", bpbackend(.self),\n                \"\\n\", .prettyPath(\"  template\", .bptemplate(.self)),\n                \"\\n  registryargs:\",\n                paste0(\"\\n    \", names(.registryargs), \": \", .registryargs),\n                \"\\n  saveregistry: \", .bpsaveregistry(.self),\n                \"\\n  resources:\",\n                if (length(.resources))\n                    paste0(\"\\n    \", names(.resources), \": \", .resources),\n                \"\\n\", sep=\"\")\n        }\n    )\n)\n\nBatchtoolsParam <-\n    function(\n        workers = batchtoolsWorkers(cluster),\n        ## Provide either cluster or template\n        cluster = batchtoolsCluster(),\n        registryargs = batchtoolsRegistryargs(),\n        saveregistry = FALSE,\n        resources = list(),\n        template = batchtoolsTemplate(cluster),\n        stop.on.error = TRUE,\n        progressbar=FALSE, RNGseed = NA_integer_,\n        timeout= WORKER_TIMEOUT, exportglobals=TRUE,\n        log=FALSE, logdir=NA_character_,\n        resultdir=NA_character_, jobname = \"BPJOB\"\n    )\n{\n    if (!requireNamespace(\"batchtools\", quietly=TRUE))\n        stop(\"BatchtoolsParam() requires 'batchtools' package\")\n\n    if (!.batchtoolsClusterAvailable(cluster))\n        stop(\"'\", cluster, \"' supported but not available on this machine\")\n\n    if (length(resources)  && is.null(names(resources)))\n        stop(\"'resources' must be a named list\")\n\n    workers <- .enforceWorkers(workers)\n\n    prototype <- .prototype_update(\n        .BatchtoolsParam_prototype,\n        workers = as.integer(workers), cluster = cluster,\n        registry = .NULLRegistry(),\n        registryargs = registryargs,\n        saveregistry = saveregistry,\n        resources = resources,\n        jobname = jobname, progressbar = progressbar, log = log,\n        logdir = logdir, resultdir = resultdir, stop.on.error = stop.on.error,\n        timeout = as.integer(timeout), exportglobals = exportglobals,\n        RNGseed = as.integer(RNGseed), template = template\n    )\n\n    param <- do.call(.BatchtoolsParam, prototype)\n    validObject(param)\n    param\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\nsetValidity(\"BatchtoolsParam\", function(object)\n{\n    msg <- NULL\n    if (!bpbackend(object) %in% .BATCHTOOLS_CLUSTERS) {\n        types <- paste(.BATCHTOOLS_CLUSTERS, collape = \", \")\n        msg <- c(msg, paste(\"'cluster' must be one of\", types))\n    }\n\n    if (is.null(msg))\n        TRUE\n    else\n        msg\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - control\n###\n\nsetMethod(\"bpisup\", \"BatchtoolsParam\",\n    function(x)\n{\n    !is(x$registry, \"NULLRegistry\")\n})\n\n.bpregistryargs <-\n    function(x)\n{\n    x$registryargs\n}\n\n.bpsaveregistry <-\n    function(x)\n{\n    x$saveregistry\n}\n\n.bpsaveregistry_path <-\n    function(x)\n{\n    ## update registry location\n    pattern <- \"\\\\-[0-9]+$\"\n    file.dir <- .bpregistryargs(x)$file.dir\n    dirname <- dirname(file.dir)\n    basename <- basename(file.dir)\n    dirs <- dir(dirname, paste0(basename, pattern))\n    n <- 0L\n    if (length(dirs))\n        n <- max(as.integer(sub(\".*\\\\-\", \"\", dirs)))\n    file.path(dirname, paste0(basename, \"-\", n + 1L))\n}\n\n.bpresources <-\n    function(x)\n{\n    x$resources\n}\n\n.bptemplate <-\n    function(x)\n{\n    x$template\n}\n\n.composeBatchtools <-\n    function(FUN)\n{\n    force(FUN)\n    function(fl, ...) {\n        x <- readRDS(fl)\n        FUN(x, ...)\n    }\n}\n\nsetMethod(\"bpbackend\", \"BatchtoolsParam\",\n    function(x)\n{\n    x$cluster\n})\n\nsetMethod(\"bpstart\", \"BatchtoolsParam\",\n    function(x)\n{\n    if (bpisup(x))\n        return(invisible(x))\n\n    cluster <- bpbackend(x)\n    registryargs <- .bpregistryargs(x)\n\n    oopt <- options(batchtools.verbose = FALSE)\n    on.exit(options(oopt))\n\n    seed <- bpRNGseed(x)\n    if (!is.na(seed))\n        registryargs$seed <- seed\n\n    if (.bpsaveregistry(x)) {\n        ## the registry$file.dir gets -0, -1, -2... for each bpstart on the\n        ## same parameter\n        registryargs$file.dir <- .bpsaveregistry_path(x)\n    }\n\n    registry <- do.call(batchtools::makeRegistry, registryargs)\n\n    registry$cluster.functions <- switch(\n        cluster,\n        interactive = batchtools::makeClusterFunctionsInteractive(),\n        socket = batchtools::makeClusterFunctionsSocket(bpnworkers(x)),\n        multicore = batchtools::makeClusterFunctionsMulticore(bpnworkers(x)),\n        sge = batchtools::makeClusterFunctionsSGE(template = .bptemplate(x)),\n        ## Add mutliple cluster support\n        slurm = batchtools::makeClusterFunctionsSlurm(template=.bptemplate(x)),\n        lsf = batchtools::makeClusterFunctionsLSF(template=.bptemplate(x)),\n        openlava = batchtools::makeClusterFunctionsOpenLava(\n            template=.bptemplate(x)\n        ),\n        torque = batchtools::makeClusterFunctionsTORQUE(\n            template=.bptemplate(x)\n        ),\n        default = stop(\"unsupported cluster type '\", cluster, \"'\")\n    )\n\n    x$registry <- registry              # toggles bpisup()\n    invisible(x)\n})\n\nsetMethod(\"bpstop\", \"BatchtoolsParam\",\n          function(x)\n{\n    wait <- getOption(\"BIOCPARALLEL_BATCHTOOLS_REMOVE_REGISTRY_WAIT\", 5)\n    if (!.bpsaveregistry(x))\n        suppressMessages({\n            batchtools::removeRegistry(wait = wait, reg = x$registry)\n        })\n\n    x$registry <- .NULLRegistry()       # toggles bpisup()\n    invisible(x)\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - evaluation\n###\n\nsetMethod(\"bplapply\", c(\"ANY\", \"BatchtoolsParam\"),\n          function(X, FUN, ..., BPREDO = list(),\n                   BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n\n    if (!length(X))\n        return(.rename(list(), X))\n\n    if (is(X, \"List\"))\n        ## hack; issue 82\n        X <- as.list(X)\n\n    idx <- .redo_index(X, BPREDO)\n    if (length(idx))\n        X <- X[idx]\n    nms <- names(X)\n\n    ## start / stop cluster\n    if (!bpisup(BPPARAM)) {\n        BPPARAM <- bpstart(BPPARAM)\n        on.exit(bpstop(BPPARAM), TRUE)\n    }\n\n    ## progressbar / verbose\n    if (bpprogressbar(BPPARAM)) {\n        opts <- options(\n            BBmisc.ProgressBar.style=\"text\", batchtools.verbose = TRUE\n        )\n        on.exit({\n            ## message(\"\")                 # clear progress bar\n            options(opts)\n        }, TRUE)\n    } else {\n        opts <- options(\n            BBmisc.ProgressBar.style=\"off\", batchtools.verbose = FALSE\n        )\n        on.exit(options(opts), TRUE)\n    }\n\n    registry <- BPPARAM$registry\n\n    OPTIONS <- .workerOptions(\n        log = bplog(BPPARAM),\n        stop.on.error = bpstopOnError(BPPARAM),\n        timeout = bptimeout(BPPARAM),\n        exportglobals = bpexportglobals(BPPARAM)\n    )\n\n    FUN <- .composeTry(\n        FUN, OPTIONS = OPTIONS, SEED = NULL\n    )\n\n    ##  Make registry / map / submit / wait / load\n    ids = batchtools::batchMap(\n        fun=FUN, X, more.args = list(...), reg = registry\n    )\n    ids$chunk = batchtools::chunk(ids$job.id, n.chunks = bpnworkers(BPPARAM))\n\n    batchtools::submitJobs(\n        ids = ids, resources = .bpresources(BPPARAM), reg = registry\n    )\n    batchtools::waitForJobs(\n        ids = ids, reg = registry, timeout = .batch_bptimeout(BPPARAM),\n        stop.on.error = bpstopOnError(BPPARAM)\n    )\n    res <- batchtools::reduceResultsList(ids = ids, reg = registry)\n\n    ## Copy logs from log dir to bplogdir before clearing registry\n    if (bplog(BPPARAM) && !is.na(bplogdir(BPPARAM))) {\n        logs <- file.path(.bpregistryargs(BPPARAM)$file.dir, \"logs\")\n        ## Create log dir\n        if (!file.exists(bplogdir(BPPARAM)))\n            dir.create(bplogdir(BPPARAM))\n        ## Recursive copy logs\n        file.copy(logs, bplogdir(BPPARAM) , recursive=TRUE, overwrite=TRUE)\n    }\n\n    ## Clear registry\n    if (bpprogressbar(BPPARAM))\n        message(\"Clearing registry ...\")\n\n    if (!.bpsaveregistry(BPPARAM))\n        ## WARNING Save a registry in a folder with extension,\n        ## _saved_registry. BatchtoolsParam('saveregistry=TRUE') option\n        ## should be set only when debugging. This can be extremely\n        ## time and space intensive.\n        suppressMessages({\n            batchtools::clearRegistry(reg=registry)\n        })\n\n    if (!is.null(res))\n        names(res) <- nms\n\n    if (length(BPREDO) && length(idx)) {\n        BPREDO[idx] <- res\n        res <- BPREDO\n    }\n\n    if (!.bpallok(res))\n        stop(.error_bplist(res))\n\n    res\n})\n\n\nsetMethod(\"bpiterate\", c(\"ANY\", \"ANY\", \"BatchtoolsParam\"),\n    function(ITER, FUN, ..., REDUCE, init, reduce.in.order=FALSE,\n             BPREDO = list(), BPPARAM=bpparam(), BPOPTIONS=bpoptions())\n{\n    ITER <- match.fun(ITER)\n    FUN <- match.fun(FUN)\n\n    if (missing(REDUCE)) {\n        if (reduce.in.order)\n            stop(\"REDUCE must be provided when 'reduce.in.order = TRUE'\")\n        if (!missing(init))\n            stop(\"REDUCE must be provided when 'init' is given\")\n    }\n\n    if (!bpschedule(BPPARAM) || bpnworkers(BPPARAM) == 1L) {\n        param <- as(BPPARAM, \"SerialParam\")\n        return(\n            bpiterate(ITER, FUN, ..., REDUCE=REDUCE, init=init,\n                      BPREDO = BPREDO, BPPARAM=param, BPOPTIONS=BPOPTIONS)\n        )\n    }\n\n    if (!identical(BPREDO, list()))\n        stop(\"BPREDO is not supported by the BatchtoolsParam yet!\")\n\n    ## start / stop cluster\n    if (!bpisup(BPPARAM)) {\n        bpstart(BPPARAM)\n        on.exit(bpstop(BPPARAM))\n    }\n\n    OPTIONS <- .workerOptions(\n        log = bplog(BPPARAM),\n        stop.on.error = bpstopOnError(BPPARAM),\n        timeout = bptimeout(BPPARAM),\n        exportglobals = bpexportglobals(BPPARAM)\n    )\n\n    ## composeTry\n    FUN <- .composeTry(\n        FUN, OPTIONS = OPTIONS, SEED = NULL\n    )\n\n    FUN <- .composeBatchtools(FUN)\n\n    ## Call batchtoolsIterate with arguments\n    bploop(structure(list(), class=\"iterate_batchtools\"),\n           ITER, FUN, BPPARAM, REDUCE, init, reduce.in.order, ...)\n})\n",
        "BiocParallel-defunct.R": "bprunMPIslave <- function() {\n    .Defunct(\"bprunMPIworker\")\n}\n\nBatchJobsParam <-\n    function(workers=NA_integer_, cleanup=TRUE,\n        work.dir=getwd(), stop.on.error=TRUE, seed=NULL, resources=NULL,\n        conffile=NULL, cluster.functions=NULL,\n        progressbar=TRUE, jobname = \"BPJOB\",\n        timeout = WORKER_TIMEOUT,\n        reg.pars=list(seed=seed, work.dir=work.dir),\n        conf.pars=list(conffile=conffile, cluster.functions=cluster.functions),\n        submit.pars=list(resources=resources), ...)\n{\n    .Defunct(\"BatchtoolsParam\")\n}\n",
        "BiocParallelParam-class.R": "### =========================================================================\n### BiocParallelParam objects\n### -------------------------------------------------------------------------\n\n.BiocParallelParam_prototype <- list(\n    workers=0L,\n    tasks=0L,\n    jobname=\"BPJOB\",\n    log=FALSE,\n    logdir = NA_character_,\n    threshold=\"INFO\",\n    resultdir = NA_character_,\n    stop.on.error=TRUE,\n    timeout=WORKER_TIMEOUT,\n    exportglobals=TRUE,\n    exportvariables=TRUE,\n    progressbar=FALSE,\n    RNGseed=NULL,\n    RNGstream = NULL,\n    force.GC = FALSE,\n    fallback = TRUE\n)\n\n.BiocParallelParam <- setRefClass(\"BiocParallelParam\",\n    contains=\"VIRTUAL\",\n    fields=list(\n        workers=\"ANY\",\n        tasks=\"integer\",\n        jobname=\"character\",\n        progressbar=\"logical\",\n        ## required for composeTry\n        log=\"logical\",\n        logdir = \"character\",\n        threshold=\"character\",\n        resultdir = \"character\",\n        stop.on.error=\"logical\",\n        timeout=\"integer\",\n        exportglobals=\"logical\",\n        exportvariables=\"logical\",\n        RNGseed = \"ANY\",        # NULL or integer(1)\n        RNGstream = \"ANY\",      # NULL or integer(); internal use only\n        force.GC = \"logical\",\n        fallback = \"logical\",\n        ## cluster management\n        .finalizer_env = \"environment\",\n        .uid = \"character\"\n    ),\n    methods=list(\n        show = function() {\n            cat(\"class: \", class(.self),\n                \"\\n\",\n                \"  bpisup: \", bpisup(.self),\n                \"; bpnworkers: \", bpnworkers(.self),\n                \"; bptasks: \", bptasks(.self),\n                \"; bpjobname: \", bpjobname(.self),\n                \"\\n\",\n                \"  bplog: \", bplog(.self),\n                \"; bpthreshold: \", bpthreshold(.self),\n                \"; bpstopOnError: \", bpstopOnError(.self),\n                \"\\n\",\n                \"  bpRNGseed: \", bpRNGseed(.self),\n                \"; bptimeout: \", bptimeout(.self),\n                \"; bpprogressbar: \", bpprogressbar(.self),\n                \"\\n\",\n                \"  bpexportglobals: \", bpexportglobals(.self),\n                \"; bpexportvariables: \", bpexportvariables(.self),\n                \"; bpforceGC: \", bpforceGC(.self),\n                \"\\n\",\n                \"  bpfallback: \", bpfallback(.self),\n                \"\\n\", .prettyPath(\"  bplogdir\", bplogdir(.self)),\n                \"\\n\", .prettyPath(\"  bpresultdir\", bpresultdir(.self)),\n                \"\\n\", sep=\"\")\n        })\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\nsetValidity(\"BiocParallelParam\", function(object)\n{\n    msg <- NULL\n\n    ## workers and tasks\n    workers <- bpworkers(object)\n    if (is.numeric(workers))\n        if (length(workers) != 1L || workers < 0)\n            msg <- c(msg, \"'workers' must be integer(1) and >= 0\")\n\n    tasks <- bptasks(object)\n    if (!is.numeric(tasks))\n        msg <- c(msg, \"bptasks(BPPARAM) must be an integer\")\n    if (length(tasks) > 1L)\n        msg <- c(msg, \"length(bptasks(BPPARAM)) must be == 1\")\n    if (!is.na(tasks) && tasks < 0L)\n        msg <- c(msg, \"bptasks(BPPARAM) must be >= 0 or 'NA'\")\n\n    if (is.character(workers)) {\n        if (length(workers) < 1L)\n            msg <- c(msg, \"length(bpworkers(BPPARAM)) must be > 0\")\n        if (!is.na(tasks) && tasks > 0L && tasks < length(workers))\n            msg <- c(msg, \"number of tasks is less than number of workers\")\n    }\n\n    if (!.isTRUEorFALSE(bpexportglobals(object)))\n        msg <- c(msg, \"'bpexportglobals' must be TRUE or FALSE\")\n\n    if (!.isTRUEorFALSE(bpexportvariables(object)))\n        msg <- c(msg, \"'bpexportvariables' must be TRUE or FALSE\")\n\n    if (!.isTRUEorFALSE(bplog(object)))\n        msg <- c(msg, \"'bplog' must be logical(1)\")\n\n    ## log / logdir\n    dir <- bplogdir(object)\n    if (length(dir) != 1L || !is(dir, \"character\")) {\n        msg <- c(msg, \"'logdir' must be character(1)\")\n    } else if (!is.na(dir)) {\n        if (!bplog(object))\n            msg <- c(msg, \"'log' must be TRUE when 'logdir' is given\")\n        if (!.dir_valid_rw(dir))\n            msg <- c(msg, \"'logdir' must exist with read / write permission\")\n    }\n\n    ## resultdir\n    dir <- bpresultdir(object)\n    if (length(dir) != 1L || !is(dir, \"character\")) {\n        msg <- c(msg, \"'resultdir' must be character(1)\")\n    } else if (!is.na(dir) && !.dir_valid_rw(dir)) {\n        msg <- c(msg, \"'resultdir' must exist with read / write permissions\")\n    }\n\n    levels <- c(\"TRACE\", \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"FATAL\")\n    threshold <- bpthreshold(object)\n    if (length(threshold) > 1L) {\n        msg <- c(msg, \"'bpthreshold' must be character(0) or character(1)\")\n    } else if ((length(threshold) == 1L) && (!threshold %in% levels)) {\n        txt <- sprintf(\"'bpthreshold' must be one of %s\",\n                       paste(sQuote(levels), collapse=\", \"))\n        msg <- c(msg, paste(strwrap(txt, indent=2, exdent=2), collapse=\"\\n\"))\n    }\n\n    if (!.isTRUEorFALSE(bpstopOnError(object)))\n        msg <- c(msg, \"'bpstopOnError' must be TRUE or FALSE\")\n\n    if (!.isTRUEorFALSE(bpforceGC(object)))\n        msg <- c(msg, \"'force.GC' must be TRUE or FALSE\")\n\n    if (is.null(msg)) TRUE else msg\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters / Setters\n###\n\nsetMethod(\"bpworkers\", \"BiocParallelParam\",\n   function(x)\n{\n    x$workers\n})\n\nsetMethod(\"bptasks\", \"BiocParallelParam\",\n   function(x)\n{\n    x$tasks\n})\n\nsetReplaceMethod(\"bptasks\", c(\"BiocParallelParam\", \"ANY\"),\n    function(x, value)\n{\n    x$tasks <- as.integer(value)\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpjobname\", \"BiocParallelParam\",\n   function(x)\n{\n    x$jobname\n})\n\nsetReplaceMethod(\"bpjobname\", c(\"BiocParallelParam\", \"character\"),\n    function(x, value)\n{\n    x$jobname <- value\n    x\n})\n\nsetMethod(\"bplog\", \"BiocParallelParam\",\n    function(x)\n{\n    x$log\n})\n\nsetMethod(\"bplogdir\", \"BiocParallelParam\",\n    function(x)\n{\n    x$logdir\n})\n\nsetReplaceMethod(\"bplogdir\", c(\"BiocParallelParam\", \"character\"),\n    function(x, value)\n{\n    if (bpisup(x))\n        stop(\"use 'bpstop()' before setting 'bplogdir()'\")\n\n    x$logdir <- value\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpthreshold\", \"BiocParallelParam\",\n    function(x)\n{\n    x$threshold\n})\n\nsetMethod(\"bpresultdir\", \"BiocParallelParam\",\n    function(x)\n{\n    x$resultdir\n})\n\nsetReplaceMethod(\"bpresultdir\", c(\"BiocParallelParam\", \"character\"),\n    function(x, value)\n{\n    if (bpisup(x))\n        stop(\"use 'bpstop()' before setting 'bpresultdir()'\")\n\n    x$resultdir <- value\n    validObject(x)\n    x\n})\n\nsetMethod(\"bptimeout\", \"BiocParallelParam\",\n    function(x)\n{\n    x$timeout\n})\n\nsetReplaceMethod(\"bptimeout\", c(\"BiocParallelParam\", \"numeric\"),\n    function(x, value)\n{\n    x$timeout <- as.integer(value)\n    x\n})\n\nsetMethod(\"bpexportglobals\", \"BiocParallelParam\",\n    function(x)\n{\n    x$exportglobals\n})\n\nsetReplaceMethod(\"bpexportglobals\", c(\"BiocParallelParam\", \"logical\"),\n    function(x, value)\n{\n    x$exportglobals <- value\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpexportvariables\", \"BiocParallelParam\",\n    function(x)\n{\n    x$exportvariables\n})\n\nsetReplaceMethod(\"bpexportvariables\", c(\"BiocParallelParam\", \"logical\"),\n    function(x, value)\n{\n    x$exportvariables <- value\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpstopOnError\", \"BiocParallelParam\",\n    function(x)\n{\n    x$stop.on.error\n})\n\nsetReplaceMethod(\"bpstopOnError\", c(\"BiocParallelParam\", \"logical\"),\n    function(x, value)\n{\n    x$stop.on.error <- value\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpprogressbar\", \"BiocParallelParam\",\n    function(x)\n{\n    x$progressbar\n})\n\nsetReplaceMethod(\"bpprogressbar\", c(\"BiocParallelParam\", \"logical\"),\n    function(x, value)\n{\n    x$progressbar <- value\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpRNGseed\", \"BiocParallelParam\",\n    function(x)\n{\n    x$RNGseed\n})\n\nsetReplaceMethod(\"bpRNGseed\", c(\"BiocParallelParam\", \"NULL\"),\n    function(x, value)\n{\n    x$RNGseed <- NULL\n    .RNGstream(x) <- NULL\n    validObject(x)\n    x\n})\n\nsetReplaceMethod(\"bpRNGseed\", c(\"BiocParallelParam\", \"numeric\"),\n    function(x, value)\n{\n    x$RNGseed <- as.integer(value)\n    .RNGstream(x) <- NULL\n    validObject(x)\n    x\n})\n\n.RNGstream <-\n    function(x)\n{\n    if (length(x$RNGstream) == 0)\n        .RNGstream(x) <- .rng_init_stream(bpRNGseed(x))\n    x$RNGstream\n}\n\n`.RNGstream<-` <-\n    function(x, value)\n{\n    value <- as.integer(value)\n    if (anyNA(value))\n        stop(\"[internal] RNGstream value could not be coerced to integer\")\n    x$RNGstream <- value\n    x\n}\n\n.bpnextRNGstream <-\n    function(x)\n{\n    ## initialize or get the next random number stream; increment the\n    ## stream only in bpstart_impl\n    .RNGstream(x) <- .rng_next_stream(.RNGstream(x))\n}\n\nsetMethod(\"bpforceGC\", \"BiocParallelParam\",\n    function(x)\n{\n    x$force.GC\n})\n\nsetReplaceMethod(\"bpforceGC\", c(\"BiocParallelParam\", \"numeric\"),\n    function(x, value)\n{\n    x$force.GC <- as.logical(value)\n    validObject(x)\n    x\n})\n\nsetMethod(\"bpfallback\", \"BiocParallelParam\",\n    function(x)\n{\n    x$fallback\n})\n\nsetReplaceMethod(\"bpfallback\", c(\"BiocParallelParam\", \"logical\"),\n    function(x, value)\n{\n    x$fallback <- value\n    validObject(x)\n    x\n})\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - evaluation\n###\n\nsetMethod(\"bpstart\", \"BiocParallelParam\", .bpstart_impl)\n\nsetMethod(\"bpstop\", \"BiocParallelParam\", .bpstop_impl)\n\nsetMethod(\"bplapply\", c(\"ANY\", \"BiocParallelParam\"), .bplapply_impl)\n\nsetMethod(\"bpiterate\", c(\"ANY\", \"ANY\", \"BiocParallelParam\"), .bpiterate_impl)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helpers\n###\n\n## taken from S4Vectors\n.isTRUEorFALSE <- function (x) {\n    is.logical(x) && length(x) == 1L && !is.na(x)\n}\n",
        "DeveloperInterface.R": "##\n## see NAMESPACE section for definitive exports\n##\n## Manager class\n.TaskManager <- setClass(\"TaskManager\", contains = \"environment\")\n\n## server\nsetGeneric(\n    \".send_to\",\n    function(backend, node, value) standardGeneric(\".send_to\"),\n    signature = \"backend\"\n)\n\nsetGeneric(\n    \".recv_any\",\n    function(backend) standardGeneric(\".recv_any\"),\n    signature = \"backend\"\n)\n\nsetGeneric(\n    \".send_all\",\n    function(backend, value) standardGeneric(\".send_all\"),\n    signature = \"backend\"\n)\n\nsetGeneric(\n    \".recv_all\",\n    function(backend) standardGeneric(\".recv_all\"),\n    signature = \"backend\"\n)\n\n## client\n\nsetGeneric(\n    \".send\",\n    function(worker, value) standardGeneric(\".send\"),\n    signature = \"worker\"\n)\n\nsetGeneric(\n    \".recv\",\n    function(worker) standardGeneric(\".recv\"),\n    signature = \"worker\"\n)\n\nsetGeneric(\n    \".close\",\n    function(worker) standardGeneric(\".close\"),\n    signature = \"worker\"\n)\n\n## task manager\nsetGeneric(\n    \".manager\",\n    function(BPPARAM) standardGeneric(\".manager\"),\n    signature = \"BPPARAM\"\n)\n\nsetGeneric(\n    \".manager_send\",\n    function(manager, value, ...) standardGeneric(\".manager_send\"),\n    signature = \"manager\"\n)\n\nsetGeneric(\n    \".manager_recv\",\n    function(manager) standardGeneric(\".manager_recv\"),\n    signature = \"manager\"\n)\n\nsetGeneric(\n  \".manager_send_all\",\n  function(manager, value) standardGeneric(\".manager_send_all\"),\n  signature = \"manager\"\n)\n\nsetGeneric(\n  \".manager_recv_all\",\n  function(manager) standardGeneric(\".manager_recv_all\"),\n  signature = \"manager\"\n)\n\nsetGeneric(\n    \".manager_capacity\",\n    function(manager) standardGeneric(\".manager_capacity\"),\n    signature = \"manager\"\n)\n\nsetGeneric(\n    \".manager_flush\",\n    function(manager) standardGeneric(\".manager_flush\"),\n    signature = \"manager\"\n)\n\nsetGeneric(\n    \".manager_cleanup\",\n    function(manager) standardGeneric(\".manager_cleanup\"),\n    signature = \"manager\"\n)\n\n## default implementation -- SNOW backend\n\nsetMethod(\n    \".send_all\", \"ANY\",\n    function(backend, value)\n{\n    for (node in seq_along(backend))\n        .send_to(backend, node, value)\n})\n\nsetMethod(\n    \".recv_all\", \"ANY\",\n    function(backend)\n{\n    replicate(length(backend), .recv_any(backend), simplify=FALSE)\n})\n\nsetMethod(\n    \".send_to\", \"ANY\",\n    function(backend, node, value)\n{\n    parallel:::sendData(backend[[node]], value)\n    TRUE\n})\n\nsetMethod(\n    \".recv_any\", \"ANY\",\n    function(backend)\n{\n    tryCatch({\n        parallel:::recvOneData(backend)\n    }, error  = function(e) {\n        ## indicate error, but do not stop\n        .error_worker_comm(e, \"'.recv_any()' data failed\")\n    })\n})\n\nsetMethod(\n    \".send\", \"ANY\",\n    function(worker, value)\n{\n    parallel:::sendData(worker, value)\n})\n\nsetMethod(\n    \".recv\", \"ANY\",\n    function(worker)\n{\n    tryCatch({\n        parallel:::recvData(worker)\n    }, error = function(e) {\n        ## indicate error, but do not stop\n        .error_worker_comm(e, \"'.recv()' data failed\")\n    })\n})\n\nsetMethod(\n    \".close\", \"ANY\",\n    function(worker)\n{\n    parallel:::closeNode(worker)\n})\n\n\nsetMethod(\n    \".close\", \"ANY\",\n    function(worker)\n{\n    parallel:::closeNode(worker)\n})\n\n## default task manager implementation\n##\n## define as plain function for re-use without method dispatch\n.manager_ANY <-\n    function(BPPARAM)\n{\n    manager <- .TaskManager()\n    manager$BPPARAM <- BPPARAM\n    manager$backend <- bpbackend(BPPARAM)\n    manager$capacity <- length(manager$backend)\n    availability <- rep(list(TRUE), manager$capacity)\n    names(availability) <- as.character(seq_along(manager$backend))\n    manager$availability <- as.environment(availability)\n    manager\n}\n\nsetMethod(\".manager\", \"ANY\", .manager_ANY)\n\nsetMethod(\n    \".manager_send\", \"ANY\",\n    function(manager, value, ...)\n{\n    availability <- manager$availability\n    stopifnot(length(availability) >=0)\n    ## send the job to the next available worker\n    worker <- names(availability)[1]\n    .send_to(manager$backend, as.integer(worker), value)\n    rm(list = worker, envir = availability)\n})\n\nsetMethod(\n    \".manager_recv\", \"ANY\",\n    function(manager)\n{\n    result <- .recv_any(manager$backend)\n    manager$availability[[as.character(result$node)]] <- TRUE\n    list(result)\n})\n\nsetMethod(\n  \".manager_send_all\", \"ANY\",\n  function(manager, value) .send_all(manager$backend, value)\n)\n\nsetMethod(\n  \".manager_recv_all\", \"ANY\",\n  function(manager) .recv_all(manager$backend)\n)\n\nsetMethod(\n    \".manager_capacity\", \"ANY\",\n    function(manager)\n{\n      manager$capacity\n})\n\nsetMethod(\n    \".manager_flush\", \"ANY\",\n    function(manager) manager\n)\n\nsetMethod(\n    \".manager_cleanup\", \"ANY\",\n    function(manager) manager\n)\n",
        "DoparParam-class.R": "### =========================================================================\n### DoparParam objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.DoparParam_prototype <- .BiocParallelParam_prototype\n\n.DoparParam <- setRefClass(\"DoparParam\",\n    contains=\"BiocParallelParam\",\n    fields=list(),\n    methods=list()\n)\n\nDoparParam <-\n    function(stop.on.error=TRUE, RNGseed = NULL)\n{\n    if (!requireNamespace(\"foreach\", quietly = TRUE))\n        stop(\"DoparParam() requires the 'foreach' package\", call. = FALSE)\n\n    prototype <- .prototype_update(\n        .DoparParam_prototype,\n        stop.on.error=stop.on.error,\n        RNGseed=RNGseed\n    )\n\n    x <- do.call(.DoparParam, prototype)\n\n    ## DoparParam is always up, so we need to initialize\n    ## the seed stream here\n    .bpstart_set_rng_stream(x)\n\n    validObject(x)\n    x\n}\n\nsetMethod(\"bpworkers\", \"DoparParam\",\n    function(x)\n{\n    if (bpisup(x))\n        foreach::getDoParWorkers()\n    else 0L\n})\n\nsetMethod(\"bpisup\", \"DoparParam\",\n    function(x)\n{\n    isNamespaceLoaded(\"foreach\") &&\n        foreach::getDoParRegistered() &&\n        (foreach::getDoParName() != \"doSEQ\")\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Manager\n###\n.DoparParamManager <- setClass(\"DoparParamManager\",\n    contains=\"TaskManager\"\n)\n\n## constructor\nsetMethod(\n    \".manager\", \"DoparParam\",\n    function(BPPARAM)\n{\n    .DoparParamManager(\n        BPPARAM = BPPARAM,\n        tasks = new.env(parent = emptyenv())\n    )\n})\n\nsetMethod(\n    \".manager_send\", \"DoparParamManager\",\n    function(manager, value, ...)\n{\n    taskId <- length(manager$tasks) + 1L\n    if (taskId == 1L)\n        manager$const.value <- .task_const(value)\n    manager$tasks[[as.character(taskId)]] <- .task_dynamic(value)\n})\n\nsetMethod(\n    \".manager_recv\", \"DoparParamManager\",\n    function(manager)\n{\n    stopifnot(length(manager$tasks) > 0L)\n    tasks <- as.list(manager$tasks)\n    tasks <- tasks[order(names(tasks))]\n    const.value <- manager$const.value\n    `%dopar%` <- foreach::`%dopar%`\n    foreach <- foreach::foreach\n    tryCatch({\n        results <-\n            foreach(task = tasks)%dopar%{\n                task <- .task_remake(task, const.value)\n                if (task$type == \"EXEC\")\n                    value <- .bpworker_EXEC(task)\n                else\n                    value <- NULL\n                list(value = value)\n            }\n    }, error=function(e) {\n        stop(\n            \"'DoparParam()' foreach() error occurred: \",\n            conditionMessage(e)\n        )\n    })\n    ## cleanup the tasks\n    remove(list = ls(manager$tasks), envir = manager$tasks)\n    manager$const.value <- NULL\n\n    results\n})\n\nsetMethod(\n    \".manager_send_all\", \"DoparParamManager\",\n    function(manager, value)\n{\n    nworkers <- bpworkers(manager$BPPARAM)\n    for (i in seq_len(nworkers)) {\n        .manager_send(manager, value)\n    }\n})\n\nsetMethod(\n    \".manager_recv_all\", \"DoparParamManager\",\n    function(manager) .manager_recv(manager)\n)\n\nsetMethod(\n    \".manager_capacity\", \"DoparParamManager\",\n    function(manager)\n{\n    .Machine$integer.max\n})\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - evaluation\n###\n\nsetMethod(\"bpiterate\", c(\"ANY\", \"ANY\", \"DoparParam\"),\n    function(ITER, FUN, ..., BPREDO = list(),\n             BPPARAM=bpparam(), BPOPTIONS=bpoptions())\n{\n    stop(\"'bpiterate' not supported for DoparParam\")\n})\n",
        "ErrorHandling.R": "### =========================================================================\n### Error handling\n### -------------------------------------------------------------------------\n.bpeltok <-\n    function(x, type = bperrorTypes())\n{\n    !inherits(x, type)\n}\n\nbpok <-\n    function(x, type = bperrorTypes())\n{\n    x <- bpresult(x)\n    type <- match.arg(type)\n    vapply(x, .bpeltok, logical(1), type)\n}\n\n.bpallok <-\n    function(x, type = bperrorTypes(), attrOnly = FALSE)\n{\n    if (attrOnly)\n        is.null(.redo_env(x))\n    else\n        is.null(.redo_env(x)) && all(bpok(x, type))\n}\n\nbptry <-\n    function(expr, ..., bplist_error, bperror)\n{\n    if (missing(bplist_error))\n        bplist_error <- bpresult\n\n    if (missing(bperror))\n        bperror <- identity\n\n    tryCatch(expr, ..., bplist_error=bplist_error, bperror=bperror)\n}\n\nbpresult <- function(x)\n{\n    if (is(x, \"bplist_error\"))\n        x <- attr(x, \"result\")\n    x\n}\n\n.error <- function(msg, class=NULL) {\n    structure(list(message=msg),\n              class = c(class, \"bperror\", \"error\", \"condition\"))\n}\n\n.error_remote <- function(x, call) {\n    structure(x, class = c(\"remote_error\", \"bperror\", \"error\", \"condition\"),\n              traceback = capture.output(traceback(call)))\n}\n\n.error_unevaluated <- function()\n{\n    structure(list(message=\"not evaluated due to previous error\"),\n              class=c(\"unevaluated_error\", \"bperror\", \"error\", \"condition\"))\n}\n\n.error_not_available <- function(msg)\n{\n    structure(list(message=msg),\n              class=c(\"not_available_error\", \"bperror\", \"error\", \"condition\"))\n}\n\n.error_worker_comm <- function(error, msg) {\n    msg <- sprintf(\"%s:\\n  %s\", msg, conditionMessage(error))\n    structure(list(message=msg, original_error_class=class(error)),\n              class=c(\"worker_comm_error\", \"bperror\", \"error\", \"condition\"))\n}\n\nbperrorTypes <-\n    function()\n{\n    subclasses <- paste0(\n        c(\"remote\", \"unevaluated\", \"not_available\", \"worker_comm\"),\n        \"_error\"\n    )\n    c(\"bperror\", subclasses)\n}\n\n.error_bplist <- function(result) {\n    if (is.null(attr(result, \"errors\"))) {\n        errors <- result\n        total_error <- sum(!bpok(errors))\n        remote_error <-\n            !bpok(errors, \"remote_error\") |\n            !bpok(errors, \"worker_comm_error\")\n        remote_idx <- which(remote_error)\n        if (length(remote_idx))\n          first_error <- errors[[remote_idx[1]]]\n        else\n          first_error <- \"\"\n    } else {\n        errors <- attr(result, \"errors\")\n        total_error <- length(errors)\n        remote_error <-\n            !bpok(errors, \"remote_error\") |\n            !bpok(errors, \"worker_comm_error\")\n        first_error_idx <- which(remote_error)[1]\n        if (!is.null(first_error_idx))\n          first_error <- errors[[first_error_idx]]\n        else\n          first_error <- \"\"\n        remote_idx <- as.integer(names(errors[remote_error]))\n    }\n\n    n_remote_error <- length(remote_idx)\n    n_other_error <- total_error - n_remote_error\n\n    fmt = paste(\n        \"BiocParallel errors\",\n        \"%d remote errors, element index: %s%s\",\n        \"%d unevaluated and other errors\",\n        \"first remote error:\\n%s\",\n        sep = \"\\n  \"\n    )\n    class(first_error) <- tail(class(first_error), 2L)\n    first_error_msg <- as.character(first_error)\n    message <- sprintf(\n        fmt,\n        n_remote_error,\n        paste(head(remote_idx), collapse = \", \"),\n        ifelse(length(remote_idx) > 6, \", ...\", \"\"),\n        n_other_error,\n        first_error_msg\n    )\n\n    err <- structure(\n        list(message=message),\n        result=result,\n        class = c(\"bplist_error\", \"bperror\", \"error\", \"condition\"))\n}\n\nprint.remote_error <- function(x, ...) {\n    NextMethod(x)\n    cat(\"traceback() available as 'attr(x, \\\"traceback\\\")'\\n\")\n}\n\n`print.bplist_error` <- function(x, ...) {\n    NextMethod(x)\n    cat(\"results and errors available as 'bpresult(x)'\\n\")\n}\n",
        "MulticoreParam-class.R": "### =========================================================================\n### MulticoreParam objects\n### -------------------------------------------------------------------------\n\nmulticoreWorkers <- function()\n    .snowCores(\"multicore\")\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.MulticoreParam_prototype <- .SnowParam_prototype\n\n.MulticoreParam <- setRefClass(\"MulticoreParam\",\n    contains=\"SnowParam\",\n    fields=list(),\n    methods=list()\n)\n\nMulticoreParam <- function(workers=multicoreWorkers(), tasks=0L,\n        stop.on.error=TRUE,\n        progressbar=FALSE, RNGseed=NULL, timeout= WORKER_TIMEOUT,\n        exportglobals=TRUE,\n        log=FALSE, threshold=\"INFO\", logdir=NA_character_,\n        resultdir=NA_character_, jobname = \"BPJOB\",\n        force.GC = FALSE,\n        fallback = TRUE,\n        manager.hostname=NA_character_, manager.port=NA_integer_, ...)\n{\n    if (.Platform$OS.type == \"windows\") {\n        warning(\"MulticoreParam() not supported on Windows, use SnowParam()\")\n        workers = 1L\n    }\n\n    if (progressbar && missing(tasks))\n        tasks <- TASKS_MAXIMUM\n\n    clusterargs <- c(list(spec=workers, type=\"FORK\"), list(...))\n\n    manager.hostname <-\n        if (is.na(manager.hostname)) {\n            local <- (clusterargs$type == \"FORK\") ||\n                is.numeric(clusterargs$spec)\n            manager.hostname <- .snowHost(local)\n        } else as.character(manager.hostname)\n\n    manager.port <-\n        if (is.na(manager.port)) {\n            .snowPort()\n        } else as.integer(manager.port)\n\n    if (!is.null(RNGseed))\n        RNGseed <- as.integer(RNGseed)\n\n    prototype <- .prototype_update(\n        .MulticoreParam_prototype,\n        .clusterargs=clusterargs, cluster=.NULLcluster(),\n        .controlled=TRUE, workers=as.integer(workers),\n        tasks=as.integer(tasks),\n        stop.on.error=stop.on.error,\n        progressbar=progressbar,\n        RNGseed=RNGseed, timeout=as.integer(timeout),\n        exportglobals=exportglobals,\n        exportvariables=FALSE,\n        log=log, threshold=threshold,\n        logdir=logdir, resultdir=resultdir, jobname=jobname,\n        force.GC = force.GC,\n        fallback = fallback,\n        hostname=manager.hostname, port=manager.port,\n        ...\n    )\n\n    param <- do.call(.MulticoreParam, prototype)\n    bpworkers(param) <- workers # enforce worker number\n    validObject(param)\n    param\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - control\n###\n\nsetReplaceMethod(\"bpworkers\", c(\"MulticoreParam\", \"numeric\"),\n    function(x, value)\n{\n    value <- as.integer(value)\n    nworkers <- .enforceWorkers(value, x$.clusterargs$type)\n    x$workers <- x$.clusterargs$spec <- nworkers\n    x\n})\n\nsetMethod(\"bpschedule\", \"MulticoreParam\",\n    function(x)\n{\n    if (.Platform$OS.type == \"windows\")\n        FALSE\n    else\n        TRUE\n})\n",
        "SerialParam-class.R": "### =========================================================================\n### SerialParam objects\n### -------------------------------------------------------------------------\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.SerialParam_prototype <- c(\n    list(\n        workers = 1L,\n        backend = NULL\n    ),\n    .BiocParallelParam_prototype\n)\n\n.SerialParam <- setRefClass(\n    \"SerialParam\",\n    fields=list(backend = \"ANY\"),\n    contains=\"BiocParallelParam\",\n)\n\nSerialParam <-\n    function(stop.on.error = TRUE,\n             progressbar=FALSE,\n             RNGseed = NULL,\n             timeout = WORKER_TIMEOUT,\n             log=FALSE, threshold=\"INFO\", logdir=NA_character_,\n             resultdir = NA_character_,\n             jobname = \"BPJOB\",\n             force.GC = FALSE)\n{\n    if (!is.null(RNGseed))\n        RNGseed <- as.integer(RNGseed)\n\n    if (progressbar) {\n        tasks <- TASKS_MAXIMUM\n    } else {\n        tasks <- 0L\n    }\n\n    prototype <- .prototype_update(\n        .SerialParam_prototype,\n        tasks = tasks,\n        stop.on.error=stop.on.error,\n        progressbar=progressbar,\n        RNGseed = RNGseed,\n        timeout = as.integer(timeout),\n        log=log,\n        threshold=threshold,\n        logdir=logdir,\n        resultdir = resultdir,\n        jobname = jobname,\n        force.GC = force.GC,\n        fallback = FALSE,\n        exportglobals = FALSE,\n        exportvariables = FALSE\n    )\n    x <- do.call(.SerialParam, prototype)\n    validObject(x)\n    x\n}\n\nsetAs(\"BiocParallelParam\", \"SerialParam\", function(from) {\n    SerialParam(\n        stop.on.error = bpstopOnError(from),\n        progressbar = bpprogressbar(from),\n        RNGseed = bpRNGseed(from),\n        timeout = bptimeout(from),\n        log = bplog(from),\n        threshold = bpthreshold(from),\n        logdir = bplogdir(from),\n        resultdir = bpresultdir(from),\n        jobname = bpjobname(from),\n        force.GC = bpforceGC(from)\n    )\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - control\n###\n\nsetMethod(\n    \"bpbackend\", \"SerialParam\",\n    function(x)\n{\n    x$backend\n})\n\nsetMethod(\n    \"bpstart\", \"SerialParam\",\n    function(x, ...)\n{\n    x$backend <- .SerialBackend()\n    x$backend$BPPARAM <- x\n    .bpstart_impl(x)\n})\n\nsetMethod(\n    \"bpstop\", \"SerialParam\",\n    function(x)\n{\n    x$backend <- NULL\n    .bpstop_impl(x)\n})\n\nsetMethod(\n    \"bpisup\", \"SerialParam\",\n    function(x)\n{\n    is.environment(bpbackend(x))\n})\n\nsetReplaceMethod(\"bplog\", c(\"SerialParam\", \"logical\"),\n    function(x, value)\n{\n    x$log <- value\n    validObject(x)\n    x\n})\n\nsetReplaceMethod(\n    \"bpthreshold\", c(\"SerialParam\", \"character\"),\n    function(x, value)\n{\n    x$threshold <- value\n    x\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Backend method\n###\n.SerialBackend <- setClass(\"SerialBackend\", contains = \"environment\")\n\nsetMethod(\".send_to\", \"SerialBackend\",\n          function(backend, node, value){\n    backend$value <- value\n    TRUE\n})\n\nsetMethod(\n    \".recv_any\", \"SerialBackend\",\n    function(backend)\n{\n    on.exit(backend$value <- NULL)\n    msg <- backend$value\n    if (inherits(msg, \"error\"))\n        stop(msg)\n    if (msg$type == \"EXEC\") {\n        value <- .bpworker_EXEC(msg, bplog(backend$BPPARAM))\n        list(node = 1L, value = value)\n    }\n})\n\nsetMethod(\"length\", \"SerialBackend\",\n          function(x){\n              1L\n})\n",
        "SnowParam-class.R": "### =========================================================================\n### SnowParam objects\n### -------------------------------------------------------------------------\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Helpers\n###\n\n.snowHost <- function(local=TRUE) {\n    host <-\n        if (local) {\n            \"localhost\"\n        } else Sys.info()[[\"nodename\"]]\n    host <- Sys.getenv(\"MASTER\", host)\n    host <- getOption(\"bphost\", host)\n\n    host\n}\n\n.snowPort <- function() {\n    port <- Sys.getenv(\"R_PARALLEL_PORT\", NA_integer_)\n    port <- Sys.getenv(\"PORT\", port)\n    port <- getOption(\"ports\", port)\n\n    if (identical(tolower(port), \"random\") || is.na(port)) {\n        .rng_internal_stream$set()\n        on.exit(.rng_internal_stream$reset())\n        portAvailable <- FALSE\n        for (i in 1:5) {\n            port <- as.integer(\n                11000 +\n                1000 * ((stats::runif(1L) + unclass(Sys.time()) / 300) %% 1L)\n            )\n            tryCatch(\n                {\n                    ## User should not be able to interrupt the port check\n                    ## Otherwise we might have an unclosed connection\n                    suspendInterrupts(\n                        {\n                            con <- serverSocket(port)\n                            close(con)\n                        }\n                    )\n                    portAvailable <- TRUE\n                },\n                error = function(e) {\n                    message(\"failed to open the port \", port,\", trying a new port...\")\n                }\n            )\n            if (portAvailable) break\n        }\n        if (!portAvailable)\n            .stop(\"cannot find an open port. For manually specifying the port, see ?SnowParam\")\n    } else {\n        port <- as.integer(port)\n    }\n\n    port\n}\n\n.snowCoresMax <- function(type) {\n    if (type == \"MPI\") {\n        .Machine$integer.max\n    } else {\n        128L - nrow(showConnections(all=TRUE))\n    }\n}\n\n.snowCores <- function(type) {\n    if (type == \"multicore\" && .Platform$OS.type == \"windows\")\n        return(1L)\n\n    min(.defaultWorkers(), .snowCoresMax(type))\n}\n\nsnowWorkers <- function(type = c(\"SOCK\", \"MPI\", \"FORK\")) {\n    type <- match.arg(type)\n    min(.defaultWorkers(), .snowCores(type))\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\nsetOldClass(c(\"NULLcluster\", \"cluster\"))\n\n.NULLcluster <-\n    function()\n{\n    cl <- list()\n    class(cl) <- c(\"NULLcluster\", \"cluster\")\n    cl\n}\n\n.SnowParam_prototype <- c(\n    list(\n        cluster = .NULLcluster(),\n        .clusterargs = list(spec=0, type=\"SOCK\"),\n        .controlled = TRUE,\n        hostname = NA_character_, port = NA_integer_\n    ),\n    .BiocParallelParam_prototype\n)\n\n.SnowParam <- setRefClass(\"SnowParam\",\n    contains=\"BiocParallelParam\",\n    fields=list(\n        cluster = \"cluster\",\n        .clusterargs = \"list\",\n        .controlled = \"logical\",\n        hostname = \"character\",\n        port = \"integer\"\n    ),\n    methods=list(\n        show = function() {\n            callSuper()\n            cat(\"  cluster type: \", .clusterargs$type, \"\\n\", sep=\"\")\n        })\n)\n\nSnowParam <- function(workers=snowWorkers(type),\n                      type=c(\"SOCK\", \"MPI\", \"FORK\"), tasks=0L,\n                      stop.on.error=TRUE,\n                      progressbar=FALSE, RNGseed=NULL,\n                      timeout=WORKER_TIMEOUT,\n                      exportglobals=TRUE, exportvariables=TRUE,\n                      log=FALSE, threshold=\"INFO\", logdir=NA_character_,\n                      resultdir=NA_character_, jobname = \"BPJOB\",\n                      force.GC = FALSE,\n                      fallback = TRUE,\n                      manager.hostname=NA_character_,\n                      manager.port=NA_integer_, ...)\n{\n    type <- tryCatch(match.arg(type), error=function(...) {\n        stop(\"'type' must be one of \",\n             paste(sQuote(formals(\"SnowParam\")$type), collapse=\", \"))\n    })\n\n    if (type %in% c(\"MPI\", \"FORK\") && is(workers, \"character\"))\n        stop(\"'workers' must be integer(1) when 'type' is MPI or FORK\")\n\n    if (progressbar && missing(tasks))\n        tasks <- TASKS_MAXIMUM\n\n    clusterargs <- c(list(spec=workers, type=type), list(...))\n\n    manager.hostname <-\n        if (is.na(manager.hostname)) {\n            local <- (clusterargs$type == \"FORK\") ||\n                is.numeric(clusterargs$spec)\n            manager.hostname <- .snowHost(local)\n        } else as.character(manager.hostname)\n\n    manager.port <-\n        if (is.na(manager.port)) {\n            .snowPort()\n        } else as.integer(manager.port)\n\n    if (!is.null(RNGseed))\n        RNGseed <- as.integer(RNGseed)\n\n    prototype <- .prototype_update(\n        .SnowParam_prototype,\n        .clusterargs=clusterargs,\n        .controlled=TRUE, workers=workers, tasks=as.integer(tasks),\n        stop.on.error=stop.on.error,\n        progressbar=progressbar, RNGseed=RNGseed,\n        timeout=as.integer(timeout),\n        exportglobals=exportglobals,\n        exportvariables=exportvariables,\n        log=log, threshold=threshold, logdir=logdir,\n        resultdir=resultdir, jobname=jobname,\n        force.GC = force.GC,\n        fallback = fallback,\n        hostname=manager.hostname, port=manager.port,\n        ...\n    )\n\n    param <- do.call(.SnowParam, prototype)\n    bpworkers(param) <- workers # enforce worker number\n    validObject(param)\n    param\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\nsetValidity(\"SnowParam\", function(object)\n{\n    msg <- NULL\n    if (!.isTRUEorFALSE(.controlled(object)))\n        msg <- c(msg, \"'.controlled' must be TRUE or FALSE\")\n\n    if (.controlled(object)) {\n        if (!all(bpworkers(object) == object$.clusterargs$spec))\n            msg <- c(msg,\n                \"'bpworkers(BPPARAM)' must equal BPPARAM$.clusterargs$spec\")\n    }\n\n    if (is.null(msg)) TRUE else msg\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters / Setters\n###\n\n.hostname <- function(x)\n    x$hostname\n\n.port <- function(x)\n    x$port\n\nsetReplaceMethod(\"bpworkers\", c(\"SnowParam\", \"numeric\"),\n    function(x, value)\n{\n    value <- as.integer(value)\n    value <- .enforceWorkers(value, x$.clusterargs$type)\n    x$workers <- x$.clusterargs$spec <- value\n    x\n})\n\nsetReplaceMethod(\"bpworkers\", c(\"SnowParam\", \"character\"),\n    function(x, value)\n{\n    nworkers <- .enforceWorkers(length(value), x$.clusterargs$type)\n    x$workers <- x$.clusterargs$spec <- head(value, nworkers)\n    x\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Methods - control\n###\n\n.bpstart_makeCluster <-\n    function(cargs)\n{\n    ## set internal stream to avoid iterating global random number\n    ## stream in `parallel::makeCluster()`. Use the internal stream so\n    ## that the random number generator advances on each call.\n    state <- .rng_internal_stream$set()\n    on.exit(.rng_internal_stream$reset())\n    do.call(parallel::makeCluster, cargs)\n}\n\nsetMethod(\"bpstart\", \"SnowParam\",\n    function(x, lenX = bpnworkers(x))\n{\n    if (!.controlled(x))\n        stop(\"'bpstart' not available; instance from outside BiocParallel?\")\n    if (bpisup(x))\n        stop(\"cluster already started\")\n    if (bpnworkers(x) == 0 && lenX <= 0)\n        stop(\"cluster not started; no workers specified\")\n\n    nnodes <- min(bpnworkers(x), lenX)\n    if (x$.clusterargs$type != \"MPI\" &&\n        (nnodes > 128L - nrow(showConnections(all=TRUE))))\n        stop(\"cannot create \", nnodes, \" workers; \",\n             128L - nrow(showConnections(all=TRUE)),\n             \" connections available in this session\")\n\n    if (x$.clusterargs$type == \"FORK\") {\n        ## FORK (useRscript not relevant)\n        bpbackend(x) <- .bpfork(nnodes, .hostname(x), .port(x))\n    } else {\n        ## SOCK, MPI\n        cargs <- x$.clusterargs\n        cargs$spec <- if (is.numeric(cargs$spec)) {\n            nnodes\n        } else cargs$spec[seq_len(nnodes)]\n\n        ## work around devtools::load_all()\n        ##\n        ## 'inst' exists when using devtools::load_all()\n        libPath <- find.package(\"BiocParallel\")\n        if (dir.exists(file.path(libPath, \"inst\")))\n            libPath <- file.path(libPath, \"inst\")\n\n        if (is.null(cargs$snowlib))\n            cargs$snowlib <- libPath\n\n        if (!is.null(cargs$useRscript) && !cargs$useRscript)\n            cargs$scriptdir <- libPath\n\n        if (x$.clusterargs$type == \"SOCK\") {\n            cargs$master <- .hostname(x)\n            cargs$port <- .port(x)\n        }\n\n        bpbackend(x) <- .bpstart_makeCluster(cargs)\n    }\n\n    .bpstart_impl(x)\n})\n\nsetMethod(\"bpstop\", \"SnowParam\",\n    function(x)\n{\n    if (!.controlled(x)) {\n        warning(\"'bpstop' not available; instance from outside BiocParallel?\")\n        return(invisible(x))\n    }\n    if (!bpisup(x))\n        return(invisible(x))\n\n    x <- .bpstop_impl(x)\n    cluster <- bpbackend(x)\n    for (i in seq_along(cluster))\n        .close(cluster[[i]])\n    bpbackend(x) <- .NULLcluster()\n\n    invisible(x)\n})\n\nsetMethod(\"bpisup\", \"SnowParam\",\n    function(x)\n{\n    length(bpbackend(x)) != 0L\n})\n\nsetMethod(\"bpbackend\", \"SnowParam\",\n    function(x)\n{\n    x$cluster\n})\n\nsetReplaceMethod(\"bpbackend\", c(\"SnowParam\", \"cluster\"),\n    function(x, value)\n{\n    x$cluster <- value\n    x\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters / Setters\n###\n\n.controlled <-\n    function(x)\n{\n    x$.controlled\n}\n\nsetReplaceMethod(\"bplog\", c(\"SnowParam\", \"logical\"),\n    function(x, value)\n{\n    x$log <- value\n    x\n})\n\nsetReplaceMethod(\"bpthreshold\", c(\"SnowParam\", \"character\"),\n    function(x, value)\n{\n    x$threshold <- value\n    x\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion methods for SOCK and MPI clusters\n###\n\n### parallel::SOCKcluster types\n\nsetOldClass(c(\"SOCKcluster\", \"cluster\"))\n\nstopCluster.SOCKcluster <-\n    parallel:::stopCluster.default\n\nsetAs(\"SOCKcluster\", \"SnowParam\",\n    function(from)\n{\n    .clusterargs <-\n        list(spec=length(from), type=sub(\"cluster$\", \"\", class(from)[1L]))\n    prototype <- .prototype_update(\n        .SnowParam_prototype,\n        .clusterargs = .clusterargs,\n        cluster = from,\n        .controlled = FALSE,\n        workers = length(from)\n    )\n\n    do.call(.SnowParam, prototype)\n})\n\n### MPIcluster\n\nsetOldClass(c(\"spawnedMPIcluster\", \"MPIcluster\", \"cluster\"))\n\nsetAs(\"spawnedMPIcluster\", \"SnowParam\",\n    function(from)\n{\n    .clusterargs <- list(spec=length(from),\n        type=sub(\"cluster\", \"\", class(from)[1L]))\n    .SnowParam(.clusterargs=.clusterargs, cluster=from, .controlled=FALSE,\n               workers=length(from))\n})\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### task dispatching interface\n###\n\nsetOldClass(c(\"SOCK0node\", \"SOCKnode\")) # needed for method dispatch\n\n.SOCKmanager <- setClass(\"SOCKmanager\", contains = \"TaskManager\")\n\nsetMethod(\n    \".manager\", \"SnowParam\",\n    function(BPPARAM)\n{\n    manager <- callNextMethod()\n    manager$initialized <- rep(FALSE, manager$capacity)\n    as(manager, \"SOCKmanager\")\n})\n\nsetMethod(\n    \".manager_send\", \"SOCKmanager\",\n    function(manager, value, ...)\n{\n    availability <- manager$availability\n    stopifnot(length(availability) >= 0L)\n    ## send the job to the next available worker\n    worker <- names(availability)[1]\n    id <- as.integer(worker)\n    ## Do the cache only when the snow worker is\n    ## created by our package.\n    if (.controlled(manager$BPPARAM)) {\n        if (manager$initialized[id])\n            value <- .task_dynamic(value)\n        else\n            manager$initialized[id] <- TRUE\n    }\n    .send_to(manager$backend, as.integer(worker), value)\n    rm(list = worker, envir = availability)\n    manager\n})\n\nsetMethod(\n    \".manager_cleanup\", \"SOCKmanager\",\n    function(manager)\n{\n    manager <- callNextMethod()\n    manager$initialized <- rep(FALSE, manager$capacity)\n    if (.controlled(manager$BPPARAM)) {\n        value <- .EXEC(tag = NULL, .clean_task_static, args = NULL)\n        .send_all(manager$backend, value)\n        msg <- .recv_all(manager$backend)\n    }\n    manager\n})\n\n## The worker class of SnowParam\nsetMethod(\n    \".recv\", \"SOCKnode\",\n    function(worker)\n{\n    msg <- callNextMethod()\n    if (inherits(msg, \"error\"))\n        return(msg)\n    ## read/write the static value(if any)\n    .load_task_static(msg)\n})\n",
        "SnowParam-utils.R": ".connect_timeout <-\n    function()\n{\n    timeout <- getOption(\"timeout\")\n    timeout_is_valid <-\n        length(timeout) == 1L && !is.na(timeout) &&\n        timeout > 0L\n    if (!timeout_is_valid)\n        stop(\"'getOption(\\\"timeout\\\")' must be positive integer(1)\")\n    timeout\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### snow::MPI\n###\n\nbprunMPIworker <- function() {\n    comm <- 1\n    intercomm <- 2\n    Rmpi::mpi.comm.get.parent(intercomm)\n    Rmpi::mpi.intercomm.merge(intercomm,1,comm)\n    Rmpi::mpi.comm.set.errhandler(comm)\n    Rmpi::mpi.comm.disconnect(intercomm)\n\n    .bpworker_impl(snow::makeMPImaster(comm))\n\n    Rmpi::mpi.comm.disconnect(comm)\n    Rmpi::mpi.quit()\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### parallel::FORK\n###\n\n.bpfork <- function (nnodes, host, port)\n{\n    nnodes <- as.integer(nnodes)\n    if (is.na(nnodes) || nnodes < 1L)\n        stop(\"'nnodes' must be >= 1\")\n\n    if (length(host) != 1L || is.na(host) || !is.character(host))\n        stop(\"'host' must be character(1)\")\n    if (length(port) != 1L || is.na(port) || !is.integer(port))\n        stop(\"'port' must be integer(1)\")\n\n    connect_timeout <- .connect_timeout()\n    idle_timeout <- IDLE_TIMEOUT\n\n    cl <- vector(\"list\", nnodes)\n    for (rank in seq_along(cl)) {\n        .bpforkChild(host, port, rank, connect_timeout, idle_timeout)\n        cl[[rank]] <- .bpforkConnect(\n            host, port, rank, connect_timeout, idle_timeout\n        )\n    }\n\n    class(cl) <- c(\"SOCKcluster\", \"cluster\")\n    cl\n}\n\n.bpforkChild <-\n    function(host, port, rank, connect_timeout, idle_timeout)\n{\n    parallel::mcparallel({\n        con <- NULL\n        suppressWarnings({\n            while (is.null(con)) {\n                con <- tryCatch({\n                    socketConnection(\n                        host, port, FALSE, TRUE, \"a+b\",\n                        timeout = connect_timeout\n                    )\n                }, error=function(e) {})\n            }\n            socketTimeout(con, idle_timeout)\n        })\n        node <- structure(list(con = con), class = \"SOCK0node\")\n        .bpworker_impl(node)\n    }, detached=TRUE)\n}\n\n.bpforkConnect <-\n    function(host, port, rank, connect_timeout, idle_timeout)\n{\n    idle_timeout <- IDLE_TIMEOUT\n    con <- socketConnection(\n        host, port, TRUE, TRUE, \"a+b\", timeout = connect_timeout\n    )\n    socketTimeout(con, idle_timeout)\n    structure(list(con = con, host = host, rank = rank),\n              class = c(\"forknode\", \"SOCK0node\"))\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### EXEC command cache\n###\n\n## read/write the static value\n.load_task_static <-\n    function(value)\n{\n    static_data <- .task_const(value)\n    if (is.null(static_data)) {\n        static_data <- options(\"BIOCPARALLEL_SNOW_STATIC\")[[1]]\n        .task_remake(value, static_data)\n    } else {\n        options(BIOCPARALLEL_SNOW_STATIC = static_data)\n        value\n    }\n}\n\n.clean_task_static <-\n    function()\n{\n    options(BIOCPARALLEL_SNOW_STATIC = NULL)\n}\n",
        "TransientMulticoreParam-class.R": ".TransientMulticoreParam <-\n    setRefClass(\n        \"TransientMulticoreParam\",\n        contains = \"MulticoreParam\"\n    )\n\nTransientMulticoreParam <-\n    function(param)\n{\n    param <- as(param, \"TransientMulticoreParam\")\n    bpstart(param)\n}\n\n.TRANSIENTMULTICOREPARAM_JOBNODE <- new.env(parent=emptyenv())\n.TRANSIENTMULTICOREPARAM_RESULT <- new.env(parent=emptyenv())\n\nsetMethod(\n    \"bpstart\", \"TransientMulticoreParam\",\n    function(x, ...)\n{\n    parallel::mccollect(wait=TRUE)\n\n    rm(\n        list=ls(envir = .TRANSIENTMULTICOREPARAM_JOBNODE),\n        envir = .TRANSIENTMULTICOREPARAM_JOBNODE\n    )\n    rm(\n        list = ls(envir = .TRANSIENTMULTICOREPARAM_RESULT),\n        envir = .TRANSIENTMULTICOREPARAM_RESULT\n    )\n    .bpstart_impl(x)\n})\n\nsetMethod(\n    \"bpstop\", \"TransientMulticoreParam\",\n    function(x)\n{\n    .bpstop_impl(x)\n})\n\nsetMethod(\n    \"bpbackend\", \"TransientMulticoreParam\",\n    function(x)\n{\n    x\n})\n\nsetMethod(\n    \"length\", \"TransientMulticoreParam\",\n    function(x)\n{\n    bpnworkers(x)\n})\n\n##\n## send / recv\n##\n\nsetMethod(\n    \".recv_all\", \"TransientMulticoreParam\",\n    function(backend)\n{\n    replicate(length(backend), .recv_any(backend), simplify=FALSE)\n})\n\nsetMethod(\n    \".send_to\", \"TransientMulticoreParam\",\n    function(backend, node, value)\n{\n    if (value$type == \"EXEC\") {\n        job <- parallel::mcparallel(.bpworker_EXEC(value))\n        id <- as.character(job$pid)\n        .TRANSIENTMULTICOREPARAM_JOBNODE[[id]] <- node\n    }\n    TRUE\n})\n\nsetMethod(\n    \".recv_any\", \"TransientMulticoreParam\",\n    function(backend)\n{\n    .BUFF <- .TRANSIENTMULTICOREPARAM_RESULT # alias\n    tryCatch({\n        while (!length(.BUFF)) {\n            result <- parallel::mccollect(wait = FALSE, timeout = 1)\n            for (id in names(result))\n                .BUFF[[id]] <- result[[id]]\n        }\n        id <- head(names(.BUFF), 1L)\n\n        value <- .BUFF[[id]]\n        rm(list = id, envir = .BUFF)\n        node <- .TRANSIENTMULTICOREPARAM_JOBNODE[[id]]\n        rm(list = id, envir = .TRANSIENTMULTICOREPARAM_JOBNODE)\n        list(node = node, value = value)\n    }, error  = function(e) {\n        ## indicate error, but do not stop\n        .error_worker_comm(e, \"'.recv_any()' data failed\")\n    })\n})\n\nsetMethod(\n    \".send\", \"TransientMulticoreParam\",\n    function(worker, value)\n{\n    stop(\"'.send,TransientMulticoreParam-method' not implemented\")\n})\n\nsetMethod(\n    \".recv\", \"TransientMulticoreParam\",\n    function(worker)\n{\n    stop(\"'.recv,TransientMulticoreParam-method' not implemented\")\n})\n\nsetMethod(\n    \".close\", \"TransientMulticoreParam\",\n    function(worker)\n{\n    stop(\"'.close,TransientMulticoreParam-method' not implemented\")\n})\n\nsetMethod(\".manager\", \"TransientMulticoreParam\", .manager_ANY)\n",
        "bpaggregate-methods.R": "### =========================================================================\n### bpaggregate methods\n### -------------------------------------------------------------------------\n\n## All params use bpaggregate,data.frame,BiocParallelParam.\n## bpaggretate() dispatches to bplapply() where errors and\n## logging are handled.\n\n\nsetMethod(\"bpaggregate\", c(\"ANY\", \"missing\"),\n    function(x, ..., BPREDO=list(), BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    bpaggregate(x, ..., BPREDO=BPREDO, BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n\nsetMethod(\"bpaggregate\", c(\"matrix\", \"BiocParallelParam\"),\n    function(x, by, FUN, ..., simplify=TRUE,\n             BPREDO=list(), BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    if (!is.data.frame(x))\n        x <- as.data.frame(x)\n    bpaggregate(x, by, FUN, ..., simplify=simplify,\n                BPREDO=BPREDO, BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n\nsetMethod(\"bpaggregate\", c(\"data.frame\", \"BiocParallelParam\"),\n    function(x, by, FUN, ..., simplify=TRUE,\n             BPREDO=list(),  BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n    if (!is.data.frame(x))\n        x <- as.data.frame(x)\n    if (!is.list(by))\n        stop(\"'by' must be a list\")\n    by <- lapply(by, as.factor)\n\n    wrapper <- function(.ind, .x, .AGGRFUN, ..., .simplify)\n    {\n        sapply(.x[.ind,, drop=FALSE], .AGGRFUN, ..., simplify=.simplify)\n    }\n    ind <- Filter(length, split(seq_len(nrow(x)), by))\n    grp <- rep(seq_along(ind), lengths(ind))\n    grp <- grp[match(seq_len(nrow(x)), unlist(ind))]\n    res <- bplapply(ind, wrapper, .x=x, .AGGRFUN=FUN, .simplify=simplify,\n                    BPREDO=BPREDO, BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n    res <- do.call(rbind, lapply(res, rbind))\n\n    if (is.null(names(by)) && length(by)) {\n        names(by) <- sprintf(\"Group.%i\", seq_along(by))\n    } else {\n        ind <- which(!nzchar(names(by)))\n        names(by)[ind] <- sprintf(\"Group.\", ind)\n    }\n\n    tab <- as.data.frame(lapply(by, as.character), stringsAsFactors=FALSE)\n    tab <- tab[match(sort(unique(grp)), grp),, drop=FALSE]\n    rownames(tab) <- rownames(res) <- NULL\n    tab <- cbind(tab, res)\n\n    names(tab) <- c(names(by), names(x))\n    tab\n})\n\nsetMethod(\"bpaggregate\", c(\"formula\", \"BiocParallelParam\"),\n    function (x, data, FUN, ..., BPREDO=list(),\n              BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    if (length(x) != 3L)\n        stop(\"Formula 'x' must have both left and right hand sides\")\n\n    m <- match.call(expand.dots=FALSE)\n    if (is.matrix(eval(m$data, parent.frame())))\n        m$data <- as.data.frame(data)\n    m$... <- m$FUN <- m$BPPARAM <- m$BPREDO <- m$BPOPTIONS <- NULL\n    m[[1L]] <- quote(stats::model.frame)\n    names(m)[[2]] <- \"formula\"\n\n    if (x[[2L]] == \".\") {\n        rhs <- as.list(attr(terms(x[-2L]), \"variables\")[-1])\n        lhs <- as.call(c(quote(cbind),\n            setdiff(lapply(names(data), as.name), rhs)))\n        x[[2L]] <- lhs\n        m[[2L]] <- x\n    }\n    mf <- eval(m, parent.frame())\n\n    if (is.matrix(mf[[1L]])) {\n        lhs <- as.data.frame(mf[[1L]])\n        bpaggregate(lhs, mf[-1L], FUN=FUN, ...,\n                    BPREDO=BPREDO, BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n    }\n    else bpaggregate(mf[1L], mf[-1L], FUN=FUN, ...,\n                     BPREDO=BPREDO, BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n",
        "bpbackend-methods.R": "setMethod(\"bpbackend\", \"missing\",\n    function(x)\n{\n    x <- registered()[[1]]\n    bpbackend(x)\n})\n\nsetReplaceMethod(\"bpbackend\", c(\"missing\", \"ANY\"),\n    function(x, value)\n{\n    x <- registered()[[1]]\n    bpbackend(x) <- value\n    x\n})\n\n",
        "bpinit.R": ".bpinit <-\n    function(manager, BPPARAM, BPOPTIONS, ...)\n{\n    ## temporarily change the paramters in BPPARAM\n    oldOptions <- .bpparamOptions(BPPARAM, names(BPOPTIONS))\n    on.exit(.bpparamOptions(BPPARAM) <- oldOptions, TRUE, FALSE)\n    .bpparamOptions(BPPARAM) <- BPOPTIONS\n\n    ## fallback conditions(all must be satisfied):\n    ## 1. BPPARAM has not been started\n    ## 2. fallback is allowed (bpfallback(x) == TRUE)\n    ## 3. One of the following conditions is met:\n    ##   3.1 the worker number is less than or equal to 1\n    ##   3.2 Parallel evaluation is disallowed (bpschedule(BPPARAM) == FALSE)\n    ##   3.3 BPPARAM is of MulticoreParam class\n    if (!bpisup(BPPARAM) && bpfallback(BPPARAM)) {\n        ## use cases:\n        ## bpnworkers: no worker available, or no benefit in parallel evaluation\n        ## bpschedule: in nested parallel call where the same\n        ##             BPPARAM cannot be reused\n        if (bpnworkers(BPPARAM) <= 1L || !bpschedule(BPPARAM)) {\n            oldParam <- BPPARAM\n            BPPARAM <- as(BPPARAM, \"SerialParam\")\n            on.exit({\n                .RNGstream(oldParam) <- .RNGstream(BPPARAM)\n            }, TRUE, FALSE) # add = TRUE, last = FALSE --> last in,\n                            # first out order\n        } else if (is(BPPARAM, \"MulticoreParam\")) {\n            ## use TransientMulticoreParam when MulticoreParam has not\n            ## started\n            oldParam <- BPPARAM\n            BPPARAM <- TransientMulticoreParam(BPPARAM)\n            on.exit({\n                .RNGstream(oldParam) <- .RNGstream(BPPARAM)\n            }, TRUE, FALSE)\n        }\n    }\n\n    ## start the BPPARAM if haven't\n    if (!bpisup(BPPARAM)) {\n        ## start / stop cluster\n        BPPARAM <- bpstart(BPPARAM)\n        on.exit(bpstop(BPPARAM), TRUE, FALSE)\n    }\n\n    ## iteration\n    res <- bploop(\n        manager, # dispatch\n        BPPARAM = BPPARAM,\n        BPOPTIONS = BPOPTIONS,\n        ...\n    )\n\n    if (!.bpallok(res, attrOnly = TRUE))\n        stop(.error_bplist(res))\n    res\n}\n\n",
        "bpisup-methods.R": "setMethod(\"bpisup\", \"ANY\", function(x) FALSE)\n\nsetMethod(\"bpisup\", \"missing\",\n    function(x)\n{\n    x <- registered()[[1]]\n    bpisup(x)\n})\n\n",
        "bpiterate-methods.R": "bpiterateAlong <-\n    function(X)\n{\n    n <- length(X)\n    i <- 0L\n    function() {\n        if (i >= n)\n            NULL\n        else {\n            i <<- i + 1L\n            X[[i]]\n        }\n    }\n}\n\n### =========================================================================\n### bpiterate methods\n### -------------------------------------------------------------------------\n\n## All params have dedicated bpiterate() methods.\n\nsetMethod(\"bpiterate\", c(\"ANY\", \"ANY\", \"missing\"),\n    function(ITER, FUN, ..., BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS=bpoptions())\n{\n    ITER <- tryCatch({\n        match.fun(ITER)\n    }, error = function(e) {\n        bpiterateAlong(ITER)\n    })\n    FUN <- match.fun(FUN)\n    bpiterate(ITER, FUN, ..., BPREDO = BPREDO,\n              BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n\n## TODO: support BPREDO\n.bpiterate_impl <-\n    function(ITER, FUN, ..., REDUCE, init, reduce.in.order = FALSE,\n             BPREDO = list(), BPPARAM = bpparam(), BPOPTIONS=bpoptions())\n{\n    ## Required API\n    ##\n    ## - BiocParallelParam()\n    ## - bpschedule(), bpisup(), bpstart(), bpstop()\n    ## - .sendto, .recvfrom, .recv, .close\n    ITER <- tryCatch({\n        match.fun(ITER)\n    }, error = function(e) {\n        bpiterateAlong(ITER)\n    })\n    FUN <- match.fun(FUN)\n\n    if (missing(REDUCE)) {\n        if (!missing(init))\n            stop(\"REDUCE must be provided when 'init' is given\")\n    }\n\n    ARGS <- list(...)\n\n    manager <- structure(list(), class=\"iterate\") # dispatch\n    .bpinit(\n        manager = manager,\n        ITER = ITER,\n        FUN = FUN,\n        ARGS = ARGS,\n        BPPARAM = BPPARAM,\n        BPOPTIONS = BPOPTIONS,\n        BPREDO = BPREDO,\n        init = init,\n        REDUCE = REDUCE,\n        reduce.in.order = reduce.in.order\n    )\n}\n",
        "bplapply-methods.R": "### =========================================================================\n### bplapply methods\n### -------------------------------------------------------------------------\n\n## All params have dedicated bplapply methods.\n\nsetMethod(\"bplapply\", c(\"ANY\", \"missing\"),\n    function(X, FUN, ..., BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n    bplapply(X, FUN, ..., BPREDO=BPREDO,\n             BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n\nsetMethod(\"bplapply\", c(\"ANY\", \"list\"),\n    function(X, FUN, ..., BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n\n    if (!all(vapply(BPPARAM, inherits, logical(1), \"BiocParallelParam\")))\n        stop(\"All elements in 'BPPARAM' must be BiocParallelParam objects\")\n    if (length(BPPARAM) == 0L)\n        stop(\"'length(BPPARAM)' must be > 0\")\n\n    myFUN <- if (length(BPPARAM) > 1L) {\n          if (length(param <- BPPARAM[-1]) == 1L)\n            function(...) FUN(..., BPPARAM=param[[1]])\n          else\n            function(...) FUN(..., BPPARAM=param)\n        } else FUN\n    bplapply(X, myFUN, ..., BPREDO=BPREDO,\n             BPPARAM=BPPARAM[[1]], BPOPTIONS = BPOPTIONS)\n})\n\n.bplapply_impl <-\n    function(X, FUN, ..., BPREDO = list(),\n             BPPARAM = bpparam(), BPOPTIONS = bpoptions())\n{\n    ## abstract 'common' implementation using accessors only\n    ##\n    ## Required API:\n    ##\n    ## - BiocParallelParam()\n    ## - bpschedule(), bpisup(), bpstart(), bpstop()\n    ## - .send_to, .recv_any, .send, .recv, .close\n    FUN <- match.fun(FUN)\n    BPREDO <- bpresult(BPREDO)\n\n    if (!length(X))\n        return(.rename(list(), X))\n\n    ARGS <- list(...)\n\n    manager <- structure(list(), class=\"lapply\") # dispatch\n    .bpinit(\n        manager = manager,\n        X = X,\n        FUN = FUN,\n        ARGS = ARGS,\n        BPPARAM = BPPARAM,\n        BPOPTIONS = BPOPTIONS,\n        BPREDO = BPREDO\n    )\n}\n",
        "bploop.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Manager loop used by SOCK, MPI and FORK\n\n## collect the results from the workers\n.collect_result <-\n    function(manager, reducer, progress, BPPARAM)\n{\n    data_list <- .manager_recv(manager)\n    success <- rep(TRUE, length(data_list))\n    for(i in seq_along(data_list)){\n        ## each result is a list containing the element value passed\n        ## in `.send` and possibly other elements used by the backend\n        d <- data_list[[i]]\n\n        value <- d$value$value\n        njob <- d$value$tag\n\n        ## reduce\n        .reducer_add(reducer, njob, value)\n        .manager_log(BPPARAM, njob, d)\n        .manager_result_save(BPPARAM, njob, reducer$value())\n\n        ## progress\n        progress$step(length(value))\n\n        ## whether the result is ok, or to treat the failure as success\n        success[i] <- !bpstopOnError(BPPARAM) || d$value$success\n    }\n    success\n}\n\n## These functions are used by all cluster types (SOCK, MPI, FORK) and\n## run on the master. Both enable logging, writing logs/results to\n## files and 'stop on error'.\n.clear_cluster <-\n    function(manager, running, reducer, progress, BPPARAM)\n{\n    tryCatch({\n        setTimeLimit(30, 30, TRUE)\n        on.exit(setTimeLimit(Inf, Inf, FALSE))\n        while (running) {\n            success <- .collect_result(manager, reducer, progress, BPPARAM)\n            running <- running - length(success)\n        }\n    }, error=function(e) {\n        message(\"Stop worker failed with the error: \", conditionMessage(e))\n    })\n    reducer\n}\n\n.manager_log <-\n    function(BPPARAM, njob, d)\n{\n    if (bplog(BPPARAM)) {\n        con <- NULL\n        if (!is.na(bplogdir(BPPARAM))) {\n            fname <- paste0(bpjobname(BPPARAM), \".task\", njob, \".log\")\n            lfile <- file.path(bplogdir(BPPARAM), fname)\n            con <- file(lfile, open=\"a\")\n            on.exit(close(con))\n        }\n        .bpwriteLog(con, d)\n    } else if (length(d$value$sout)) {\n        message(paste(d$value$sout, collapse=\"\\n\"))\n    }\n}\n\n.manager_result_save <-\n    function(BPPARAM, njob, value)\n{\n    if (is.na(bpresultdir(BPPARAM)))\n        return(NULL)\n\n    fname <- paste0(bpjobname(BPPARAM), \".task\", njob, \".Rda\")\n    rfile <- file.path(bpresultdir(BPPARAM), fname)\n    save(value, file=rfile)\n}\n\n\n## A dummy iterator for bploop.lapply\n.bploop_lapply_iter <-\n    function(X, redo_index, elements_per_task)\n{\n    redo_n <- length(redo_index)\n    redo_i <- 1L\n    x_n <- length(X)\n    x_i <- 1L\n    function() {\n        if (redo_i <= redo_n && x_i <= x_n) {\n            redo <- redo_index[redo_i] == x_i\n            if (redo) {\n                ## Maximize `len` such that\n                ## - 1. all elements in X[x_i:(x_i + len)] should be redone\n                ## - 2. the number of elements in the task must be\n                ##      limited by `elements_per_task`\n                len <- 1L\n                while (redo_i + len <= redo_n &&\n                       redo_index[redo_i + len] == x_i + len &&\n                       len < elements_per_task) {\n                    len <- len + 1L\n                }\n                redo_i <<- redo_i + len\n                value <- X[seq.int(x_i, length.out = len)]\n            } else {\n                len <- redo_index[redo_i] - x_i\n                value <- .bploop_rng_iter(len)\n            }\n            x_i <<- x_i + len\n            ## Do not return the last seed iterator\n            ## if no more redo element\n            if (x_i > x_n && !redo) {\n                list(NULL)\n            } else {\n                value\n            }\n        } else {\n            list(NULL)\n        }\n    }\n}\n\n## An iterator for bpiterate to handle BPREDO\n.bploop_iterate_iter <-\n    function(ITER, reducer)\n{\n    errors <- sort(.redo_index_iterate(reducer))\n    len <- reducer$total\n    if(is.null(len)) len <- 0L\n    i <- 0L\n    function(){\n        if (i < len) {\n            i <<- i + 1L\n            value <- ITER()\n            if (i%in%errors)\n                list(value)\n            else\n                .bploop_rng_iter(1L)\n        } else {\n            list(ITER())\n        }\n    }\n}\n\n\n## This class object can force bploop.iterator to iterate\n## the seed stream n times\n.bploop_rng_iter <- function(n) {\n    structure(as.integer(n), class = c(\".bploop_rng_iter\"))\n}\n\n## Accessor for the elements in the BPREDO argument\n## Return NULL if not exists\n.redo_env <-\n    function(x)\n{\n    attr(x, \"REDOENV\")\n}\n\n.redo_reducer <-\n    function(x)\n{\n    .redo_env(x)$reducer\n}\n\n.redo_seed <-\n    function(x)\n{\n    .redo_env(x)$rng_seed\n}\n\n`.redo_env<-` <-\n    function(x, value)\n{\n    attr(x, \"REDOENV\") <- value\n    x\n}\n\n`.redo_reducer<-` <-\n    function(x, value)\n{\n    .redo_env(x)$reducer <- value\n    x\n}\n\n`.redo_seed<-` <-\n    function(x, value)\n{\n    .redo_env(x)$rng_seed <- value\n    x\n}\n\n## The core bploop implementation\n## Arguments\n## - ITER: Return a list where each list element will be passed to FUN\n##   1. if nothing to proceed, it should return list(NULL)\n##   2. if the task is to iterate the seed stream only, it should return\n##      an object from .bploop_rng_iter()\n## - FUN: A function that will be evaluated in the worker\n## - ARGS: the arguments to FUN\n.bploop_impl <-\n    function(ITER, FUN, ARGS, BPPARAM, BPREDO, BPOPTIONS, reducer, progress.length)\n{\n    manager <- .manager(BPPARAM)\n    on.exit(.manager_cleanup(manager), add = TRUE)\n\n    ## worker options\n    OPTIONS <- .workerOptions(\n        log = bplog(BPPARAM),\n        threshold = bpthreshold(BPPARAM),\n        stop.on.error = bpstopOnError(BPPARAM),\n        timeout = bptimeout(BPPARAM),\n        exportglobals = bpexportglobals(BPPARAM),\n        force.GC = bpforceGC(BPPARAM)\n    )\n\n    ## prepare the seed stream for the worker\n    init_seed <- .redo_seed(BPREDO)\n    if (is.null(init_seed)) {\n        seed <- .RNGstream(BPPARAM)\n        on.exit(.RNGstream(BPPARAM) <- seed, add = TRUE)\n        init_seed <- seed\n    } else {\n        seed <- init_seed\n    }\n\n    ## Progress bar\n    progress <- .progress(\n        active=bpprogressbar(BPPARAM), iterate=missing(progress.length)\n    )\n    on.exit(progress$term(), add = TRUE)\n    progress$init(progress.length)\n\n    ## detect auto export variables and packages\n    globalVarNames <- as.character(BPOPTIONS$exports)\n    packages <- as.character(BPOPTIONS$packages)\n    if (bpexportvariables(BPPARAM)) {\n        exports <- .findVariables(FUN)\n        globalVarNames <- c(globalVarNames, exports$globalvars)\n        packages <- c(packages, exports$pkgs)\n    }\n    globalVars <- lapply(globalVarNames, get, envir = .GlobalEnv)\n    names(globalVars) <- globalVarNames\n\n    ## The data that will be sent to the worker\n    ARGFUN <- function(X, seed)\n        list(\n            X=X , FUN=FUN , ARGS = ARGS,\n            OPTIONS = OPTIONS, BPRNGSEED = seed,\n            GLOBALS = globalVars,\n            PACKAGES = packages\n        )\n    static.args <- c(\"FUN\", \"ARGS\", \"OPTIONS\", \"GLOBALS\")\n\n    total <- 0L\n    running <- 0L\n    value <- NULL\n    ## keep the loop when there exists more ITER value or running tasks\n    while (!identical(value, list(NULL)) || running) {\n        ## send tasks to the workers\n        while (running < .manager_capacity(manager)) {\n            value <- ITER()\n            ## If the value is of the class .bploop_rng_iter, we merely iterate\n            ## the seed stream `value` times and obtain the next value.\n            if (inherits(value, \".bploop_rng_iter\")) {\n                seed <- .rng_iterate_substream(seed, value)\n                next\n            }\n            if (identical(value, list(NULL))) {\n                if (total == 0L)\n                    warning(\"first invocation of 'ITER()' returned NULL\")\n                break\n            }\n            args <- ARGFUN(value, seed)\n            task <- .EXEC(\n                total + 1L, .workerLapply,\n                args = args,\n                static.fun = TRUE,\n                static.args = static.args\n            )\n            .manager_send(manager, task)\n            seed <- .rng_iterate_substream(seed, length(value))\n            total <- total + 1L\n            running <- running + 1L\n        }\n        .manager_flush(manager)\n\n        ## If the cluster does not have any worker, waiting for the worker\n        if (!running)\n            next\n\n        ## collect results from the workers\n        success <- .collect_result(manager, reducer, progress, BPPARAM)\n        running <- running - length(success)\n\n        ## stop on error; Let running jobs finish and break\n        if (!all(success)) {\n            reducer <- .clear_cluster(\n                manager, running, reducer, progress, BPPARAM\n            )\n            break\n        }\n    }\n\n    ## return results\n    if (!is.na(bpresultdir(BPPARAM)))\n        return(NULL)\n\n    res <- .reducer_value(reducer)\n    ## Attach the redo information when the error occurs\n    if(!.reducer_ok(reducer) || !.reducer_complete(reducer)) {\n        .redo_env(res) <- new.env(parent = emptyenv())\n        .redo_reducer(res) <- reducer\n        .redo_seed(res) <- init_seed\n    }\n    res\n}\n\n\n##\n## bploop.lapply(): derived from snow::dynamicClusterApply.\n##\nbploop <-\n    function(manager, ...)\n{\n    UseMethod(\"bploop\")\n}\n\n## X: the loop value after division\n## ARGS: The function arguments for `FUN`\nbploop.lapply <-\n    function(manager, X, FUN, ARGS, BPPARAM,\n             BPOPTIONS = bpoptions(), BPREDO = list(), ...)\n{\n    ## which need to be redone?\n    redo_index <- .redo_index(X, BPREDO)\n\n    ## How many elements in a task?\n    ntask <- .ntask(X, bpnworkers(BPPARAM), bptasks(BPPARAM))\n    elements_per_task <- ceiling(length(redo_index)/ntask)\n    ITER <- .bploop_lapply_iter(X, redo_index, elements_per_task)\n\n    ntotal <- length(X)\n    reducer <- .lapplyReducer(ntotal, reducer = .redo_reducer(BPREDO))\n\n    res <- .bploop_impl(\n        ITER = ITER,\n        FUN = FUN,\n        ARGS = ARGS,\n        BPPARAM = BPPARAM,\n        BPOPTIONS = BPOPTIONS,\n        BPREDO = BPREDO,\n        reducer = reducer,\n        progress.length = length(redo_index)\n    )\n\n    if (!is.null(res))\n        names(res) <- names(X)\n\n    res\n}\n\n##\n## bploop.iterate():\n##\n## Derived from snow::dynamicClusterApply and parallel::mclapply.\n##\n## - length of 'X' is unknown (defined by ITER())\n## - results not pre-allocated; list grows each iteration if no REDUCE\nbploop.iterate <-\n    function(\n        manager, ITER, FUN, ARGS, BPPARAM,\n        BPOPTIONS = bpoptions(), REDUCE, BPREDO,\n        init, reduce.in.order, ...\n    )\n{\n    ITER_ <- .bploop_iterate_iter(ITER, reducer = .redo_reducer(BPREDO))\n    reducer <- .iterateReducer(REDUCE, init, reduce.in.order,\n                               reducer = .redo_reducer(BPREDO))\n    .bploop_impl(\n        ITER = ITER_,\n        FUN = FUN,\n        ARGS = ARGS,\n        BPPARAM = BPPARAM,\n        BPOPTIONS = BPOPTIONS,\n        BPREDO = BPREDO,\n        reducer = reducer\n    )\n}\n\nbploop.iterate_batchtools <-\n    function(manager, ITER, FUN, BPPARAM, REDUCE, init, reduce.in.order, ...)\n{\n    ## get number of workers\n    workers <- bpnworkers(BPPARAM)\n    ## reduce in order\n    reducer <- .iterateReducer(REDUCE, init, reduce.in.order,\n                               NULL)\n\n    ## progress bar.\n    progress <- .progress(active=bpprogressbar(BPPARAM), iterate=TRUE)\n    on.exit(progress$term(), TRUE)\n    progress$init()\n\n    def.id <- job.id <- 1L\n    repeat{\n        value <- ITER()\n        if (is.null(value)) {\n            if (job.id == 1L)\n                warning(\"first invocation of 'ITER()' returned NULL\")\n            break\n        }\n\n        ## save 'value' to registry tempfile\n        fl <- tempfile(tmpdir = BPPARAM$registry$file.dir)\n        saveRDS(value, fl)\n\n        if (job.id == 1L) {\n            suppressMessages({\n                ids <- batchtools::batchMap(\n                    fun = FUN, fl, more.args = list(...),\n                    reg = BPPARAM$registry\n                )\n            })\n        } else {\n            job.pars <- list(fl)\n            BPPARAM$registry$defs <-\n                rbind(BPPARAM$registry$defs, list(def.id, list(job.pars)))\n            entry <- c(list(job.id, def.id), rep(NA, 10))\n            BPPARAM$registry$status <- rbind(BPPARAM$registry$status, entry)\n        }\n        def.id <- def.id + 1L\n        job.id <- job.id + 1L\n    }\n\n    ## finish  updating tables\n    ids <- data.table::data.table(job.id = seq_len(job.id - 1))\n    data.table::setkey(BPPARAM$registry$status, \"job.id\")\n    ids$chunk = batchtools::chunk(ids$job.id, n.chunks = workers)\n\n    ## submit and wait for jobs\n    batchtools::submitJobs(\n        ids = ids, resources = .bpresources(BPPARAM), reg = BPPARAM$registry\n    )\n    batchtools::waitForJobs(\n        ids = BPPARAM$registry$status$job.id,\n        reg = BPPARAM$registry, timeout = .batch_bptimeout(BPPARAM),\n        stop.on.error = bpstopOnError(BPPARAM)\n    )\n\n    ## reduce in order\n    for (job.id in ids$job.id) {\n        value <- batchtools::loadResult(id = job.id, reg=BPPARAM$registry)\n        .reducer_add(reducer, job.id, list(value))\n    }\n\n    ## return reducer value\n    .reducer_value(reducer)\n}\n",
        "bpmapply-methods.R": "### =========================================================================\n### bpmapply methods\n### -------------------------------------------------------------------------\n\n# see test_utilities.R:test_transposeArgsWithIterations() for all\n# USE.NAMES corner cases\n.transposeArgsWithIterations <- function(nestedList, USE.NAMES) {\n    num_arguments <- length(nestedList)\n    if (num_arguments == 0L) {\n        return(list())\n    }\n\n    ## nestedList[[1L]] has the values for the first argument in all\n    ## iterations\n    num_iterations <- length(nestedList[[1L]])\n\n    ## count the iterations, and name them if needed\n    iterations <- seq_len(num_iterations)\n    if (USE.NAMES) {\n        first_arg <- nestedList[[1L]]\n        if (is.character(first_arg) && is.null(names(first_arg))) {\n            names(iterations) <- first_arg\n        } else {\n            names(iterations) <- names(first_arg)\n        }\n    }\n\n    ## argnames:\n    argnames <- names(nestedList)\n\n    ## on iteration `i` we get the i-th element from each list. Note\n    ## that .getDotsForMapply() has taken care already of ensuring\n    ## that nestedList elements are recycled properly\n    lapply(iterations, function(i) {\n        x <- lapply(nestedList, function(argi) {\n            unname(argi[i])\n        })\n        names(x) <- argnames\n        x\n    })\n}\n\n## bpmapply() dispatches to bplapply() where errors and logging are handled.\n\nsetMethod(\"bpmapply\", c(\"ANY\", \"BiocParallelParam\"),\n    function(FUN, ..., MoreArgs=NULL, SIMPLIFY=TRUE,\n             USE.NAMES=TRUE, BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    ## re-package for lapply\n    ddd <- .getDotsForMapply(...)\n    FUN <- match.fun(FUN)\n\n    if (!length(ddd))\n      return(list())\n     \n    ddd <- .transposeArgsWithIterations(ddd, USE.NAMES)\n    if (!length(ddd))\n      return(ddd)\n\n    .wrapMapplyNotShared <- local({\n        function(dots, .FUN, .MoreArgs) {\n            .mapply(.FUN, dots, .MoreArgs)[[1L]]\n        }\n    }, envir = baseenv())\n\n    res <- bplapply(\n        X=ddd, .wrapMapplyNotShared, .FUN=FUN,\n        .MoreArgs=MoreArgs, BPREDO=BPREDO,\n        BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS\n    )\n    .simplify(res, SIMPLIFY)\n})\n\nsetMethod(\"bpmapply\", c(\"ANY\", \"missing\"),\n    function(FUN, ..., MoreArgs=NULL, SIMPLIFY=TRUE,\n             USE.NAMES=TRUE, BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n    bpmapply(FUN, ..., MoreArgs=MoreArgs, SIMPLIFY=SIMPLIFY,\n             USE.NAMES=USE.NAMES, BPREDO=BPREDO,\n             BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n\nsetMethod(\"bpmapply\", c(\"ANY\", \"list\"),\n    function(FUN, ..., MoreArgs=NULL, SIMPLIFY=TRUE,\n             USE.NAMES=TRUE, BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n\n    if (!all(vapply(BPPARAM, inherits, logical(1), \"BiocParallelParam\")))\n        stop(\"All elements in 'BPPARAM' must be BiocParallelParam objects\")\n    if (length(BPPARAM) == 0L)\n        stop(\"'length(BPPARAM)' must be > 0\")\n\n    myFUN <-\n        if (length(BPPARAM) > 1L) {\n          if (length(param <- BPPARAM[-1]) == 1L)\n            function(...) FUN(..., BPPARAM=param[[1]])\n          else\n            function(...) FUN(..., BPPARAM=param)\n        } else FUN\n    bpmapply(myFUN, ..., MoreArgs=MoreArgs, SIMPLIFY=SIMPLIFY,\n             USE.NAMES=USE.NAMES, BPREDO=BPREDO,\n             BPPARAM=BPPARAM[[1L]], BPOPTIONS = BPOPTIONS)\n})\n\n",
        "bpoptions.R": ".optionRegistry <- setRefClass(\".BiocParallelOptionsRegistry\",\n    fields=list(\n        options = \"list\"),\n    methods=list(\n        register = function(optionName, genericName) {\n            if (!is.null(.self$options[[optionName]]))\n                message(\"Replacing the function `\",\n                        optionName,\n                        \"` from the option registry\")\n            .self$options[[optionName]] <- genericName\n            invisible(registered())\n        },\n        registered = function() {\n            .self$options\n        })\n)$new()  # Singleton\n\n## Functions to register the S4generic for BPPARAM\n.registeredOptions <-\n    function()\n{\n    .optionRegistry$registered()\n}\n\n.registerOption <-\n    function(optionName, genericName)\n{\n    getter <- getGeneric(genericName)\n    setter <- getGeneric(paste0(genericName, \"<-\"))\n    if (is.null(getter))\n        stop(\"The S4 function '\", genericName, \"' is not found\")\n    if (is.null(setter))\n        stop(\"The S4 replacement function '\", genericName, \"' is not found\")\n    .optionRegistry$register(optionName, genericName)\n}\n\n.registerOption(\"workers\", \"bpworkers\")\n.registerOption(\"tasks\", \"bptasks\")\n.registerOption(\"jobname\", \"bpjobname\")\n.registerOption(\"log\", \"bplog\")\n.registerOption(\"logdir\", \"bplogdir\")\n.registerOption(\"threshold\", \"bpthreshold\")\n.registerOption(\"resultdir\", \"bpresultdir\")\n.registerOption(\"stop.on.error\", \"bpstopOnError\")\n.registerOption(\"timeout\", \"bptimeout\")\n.registerOption(\"exportglobals\", \"bpexportglobals\")\n.registerOption(\"exportvariables\", \"bpexportvariables\")\n.registerOption(\"progressbar\", \"bpprogressbar\")\n.registerOption(\"RNGseed\", \"bpRNGseed\")\n.registerOption(\"force.GC\", \"bpforceGC\")\n.registerOption(\"fallback\", \"bpfallback\")\n\n## functions for changing the paramters in BPPARAM\n.bpparamOptions <-\n    function(BPPARAM, optionNames)\n{\n    registeredOptions <- .registeredOptions()\n    ## find the common parameters both BPPARAM and BPOPTIONS\n    paramOptions <- intersect(names(registeredOptions), optionNames)\n    getterNames <- unlist(registeredOptions[paramOptions])\n    result <- vector(\"list\", length(getterNames))\n    for (i in seq_along(getterNames))\n        result[i] <- list(do.call(getterNames[[i]], list(BPPARAM)))\n    setNames(result, paramOptions)\n}\n\n## value: BPOPTIONS\n`.bpparamOptions<-` <-\n    function(BPPARAM, value)\n{\n    BPOPTIONS <- value\n    registeredOptions <- .registeredOptions()\n    optionNames <- names(BPOPTIONS)\n    paramOptions <- intersect(names(registeredOptions), optionNames)\n    setterNames <- paste0(unlist(registeredOptions[paramOptions]), \"<-\")\n    for (i in seq_along(paramOptions)) {\n        paramOption <- paramOptions[i]\n        setterName <- setterNames[i]\n        do.call(\n            setterName,\n            args = list(BPPARAM, BPOPTIONS[[paramOption]])\n        )\n    }\n    BPPARAM\n}\n\n## Check any possible issues in bpoptions\n.validateBpoptions <-\n    function(BPOPTIONS)\n{\n    bpoptionsArgs <- names(formals(bpoptions))\n    registeredOptions <- names(.registeredOptions())\n    allOptions <- c(bpoptionsArgs, registeredOptions)\n    idx <- which(!names(BPOPTIONS) %in% allOptions)\n    if (length(idx))\n        message(\n            \"unregistered options found in bpoptions:\\n\",\n            \"  \", paste0(names(BPOPTIONS)[idx], collapse = \", \")\n        )\n}\n\n## The function simply return a list of its arguments\nbpoptions <-\n    function(\n        workers, tasks, jobname,\n        log, logdir, threshold,\n        resultdir, stop.on.error,\n        timeout, exportglobals, exportvariables,\n        progressbar,\n        RNGseed, force.GC,\n        fallback,\n        exports, packages,\n        ...)\n{\n        dotsArgs <- list(...)\n        passed <- names(as.list(match.call())[-1])\n        passed <- setdiff(passed, names(dotsArgs))\n        if (length(passed))\n            passedArgs <- setNames(mget(passed), passed)\n        else\n            passedArgs <- NULL\n        opts <- c(passedArgs, dotsArgs)\n        .validateBpoptions(opts)\n        opts\n}\n\n\n",
        "bpschedule-methods.R": "setMethod(\"bpschedule\", \"ANY\", function(x) TRUE)\n\nsetMethod(\"bpschedule\", \"missing\",\n    function(x)\n{\n    x <- registered()[[1]]\n    bpschedule(x)\n})\n\n",
        "bpstart-methods.R": "### =========================================================================\n### ClusterManager object: ensures started clusters are stopped\n### -------------------------------------------------------------------------\n\n.ClusterManager <- local({\n    ## package-global registry of backends; use to avoid closing\n    ## socket connections of unreferenced backends during garbage\n    ## collection -- bpstart(MulticoreParam(1)); gc(); gc()\n    uid <- 0\n    env <- environment()\n    list(add = function(cluster) {\n        uid <<- uid + 1L\n        cuid <- as.character(uid)\n        env[[cuid]] <- cluster          # protection\n        cuid\n    }, drop = function(cuid) {\n        if (length(cuid) && cuid %in% names(env))\n            rm(list=cuid, envir=env)\n        invisible(NULL)\n    }, get = function(cuid) {\n        env[[cuid]]\n    }, ls = function() {\n        cuid <- setdiff(ls(env), c(\"uid\", \"env\"))\n        cuid[order(as.integer(cuid))]\n    })\n})\n\n### =========================================================================\n### bpstart() methods\n### -------------------------------------------------------------------------\n\nsetMethod(\"bpstart\", \"ANY\", function(x, ...) invisible(x))\n\nsetMethod(\"bpstart\", \"missing\",\n    function(x, ...)\n{\n    x <- registered()[[1]]\n    bpstart(x)\n})\n\n##\n## .bpstart_impl: common functionality after bpisup()\n##\n\n.bpstart_error_handler <-\n    function(x, response, id)\n{\n    value <- lapply(response, function(elt) elt[[\"value\"]][[\"value\"]])\n    if (!all(bpok(value))) {\n        on.exit(try(bpstop(x)))\n        stop(\n            \"\\nbpstart() \", id, \" error:\\n\",\n            conditionMessage(.error_bplist(value))\n        )\n    }\n}\n\n.bpstart_set_rng_stream <-\n    function(x)\n{\n    ## initialize the random number stream; increment the stream only\n    ## in bpstart_impl\n    .RNGstream(x) <- .rng_init_stream(bpRNGseed(x))\n\n    invisible(.RNGstream(x))\n}\n\n\n.bpstart_set_finalizer <-\n    function(x)\n{\n    if (length(x$.uid) == 0L) {\n        finalizer_env <- as.environment(list(self=x$.self))\n        reg.finalizer(\n            finalizer_env, function(e) bpstop(e[[\"self\"]]), onexit=TRUE\n        )\n        x$.finalizer_env <- finalizer_env\n    }\n    x$.uid <- .ClusterManager$add(bpbackend(x))\n\n    invisible(x)\n}\n\n.bpstart_impl <-\n    function(x)\n{\n    ## common actions once bpisup(backend)\n\n    ## initialize the random number stream\n    .bpstart_set_rng_stream(x)\n\n    ## clean up when x left open\n    .bpstart_set_finalizer(x)\n}\n",
        "bpstop-methods.R": "setMethod(\"bpstop\", \"ANY\", function(x) invisible(x))\n\nsetMethod(\"bpstop\", \"missing\",\n    function(x)\n{\n    x <- registered()[[1]]\n    bpstop(x)\n})\n\n##\n## .bpstop_impl: common functionality after bpisup() is no longer TRUE\n##\n\n.bpstop_nodes <-\n    function(x)\n{\n    manager <- .manager(x)\n    .manager_send_all(manager, .DONE())\n    TRUE\n}\n\n.bpstop_impl <-\n    function(x)\n{\n    bpisup(x) && .bpstop_nodes(x)\n    .ClusterManager$drop(x$.uid)\n    invisible(x)\n}\n",
        "bpvalidate.R": ".BPValidate <- setClass(\n    \"BPValidate\",\n    slots = c(\n        symbol = \"character\",\n        environment = \"character\",\n        unknown = \"character\"\n    )\n)\n\nBPValidate <-\n    function(symbol = character(), environment = character(),\n        unknown = character())\n{\n    if (is.null(symbol))\n        symbol <- character()\n    if (is.null(environment))\n        environment <- character()\n    .BPValidate(symbol = symbol, environment = environment, unknown = unknown)\n}\n\n.bpvalidateSymbol <- function(x) x@symbol\n\n.bpvalidateEnvironment <- function(x) x@environment\n\n.bpvalidateUnknown <- function(x) x@unknown\n\n.show_bpvalidateSearch <- function(x)\n{\n    search <- data.frame(\n        symbol = .bpvalidateSymbol(x),\n        environment = .bpvalidateEnvironment(x),\n        row.names = NULL\n    )\n    output <- capture.output(search)\n    text <- ifelse(NROW(search), paste(output, collapse = \"\\n  \"), \"none\")\n    c(\"symbol(s) in search() path:\\n  \", text)\n}\n\n.show_bpvalidateUnknown <- function(x)\n{\n    unknown <- .bpvalidateUnknown(x)\n    text <- ifelse(length(unknown), paste(unknown, collapse = \"\\n  \"), \"none\")\n    c(\"unknown symbol(s):\\n  \", text)\n}\n\nsetMethod(\"show\", \"BPValidate\", function(object) {\n    cat(\n        \"class: \", class(object), \"\\n\",\n        .show_bpvalidateSearch(object), \"\\n\\n\",\n        .show_bpvalidateUnknown(object), \"\\n\\n\",\n        sep = \"\"\n    )\n})\n\n#########################\n## Utils\n#########################\n.filterDefaultPackages <-\n    function(symbols)\n{\n    pkgs <- c(\n        \"stats\", \"graphics\", \"grDevices\", \"utils\", \"datasets\",\n        \"methods\", \"Autoloads\", \"base\"\n    )\n    drop <- unlist(symbols, use.names = FALSE) %in% paste0(\"package:\", pkgs)\n    symbols[!drop]\n}\n\n## Filter the variables that will be available after `fun` loads\n## packages\n.filterLibraries <-\n    function(codes, symbols, ERROR_FUN)\n{\n    warn <- err <- NULL\n    ## 'fun' body loads libraries\n    pkgLoadFunc <- c(\"require\", \"library\")\n    i <- grepl(\n        paste0(\"(\", paste0(pkgLoadFunc, collapse = \"|\"), \")\"),\n        codes\n    )\n    xx <- lapply(codes[i], function(code) {\n        withCallingHandlers(tryCatch({\n            ## convert character code to expression\n            expr <- parse(text = code)[[1]]\n            ## match the library/require function arguments\n            expr <- match.call(eval(expr[[1]]), expr)\n            ## get the package name from the function arguments\n            pkg <- as.character(expr[[which(names(expr) == \"package\")]])\n            which(symbols %in% getNamespaceExports(pkg))\n        }, error=function(e) {\n            err <<- append(err, conditionMessage(e))\n            NULL\n        }), warning=function(w) {\n            warn <<- append(warn, conditionMessage(w))\n            invokeRestart(\"muffleWarning\")\n        })\n    })\n    if (!is.null(warn) || !is.null(err))\n        ERROR_FUN(\"attempt to load library failed:\\n    \",\n                  paste(c(warn, err), collapse=\"\\n    \"))\n    xx <- unlist(xx)\n    if (length(xx))\n        symbols <- symbols[-xx]\n    symbols\n}\n\n## find the variables that needed to be exported\n.findVariables <-\n    function(fun, ERROR_FUN = capture.output)\n{\n    unknown <- findGlobals(fun)\n    env <- environment(fun)\n    codes <- deparse(fun)\n    ## TODO: The location where the pkg is loaded is not considered here\n    ## (should we consider it??)\n    ## remove the symbols that will be loaded inside the function\n    unknown <- .filterLibraries(codes, unknown, ERROR_FUN)\n\n    ## Find the objects that will ship with the function\n    while (length(unknown) &&\n           !identical(env, emptyenv()) &&\n           !identical(.GlobalEnv, env))\n    {\n        i <- vapply(unknown, function(x) {\n            !exists(x, envir = env, inherits = FALSE)\n        }, logical(1))\n        ## Force evaluation of the known arguments to\n        ## make sure they will be exported correctly\n        known <- unknown[-i]\n        for (nm in known)\n            force(env[[nm]])\n        unknown <- unknown[i]\n        env <- parent.env(env)\n    }\n\n    ## Find the objects that are defined in the search path\n    ## (only if the function/expr depends on the global)\n    inpath <- list()\n    if (length(unknown) && identical(.GlobalEnv, env)) {\n        inpath <- lapply(unknown, function(x) {\n            where <- find(x)\n            ## Includes only packages and variables in the global\n            ## environment\n            keep <-  startsWith(where, \"package:\") | where == \".GlobalEnv\"\n            head(where[keep], 1L)\n        })\n        names(inpath) <- unknown\n        i <- as.logical(lengths(inpath))\n        unknown <- unknown[!i]\n        inpath <- inpath[i]\n        inpath <- .filterDefaultPackages(inpath)\n    }\n\n    ## The package required by the worker\n    pkgs <- unique(unlist(inpath, use.names = FALSE))\n\n    ## variables defined in the global environment\n    globalvars <- names(inpath)[pkgs == \".GlobalEnv\"]\n\n    pkgs <- pkgs[pkgs != \".GlobalEnv\"]\n    pkgs <- gsub(\"package:\", \"\", pkgs, fixed = TRUE)\n\n    list(\n        unknown = unknown,\n        pkgs = pkgs,\n        globalvars = globalvars,\n        inpath = inpath\n    )\n}\n\n#########################\n## validate funtions and vairables that need to be exported\n#########################\nbpvalidate <- function(fun, signal = c(\"warning\", \"error\", \"silent\"))\n{\n    typeof <- suppressWarnings(typeof(fun))\n    if (!typeof %in% c(\"closure\", \"builtin\"))\n        stop(\"'fun' must be a closure or builtin\")\n\n    if (is.function(signal)) {\n        ERROR_FUN <- signal\n    } else {\n        ERROR_FUN <- switch(\n            match.arg(signal),\n            warning = warning,\n            error = stop,\n            silent = capture.output\n        )\n    }\n\n    ## Filter the symbols that is loaded via library/require\n    exports <- .findVariables(fun, ERROR_FUN = ERROR_FUN)\n    inpath <- exports$inpath\n\n    result <- BPValidate(\n        symbol = names(inpath),\n        environment = unlist(inpath, use.names = FALSE),\n        unknown = exports$unknown\n    )\n\n    ## error report\n    msg <- character()\n    test <- .bpvalidateEnvironment(result) %in% \".GlobalEnv\"\n    if (any(test))\n        msg <- c(\n            msg, \"symbol(s) in .GlobalEnv:\\n  \",\n            paste(.bpvalidateSymbol(result)[test], collapse = \"\\n  \"), \"\\n\"\n        )\n    test <- .bpvalidateUnknown(result)\n    if (length(test))\n        msg <- c(\n            msg, \"unknown symbol(s):\\n  \", paste(test, collapse = \"\\n  \"), \"\\n\"\n        )\n    if (length(msg))\n        ERROR_FUN(\"\\n\", paste(msg, collapse = \"\"), call. = FALSE)\n\n    result\n}\n\n\n\n",
        "bpvec-methods.R": "### =========================================================================\n### bpvec methods\n### -------------------------------------------------------------------------\n\n## bpvec() dispatches to bplapply() where errors and logging are\n## handled.\n\nsetMethod(\"bpvec\", c(\"ANY\", \"BiocParallelParam\"),\n    function(X, FUN, ..., AGGREGATE=c, BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    if (!length(X))\n        return(.rename(list(), X))\n\n    FUN <- match.fun(FUN)\n    AGGREGATE <- match.fun(AGGREGATE)\n    BPREDO <- bpresult(BPREDO)\n\n    if (!bpschedule(BPPARAM)) {\n        param <- as(BPPARAM, \"SerialParam\")\n        return(\n            bpvec(\n                X, FUN, ..., AGGREGATE=AGGREGATE, BPREDO=BPREDO,\n                BPPARAM = param, BPOPTIONS = BPOPTIONS\n            )\n        )\n    }\n\n    si <- .splitX(seq_along(X), bpnworkers(BPPARAM), bptasks(BPPARAM))\n    otasks <- bptasks(BPPARAM)\n    bptasks(BPPARAM) <- 0L\n    on.exit(bptasks(BPPARAM) <- otasks)\n\n    FUN1 <- function(i, ...) FUN(X[i], ...)\n    res <- bptry(bplapply(\n        si, FUN1, ..., BPREDO=BPREDO, BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS\n    ))\n\n    if (is(res, \"error\") || !all(bpok(res)))\n        stop(.error_bplist(res))\n\n    if (any(lengths(res) != lengths(si)))\n        stop(.error(\"length(FUN(X)) not equal to length(X)\", \"bpvec_error\"))\n\n    do.call(AGGREGATE, res)\n})\n\nsetMethod(\"bpvec\", c(\"ANY\", \"missing\"),\n    function(X, FUN, ..., AGGREGATE=c, BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n    AGGREGATE <- match.fun(AGGREGATE)\n    bpvec(X, FUN, ..., AGGREGATE=AGGREGATE, BPREDO=BPREDO,\n          BPPARAM=BPPARAM, BPOPTIONS = BPOPTIONS)\n})\n\nsetMethod(\"bpvec\", c(\"ANY\", \"list\"),\n    function(X, FUN, ..., BPREDO=list(),\n             BPPARAM=bpparam(), BPOPTIONS = bpoptions())\n{\n    FUN <- match.fun(FUN)\n\n    if (!all(vapply(BPPARAM, inherits, logical(1), \"BiocParallelParam\")))\n        stop(\"All elements in 'BPPARAM' must be BiocParallelParam objects\")\n    if (length(BPPARAM) == 0L)\n        stop(\"'length(BPPARAM)' must be > 0\")\n\n    myFUN <- if (length(BPPARAM) > 1L) {\n        param <- BPPARAM[-1]\n        if (length(param) == 1L)\n            function(...) FUN(..., BPPARAM=param[[1]])\n        else\n            function(...) FUN(..., BPPARAM=param)\n    } else FUN\n\n    bpvec(\n        X, myFUN, ..., BPREDO=BPREDO,\n        BPPARAM=BPPARAM[[1]], BPOPTIONS = BPOPTIONS\n    )\n})\n",
        "bpvectorize-methods.R": "setMethod(\"bpvectorize\", c(\"ANY\", \"ANY\"),\n    function(FUN, ..., BPREDO=list(), BPPARAM=bpparam())\n{\n    FUN <- match.fun(FUN)\n    function(...)\n        bpvec(FUN=FUN, ..., BPREDO=BPREDO, BPPARAM=BPPARAM)\n})\n\nsetMethod(\"bpvectorize\", c(\"ANY\", \"missing\"),\n    function(FUN, ..., BPREDO=list(), BPPARAM=bpparam())\n{\n    FUN <- match.fun(FUN)\n    bpvectorize(FUN, ..., BPREDO=BPREDO, BPPARAM=BPPARAM)\n})\n",
        "bpworkers-methods.R": "setMethod(\"bpworkers\", \"missing\",\n    function(x)\n{\n    x <- registered()[[1]]\n    bpworkers(x)\n})\n\nbpnworkers <- function(x) {\n    n <- bpworkers(x)\n    if (!is.numeric(n))\n        n <- length(n)\n    n\n}\n",
        "cpp11.R": "# Generated by cpp11: do not edit by hand\n\ncpp_ipc_remove <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_remove`, id_sexp)\n}\n\ncpp_ipc_uuid <- function() {\n  .Call(`_BiocParallel_cpp_ipc_uuid`)\n}\n\ncpp_ipc_locked <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_locked`, id_sexp)\n}\n\ncpp_ipc_lock <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_lock`, id_sexp)\n}\n\ncpp_ipc_try_lock <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_try_lock`, id_sexp)\n}\n\ncpp_ipc_unlock <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_unlock`, id_sexp)\n}\n\ncpp_ipc_value <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_value`, id_sexp)\n}\n\ncpp_ipc_reset <- function(id_sexp, n) {\n  .Call(`_BiocParallel_cpp_ipc_reset`, id_sexp, n)\n}\n\ncpp_ipc_yield <- function(id_sexp) {\n  .Call(`_BiocParallel_cpp_ipc_yield`, id_sexp)\n}\n",
        "ipcmutex.R": "## Utilities\n\nipcid <- function(id) {\n    uuid <- cpp_ipc_uuid()\n    if (!missing(id))\n        uuid <- paste(as.character(id), uuid, sep=\"-\")\n    uuid\n}\n\nipcremove <- function(id) {\n    invisible(cpp_ipc_remove(id))\n}\n\n## Locks\n\nipclocked <- function(id)\n    cpp_ipc_locked(id)\n\nipclock <- function(id) {\n    cpp_ipc_lock(id)\n}\n\nipctrylock <- function(id) {\n    cpp_ipc_try_lock(id)\n}\n\nipcunlock <- function(id) {\n    cpp_ipc_unlock(id)\n}\n\n## Counters\n\nipcyield <- function(id) {\n    cpp_ipc_yield(id)\n}\n\nipcvalue <- function(id) {\n    cpp_ipc_value(id)\n}\n\nipcreset <- function(id, n = 1) {\n    invisible(cpp_ipc_reset(id, n))\n}\n",
        "log.R": ".log_data <- local({\n    env <- new.env(parent=emptyenv())\n    env[[\"buffer\"]] <- character()\n    env\n})\n\n.log_load <- function(log, threshold)\n{\n    if (!log) {\n        if (isNamespaceLoaded(\"futile.logger\")) {\n            futile.logger::flog.appender(\n                futile.logger::appender.console(),\n                'ROOT'\n                )\n        }\n        return(invisible(NULL))\n    }\n\n    ## log == TRUE\n    if (!isNamespaceLoaded(\"futile.logger\"))\n        tryCatch({\n            loadNamespace(\"futile.logger\")\n        }, error=function(err) {\n            msg <- \"logging requires the 'futile.logger' package\"\n            stop(conditionMessage(err), msg)\n        })\n    futile.logger::flog.appender(.log_buffer_append, 'ROOT')\n    futile.logger::flog.threshold(threshold)\n    futile.logger::flog.info(\"loading futile.logger package\")\n}\n\n.log_warn <- function(log, fmt, ...)\n{\n    if (log)\n        futile.logger::flog.warn(fmt, ...)\n}\n\n.log_error <- function(log, fmt, ...)\n{\n    if (log)\n        futile.logger::flog.error(fmt, ...)\n}\n\n## logging buffer\n\n.log_buffer_init <- function()\n{\n    .log_data[[\"buffer\"]] <- character()\n}\n\n.log_buffer_append <- function(line)\n{\n    .log_data[[\"buffer\"]] <- c(.log_data[[\"buffer\"]], line)\n}\n\n.log_buffer_get <- function()\n{\n    .log_data[[\"buffer\"]]\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### logs and results printed in the manager process\n###\n\n.bpwriteLog <- function(con, d) {\n    .log_internal <- function() {\n        message(\n            \"############### LOG OUTPUT ###############\\n\",\n            \"Task: \", d$value$tag,\n            \"\\nNode: \", d$node,\n            \"\\nTimestamp: \", Sys.time(),\n            \"\\nSuccess: \", d$value$success,\n            \"\\n\\nTask duration:\\n\",\n            paste(capture.output(d$value$time), collapse=\"\\n\"),\n            \"\\n\\nMemory used:\\n\", paste(capture.output(gc()), collapse=\"\\n\"),\n            \"\\n\\nLog messages:\\n\",\n            paste(trimws(d$value$log), collapse=\"\\n\"),\n            \"\\n\\nstderr and stdout:\\n\",\n            if (!is.null(d$value$sout))\n                paste(noquote(d$value$sout), collapse=\"\\n\")\n        )\n    }\n    if (!is.null(con)) {\n        on.exit({\n            sink(NULL, type = \"message\")\n            sink(NULL, type = \"output\")\n        })\n        sink(con, type = \"message\")\n        sink(con, type = \"output\")\n    }\n    .log_internal()\n}\n",
        "progress.R": "### =========================================================================\n### progress bar \n### -------------------------------------------------------------------------\n\n.progress <- function(style = 3, active = TRUE, iterate = FALSE, ...) {\n\n    if (active) {\n        ntasks <- 0L\n        if (iterate) {\n            list(init = function(x) {\n                message(\"iteration: \", appendLF=FALSE)\n            }, step = function(n) {\n                ntasks <<- ntasks + 1L\n                erase <- paste(rep(\"\\b\", ceiling(log10(ntasks))), collapse=\"\")\n                message(erase, ntasks, appendLF = FALSE)\n            }, term = function() {\n                message()               # new line\n            })\n        } else {\n            ## derived from plyr::progress_text()\n            txt <- NULL\n            max <- 0\n            list(init = function(x) {\n                txt <<- txtProgressBar(max = x, style = style, ...)\n                setTxtProgressBar(txt, 0)\n                max <<- x\n            }, step = function(n) {\n                ntasks <<- ntasks + n\n                setTxtProgressBar(txt, ntasks)\n                if (ntasks == max) cat(\"\\n\")\n            }, term = function() {\n                close(txt)\n            })\n        }\n    } else {\n        list(\n            init = function(x) NULL,\n            step = function(n) NULL,\n            term = function() NULL\n        )\n    }\n}\n",
        "prototype.R": "## There are three timeouts involved\n##\n## - establishing a socket connection, from getOption(\"timeout\"),\n##   default 60 seconds\n## - duration of allowed computations, from argument `timeout=` to\n##   *Param(), default WORKER_TIMEOUT (infinite)\n## - duration of idle connections (no activity from the worker\n##   socket), default IDLE_TIMEOUT (30 days) beause (a) this is the\n##   snow behavior and (b) sockets appear to sometimes segfault & lead\n##   to PROTECTion imbalance if an attempt is made to write to a\n##   terminated socket.\n\n## Timeout for individual worker tasks\nWORKER_TIMEOUT <- NA_integer_\n\n## Timeout for socket inactivity\nIDLE_TIMEOUT <- 2592000L # 60 * 60 * 24 * 30 = 30 day; consistent w/ parallel\n\n## Maximum number of tasks, e.g., when using progress bar\nTASKS_MAXIMUM <- .Machine$integer.max\n\n.prototype_update <-\n    function(prototype, ...)\n{\n    args <- list(...)\n    stopifnot(\n        all(names(args) %in% names(prototype))\n    )\n    prototype[names(args)] <- unname(args)\n    prototype\n}\n",
        "reducer.R": ".Reducer <- setRefClass(\n    \"Reducer\",\n    fields = list(\n        result = \"ANY\",\n        total = \"numeric\",\n        reduced.num = \"numeric\",\n        reduced.index = \"numeric\",\n        value.cache = \"environment\",\n        redo.index = \"numeric\"\n    )\n)\n\n.LapplyReducer <- setRefClass(\n    \"LapplyReducer\",\n    fields = list(\n        exists.error = \"logical\"\n    ),\n    contains = \"Reducer\"\n)\n\n.IterateReducer <- setRefClass(\n    \"IterateReducer\",\n    fields = list(\n        REDUCE = \"ANY\",\n        errors = \"environment\",\n        reduce.in.order = \"logical\",\n        appending.offset = \"numeric\",\n        init.missing = \"logical\",\n        REDUCE.missing = \"logical\"\n        ),\n    contains = \"Reducer\"\n)\n\n\nsetGeneric(\".map_index\", function(reducer, idx){\n    standardGeneric(\".map_index\")\n})\n\nsetGeneric(\".reducer_add\", function(reducer, idx, values){\n    standardGeneric(\".reducer_add\")\n})\n\nsetGeneric(\".reducer_reduce\", function(reducer, idx){\n    standardGeneric(\".reducer_reduce\")\n})\n\nsetGeneric(\".reducer_ok\", function(reducer){\n    standardGeneric(\".reducer_ok\")\n})\n\nsetGeneric(\".reducer_complete\", function(reducer){\n    standardGeneric(\".reducer_complete\")\n})\n\nsetGeneric(\".reducer_value\", function(reducer){\n    standardGeneric(\".reducer_value\")\n})\n\n#########################\n## Reducer\n#########################\nsetMethod(\".reducer_complete\", signature = \"Reducer\",\n          function(reducer)\n{\n    reducer$total == reducer$reduced.num\n})\n\nsetMethod(\".reducer_ok\", signature = \"Reducer\",\n    function(reducer)\n{\n    length(reducer$errors) == 0L\n})\n#########################\n## LapplyReducer\n#########################\n.lapplyReducer <-\n    function(ntotal, reducer = NULL)\n{\n    if (is.null(reducer)) {\n        result <- rep(list(.error_unevaluated()), ntotal)\n        redo.index <- seq_len(ntotal)\n    } else {\n        result <- reducer$result\n        redo.index <- which(!bpok(result))\n        ntotal <- length(redo.index)\n    }\n\n    .LapplyReducer(\n        result = result,\n        total = ntotal,\n        reduced.index = 1L,\n        reduced.num = 0L,\n        value.cache = new.env(parent = emptyenv()),\n        redo.index = redo.index,\n        exists.error = FALSE\n    )\n}\n\nsetMethod(\".reducer_add\", signature = \"LapplyReducer\",\n    function(reducer, idx, values)\n{\n    reducer$value.cache[[as.character(idx)]] <- values\n\n    while (.reducer_reduce(reducer, reducer$reduced.index)) {}\n\n    if(!all(bpok(values)))\n        reducer$exists.error <- TRUE\n\n    reducer\n})\n\nsetMethod(\".reducer_reduce\", signature = \"LapplyReducer\",\n    function(reducer, idx)\n{\n    ## obtain the cached value\n    idx <- as.character(idx)\n    if (!exists(idx, envir = reducer$value.cache))\n        return(FALSE)\n    values <- reducer$value.cache[[idx]]\n    rm(list = idx, envir = reducer$value.cache)\n\n    ## Find the true index of the reduced value in the result\n    idx <- reducer$redo.index[reducer$reduced.num + 1L]\n    reducer$result[idx - 1L + seq_along(values)] <- values\n\n    reducer$reduced.index <- reducer$reduced.index + 1L\n    reducer$reduced.num <- reducer$reduced.num + length(values)\n    TRUE\n})\n\nsetMethod(\".reducer_value\", signature = \"LapplyReducer\",\n    function(reducer)\n{\n    reducer$result\n})\n\nsetMethod(\".reducer_ok\", signature = \"LapplyReducer\",\n    function(reducer)\n{\n    !reducer$exists.error\n})\n\n#########################\n## IterateReducer\n#########################\n.redo_index_iterate <-\n    function(reducer)\n{\n    if (is.null(reducer))\n        return(integer())\n    finished_idx <- as.integer(names(reducer$value.cache))\n    missing_idx <- setdiff(seq_len(reducer$total), finished_idx)\n    c(missing_idx, as.integer(names(reducer$errors)))\n}\n\n.iterateReducer <-\n    function(REDUCE, init, reduce.in.order=FALSE, reducer = NULL)\n{\n    if (is.null(reducer)) {\n        if (missing(init)){\n            result <- NULL\n            init.missing <- TRUE\n        } else {\n            result <- init\n            init.missing <- FALSE\n        }\n        if (missing(REDUCE)) {\n            REDUCE <- NULL\n            REDUCE.missing <- TRUE\n        } else {\n            REDUCE.missing <- FALSE\n        }\n        .IterateReducer(\n            result = result,\n            total = 0L,\n            reduced.num = 0L,\n            reduced.index = 1L,\n            value.cache = new.env(parent = emptyenv()),\n            redo.index = integer(),\n            REDUCE = REDUCE,\n            errors = new.env(parent = emptyenv()),\n            reduce.in.order = reduce.in.order,\n            appending.offset = 0L,\n            init.missing = init.missing,\n            REDUCE.missing = REDUCE.missing\n        )\n    } else {\n        reducer <- reducer$copy()\n        reducer$appending.offset <- reducer$total\n        reducer$redo.index <- .redo_index_iterate(reducer)\n        reducer$value.cache <- as.environment(\n            as.list(reducer$value.cache, all.names=TRUE)\n            )\n        reducer$errors <- as.environment(\n            as.list(reducer$errors, all.names=TRUE)\n        )\n        reducer\n    }\n}\n\nsetMethod(\".map_index\", signature = \"IterateReducer\",\n    function(reducer, idx)\n{\n    redo.index <- reducer$redo.index\n    if (idx <= length(redo.index))\n        idx <- redo.index[idx]\n    else\n        idx <- idx - length(redo.index) + reducer$appending.offset\n    idx\n})\n\nsetMethod(\".reducer_add\", signature = \"IterateReducer\",\n    function(reducer, idx, values)\n{\n    reduce.in.order <- reducer$reduce.in.order\n    idx <- as.character(.map_index(reducer, idx))\n    value <- values[[1]]\n    if (.bpeltok(value)) {\n        if (exists(idx, envir = reducer$errors))\n            rm(list = idx, envir = reducer$errors)\n    } else {\n        reducer$errors[[idx]] <- idx\n    }\n    reducer$value.cache[[idx]] <- value\n\n    reducer$total <- max(reducer$total, as.numeric(idx))\n\n    if (reduce.in.order)\n        while (.reducer_reduce(reducer, reducer$reduced.index)) {}\n    else\n        .reducer_reduce(reducer, idx)\n\n    reducer\n})\n\nsetMethod(\".reducer_reduce\", signature = \"IterateReducer\",\n    function(reducer, idx)\n{\n    idx <- as.character(idx)\n    if (!exists(idx, envir = reducer$value.cache)) {\n        return(FALSE)\n    }\n\n    ## stop reducing when reduce.in.order == TRUE\n    ## and we have a pending error\n    if (!.reducer_ok(reducer) && reducer$reduce.in.order)\n        return(FALSE)\n    value <- reducer$value.cache[[idx]]\n    ## Do not reduce the erroneous result\n    if (!.bpeltok(value))\n        return(FALSE)\n    if (!reducer$REDUCE.missing) {\n        if (reducer$init.missing && (reducer$reduced.num == 0)) {\n            reducer$result <- value\n        } else {\n            reducer$result <- reducer$REDUCE(reducer$result, value)\n        }\n        ## DO NOT REMOVE, only set to NULL to keep track\n        ## of the finished results\n        reducer$value.cache[[idx]] <- NULL\n    }\n    reducer$reduced.num <- reducer$reduced.num + 1L\n    reducer$reduced.index <- reducer$reduced.index + 1L\n    TRUE\n})\n\nsetMethod(\".reducer_value\", signature = \"IterateReducer\",\n    function(reducer)\n{\n    value.cache <- reducer$value.cache\n    if (!reducer$REDUCE.missing) {\n        res <- reducer$result\n    } else {\n        ## remove the index of the meta elements and errors\n        idx <- names(value.cache)\n        idx <- setdiff(idx, names(reducer$errors))\n        res <- rep(list(NULL), reducer$total)\n        for (i in idx)\n            res[[as.integer(i)]] <- value.cache[[i]]\n    }\n    ## Attach the errors as an attribute\n    if (!.reducer_ok(reducer) || !.reducer_complete(reducer)) {\n        ## cannot attach attribute to NULL\n        if (is.null(res)) res <- list()\n        idx <- .redo_index_iterate(reducer)\n        errors <- rep(list(.error_unevaluated()), length(idx))\n        names(errors) <- as.character(idx)\n        for (i in names(reducer$errors))\n            errors[[i]] <- value.cache[[i]]\n        attr(res, \"errors\") <- errors\n    }\n    res\n})\n\n\n",
        "register.R": "### =========================================================================\n### .registry object\n### -------------------------------------------------------------------------\n\n.registry <- setRefClass(\".BiocParallelRegistry\",\n    fields=list(\n        bpparams = \"list\"),\n    methods=list(\n        register = function(BPPARAM, default = TRUE) {\n            BPPARAM <- eval(BPPARAM)\n            if ((!length(BPPARAM) == 1) || !is(BPPARAM, \"BiocParallelParam\"))\n                stop(\"'BPPARAM' must be a 'BiocParallelParam' instance\")\n            .self$bpparams[[class(BPPARAM)]] <- BPPARAM\n            if (default) {\n                idx <- match(class(BPPARAM), names(.self$bpparams))\n                .self$bpparams <- c(.self$bpparams[idx], .self$bpparams[-idx])\n            }\n            invisible(registered())\n        },\n        registered = function(bpparamClass) {\n            if (missing(bpparamClass))\n                .self$bpparams\n            else .self$bpparams[[bpparamClass]]\n        })\n)$new()  # Singleton\n\n.register <- .registry$register\n\n.registered <- .registry$registered\n\n.registry_init <- function() {\n    multicore <- .defaultWorkers() > 1L\n    tryCatch({\n        if ((.Platform$OS.type == \"windows\") && multicore) {\n            .register(getOption(\n                \"SnowParam\",\n                SnowParam()\n            ), TRUE)\n            .register(getOption(\"SerialParam\", SerialParam()), FALSE)\n        } else if (multicore) {\n            ## linux / mac\n            .register(getOption(\n                \"MulticoreParam\",\n                MulticoreParam()\n            ), TRUE)\n            .register(getOption(\n                \"SnowParam\",\n                SnowParam()\n            ), FALSE)\n            .register(getOption(\"SerialParam\", SerialParam()), FALSE)\n        } else {\n            .register(getOption(\"SerialParam\", SerialParam()), TRUE)\n        }\n    }, error=function(err) {\n        message(\n            \"'BiocParallel' did not register default BiocParallelParam:\\n\",\n            \"  \", conditionMessage(err)\n        )\n        NULL\n    })\n}\n\nregister <- function(BPPARAM, default = TRUE) {\n    if (length(.registry$bpparams) == 0L)\n        .registry_init()\n    .register(BPPARAM, default = default)\n}\n\nregistered <- function(bpparamClass) {\n    if (length(.registry$bpparams) == 0L)\n        .registry_init()\n    .registered(bpparamClass)\n}\n\nbpparam <- function(bpparamClass) {\n    if (missing(bpparamClass))\n        bpparamClass <- names(registered())[1]\n    default <- registered()[[bpparamClass]]\n    result <- getOption(bpparamClass, default)\n    if (is.null(result))\n        stop(\"BPPARAM '\", bpparamClass,\n             \"' not registered() or in names(options())\")\n    result\n}\n",
        "rng.R": "## .rng_get_generator(): get the current generator kind and seed\n.rng_get_generator <-\n    function()\n{\n    seed <-\n        if (exists(\".Random.seed\", envir = .GlobalEnv, inherits = FALSE)) {\n            get(\".Random.seed\", envir = .GlobalEnv, inherits = FALSE)\n        } else NULL\n    kind <- RNGkind()\n\n    list(kind = kind, seed = seed)\n}\n## .rng_reset_generator(): reset the generator to a state returned by\n## .rng_get_generator()\n.rng_reset_generator <-\n    function(kind, seed)\n{\n    ## Setting RNGkind() changes the seed, so restore the original\n    ## seed after restoring the kind\n    RNGkind(kind[[1]])\n    if (is.null(seed)) {\n        rm(.Random.seed, envir = .GlobalEnv)\n    } else {\n        assign(\".Random.seed\", seed, envir = .GlobalEnv)\n    }\n\n    list(kind = kind, seed = seed)\n}\n\n## .rng_init_stream(): initialize the generator to a new kind,\n## optionally using `set.seed()` to set the seed for the the\n## generator.\n.rng_init_stream <-\n    function(seed)\n{\n    state <- .rng_get_generator()\n    on.exit(.rng_reset_generator(state$kind, state$seed))\n\n    ## coerces seed to appropriate format for RNGkind; NULL seed (from\n    ## bpRNGseed()) uses the global random number stream.\n    if (!is.null(seed)) {\n        RNGkind(\"default\", \"default\", \"default\")\n        set.seed(seed)\n\n        ## change kind\n        kind <- \"L'Ecuyer-CMRG\"\n        RNGkind(kind)\n\n        ## .Random.seed always exists after RNGkind()\n        seed <- get(\".Random.seed\", envir = .GlobalEnv, inherits = FALSE)\n    } else {\n        .rng_internal_stream$set()\n        seed <- get(\".Random.seed\", envir = .GlobalEnv, inherits = FALSE)\n        ## advance internal stream by 1\n        runif(1)\n        .rng_internal_stream$reset()\n    }\n\n    seed\n}\n\n## .rng_next_stream(): return the next stream for a parallel job\n.rng_next_stream <-\n    function(seed)\n{\n    ## `nextRNGStream()` does not require that the current stream is\n    ## L'Ecuyer-CMRG\n    if (is.null(seed))\n        seed <- .rng_init_stream(seed)\n    nextRNGStream(seed)\n}\n\n.rng_next_substream <-\n    function(seed)\n{\n    if (is.null(seed))\n        seed <- .rng_init_stream(seed)\n    nextRNGSubStream(seed)\n}\n\n## iterate the seed stream n times\n.rng_iterate_substream <-\n    function(seed, n)\n{\n    for (k in seq_len(n))\n        seed <- .rng_next_substream(seed)\n    seed\n}\n\n## a random number stream independent of the stream used by R. Use for\n## port and other 'internal' assignments without changing the random\n## number sequence of users.\n.rng_internal_stream <- local({\n    state <- .rng_get_generator()\n    RNGkind(\"L'Ecuyer-CMRG\") # sets .Random.seed to non-NULL value\n    internal_seed <- .Random.seed\n    .rng_reset_generator(state$kind, state$seed)\n\n    list(set = function() {\n        state <<- .rng_get_generator()\n        internal_seed <<- .rng_reset_generator(\"L'Ecuyer-CMRG\", internal_seed)\n    }, reset = function() {\n        internal_seed <<- .rng_get_generator()$seed\n        .rng_reset_generator(state$kind, state$seed)\n    })\n})\n",
        "utilities.R": ".splitIndices <- function (nx, tasks)\n{\n    ## derived from parallel\n    i <- seq_len(nx)\n    if (nx == 0L)\n        list()\n    else if (tasks <= 1L || nx == 1L)  # allow nx, nc == 0\n        list(i)\n    else {\n        fuzz <- min((nx - 1L)/1000, 0.4 * nx / tasks)\n        breaks <- seq(1 - fuzz, nx + fuzz, length.out = tasks + 1L)\n        si <- structure(split(i, cut(i, breaks)), names = NULL)\n        si[sapply(si, length) != 0]\n    }\n}\n\n.ntask <-\n    function(X, workers, tasks)\n{\n    if (is.na(tasks)) {\n        length(X)\n    } else if (tasks == 0L) {\n        workers\n    } else {\n        min(length(X), tasks)\n    }\n}\n\n.splitX <-\n    function(X, workers, tasks)\n{\n    tasks <- .ntask(X, workers, tasks)\n    idx <- .splitIndices(length(X), tasks)\n    relist(X, idx)\n}\n\n.redo_index <-\n    function(X, BPREDO)\n{\n    if (length(BPREDO)) {\n        if (length(BPREDO) != length(X))\n            stop(\"'length(BPREDO)' must equal 'length(X)'\")\n        idx <- which(!bpok(BPREDO))\n        if (!length(idx))\n            stop(\"no previous error in 'BPREDO'\")\n        idx\n    } else {\n        seq_along(X)\n    }\n}\n\n## re-apply names on X of lapply(X, FUN) to the return value\n.rename <-\n    function(results, X)\n{\n    names(results) <- names(X)\n    results\n}\n\n.simplify <-\n    function(results, SIMPLIFY=FALSE)\n{\n    if (SIMPLIFY && length(results))\n        results <- simplify2array(results)\n    results\n}\n\n.prettyPath <- function(tag, filepath)\n{\n    wd <- options('width')[[1]] - nchar(tag) - 6\n    if (length(filepath) == 0 || is.na(filepath))\n        return(sprintf(\"%s: %s\", tag, NA_character_))\n    if (0L == length(filepath) || nchar(filepath) < wd)\n        return(sprintf(\"%s: %s\", tag, filepath))\n    bname <- basename(filepath)\n    wd1 <- wd - nchar(bname)\n    dname <- substr(dirname(filepath), 1, wd1)\n    sprintf(\"%s: %s...%s%s\",\n            tag, dname, .Platform$file.sep, bname)\n}\n\n.getDotsForMapply <-\n    function(...)\n{\n    ddd <- list(...)\n    if (!length(ddd))\n        return(list(list()))\n    len <- vapply(ddd, length, integer(1L))\n    if (!all(len == len[1L])) {\n        max.len <- max(len)\n        if (max.len && any(len == 0L))\n            stop(\"zero-length and non-zero length inputs cannot be mixed\")\n        if (any(max.len %% len))\n            warning(\"longer argument not a multiple of length of vector\")\n        ddd <- lapply(ddd, rep_len, length.out=max.len)\n    }\n\n    ddd\n}\n\n.dir_valid_rw <-\n    function(x)\n{\n    all(file.access(x, 6L) == 0L)\n}\n\n.warning <- function(...) {\n    msg <- paste(\n        strwrap(paste0(\"\\n\", ...), indent = 2, exdent = 2), collapse=\"\\n\"\n    )\n    warning(msg, call. = FALSE)\n}\n\n.stop <- function(...) {\n    msg <- paste(\n        strwrap(paste0(\"\\n\", ...), indent = 2, exdent = 2), collapse=\"\\n\"\n    )\n    stop(msg, call. = FALSE)\n}\n\n## batchtools signals no timeout with 'Inf', rather than NA; do not\n## implement as bptimeout() method because NA is appropriate in other\n## contexts, e.g., when 'show()'ing param.\n.batch_bptimeout <-\n    function(BPPARAM)\n{\n    timeout <- bptimeout(BPPARAM)\n    if (identical(timeout, NA_integer_))\n        timeout <- Inf\n    timeout\n}\n",
        "worker-number.R": ".workerEnvironmentVariable <-\n    function(variable, default = NA_integer_)\n{\n    result <- withCallingHandlers({\n        value <- Sys.getenv(variable, default)\n        as.integer(value)\n    }, warning = function(w) {\n        txt <- sprintf(\n            paste0(\n                \"Trying to coercing the environment variable '%s' to an \",\n                \"integer caused a warning. The value of the environment \",\n                \"variable was '%s'. The warning was: %s\"\n            ),\n            variable, value, conditionMessage(w)\n        )\n        .warning(txt)\n        invokeRestart(\"muffleWarning\")\n    })\n\n    if (!is.na(result) && (result <= 0L)) {\n        txt <- sprintf(\n            \"The environment variable '%s' must be > 0. The value was '%d'.\",\n            variable, result\n        )\n        .stop(txt)\n    }\n\n    result\n}\n\n.defaultWorkers <-\n    function()\n{\n    ## assign default cores\n    ## environment variables; least to most compelling\n    result <- .workerEnvironmentVariable(\"R_PARALLELLY_AVAILABLECORES_FALLBACK\")\n    max_number <- .workerEnvironmentVariable(\"BIOCPARALLEL_WORKER_MAX\", result)\n    default_number <-\n        .workerEnvironmentVariable(\"BIOCPARALLEL_WORKER_NUMBER\", result)\n    if (is.na(max_number)) {\n        result <- default_number\n    } else {\n        result <- min(max_number, default_number, na.rm = TRUE)\n    }\n\n    ## fall back to detectCores() if necessary\n    if (is.na(result)) {\n        result <- parallel::detectCores()\n        if (is.na(result))\n            result <- 1L\n        result <- max(1L, result - 2L)\n    }\n\n    ## respect 'mc.cores', overriding env. variables an detectCores()\n    result <- getOption(\"mc.cores\", result)\n\n    ## coerce to integer; check for valid value\n    tryCatch({\n        result <- as.integer(result)\n        if ( length(result) != 1L || is.na(result) || result < 1L )\n            stop(\"number of cores must be a non-negative integer\")\n    }, error = function(e) {\n        msg <- paste0(\n            conditionMessage(e), \". \",\n            \"Did you mis-specify R_PARALLELLY_AVAILABLECORES_FALLBACK, \",\n            \"BIOCPARALLEL_WORKER_NUMBER, or options('mc.cores')?\"\n        )\n        .stop(msg)\n    })\n\n    ## override user settings by build-system configurations\n    if (identical(Sys.getenv(\"IS_BIOC_BUILD_MACHINE\"), \"true\"))\n        result <- min(result, 4L)\n\n    ## from R-ints.texi\n    ## @item _R_CHECK_LIMIT_CORES_\n    ## If set, check the usage of too many cores in package @pkg{parallel}.  If\n    ## set to @samp{warn} gives a warning, to @samp{false} or @samp{FALSE} the\n    ## check is skipped, and any other non-empty value gives an error when more\n    ## than 2 children are spawned.\n    ## Default: unset (but @samp{TRUE} for CRAN submission checks).\n    check_limit_cores <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", NA_character_)\n    check_limit_cores_is_set <-\n        !is.na(check_limit_cores) &&\n        !identical(toupper(check_limit_cores), \"FALSE\")\n    if (check_limit_cores_is_set)\n        result <- min(result, 2L)\n\n    result\n}\n\n.enforceWorkers <-\n    function(workers, type = NULL)\n{\n    ## Ensure that user 'workers' does not exceed hard limits; most-\n    ## to least stringent. Usually on build systems\n\n    ## R CMD check limit (though it applies outside check, too...\n    check_limit_cores <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", NA_character_)\n    check_limit_cores_is_set <-\n        !is.na(check_limit_cores) &&\n        !identical(toupper(check_limit_cores), \"FALSE\")\n    if (workers > 2L && check_limit_cores_is_set) {\n        if (!identical(check_limit_cores, \"warn\")) {\n            .stop(\n                \"_R_CHECK_LIMIT_CORES_' environment variable detected, \",\n                \"BiocParallel workers must be <= 2 was (\", workers, \")\"\n            )\n        }\n        .warning(\n            \"'_R_CHECK_LIMIT_CORES_' environment variable detected, \",\n            \"setting BiocParallel workers to 2 (was \", workers, \")\"\n        )\n        workers <- 2L\n    }\n\n    ## Bioconductor build system\n    test <-\n        (workers > 4L) && identical(Sys.getenv(\"IS_BIOC_BUILD_MACHINE\"), \"true\")\n    if (test) {\n        .warning(\n            \"'IS_BIOC_BUILD_MACHINE' environment variable detected, \",\n            \"setting BiocParallel workers to 4 (was \", workers, \")\"\n        )\n        workers <- 4L\n    }\n\n    worker_max <- .workerEnvironmentVariable(\"BIOCPARALLEL_WORKER_MAX\")\n    if (!is.na(worker_max) && workers > worker_max) {\n        .warning(\n            \"'BIOCPARALLEL_WORKER_MAX' environment variable detected, \",\n            \"setting BiocParallel workers to \", worker_max, \" \",\n            \"(was \", workers, \")\"\n        )\n        workers <- worker_max\n    }\n\n    ## limit on number of available sockets\n    if (!is.null(type) && workers > .snowCoresMax(type)) {\n        max <- .snowCoresMax(type)\n        .warning(\n            \"worker number limited by available socket connections, \",\n            \"setting BiocParallel workers to \", max, \" (was \", workers, \")\"\n        )\n        workers <- max\n    }\n\n    workers\n}\n",
        "worker.R": "### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Utils\n\n## Extract static and dynamic data from a task Return NULL if no\n## static data can be extracted\n.task_const <-\n    function(value)\n{\n    ## Supports EXEC task only\n    if (value$type != \"EXEC\")\n        return(NULL)\n    if (isTRUE(value$dynamic.only))\n        return(NULL)\n\n    if (value$static.fun)\n        fun <- value$data$fun\n    else\n        fun <- NULL\n\n    fullArgNames <- names(value$data$args)\n    if (all(value$static.args %in% fullArgNames)) {\n        args <- value$data$args[value$static.args]\n        if (!length(args)) args <- NULL\n    } else {\n        args <- NULL\n    }\n\n    if (!is.null(fun) || !is.null(args))\n        list(fun = fun, args = args, fullArgNames = fullArgNames)\n    else\n        NULL\n}\n\n## Extract the dynamic part from a task\n.task_dynamic <-\n    function(value)\n{\n    ## Supports EXEC task only\n    if (value$type != \"EXEC\")\n        return(value)\n\n    if (value$static.fun)\n        value$data$fun <- TRUE\n    if (length(value$static.args))\n        value$data$args[value$static.args] <- NULL\n\n    if (value$static.fun || length(value$static.args))\n        value$dynamic.only <- TRUE\n\n    value\n}\n\n## Recreate the task from the dynamic and static parts of the task\n## It is safe to call the function if the task is complete\n## (Not extracted by `.task_dynamic`) or `static_Data` is NULL\n.task_remake <-\n    function(value, static_data = NULL)\n{\n    if (is.null(static_data))\n        return(value)\n    if (value$type != \"EXEC\")\n        return(value)\n    if (!isTRUE(value$dynamic.only))\n        return(value)\n\n    if (value$static.fun)\n        value$data$fun <- static_data$fun\n    if (length(value$static.args)) {\n        value$data$args <- c(value$data$args, static_data$args)\n        value$data$args <- value$data$args[static_data$fullArgNames]\n    }\n    value$dynamic.only <- NULL\n    value\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Worker commands\n\n### Support for SOCK, MPI and FORK connections.\n### Derived from snow version 0.3-13 by Luke Tierney\n### Derived from parallel version 2.16.0 by R Core Team\n\n.EXEC <-\n    function(tag, fun, args, static.fun = FALSE, static.args = NULL)\n{\n    list(\n        type = \"EXEC\",\n        data = list(tag = tag, fun = fun, args = args),\n        static.fun = static.fun,\n        static.args = static.args\n    )\n}\n\n.VALUE <-\n    function(tag, value, success, time, log, sout)\n{\n    list(\n        type = \"VALUE\",\n        tag = tag, value = value, success = success, time = time,\n        log = log, sout = sout\n    )\n}\n\n.DONE <-\n    function()\n{\n    list(type = \"DONE\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Worker options and function to run the task\n.workerOptions <-\n    function(\n        log = FALSE,\n        threshold = \"INFO\",\n        stop.on.error = TRUE,\n        as.error = TRUE,\n        timeout = WORKER_TIMEOUT,\n        exportglobals = TRUE,\n        force.GC = FALSE)\n{\n    force(log)\n    force(threshold)\n    force(stop.on.error)\n    force(as.error)\n    force(timeout)\n    force(force.GC)\n\n    if (exportglobals) {\n        blocklist <- c(\n            \"askpass\", \"asksecret\", \"buildtools.check\",\n            \"buildtools.with\", \"pager\", \"plumber.swagger.url\",\n            \"profvis.print\", \"restart\", \"reticulate.repl.hook\",\n            \"reticulate.repl.initialize\", \"reticulate.repl.teardown\",\n            \"shiny.launch.browser\", \"terminal.manager\", \"error\",\n            \"topLevelEnvironment\", \"connectionObserver\"\n        )\n        globalOptions <- base::options()\n        globalOptions <- globalOptions[!names(globalOptions) %in% blocklist]\n    } else {\n        globalOptions <- NULL\n    }\n\n    list(\n        log = log,\n        threshold = threshold,\n        stop.on.error = stop.on.error,\n        as.error = as.error,\n        timeout = timeout,\n        force.GC = force.GC,\n        globalOptions = globalOptions\n    )\n}\n\n.composeTry <-\n    function(FUN, OPTIONS, SEED)\n{\n    FUN <- match.fun(FUN)\n    ERROR_OCCURRED <- FALSE\n    ## use `ERROR_CALL_DEPTH` to trim call stack. default: show all\n    ERROR_CALL_DEPTH <- -.Machine$integer.max\n    UNEVALUATED <- .error_unevaluated() # singleton\n\n    log <- OPTIONS$log\n    stop.on.error <- OPTIONS$stop.on.error\n    as.error <- OPTIONS$as.error\n    timeout <- OPTIONS$timeout\n    force.GC <- OPTIONS$force.GC\n    globalOptions <- OPTIONS$globalOptions\n\n    handle_warning <- function(w) {\n        .log_warn(log, \"%s\", w)\n        w       # FIXME: muffleWarning; don't rely on capture.output()\n    }\n\n    handle_error <- function(e) {\n        ERROR_OCCURRED <<- TRUE\n        .log_error(log, \"%s\", e)\n        call <- rev(tail(sys.calls(), -ERROR_CALL_DEPTH))\n        .error_remote(e, call)\n    }\n\n    if (!is.null(SEED))\n        SEED <- .rng_reset_generator(\"L'Ecuyer-CMRG\", SEED)$seed\n\n    function(...) {\n        if (!identical(timeout, WORKER_TIMEOUT)) {\n            setTimeLimit(timeout, timeout, TRUE)\n            on.exit(setTimeLimit(Inf, Inf, FALSE))\n        }\n\n        if (!is.null(globalOptions))\n            base::options(globalOptions)\n\n        if (stop.on.error && ERROR_OCCURRED) {\n            UNEVALUATED\n        } else {\n            .rng_reset_generator(\"L'Ecuyer-CMRG\", SEED)\n\n            ## capture warnings and errors. Both are initially handled\n            ## by `withCallingHandlers()`.\n            ##\n            ## 'error' conditions are logged (via `handle_error()`),\n            ## annotated, and then re-signalled via `stop()`.  The\n            ## condition needs to be handled first by\n            ## `withCallingHandlers()` so that the full call stack to\n            ## the error can be recovered.  The annotated condition\n            ## needs to be resignalled so that it can be returned as\n            ## 'output'; but the condition needs to be silenced by the\n            ## outer `tryCatch()`.\n            ##\n            ## 'warning' conditions are logged (via\n            ## `handle_warning()`). The handler returns the original\n            ## condition, and the 'muffleWarning' handler is invoked\n            ## somewhere above this point.\n            output <- tryCatch({\n                withCallingHandlers({\n                    ## emulate call depth from 'inside' FUN, to\n                    ## account for frames from tryCatch,\n                    ## withCallingHandlers\n                    ERROR_CALL_DEPTH <<- (\\() sys.nframe() - 1L)()\n                    FUN(...)\n                }, error = function(e) {\n                    annotated_condition <- handle_error(e)\n                    stop(annotated_condition)\n                }, warning = handle_warning)\n            }, error = identity)\n\n            ## Trigger garbage collection to cut down on memory usage within\n            ## each worker in shared memory contexts. Otherwise, each worker is\n            ## liable to think the entire heap is available (leading to each\n            ## worker trying to fill said heap, causing R to exhaust memory).\n            if (force.GC)\n                gc(verbose=FALSE, full=FALSE)\n\n            SEED <<- .rng_next_substream(SEED)\n\n            output\n        }\n    }\n}\n\n.workerLapply_impl <-\n    function(X, FUN, ARGS, OPTIONS, BPRNGSEED,\n             GLOBALS = NULL, PACKAGES = NULL)\n{\n    state <- .rng_get_generator()\n    on.exit(.rng_reset_generator(state$kind, state$seed))\n\n    ## FUN is not compiled when using MulticoreParam\n    FUN <- compiler::cmpfun(FUN)\n\n    if (!is.null(OPTIONS$globalOptions)) {\n        oldOptions <- base::options()\n        on.exit(base::options(oldOptions), add = TRUE)\n    }\n\n    ## Set log\n    .log_load(OPTIONS$log, OPTIONS$threshold)\n\n    for (pkg in PACKAGES) {\n        suppressPackageStartupMessages(library(pkg, character.only = TRUE))\n    }\n    ## Add variables to the global space and remove them afterward\n    ## Recover the replaced variables at the end if necessary\n    replaced_variables <- new.env(parent = emptyenv())\n    if (length(GLOBALS)) {\n        for (i in names(GLOBALS)) {\n            if (exists(i, envir = .GlobalEnv))\n                replaced_variables[[i]] <- .GlobalEnv[[i]]\n            assign(i, GLOBALS[[i]], envir = .GlobalEnv)\n        }\n        on.exit({\n            remove(list = names(GLOBALS), envir = .GlobalEnv)\n            for (i in names(replaced_variables))\n                assign(i, replaced_variables[[i]], envir = .GlobalEnv)\n        },\n        add = TRUE)\n    }\n\n    composeFunc <- .composeTry(FUN, OPTIONS, BPRNGSEED)\n    args <- c(list(X = X, FUN = composeFunc), ARGS)\n    do.call(lapply, args)\n}\n\n## reduce the size of the serialization of .workerLapply_impl from\n## 124k to 3k\n.workerLapply <- eval(\n    parse(text = \"function(...) BiocParallel:::.workerLapply_impl(...)\"),\n    envir = getNamespace(\"base\")\n)\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Worker loop.  Error handling is done in .composeTry.\n\n.bpworker_EXEC <-\n    function(msg, sink.sout = TRUE)\n{\n    ## need local handler for worker read/send errors\n    if (sink.sout) {\n        on.exit({\n            sink(NULL, type=\"message\")\n            sink(NULL, type=\"output\")\n            close(file)\n        })\n        file <- rawConnection(raw(), \"r+\")\n        sink(file, type=\"message\")\n        sink(file, type=\"output\")\n    }\n\n    t1 <- proc.time()\n    value <- tryCatch({\n        do.call(msg$data$fun, msg$data$args)\n    }, error=function(e) {\n        ## return as 'list()' because msg$fun has lapply semantics\n        list(.error_worker_comm(e, \"worker evaluation failed\"))\n    })\n    t2 <- proc.time()\n\n    if (sink.sout) {\n        sout <- rawToChar(rawConnectionValue(file))\n        if (!nchar(sout)) sout <- NULL\n    } else {\n        sout <- NULL\n    }\n\n    success <- !(inherits(value, \"bperror\") || !all(bpok(value)))\n    log <- .log_buffer_get()\n    ## Reset the log buffer\n    .log_buffer_init()\n\n    value <- .VALUE(\n        msg$data$tag, value, success, t2 - t1, log, sout\n    )\n}\n\n.bpworker_impl <-\n    function(worker)\n{\n    repeat {\n        tryCatch({\n            msg <- .recv(worker)\n            if (inherits(msg, \"error\"))\n                ## FIXME: try to return error to manager\n                break                   # lost socket connection?\n            if (msg$type == \"DONE\") {\n                .close(worker)\n                break\n            } else if (msg$type == \"EXEC\") {\n                value <- .bpworker_EXEC(msg)\n                .send(worker, value)\n            }\n        }, interrupt = function(e) {\n            NULL\n        })\n    }\n}\n"
    },
    "MatrixGenerics": {
        "MatrixGenerics-package.R": "#' The MatrixGenerics package\n#'\n#' The \\pkg{MatrixGenerics} package defines S4 generic summary statistic\n#' functions that operate on matrix-Like objects.\n#'\n#' @import methods matrixStats\n#'\n#' @name MatrixGenerics-package\n#' @exportClass matrix_OR_array_OR_table_OR_numeric\n#' @aliases class:matrix_OR_array_OR_table_OR_numeric\n#' @aliases matrix_OR_array_OR_table_OR_numeric-class\n#' @aliases matrix_OR_array_OR_table_OR_numeric\n# NOTE: Starting with R 4.0.0 a matrix is an array so no need to explicitly\n# list \"matrix\" as a member of the union.\nsetClassUnion(\"matrix_OR_array_OR_table_OR_numeric\",\n    c(\"array\", \"table\", \"numeric\")\n)\n\n\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n## make_default_method_def()\n##\n\n## All packages listed below must also be listed in the Suggests field.\n## They are expected to implement methods for the generics defined in\n## MatrixGenerics. No need to list matrixStats here as it is special and\n## already imported by default.\n.SUGGESTED_PACKAGES_TO_SEARCH <- c(\n    # Most row/col summarization methods for dgCMatrix objects are defined\n    # in the sparseMatrixStats package but a few of them are defined in the\n    # Matrix package.\n    \"Matrix\",\n    \"sparseMatrixStats\",\n    # The SparseArray package implements SVT_SparseMatrix objects and defines\n    # row/col summarization methods for them.\n    \"SparseArray\",\n    # Most row/col summarization methods for DelayedMatrix objects are defined\n    # in the DelayedMatrixStats package but a few of them are defined in the\n    # DelayedArray package.\n    \"DelayedArray\",\n    \"DelayedMatrixStats\"\n    # ... add more packages in the future\n)\n\n.long_and_fancy_errmsg <- function(short_errmsg, unloaded_pkgs)\n{\n    plural <- length(unloaded_pkgs) > 1L\n    pkgs_to_install <- if (plural) \"...\" else paste0(\"\\\"\", unloaded_pkgs, \"\\\"\")\n    errmsg <- paste0(short_errmsg,  \"\\n  However, the following package\",\n        if (plural) \"s are\" else \" is\",\n        \" likely to contain the missing method\\n  but \",\n        if (plural) \"are\" else \"is\", \" not installed: \",\n        paste0(unloaded_pkgs, collapse=\", \"), \".\\n  \",\n        \"Please install \", if (plural) \"them\" else \"it\",\n        \" (with 'BiocManager::install(\", pkgs_to_install, \")')\",\n        if (plural) \" \" else \"\\n  \", \"and try again.\")\n    if (plural)\n        errmsg <- paste0(errmsg, \"\\n  Alternatively, if you know where \",\n                         \"the missing method is defined, install\\n  only \",\n                         \"that package.\")\n    errmsg\n}\n\n## The purpose of .load_next_suggested_package_to_search() is to support\n## useful fallbacks methods i.e. \"ANY\" methods that implement a fallback\n## mechanism in case dispatch failed to find a suitable method.\n## Try to load installed packages first.\n.load_next_suggested_package_to_search <- function(x, genericName=NULL)\n{\n    if (is.null(genericName)) {\n        ## The ugly and hacky code below tries to find the name of the\n        ## generic. Taken from the implementation of callGeneric().\n        call <- sys.call(sys.parent(1L))\n        .local <- identical(call[[1L]], quote(.local))\n        methodCtxInd <- 1L + if (.local) 1L else 0L\n        callerCtxInd <- methodCtxInd + 1L\n        methodCall <- sys.call(sys.parent(methodCtxInd))\n        if (methods:::fromNextMethod(methodCall))\n            methodCtxInd <- methodCtxInd + 1L\n        methodFrame <- parent.frame(methodCtxInd)\n        genericName <- methods:::getGenericFromCall(methodCall, methodFrame)\n        if (is.null(genericName))\n          stop(\"when 'genericName' is not supplied, \",\n               \".load_next_suggested_package_to_search()\\n  \",\n               \"must be called from within a method body\")\n    }\n    short_errmsg <- paste0(\"Failed to find a \", genericName,\"() method \",\n                           \"for \", class(x)[[1L]], \" objects.\")\n    is_loaded <- vapply(.SUGGESTED_PACKAGES_TO_SEARCH, isNamespaceLoaded,\n                        logical(1))\n    if (all(is_loaded))\n        stop(short_errmsg)\n    unloaded_pkgs <- .SUGGESTED_PACKAGES_TO_SEARCH[!is_loaded]\n    for (pkg in unloaded_pkgs) {\n        if (requireNamespace(pkg, quietly=TRUE)) {\n            ## This is just a hack to refresh the method dispatch cache.\n            ## Calling trace() on the method has the side effect of making\n            ## showMethods(genericName) aware of the method.\n            ## See https://github.com/Bioconductor/MatrixGenerics/pull/16#issuecomment-707516999\n            ## for more information.\n            GENERIC <- match.fun(genericName)\n            suppressMessages(trace(GENERIC, signature=class(x)))\n            suppressMessages(untrace(GENERIC, signature=class(x)))\n            return()\n        }\n    }\n    stop(.long_and_fancy_errmsg(short_errmsg, unloaded_pkgs))\n}\n\n## Not exported (for internal use only).\nmake_default_method_def <- function(genericName)\n{\n    def <- function() { }\n    formals(def) <- formals(match.fun(genericName))\n    e <- expression(MatrixGenerics:::.load_next_suggested_package_to_search(x),\n                    callGeneric())\n    body(def) <- as.call(c(as.name(\"{\"), e))\n    environment(def) <- getNamespace(\"MatrixGenerics\")\n    def\n}\n\n\n## - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n## normarg_center()\n##\n## Check and normalize 'center' argument.\n## Supplied 'center' must be either NULL or a numeric vector of length 'n'\n## or 1. Normalized value is guaranteed to be NULL or a numeric vector of\n## length 'n'.\n\n#' @export\n#' @name internal-helpers\n#' @title Internal helpers\n#' @description Not for end users\n#' @keywords internal utilities\nnormarg_center <- function(center, n, what)\n{\n    if (is.null(center))\n        return(center)\n    stopifnot(is.numeric(center))\n    if (length(center) == 1L)\n        return(rep.int(center, n))\n    if (length(center) != n)\n        stop(\"'center' must be of length '\", what, \"' (\", n, \") or 1\")\n    center\n}\n\n",
        "rowAlls.R": "#' Check if all elements in a row (column) of a matrix-like object are equal to\n#' a value\n#'\n#' Check if all elements in a row (column) of a matrix-like object are equal to\n#' a value.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowAlls\n#'\n#' @templateVar rowName rowAlls\n#' @templateVar colName colAlls\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template valueParameter\n#' @template dimParameter\n#' @template na_rmParameter\n#' @template returnVectorLgl\n#' @template useNamesParameter\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowAlls]{rowAlls}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowAlls]{colAlls}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For checks if \\emph{any} element is equal to a value, see\n#'   \\code{\\link{rowAnys}()}.\n#' \\item \\code{base::\\link{all}()}.\n#' }\n#'\n#' @template standardExamples\nsetGeneric(\"rowAlls\", function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowAlls\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowAlls <- function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowAlls(x, rows = rows, cols = cols, value = value, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowAlls\nsetMethod(\"rowAlls\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowAlls)\n\n#' @export\n#' @rdname rowAlls\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowAlls\", \"ANY\", make_default_method_def(\"rowAlls\"))\n\n\n\n#' @export\n#' @rdname rowAlls\nsetGeneric(\"colAlls\", function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colAlls\"),\n           signature = \"x\"\n)\n\n.matrixStats_colAlls <- function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colAlls(x, rows = rows, cols = cols, value = value, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowAlls\nsetMethod(\"colAlls\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colAlls)\n\n#' @export\n#' @rdname rowAlls\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colAlls\", \"ANY\", make_default_method_def(\"colAlls\"))\n\n",
        "rowAnyNAs.R": "#' Check if any elements in a row (column) of a matrix-like object is missing\n#'\n#' Check if any elements in a row (column) of a matrix-like object is missing.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowAnyNAs\n#'\n#' @templateVar rowName rowAnyNAs\n#' @templateVar colName colAnyNAs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template useNamesParameter\n#'\n#' @template returnVectorLgl\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:anyMissing]{rowAnyNAs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:anyMissing]{colAnyNAs}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For checks if any element is equal to a value, see\n#'   \\code{\\link{rowAnys}()}.\n#' \\item \\code{base::\\link{is.na}()} and \\code{base::\\link{any}()}.\n#' }\n#'\n#' @template standardExamples\nsetGeneric(\"rowAnyNAs\", function(x, rows = NULL, cols = NULL,  ..., useNames = TRUE) standardGeneric(\"rowAnyNAs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowAnyNAs <- function(x, rows = NULL, cols = NULL, ..., useNames = TRUE){\n  matrixStats::rowAnyNAs(x, rows = rows, cols = cols, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowAnyNAs\nsetMethod(\"rowAnyNAs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowAnyNAs)\n\n#' @export\n#' @rdname rowAnyNAs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowAnyNAs\", \"ANY\", make_default_method_def(\"rowAnyNAs\"))\n\n\n\n#' @export\n#' @rdname rowAnyNAs\nsetGeneric(\"colAnyNAs\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"colAnyNAs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colAnyNAs <- function(x, rows = NULL, cols = NULL, ..., useNames = TRUE){\n  matrixStats::colAnyNAs(x, rows = rows, cols = cols, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowAnyNAs\nsetMethod(\"colAnyNAs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colAnyNAs)\n\n#' @export\n#' @rdname rowAnyNAs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colAnyNAs\", \"ANY\", make_default_method_def(\"colAnyNAs\"))\n\n",
        "rowAnys.R": "#' Check if any elements in a row (column) of a matrix-like object is equal to\n#' a value\n#'\n#' Check if any elements in a row (column) of a matrix-like object is equal to\n#' a value.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowAnys\n#'\n#' @templateVar rowName rowAnys\n#' @templateVar colName colAnys\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template valueParameter\n#' @template dimParameter\n#' @template na_rmParameter\n#' @template useNamesParameter\n\n#' @template returnVectorLgl\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowAlls]{rowAnys}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowAlls]{colAnys}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For checks if \\emph{all} elements are equal to a value, see\n#'   \\code{\\link{rowAlls}()}.\n#' \\item \\code{base::\\link{any}()}.\n#' }\n#'\n#' @template standardExamples\nsetGeneric(\"rowAnys\", function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowAnys\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowAnys <- function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowAnys(x, rows = rows, cols = cols, value = value, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowAnys\nsetMethod(\"rowAnys\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowAnys)\n\n#' @export\n#' @rdname rowAnys\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowAnys\", \"ANY\", make_default_method_def(\"rowAnys\"))\n\n\n\n#' @export\n#' @rdname rowAnys\nsetGeneric(\"colAnys\", function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colAnys\"),\n           signature = \"x\"\n)\n\n.matrixStats_colAnys <- function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colAnys(x, rows = rows, cols = cols, value = value, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowAnys\nsetMethod(\"colAnys\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colAnys)\n\n#' @export\n#' @rdname rowAnys\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colAnys\", \"ANY\", make_default_method_def(\"colAnys\"))\n\n",
        "rowAvgsPerColSet.R": "#' Calculates for each row (column) a summary statistic for equally sized\n#' subsets of columns (rows)\n#' \n#' Calculates for each row (column) a summary statistic for equally sized\n#' subsets of columns (rows).\n#' \n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowAvgsPerColSet\n#'\n#' @templateVar rowName rowAvgsPerColSet\n#' @templateVar colName colAvgsPerRowSet\n#' \n#' @template matrixStatsLink\n#' \n#' @param X An `NxM` matrix-like object.\n#' @param W An optional numeric `NxM` matrix of weights.\n#' @param rows,cols A \\code{\\link{vector}} indicating the subset (and/or \n#'   columns) to operate over. If \\code{\\link{NULL}}, no subsetting is\n#'   done.\n#' @param S An [integer] `KxJ` matrix that specifying the `J` subsets. Each \n#'   column hold `K` column (row) indices for the corresponding subset. The \n#'   range of values is \\[1, M\\] (\\[1,N\\]).\n#' @param FUN A row-by-row (column-by-column) summary statistic function. It is \n#'   applied to to each column (row) subset of `X` that is specified by `S`.\n#' @param ... Additional arguments passed to `FUN`.\n#' @param na.rm (logical) Argument passed to `FUN()` as `na.rm = na.rm`. \n#'   If `NA` (default), then `na.rm = TRUE` is used if `X` or `S` holds missing values, \n#'   otherwise `na.rm = FALSE`.\n#' @param tFUN If `TRUE`, `X` is transposed before it is passed to `FUN`.\n#' \n#' \n#' @return Returns a numeric `JxN` (`MxJ`) matrix.\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowAvgsPerColSet]{rowAvgsPerColSet}()}\n#'   and \\code{matrixStats::\\link[matrixStats:rowAvgsPerColSet]{colAvgsPerRowSet}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' }\n#' \n#' @examples \n#'   mat <- matrix(rnorm(20), nrow = 5, ncol = 4)\n#'   mat[2, 1] <- NA\n#'   mat[3, 3] <- Inf\n#'   mat[4, 1] <- 0\n#'   \n#'   print(mat)\n#'   \n#'   S <- matrix(1:ncol(mat), ncol = 2)\n#'   print(S)\n#'   \n#'   rowAvgsPerColSet(mat, S = S, FUN = rowMeans)\n#'   rowAvgsPerColSet(mat, S = S, FUN = rowVars)\n#'\n#' @keywords array iteration robust univar2\nsetGeneric(\"rowAvgsPerColSet\", function(X, W = NULL, rows = NULL, S, FUN = rowMeans,  ..., na.rm = NA, tFUN = FALSE) standardGeneric(\"rowAvgsPerColSet\"),\n           signature = \"X\"\n)\n\n.matrixStats_rowAvgsPerColSet <- function(X, W = NULL, rows = NULL, S, FUN = rowMeans,  ..., na.rm = NA, tFUN = FALSE){\n  matrixStats::rowAvgsPerColSet(X = X, W = W, rows = rows, S = S, FUN = FUN, ..., na.rm = na.rm, tFUN = tFUN)\n}\n\n#' @export\n#' @rdname rowAvgsPerColSet\nsetMethod(\"rowAvgsPerColSet\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowAvgsPerColSet)\n\n#' @export\n#' @rdname rowAvgsPerColSet\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowAvgsPerColSet\", \"ANY\", function (X, W = NULL, rows = NULL, S, FUN = rowMeans, ..., na.rm = NA, tFUN = FALSE){\n  MatrixGenerics:::.load_next_suggested_package_to_search(X)\n  callGeneric()\n})\n\n\n\n#' @export\n#' @rdname rowAvgsPerColSet\nsetGeneric(\"colAvgsPerRowSet\", function(X, W = NULL, cols = NULL, S, FUN = colMeans,  ..., na.rm = NA, tFUN = FALSE) standardGeneric(\"colAvgsPerRowSet\"),\n           signature = \"X\"\n)\n\n.matrixStats_colAvgsPerRowSet <- function(X, W = NULL, cols = NULL, S, FUN = colMeans,  ..., na.rm = NA, tFUN = FALSE){\n  matrixStats::colAvgsPerRowSet(X = X, W = W, cols = cols, S = S, FUN = FUN, ..., na.rm = na.rm, tFUN = tFUN)\n}\n\n#' @export\n#' @rdname rowAvgsPerColSet\nsetMethod(\"colAvgsPerRowSet\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colAvgsPerRowSet)\n\n#' @export\n#' @rdname rowAvgsPerColSet\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colAvgsPerRowSet\", \"ANY\", function (X, W = NULL, cols = NULL, S, FUN = colMeans, ..., na.rm = NA, tFUN = FALSE){\n  MatrixGenerics:::.load_next_suggested_package_to_search(X)\n  callGeneric()\n})\n\n",
        "rowCollapse.R": "#' Extract one cell from each row (column) of a matrix-like object\n#'\n#' Extract one cell from each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowCollapse\n#'\n#' @templateVar rowName rowCollapse\n#' @templateVar colName colCollapse\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template dimParameter\n#' @param idxs An index \\code{\\link{vector}} with the position to extract.\n#'   It is recycled to match the number of rows (column)\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowCollapse]{rowCollapse}()}\n#'   and \\code{matrixStats::\\link[matrixStats:rowCollapse]{colCollapse}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' }\n#'\n#' @examples\n#'   mat <- matrix(rnorm(15), nrow = 5, ncol = 3)\n#'   mat[2, 1] <- NA\n#'   mat[3, 3] <- Inf\n#'   mat[4, 1] <- 0\n#'\n#'   print(mat)\n#'\n#'   rowCollapse(mat, idxs = 2)\n#'   rowCollapse(mat, idxs = c(1,1,2,3,2))\n#'\n#'   colCollapse (mat, idxs = 4)\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowCollapse\", function(x, idxs, rows = NULL, ..., useNames = TRUE) standardGeneric(\"rowCollapse\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowCollapse <- function(x, idxs, rows = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowCollapse(x, idxs = idxs, rows = rows, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCollapse\nsetMethod(\"rowCollapse\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowCollapse)\n\n#' @export\n#' @rdname rowCollapse\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowCollapse\", \"ANY\", make_default_method_def(\"rowCollapse\"))\n\n\n\n#' @export\n#' @rdname rowCollapse\nsetGeneric(\"colCollapse\", function(x, idxs, cols = NULL, ..., useNames = TRUE) standardGeneric(\"colCollapse\"),\n           signature = \"x\"\n)\n\n.matrixStats_colCollapse <- function(x, idxs, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colCollapse(x, idxs = idxs, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCollapse\nsetMethod(\"colCollapse\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colCollapse)\n\n#' @export\n#' @rdname rowCollapse\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colCollapse\", \"ANY\", make_default_method_def(\"colCollapse\"))\n\n",
        "rowCounts.R": "#' Count how often an element in a row (column) of a matrix-like object is\n#' equal to a value\n#'\n#' Count how often an element in a row (column) of a matrix-like object is\n#' equal to a value.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowCounts\n#'\n#' @templateVar rowName rowCounts\n#' @templateVar colName colCounts\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template valueParameter\n#' @template dimParameter\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVectorInt\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowCounts}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowCounts]{colCounts}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For checks if any element is equal to a value, see\n#'   \\code{\\link{rowAnys}()}. To check if all elements are equal, see\n#'   \\code{\\link{rowAlls}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @examples\n#'   rowCounts(mat, value = 0)\n#'   colCounts(mat, value = Inf, na.rm = TRUE)\nsetGeneric(\"rowCounts\", function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowCounts\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowCounts <- function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowCounts(x, rows = rows, cols = cols, value = value, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCounts\nsetMethod(\"rowCounts\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowCounts)\n\n#' @export\n#' @rdname rowCounts\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowCounts\", \"ANY\", make_default_method_def(\"rowCounts\"))\n\n\n\n#' @export\n#' @rdname rowCounts\nsetGeneric(\"colCounts\", function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colCounts\"),\n           signature = \"x\"\n)\n\n.matrixStats_colCounts <- function(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colCounts(x, rows = rows, cols = cols, value = value, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCounts\nsetMethod(\"colCounts\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colCounts)\n\n#' @export\n#' @rdname rowCounts\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colCounts\", \"ANY\", make_default_method_def(\"colCounts\"))\n\n",
        "rowCummaxs.R": "#' Calculates the cumulative maxima for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the cumulative maxima for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowCummaxs\n#'\n#' @templateVar rowName rowCummaxs\n#' @templateVar colName colCummaxs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnMatrix_SameDimX\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowCumsums]{rowCummaxs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowCumsums]{colCummaxs}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For single maximum estimates, see \\code{\\link{rowMaxs}()}.\n#' \\item \\code{base::\\link{cummax}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowCummaxs\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"rowCummaxs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowCummaxs <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowCummaxs(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCummaxs\nsetMethod(\"rowCummaxs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowCummaxs)\n\n#' @export\n#' @rdname rowCummaxs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowCummaxs\", \"ANY\", make_default_method_def(\"rowCummaxs\"))\n\n\n\n#' @export\n#' @rdname rowCummaxs\nsetGeneric(\"colCummaxs\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"colCummaxs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colCummaxs <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colCummaxs(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCummaxs\nsetMethod(\"colCummaxs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colCummaxs)\n\n#' @export\n#' @rdname rowCummaxs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colCummaxs\", \"ANY\", make_default_method_def(\"colCummaxs\"))\n\n",
        "rowCummins.R": "#' Calculates the cumulative minima for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the cumulative minima for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowCummins\n#'\n#' @templateVar rowName rowCummins\n#' @templateVar colName colCummins\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnMatrix_SameDimX\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowCumsums]{rowCummins}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowCumsums]{colCummins}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For single minimum estimates, see \\code{\\link{rowMins}()}.\n#' \\item \\code{base::\\link{cummin}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowCummins\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"rowCummins\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowCummins <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowCummins(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCummins\nsetMethod(\"rowCummins\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowCummins)\n\n#' @export\n#' @rdname rowCummins\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowCummins\", \"ANY\", make_default_method_def(\"rowCummins\"))\n\n\n\n#' @export\n#' @rdname rowCummins\nsetGeneric(\"colCummins\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"colCummins\"),\n           signature = \"x\"\n)\n\n.matrixStats_colCummins <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colCummins(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCummins\nsetMethod(\"colCummins\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colCummins)\n\n#' @export\n#' @rdname rowCummins\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colCummins\", \"ANY\", make_default_method_def(\"colCummins\"))\n\n",
        "rowCumprods.R": "#' Calculates the cumulative product for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the cumulative product for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowCumprods\n#'\n#' @templateVar rowName rowCumprods\n#' @templateVar colName colCumprods\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnMatrix_SameDimX\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowCumsums]{rowCumprods}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowCumsums]{colCumprods}()} which\n#'   are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#'  \\item \\code{base::\\link{cumprod}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowCumprods\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"rowCumprods\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowCumprods <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowCumprods(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCumprods\nsetMethod(\"rowCumprods\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowCumprods)\n\n#' @export\n#' @rdname rowCumprods\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowCumprods\", \"ANY\", make_default_method_def(\"rowCumprods\"))\n\n\n\n#' @export\n#' @rdname rowCumprods\nsetGeneric(\"colCumprods\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"colCumprods\"),\n           signature = \"x\"\n)\n\n.matrixStats_colCumprods <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colCumprods(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCumprods\nsetMethod(\"colCumprods\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colCumprods)\n\n#' @export\n#' @rdname rowCumprods\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colCumprods\", \"ANY\", make_default_method_def(\"colCumprods\"))\n\n",
        "rowCumsums.R": "#' Calculates the cumulative sum for each row (column) of a matrix-like object\n#'\n#' Calculates the cumulative sum for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowCumsums\n#'\n#' @templateVar rowName rowCumsums\n#' @templateVar colName colCumsums\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnMatrix_SameDimX\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowCumsums}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowCumsums]{colCumsums}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item \\code{base::\\link{cumsum}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowCumsums\", function(x, rows = NULL, cols = NULL,  ..., useNames = TRUE) standardGeneric(\"rowCumsums\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowCumsums <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowCumsums(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCumsums\nsetMethod(\"rowCumsums\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowCumsums)\n\n#' @export\n#' @rdname rowCumsums\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowCumsums\", \"ANY\", make_default_method_def(\"rowCumsums\"))\n\n\n\n#' @export\n#' @rdname rowCumsums\nsetGeneric(\"colCumsums\", function(x, rows = NULL, cols = NULL, ..., useNames = TRUE) standardGeneric(\"colCumsums\"),\n           signature = \"x\"\n)\n\n.matrixStats_colCumsums <- function(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colCumsums(x, rows = rows, cols = cols, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowCumsums\nsetMethod(\"colCumsums\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colCumsums)\n\n#' @export\n#' @rdname rowCumsums\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colCumsums\", \"ANY\", make_default_method_def(\"colCumsums\"))\n\n",
        "rowDiffs.R": "#' Calculates the difference between each element of a row (column) of a\n#' matrix-like object\n#'\n#' Calculates the difference between each element of a row (column) of a\n#' matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowDiffs\n#'\n#' @templateVar rowName rowDiffs\n#' @templateVar colName colDiffs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @param lag An integer specifying the lag.\n#' @param differences An integer specifying the order of difference.\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @return Returns a \\code{\\link{numeric}} \\code{\\link{matrix}} with one column\n#' (row) less than x: \\eqn{Nx(K-1)} or \\eqn{(N-1)xK}.\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowDiffs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowDiffs]{colDiffs}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item \\code{base::\\link{diff}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowDiffs\", function(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L,  ..., useNames = TRUE) standardGeneric(\"rowDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowDiffs <- function(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowDiffs(x, rows = rows, cols = cols, lag = lag, differences = differences, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowDiffs\nsetMethod(\"rowDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowDiffs)\n\n#' @export\n#' @rdname rowDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowDiffs\", \"ANY\", make_default_method_def(\"rowDiffs\"))\n\n\n\n#' @export\n#' @rdname rowDiffs\nsetGeneric(\"colDiffs\", function(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L, ..., useNames = TRUE) standardGeneric(\"colDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colDiffs <- function(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colDiffs(x, rows = rows, cols = cols, lag = lag, differences = differences, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowDiffs\nsetMethod(\"colDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colDiffs)\n\n#' @export\n#' @rdname rowDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colDiffs\", \"ANY\", make_default_method_def(\"colDiffs\"))\n\n",
        "rowIQRDiffs.R": "#' Calculates the interquartile range of the difference between each element of\n#' a row (column) of a matrix-like object\n#'\n#' Calculates the interquartile range of the difference between each element of\n#' a row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowIQRDiffs\n#'\n#' @templateVar rowName rowIQRDiffs\n#' @templateVar colName colIQRDiffs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template diff_trimParameters\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:varDiff]{rowIQRDiffs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:varDiff]{colIQRDiffs}()} which\n#'   are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For the direct interquartile range see also [rowIQRs].\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowIQRDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"rowIQRDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowIQRDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::rowIQRDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowIQRDiffs\nsetMethod(\"rowIQRDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowIQRDiffs)\n\n#' @export\n#' @rdname rowIQRDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowIQRDiffs\", \"ANY\", make_default_method_def(\"rowIQRDiffs\"))\n\n\n\n#' @export\n#' @rdname rowIQRDiffs\nsetGeneric(\"colIQRDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"colIQRDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colIQRDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::colIQRDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowIQRDiffs\nsetMethod(\"colIQRDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colIQRDiffs)\n\n#' @export\n#' @rdname rowIQRDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colIQRDiffs\", \"ANY\", make_default_method_def(\"colIQRDiffs\"))\n\n",
        "rowIQRs.R": "#' Calculates the interquartile range for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the interquartile range for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowIQRs\n#'\n#' @templateVar rowName rowIQRs\n#' @templateVar colName colIQRs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowIQRs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowIQRs]{colIQRs}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For a non-robust analog, see \\code{\\link{rowSds}()}. For a more\n#'  robust version see [rowMads()]\n#' \\item \\code{stats::\\link[stats]{IQR}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowIQRs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowIQRs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowIQRs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::rowIQRs(x, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowIQRs\nsetMethod(\"rowIQRs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowIQRs)\n\n#' @export\n#' @rdname rowIQRs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowIQRs\", \"ANY\", make_default_method_def(\"rowIQRs\"))\n\n\n\n#' @export\n#' @rdname rowIQRs\nsetGeneric(\"colIQRs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colIQRs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colIQRs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::colIQRs(x, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowIQRs\nsetMethod(\"colIQRs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colIQRs)\n\n#' @export\n#' @rdname rowIQRs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colIQRs\", \"ANY\", make_default_method_def(\"colIQRs\"))\n\n",
        "rowLogSumExps.R": "#' Accurately calculates the logarithm of the sum of exponentials for each row\n#' (column) of a matrix-like object\n#'\n#' Accurately calculates the logarithm of the sum of exponentials for each row\n#' (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowLogSumExps\n#'\n#' @templateVar rowName rowLogSumExps\n#' @templateVar colName colLogSumExps\n#'\n#' @template matrixStatsLink\n#'\n#' @param lx An NxK matrix-like object. Typically `lx` are `log(x)` values.\n#' @param rows,cols A \\code{\\link{vector}} indicating the subset (and/or\n#' columns) to operate over. If \\code{\\link{NULL}}, no subsetting is done.\n#' @param ... Additional arguments passed to specific methods.\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowLogSumExps}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowLogSumExps]{colLogSumExps}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item [rowSums2()]\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowLogSumExps\", function(lx, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowLogSumExps\"),\n           signature = \"lx\"\n)\n\n.matrixStats_rowLogSumExps <- function(lx, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(lx), ..., useNames = TRUE){\n  matrixStats::rowLogSumExps(lx, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowLogSumExps\nsetMethod(\"rowLogSumExps\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowLogSumExps)\n\n#' @export\n#' @rdname rowLogSumExps\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowLogSumExps\", \"ANY\", function (lx, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  MatrixGenerics:::.load_next_suggested_package_to_search(lx)\n  callGeneric()\n})\n\n\n\n#' @export\n#' @rdname rowLogSumExps\nsetGeneric(\"colLogSumExps\", function(lx, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colLogSumExps\"),\n           signature = \"lx\"\n)\n\n.matrixStats_colLogSumExps <- function(lx, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(lx), ..., useNames = TRUE){\n  matrixStats::colLogSumExps(lx, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowLogSumExps\nsetMethod(\"colLogSumExps\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colLogSumExps)\n\n#' @export\n#' @rdname rowLogSumExps\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colLogSumExps\", \"ANY\", function (lx, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  MatrixGenerics:::.load_next_suggested_package_to_search(lx)\n  callGeneric()\n})\n\n",
        "rowMadDiffs.R": "#' Calculates the mean absolute deviation of the difference between each\n#' element of a row (column) of a matrix-like object\n#'\n#' Calculates the mean absolute deviation of the difference between each\n#' element of a row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMadDiffs\n#'\n#' @templateVar rowName rowMadDiffs\n#' @templateVar colName colMadDiffs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template diff_trimParameters\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:varDiff]{rowMadDiffs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:varDiff]{colMadDiffs}()} which\n#'   are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowMadDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"rowMadDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowMadDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::rowMadDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMadDiffs\nsetMethod(\"rowMadDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowMadDiffs)\n\n#' @export\n#' @rdname rowMadDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowMadDiffs\", \"ANY\", make_default_method_def(\"rowMadDiffs\"))\n\n\n\n#' @export\n#' @rdname rowMadDiffs\nsetGeneric(\"colMadDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"colMadDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colMadDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::colMadDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff =diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMadDiffs\nsetMethod(\"colMadDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colMadDiffs)\n\n#' @export\n#' @rdname rowMadDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colMadDiffs\", \"ANY\", make_default_method_def(\"colMadDiffs\"))\n\n",
        "rowMads.R": "#' Calculates the median absolute deviation for each row (column) of a\n#' matrix-like object\n#'\n#' Calculates the median absolute deviation for each row (column) of a\n#' matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMads\n#'\n#' @templateVar rowName rowMads\n#' @templateVar colName colMads\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @param center (optional) the center, defaults to the row means\n#' @param constant A scale factor. See \\code{stats::\\link[stats]{mad}()} for\n#'   details.\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowSds]{rowMads}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowSds]{colMads}()} which are used\n#'   when  the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For mean estimates, see \\code{\\link{rowMeans2}()} and\n#'   \\code{\\link[base:colSums]{rowMeans}()}.\n#' \\item For non-robust standard deviation estimates, see\n#'   \\code{\\link{rowSds}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowMads\", function(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowMads\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowMads <- function(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  center <- normarg_center(center, nrow(x), \"nrow(x)\")\n  matrixStats::rowMads(x, rows = rows, cols = cols, center = center, constant = constant, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMads\nsetMethod(\"rowMads\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowMads)\n\n#' @export\n#' @rdname rowMads\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowMads\", \"ANY\", make_default_method_def(\"rowMads\"))\n\n\n\n#' @export\n#' @rdname rowMads\nsetGeneric(\"colMads\", function(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colMads\"),\n           signature = \"x\"\n)\n\n.matrixStats_colMads <- function(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  center <- normarg_center(center, ncol(x), \"ncol(x)\")\n  matrixStats::colMads(x, rows = rows, cols = cols, center = center, constant = constant, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMads\nsetMethod(\"colMads\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colMads)\n\n#' @export\n#' @rdname rowMads\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colMads\", \"ANY\", make_default_method_def(\"colMads\"))\n\n",
        "rowMaxs.R": "#' Calculates the maximum for each row (column) of a matrix-like object\n#'\n#' Calculates the maximum for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMaxs\n#'\n#' @templateVar rowName rowMaxs\n#' @templateVar colName colMaxs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowRanges]{rowMaxs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowRanges]{colMaxs}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For min estimates, see \\code{\\link{rowMins}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowMaxs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowMaxs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowMaxs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowMaxs(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMaxs\nsetMethod(\"rowMaxs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowMaxs)\n\n#' @export\n#' @rdname rowMaxs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowMaxs\", \"ANY\", make_default_method_def(\"rowMaxs\"))\n\n\n\n#' @export\n#' @rdname rowMaxs\nsetGeneric(\"colMaxs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colMaxs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colMaxs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colMaxs(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMaxs\nsetMethod(\"colMaxs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colMaxs)\n\n#' @export\n#' @rdname rowMaxs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colMaxs\", \"ANY\", make_default_method_def(\"colMaxs\"))\n\n",
        "rowMeans.R": "## IMPORTANT NOTE: We don't provide a user-friendly fallback mechanism for\n## rowMeans() and colMeans(). Here is why:\n## The method package defines **implicit generics** for the rowMeans()\n## and colMeans() functions and this is what we get when we call\n## setGeneric(\"rowMeans\") and setGeneric(\"colMeans\") below. These implicit\n## generics introduce 2 surprises:\n## 1. Their argument list (x, na.rm=FALSE, dims=1, ...) differs slightly from\n##    base::rowMeans and base::colMeans. This means that we need to be careful\n##    to use this same exact argument list in the rowMeans() and colMeans()\n##    methods that we define below.\n## 2. They define their own default method that basically calls base::rowMeans()\n##    or base::colMeans(). Unfortunately, trying to override these default\n##    methods with our own doesn't work. Even if selectMethod(\"rowMeans\", \"ANY\")\n##    and selectMethod(\"colMeans\", \"ANY\") return our methods right after\n##    loading MatrixGenerics in a fresh R session, this is no longer the case\n##    if we then load the DelayedArray package. Then the default methods get\n##    replaced with the original default methods defined by the implicit\n##    generics. VERY NASTY! This is why our attempts at providing user-friendly\n##    fallback mechanisms for rowMeans() and colMeans() are commented out below.\n\n#' Calculates the mean for each row (column) of a matrix-like object\n#'\n#' Calculates the mean for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMeans\n#'\n#' @templateVar rowName rowMeans\n#' @templateVar colName colMeans\n#'\n#' @param x An NxK matrix-like object, a numeric data frame, or an array-like\n#' object of two or more dimensions.\n#' @template na_rmParameter\n#' @param dims A single integer indicating which dimensions are regarded\n#' as rows or columns to mean over. For \\code{rowMeans}, the mean is over\n#' dimensions \\code{dims+1, ...}; for \\code{colMeans} it is over\n#' dimensions \\code{1:dims}.\n#' @param ... Additional arguments passed to specific methods.\n#'\n#' @details This man page documents the \\code{rowMeans} and \\code{colMeans}\n#' \\emph{S4 generic functions} defined in the \\pkg{MatrixGenerics} package.\n#' See \\code{?base::\\link[base]{colMeans}} for the default methods (defined\n#' in the \\pkg{base} package).\n# #' The S4 methods for \\code{x} of type \\code{\\link{matrix}},\n# #' \\code{\\link{array}}, \\code{\\link{table}}, \\code{\\link{numeric}}, or\n# #' \\code{\\link{data.frame}} call \\code{base::\\link[base]{rowMeans}} /\n# #' \\code{base::\\link[base]{colMeans}}.\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{base::\\link[base]{colMeans}} for the default\n#'       \\code{rowMeans} and \\code{colMeans} methods.\n#' \\item \\code{Matrix::\\link[Matrix]{colMeans}} in the \\pkg{Matrix} package\n#'       for \\code{rowMeans} and \\code{colMeans} methods defined for\n#'       CsparseMatrix derivatives (e.g. dgCMatrix objects).\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array algebra arith iteration robust univar\nsetGeneric(\"rowMeans\")\n\n# .base_rowMeans <- function(x, na.rm=FALSE, dims=1, ...)\n# {\n#     base::rowMeans(x, na.rm=na.rm, dims=dims, ...)\n# }\n#\n# #' @export\n# #' @rdname rowMeans\n# setMethod(\"rowMeans\", \"matrix_OR_array_OR_table_OR_numeric\", .base_rowMeans)\n#\n# #' @export\n# #' @rdname rowMeans\n# setMethod(\"rowMeans\", \"data.frame\", .base_rowMeans)\n#\n# #' @export\n# #' @rdname rowMeans\n# ## Default method with user-friendly fallback mechanism.\n# setMethod(\"rowMeans\", \"ANY\", make_default_method_def(\"rowMeans\"))\n\n\n#' @export\n#' @rdname rowMeans\nsetGeneric(\"colMeans\")\n\n# .base_colMeans <- function(x, na.rm=FALSE, dims=1, ...)\n# {\n#     base::colMeans(x, na.rm=na.rm, dims=dims, ...)\n# }\n#\n# #' @export\n# #' @rdname rowMeans\n# setMethod(\"colMeans\", \"matrix_OR_array_OR_table_OR_numeric\", .base_colMeans)\n#\n# #' @export\n# #' @rdname rowMeans\n# setMethod(\"colMeans\", \"data.frame\", .base_colMeans)\n#\n# #' @export\n# #' @rdname rowMeans\n# ## Default method with user-friendly fallback mechanism.\n# setMethod(\"colMeans\", \"ANY\", make_default_method_def(\"colMeans\"))\n\n",
        "rowMeans2.R": "#' Calculates the mean for each row (column) of a matrix-like object\n#'\n#' Calculates the mean for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMeans2\n#'\n#' @templateVar rowName rowMeans2\n#' @templateVar colName colMeans2\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowMeans2}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowMeans2]{colMeans2}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item See also \\code{\\link[base:colSums]{rowMeans}()} for the\n#'   corresponding function in base R.\n#' \\item For variance estimates, see \\code{\\link{rowVars}()}.\n#' \\item See also the base R version \\code{base::\\link{rowMeans}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowMeans2\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowMeans2\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowMeans2 <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowMeans2(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMeans2\nsetMethod(\"rowMeans2\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowMeans2)\n\n#' @export\n#' @rdname rowMeans2\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowMeans2\", \"ANY\", make_default_method_def(\"rowMeans2\"))\n\n\n\n#' @export\n#' @rdname rowMeans2\nsetGeneric(\"colMeans2\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colMeans2\"),\n           signature = \"x\"\n)\n\n.matrixStats_colMeans2 <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colMeans2(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMeans2\nsetMethod(\"colMeans2\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colMeans2)\n\n#' @export\n#' @rdname rowMeans2\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colMeans2\", \"ANY\", make_default_method_def(\"colMeans2\"))\n\n",
        "rowMedians.R": "#' Calculates the median for each row (column) of a matrix-like object\n#'\n#' Calculates the median for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMedians\n#'\n#' @templateVar rowName rowMedians\n#' @templateVar colName colMedians\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowMedians}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowMedians]{colMedians}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For mean estimates, see \\code{\\link{rowMeans2}()} and\n#'   \\code{\\link[base:colSums]{rowMeans}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowMedians\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowMedians\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowMedians <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowMedians(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMedians\nsetMethod(\"rowMedians\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowMedians)\n\n#' @export\n#' @rdname rowMedians\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowMedians\", \"ANY\", make_default_method_def(\"rowMedians\"))\n\n\n\n#' @export\n#' @rdname rowMedians\nsetGeneric(\"colMedians\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colMedians\"),\n           signature = \"x\"\n)\n\n.matrixStats_colMedians <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colMedians(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMedians\nsetMethod(\"colMedians\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colMedians)\n\n#' @export\n#' @rdname rowMedians\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colMedians\", \"ANY\", make_default_method_def(\"colMedians\"))\n\n",
        "rowMins.R": "#' Calculates the minimum for each row (column) of a matrix-like object\n#'\n#' Calculates the minimum for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowMins\n#'\n#' @templateVar rowName rowMins\n#' @templateVar colName colMins\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:rowRanges]{rowMins}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowRanges]{colMins}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For max estimates, see \\code{\\link{rowMaxs}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowMins\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowMins\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowMins <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowMins(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMins\nsetMethod(\"rowMins\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowMins)\n\n#' @export\n#' @rdname rowMins\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowMins\", \"ANY\", make_default_method_def(\"rowMins\"))\n\n\n\n#' @export\n#' @rdname rowMins\nsetGeneric(\"colMins\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colMins\"),\n           signature = \"x\"\n)\n\n.matrixStats_colMins <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colMins(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowMins\nsetMethod(\"colMins\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colMins)\n\n#' @export\n#' @rdname rowMins\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colMins\", \"ANY\", make_default_method_def(\"colMins\"))\n\n",
        "rowOrderStats.R": "#' Calculates an order statistic for each row (column) of a matrix-like object\n#'\n#' Calculates an order statistic for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowOrderStats\n#'\n#' @templateVar rowName rowOrderStats\n#' @templateVar colName colOrderStats\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @param which An integer index in \\[1,K\\] (\\[1,N\\]) indicating which order\n#'   statistic to be returned\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowOrderStats}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowOrderStats]{colOrderStats}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' }\n#'\n#' @examples\n#'     mat <- matrix(rnorm(15), nrow = 5, ncol = 3)\n#'     mat[2, 1] <- 2\n#'     mat[3, 3] <- Inf\n#'     mat[4, 1] <- 0\n#'\n#'     print(mat)\n#'\n#'     rowOrderStats(mat, which = 1)\n#'     colOrderStats(mat, which = 3)\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowOrderStats\", function(x, rows = NULL, cols = NULL, which, ..., useNames = TRUE) standardGeneric(\"rowOrderStats\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowOrderStats <- function(x, rows = NULL, cols = NULL, which, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowOrderStats(x, rows = rows, cols = cols, which = which, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowOrderStats\nsetMethod(\"rowOrderStats\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowOrderStats)\n\n#' @export\n#' @rdname rowOrderStats\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowOrderStats\", \"ANY\", make_default_method_def(\"rowOrderStats\"))\n\n\n\n#' @export\n#' @rdname rowOrderStats\nsetGeneric(\"colOrderStats\", function(x, rows = NULL, cols = NULL, which, ..., useNames = TRUE) standardGeneric(\"colOrderStats\"),\n           signature = \"x\"\n)\n\n.matrixStats_colOrderStats <- function(x, rows = NULL, cols = NULL, which, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colOrderStats(x, rows = rows, cols = cols, which = which, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowOrderStats\nsetMethod(\"colOrderStats\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colOrderStats)\n\n#' @export\n#' @rdname rowOrderStats\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colOrderStats\", \"ANY\", make_default_method_def(\"colOrderStats\"))\n\n",
        "rowProds.R": "#' Calculates the product for each row (column) of a matrix-like object\n#'\n#' Calculates the product for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowProds\n#'\n#' @templateVar rowName rowProds\n#' @templateVar colName colProds\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @param method A character vector of length one that specifies the\n#'   how the product is calculated. Note, that this is not a generic\n#'   argument and not all implementation have to provide it.\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowProds}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowProds]{colProds}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For sums across rows (columns), see\n#'   \\code{\\link{rowSums2}()} ([colSums2()])\n#' \\item \\code{base::\\link{prod}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowProds\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowProds\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowProds <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, method = c(\"direct\", \"expSumLog\"), ..., useNames = TRUE){\n  matrixStats::rowProds(x, rows = rows, cols = cols, na.rm = na.rm, method = method, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowProds\nsetMethod(\"rowProds\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowProds)\n\n#' @export\n#' @rdname rowProds\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowProds\", \"ANY\", make_default_method_def(\"rowProds\"))\n\n\n\n#' @export\n#' @rdname rowProds\nsetGeneric(\"colProds\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colProds\"),\n           signature = \"x\"\n)\n\n.matrixStats_colProds <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, method = c(\"direct\", \"expSumLog\"), ..., useNames = TRUE){\n  matrixStats::colProds(x, rows = rows, cols = cols, na.rm = na.rm, method = method, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowProds\nsetMethod(\"colProds\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colProds)\n\n#' @export\n#' @rdname rowProds\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colProds\", \"ANY\", make_default_method_def(\"colProds\"))\n\n",
        "rowQuantiles.R": "#' Calculates quantiles for each row (column) of a matrix-like object\n#'\n#' Calculates quantiles for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowQuantiles\n#'\n#' @templateVar rowName rowQuantiles\n#' @templateVar colName colQuantiles\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @param probs A numeric vector of J probabilities in \\[0, 1\\].\n#' @template na_rmParameter\n#' @param type An integer specifying the type of estimator. See\n#'   \\code{stats::\\link[stats]{quantile}()} for more details.\n#' @param digits An integer specifying the precision of the formatted\n#'   percentages. See \\code{stats::\\link[stats]{quantile}()} for more details.\n#' @param drop If `TRUE` a vector is returned if `J == 1`.\n#' @template useNamesParameter\n#'\n#' @template returnMatrix_JDim\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowQuantiles}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowQuantiles]{colQuantiles}()} which\n#'   are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item [stats::quantile]\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust\nsetGeneric(\"rowQuantiles\", function(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1, by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ..., useNames = TRUE, drop = TRUE) standardGeneric(\"rowQuantiles\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowQuantiles <- function(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1, by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ..., useNames = TRUE, drop = TRUE) {\n  matrixStats::rowQuantiles(x = x, rows = rows, cols = cols, probs = probs, na.rm = na.rm, type = type, digits = digits, ..., useNames = useNames, drop = drop)\n}\n\n#' @export\n#' @rdname rowQuantiles\nsetMethod(\"rowQuantiles\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowQuantiles)\n\n#' @export\n#' @rdname rowQuantiles\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowQuantiles\", \"ANY\", make_default_method_def(\"rowQuantiles\"))\n\n\n\n#' @export\n#' @rdname rowQuantiles\nsetGeneric(\"colQuantiles\", function(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1, by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ..., useNames = TRUE, drop = TRUE) standardGeneric(\"colQuantiles\"),\n           signature = \"x\"\n)\n\n.matrixStats_colQuantiles <- function(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1, by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ..., useNames = TRUE, drop = TRUE) {\n  matrixStats::colQuantiles(x = x, rows = rows, cols = cols, probs = probs, na.rm = na.rm, type = type, digits = digits, ..., useNames = useNames, drop = drop)\n}\n\n#' @export\n#' @rdname rowQuantiles\nsetMethod(\"colQuantiles\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colQuantiles)\n\n#' @export\n#' @rdname rowQuantiles\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colQuantiles\", \"ANY\", make_default_method_def(\"colQuantiles\"))\n\n",
        "rowRanges.R": "#' Calculates the minimum and maximum for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the minimum and maximum for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowRanges\n#'\n#' @templateVar rowName rowRanges\n#' @templateVar colName colRanges\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @return a \\code{\\link{numeric}} \\code{Nx2} (\\code{Kx2})\n#'   \\code{\\link{matrix}}, where N (K) is the number of rows (columns) for\n#'   which the ranges are calculated.\n#'\n#' @note Unfortunately for the argument list of the \\code{rowRanges()}\n#'   generic function we cannot follow the scheme used for the other\n#'   row/column matrix summarization generic functions. This is because\n#'   we need to be compatible with the historic \\code{rowRanges()} getter\n#'   for \\link[SummarizedExperiment]{RangedSummarizedExperiment} objects.\n#'   See \\code{?SummarizedExperiment::\\link[SummarizedExperiment]{rowRanges}}.\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowRanges}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowRanges]{colRanges}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For max estimates, see \\code{\\link{rowMaxs}()}.\n#' \\item For min estimates, see \\code{\\link{rowMins}()}.\n#' \\item \\code{base::\\link{range}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust\nsetGeneric(\"rowRanges\", function(x, ...) standardGeneric(\"rowRanges\"))\n\n.matrixStats_rowRanges <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowRanges(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowRanges\nsetMethod(\"rowRanges\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowRanges)\n\n## Note that because the rowRanges() accessor for SummarizedExperiment\n## objects (and other objects in Bioconductor) is implemented as a method\n## for the MatrixGenerics::rowRanges() generic, the user-friendly fallback\n## mechanism for rowRanges() could produce an error message like:\n##\n##   Error in MatrixGenerics:::.load_next_suggested_package_to_search(x) :\n##     Failed to find a rowRanges() method for <SomeClass> objects.\n##     However, the following package is likely to contain the missing\n##     method but is not installed: sparseMatrixStats.\n##     Please install it (with 'BiocManager::install(\"sparseMatrixStats\")')\n##     and try again.\n##\n## in the (admittedly rare) situations where the user tries to call the\n## accessor on a SummarizedExperiment or RaggedExperiment object etc.. but\n## doesn't have the SummarizedExperiment or RaggedExperiment package loaded.\n## Not clear that this can even happen, but if it did, the error message\n## would be quite misleading.\n#' @export\n#' @rdname rowRanges\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowRanges\", \"ANY\", make_default_method_def(\"rowRanges\"))\n\n\n\n#' @export\n#' @rdname rowRanges\nsetGeneric(\"colRanges\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colRanges\"),\n           signature = \"x\"\n)\n\n.matrixStats_colRanges <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colRanges(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowRanges\nsetMethod(\"colRanges\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colRanges)\n\n#' @export\n#' @rdname rowRanges\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colRanges\", \"ANY\", make_default_method_def(\"colRanges\"))\n\n",
        "rowRanks.R": "#' Calculates the rank of the elements for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the rank of the elements for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowRanks\n#'\n#' @templateVar rowName rowRanks\n#' @templateVar colName colRanks\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @param ties.method A character string specifying how ties are treated. Note\n#'   that the default specifies fewer options than the original matrixStats\n#'   package.\n#' @template dimParameter\n#' @param preserveShape If `TRUE` the output matrix has the same shape as the\n#'   input x. Note, that this is not a generic argument and not all\n#'   implementation of this function have to provide it.\n#' @template useNamesParameter\n#'\n#' @return A \\code{\\link[base]{matrix}} of type \\code{\\link[base]{integer}} is\n#' returned, unless \\code{ties.method = \"average\"} when it is of type\n#' \\code{\\link[base]{numeric}}.\n#'\n#' The \\code{rowRanks()} function always returns an NxK\n#' \\code{\\link[base]{matrix}}, where N (K) is the number of rows (columns)\n#' whose ranks are calculated.\n#'\n#' The \\code{colRanks()} function returns an NxK \\code{\\link[base]{matrix}}, if\n#' \\code{preserveShape = TRUE}, otherwise a KxN \\code{\\link[base]{matrix}}.\n#'\n#' Any \\code{\\link[base]{names}} of \\code{x} are ignored and absent in the\n#' result.\n#'\n#' @details\n#'    The `matrixStats::rowRanks()` function can handle a lot of different\n#'    values for the `ties.method` argument. Users of the generic function\n#'    should however only rely on `max` and `average` because the other ones\n#'    are not guaranteed to be implemented:\n#'    \\describe{\n#'      \\item{`max`}{for values with identical values the maximum rank is\n#'        returned}\n#'      \\item{`average`}{for values with identical values the average of the\n#'        ranks they cover is returned. Note, that in this case the return\n#'        value is of type `numeric`.}\n#'    }\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowRanks}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowRanks]{colRanks}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item [base::rank]\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust\nsetGeneric(\"rowRanks\", function(x, rows = NULL, cols = NULL, ties.method = c(\"max\", \"average\"), ..., useNames = TRUE) standardGeneric(\"rowRanks\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowRanks <-  function(x, rows = NULL, cols = NULL,\n                               ties.method = c(\"max\", \"average\", \"first\", \"last\", \"random\", \"max\", \"min\", \"dense\"),\n                               dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowRanks(x = x, rows = rows, cols = cols, ties.method = ties.method, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowRanks\nsetMethod(\"rowRanks\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowRanks)\n\n#' @export\n#' @rdname rowRanks\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowRanks\", \"ANY\", make_default_method_def(\"rowRanks\"))\n\n\n\n#' @export\n#' @rdname rowRanks\nsetGeneric(\"colRanks\", function(x, rows = NULL, cols = NULL, ties.method = c(\"max\", \"average\"), ..., useNames = TRUE) standardGeneric(\"colRanks\"),\n           signature = \"x\"\n)\n\n.matrixStats_colRanks <-  function(x, rows = NULL, cols = NULL,\n                               ties.method = c(\"max\", \"average\", \"first\", \"last\", \"random\", \"max\", \"min\", \"dense\"),\n                               dim. = dim(x), preserveShape = FALSE, ..., useNames = TRUE){\n  matrixStats::colRanks(x = x, rows = rows, cols = cols, ties.method = ties.method, dim. = dim., preserveShape = preserveShape, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowRanks\nsetMethod(\"colRanks\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colRanks)\n\n#' @export\n#' @rdname rowRanks\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colRanks\", \"ANY\", make_default_method_def(\"colRanks\"))\n\n",
        "rowSdDiffs.R": "#' Calculates the standard deviation of the difference between each element of\n#' a row (column) of a matrix-like object\n#'\n#' Calculates the standard deviation of the difference between each element of\n#' a row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowSdDiffs\n#'\n#' @templateVar rowName rowSdDiffs\n#' @templateVar colName colSdDiffs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template diff_trimParameters\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:varDiff]{rowSdDiffs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:varDiff]{colSdDiffs}()} which are\n#'   used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item for the direct standard deviation see [rowSds()].\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowSdDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0,  ..., useNames = TRUE) standardGeneric(\"rowSdDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowSdDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::rowSdDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowSdDiffs\nsetMethod(\"rowSdDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowSdDiffs)\n\n#' @export\n#' @rdname rowSdDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowSdDiffs\", \"ANY\", make_default_method_def(\"rowSdDiffs\"))\n\n\n\n#' @export\n#' @rdname rowSdDiffs\nsetGeneric(\"colSdDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"colSdDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colSdDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::colSdDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowSdDiffs\nsetMethod(\"colSdDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colSdDiffs)\n\n#' @export\n#' @rdname rowSdDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colSdDiffs\", \"ANY\", make_default_method_def(\"colSdDiffs\"))\n\n",
        "rowSds.R": "#' Calculates the standard deviation for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the standard deviation for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowSds\n#'\n#' @templateVar rowName rowSds\n#' @templateVar colName colSds\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @param center (optional) the center, defaults to the row means\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowSds}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowSds]{colSds}()} which are used when\n#'   the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For mean estimates, see \\code{\\link{rowMeans2}()} and\n#'   \\code{\\link[base:colSums]{rowMeans}()}.\n#' \\item For variance estimates, see \\code{\\link{rowVars}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowSds\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, ..., useNames = TRUE) standardGeneric(\"rowSds\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowSds <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, dim. = dim(x), ..., useNames = TRUE){\n  center <- normarg_center(center, nrow(x), \"nrow(x)\")\n  matrixStats::rowSds(x, rows = rows, cols = cols, na.rm = na.rm, center = center, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowSds\nsetMethod(\"rowSds\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowSds)\n\n#' @export\n#' @rdname rowSds\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowSds\", \"ANY\", make_default_method_def(\"rowSds\"))\n\n\n\n#' @export\n#' @rdname rowSds\nsetGeneric(\"colSds\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, ..., useNames = TRUE) standardGeneric(\"colSds\"),\n           signature = \"x\"\n)\n\n.matrixStats_colSds <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, dim. = dim(x), ..., useNames = TRUE){\n  center <- normarg_center(center, ncol(x), \"ncol(x)\")\n  matrixStats::colSds(x, rows = rows, cols = cols, na.rm = na.rm, center = center, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowSds\nsetMethod(\"colSds\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colSds)\n\n#' @export\n#' @rdname rowSds\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colSds\", \"ANY\", make_default_method_def(\"colSds\"))\n\n",
        "rowSums.R": "## IMPORTANT NOTE: We don't provide a user-friendly fallback mechanism for\n## rowSums() and colSums(). Here is why:\n## The method package defines **implicit generics** for the rowSums()\n## and colSums() functions and this is what we get when we call\n## setGeneric(\"rowSums\") and setGeneric(\"colSums\") below. These implicit\n## generics introduce 2 surprises:\n## 1. Their argument list (x, na.rm=FALSE, dims=1, ...) differs slightly from\n##    base::rowSums and base::colSums. This means that we need to be careful\n##    to use this same exact argument list in the rowSums() and colSums()\n##    methods that we define below.\n## 2. They define their own default method that basically calls base::rowSums()\n##    or base::colSums(). Unfortunately, trying to override these default\n##    methods with our own doesn't work. Even if selectMethod(\"rowSums\", \"ANY\")\n##    and selectMethod(\"colSums\", \"ANY\") return our methods right after\n##    loading MatrixGenerics in a fresh R session, this is no longer the case\n##    if we then load the DelayedArray package. Then the default methods get\n##    replaced with the original default methods defined by the implicit\n##    generics. VERY NASTY! This is why our attempts at providing user-friendly\n##    fallback mechanisms for rowSums() and colSums() are commented out below.\n\n\n#' Calculates the sum for each row (column) of a matrix-like object\n#'\n#' Calculates the sum for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowSums\n#'\n#' @templateVar rowName rowSums\n#' @templateVar colName colSums\n#'\n#' @param x An NxK matrix-like object, a numeric data frame, or an array-like\n#' object of two or more dimensions.\n#' @template na_rmParameter\n#' @param dims A single integer indicating which dimensions are regarded\n#' as rows or columns to sum over. For \\code{rowSums}, the sum is over\n#' dimensions \\code{dims+1, ...}; for \\code{colSums} it is over\n#' dimensions \\code{1:dims}.\n#' @param ... Additional arguments passed to specific methods.\n#'\n#' @details This man page documents the \\code{rowSums} and \\code{colSums}\n#' \\emph{S4 generic functions} defined in the \\pkg{MatrixGenerics} package.\n#' See \\code{?base::\\link[base]{colSums}} for the default methods (defined\n#' in the \\pkg{base} package).\n# #' The S4 methods for \\code{x} of type \\code{\\link{matrix}},\n# #' \\code{\\link{array}}, \\code{\\link{table}}, \\code{\\link{numeric}}, or\n# #' \\code{\\link{data.frame}} call \\code{base::\\link[base]{rowSums}} /\n# #' \\code{base::\\link[base]{colSums}}.\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{base::\\link[base]{colSums}} for the default\n#'       \\code{rowSums} and \\code{colSums} methods.\n#' \\item \\code{Matrix::\\link[Matrix]{colSums}} in the \\pkg{Matrix} package\n#'       for \\code{rowSums} and \\code{colSums} methods defined for\n#'       CsparseMatrix derivatives (e.g. dgCMatrix objects).\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array algebra arith iteration robust univar\nsetGeneric(\"rowSums\")\n\n# .base_rowSums <- function(x, na.rm=FALSE, dims=1, ...)\n# {\n#     base::rowSums(x, na.rm=na.rm, dims=dims, ...)\n# }\n#\n# #' @export\n# #' @rdname rowSums\n# setMethod(\"rowSums\", \"matrix_OR_array_OR_table_OR_numeric\", .base_rowSums)\n#\n# #' @export\n# #' @rdname rowSums\n# setMethod(\"rowSums\", \"data.frame\", .base_rowSums)\n#\n# #' @export\n# #' @rdname rowSums\n# ## Override default method of implicit generic with user-friendly fallback\n# ## mechanism.\n# setMethod(\"rowSums\", \"ANY\", make_default_method_def(\"rowSums\"))\n\n\n#' @export\n#' @rdname rowSums\nsetGeneric(\"colSums\")\n\n# .base_colSums <- function(x, na.rm=FALSE, dims=1, ...)\n# {\n#     base::colSums(x, na.rm=na.rm, dims=dims, ...)\n# }\n#\n# #' @export\n# #' @rdname rowSums\n# setMethod(\"colSums\", \"matrix_OR_array_OR_table_OR_numeric\", .base_colSums)\n#\n# #' @export\n# #' @rdname rowSums\n# setMethod(\"colSums\", \"data.frame\", .base_colSums)\n#\n# #' @export\n# #' @rdname rowSums\n# ## Override default method of implicit generic with user-friendly fallback\n# ## mechanism.\n# setMethod(\"colSums\", \"ANY\", make_default_method_def(\"colSums\"))\n\n",
        "rowSums2.R": "#' Calculates the sum for each row (column) of a matrix-like object\n#'\n#' Calculates the sum for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowSums2\n#'\n#' @templateVar rowName rowSums2\n#' @templateVar colName colSums2\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowSums2}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowSums2]{colSums2}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For mean estimates, see \\code{\\link{rowMeans2}()} and\n#'   \\code{\\link[base:colSums]{rowMeans}()}.\n#' \\item \\code{base::\\link{sum}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowSums2\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowSums2\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowSums2 <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::rowSums2(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowSums2\nsetMethod(\"rowSums2\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowSums2)\n\n#' @export\n#' @rdname rowSums2\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowSums2\", \"ANY\", make_default_method_def(\"rowSums2\"))\n\n\n\n#' @export\n#' @rdname rowSums2\nsetGeneric(\"colSums2\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colSums2\"),\n           signature = \"x\"\n)\n\n.matrixStats_colSums2 <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE){\n  matrixStats::colSums2(x, rows = rows, cols = cols, na.rm = na.rm, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowSums2\nsetMethod(\"colSums2\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colSums2)\n\n#' @export\n#' @rdname rowSums2\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colSums2\", \"ANY\", make_default_method_def(\"colSums2\"))\n\n",
        "rowTabulates.R": "#' Tabulates the values in a matrix-like object by row (column)\n#'\n#' Tabulates the values in a matrix-like object by row (column).\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowTabulates\n#'\n#' @templateVar rowName rowTabulates\n#' @templateVar colName colTabulates\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @param values the values to search for.\n#' @template useNamesParameter\n#'\n#' @template returnMatrix_JDim\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowTabulates}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowTabulates]{colTabulates}()} which\n#'   are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item \\code{base::\\link{table}()}\n#' }\n#'\n#' @examples\n#'   mat <- matrix(rpois(15, lambda = 3), nrow = 5, ncol = 3)\n#'   mat[2, 1] <- NA_integer_\n#'   mat[3, 3] <- 0L\n#'   mat[4, 1] <- 0L\n#'\n#'   print(mat)\n#'\n#'   rowTabulates(mat)\n#'   colTabulates(mat)\n#'\n#'   rowTabulates(mat, values = 0)\n#'   colTabulates(mat, values = 0)\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowTabulates\", function(x, rows = NULL, cols = NULL, values = NULL, ..., useNames = TRUE) standardGeneric(\"rowTabulates\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowTabulates <- function(x, rows = NULL, cols = NULL, values = NULL, ..., useNames = TRUE){\n  matrixStats::rowTabulates(x, rows = rows, cols = cols, values = values, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowTabulates\nsetMethod(\"rowTabulates\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowTabulates)\n\n#' @export\n#' @rdname rowTabulates\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowTabulates\", \"ANY\", make_default_method_def(\"rowTabulates\"))\n\n\n\n#' @export\n#' @rdname rowTabulates\nsetGeneric(\"colTabulates\", function(x, rows = NULL, cols = NULL, values = NULL, ..., useNames = TRUE) standardGeneric(\"colTabulates\"),\n           signature = \"x\"\n)\n\n.matrixStats_colTabulates <- function(x, rows = NULL, cols = NULL, values = NULL, ..., useNames = TRUE){\n  matrixStats::colTabulates(x, rows = rows, cols = cols, values = values, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowTabulates\nsetMethod(\"colTabulates\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colTabulates)\n\n#' @export\n#' @rdname rowTabulates\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colTabulates\", \"ANY\", make_default_method_def(\"colTabulates\"))\n\n",
        "rowVarDiffs.R": "#' Calculates the variance of the difference between each element of a row\n#' (column) of a matrix-like object\n#'\n#' Calculates the variance of the difference between each element of a row\n#' (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowVarDiffs\n#'\n#' @templateVar rowName rowVarDiffs\n#' @templateVar colName colVarDiffs\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template diff_trimParameters\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:varDiff]{rowVarDiffs}()} and\n#'   \\code{matrixStats::\\link[matrixStats:varDiff]{colVarDiffs}()} which\n#'   are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item for the direct variance see [rowVars()].\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowVarDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"rowVarDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowVarDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::rowVarDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowVarDiffs\nsetMethod(\"rowVarDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowVarDiffs)\n\n#' @export\n#' @rdname rowVarDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowVarDiffs\", \"ANY\", make_default_method_def(\"rowVarDiffs\"))\n\n\n\n#' @export\n#' @rdname rowVarDiffs\nsetGeneric(\"colVarDiffs\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE) standardGeneric(\"colVarDiffs\"),\n           signature = \"x\"\n)\n\n.matrixStats_colVarDiffs <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE){\n  matrixStats::colVarDiffs(x, rows = rows, cols = cols, na.rm = na.rm, diff = diff, trim = trim, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowVarDiffs\nsetMethod(\"colVarDiffs\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colVarDiffs)\n\n#' @export\n#' @rdname rowVarDiffs\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colVarDiffs\", \"ANY\", make_default_method_def(\"colVarDiffs\"))\n\n",
        "rowVars.R": "#' Calculates the variance for each row (column) of a matrix-like object\n#'\n#' Calculates the variance for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowVars\n#'\n#' @templateVar rowName rowVars\n#' @templateVar colName colVars\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template na_rmParameter\n#' @param center (optional) the center, defaults to the row means.\n#' @template dimParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowVars}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowVars]{colVars}()} which are used\n#'   when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item For mean estimates, see \\code{\\link{rowMeans2}()} and\n#'   \\code{\\link[base:colSums]{rowMeans}()}.\n#' \\item For standard deviation estimates, see \\code{\\link{rowSds}()}.\n#' \\item \\code{stats::\\link[stats:cor]{var}()}.\n#' }\n#'\n#' @template standardExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowVars\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, ..., useNames = TRUE) standardGeneric(\"rowVars\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowVars <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, dim. = dim(x), ..., useNames = TRUE){\n  center <- normarg_center(center, nrow(x), \"nrow(x)\")\n  matrixStats::rowVars(x, rows = rows, cols = cols, na.rm = na.rm, center = center, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowVars\nsetMethod(\"rowVars\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowVars)\n\n#' @export\n#' @rdname rowVars\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowVars\", \"ANY\", make_default_method_def(\"rowVars\"))\n\n\n\n#' @export\n#' @rdname rowVars\nsetGeneric(\"colVars\", function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, ..., useNames = TRUE) standardGeneric(\"colVars\"),\n           signature = \"x\"\n)\n\n.matrixStats_colVars <- function(x, rows = NULL, cols = NULL, na.rm = FALSE, center = NULL, dim. = dim(x), ..., useNames = TRUE){\n  center <- normarg_center(center, ncol(x), \"ncol(x)\")\n  matrixStats::colVars(x, rows = rows, cols = cols, na.rm = na.rm, center = center, dim. = dim., ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowVars\nsetMethod(\"colVars\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colVars)\n\n#' @export\n#' @rdname rowVars\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colVars\", \"ANY\", make_default_method_def(\"colVars\"))\n\n",
        "rowWeightedMads.R": "#' Calculates the weighted median absolute deviation for each row (column) of a\n#' matrix-like object\n#'\n#' Calculates the weighted  median absolute deviation for each row (column) of\n#' a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowWeightedMads\n#'\n#' @templateVar rowName rowWeightedMads\n#' @templateVar colName colWeightedMads\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template weightParam\n#' @template na_rmParameter\n#' @template useNamesParameter\n#' @param center (optional) the center, defaults to the row means\n#' @param constant A scale factor. See \\code{stats::\\link[stats]{mad}()} for\n#'   details.\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:weightedMad]{rowWeightedMads}()} and\n#'   \\code{matrixStats::\\link[matrixStats:weightedMad]{colWeightedMads}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item See also [rowMads] for the corresponding unweighted function.\n#' }\n#'\n#' @template weightedExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowWeightedMads\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, constant = 1.4826, center = NULL, ..., useNames = TRUE) standardGeneric(\"rowWeightedMads\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowWeightedMads <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,  constant = 1.4826, center = NULL, ..., useNames = TRUE){\n  center <- normarg_center(center, nrow(x), \"nrow(x)\")\n  matrixStats::rowWeightedMads(x, w = w, rows = rows, cols = cols, na.rm = na.rm, constant = constant, center = center, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedMads\nsetMethod(\"rowWeightedMads\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowWeightedMads)\n\n#' @export\n#' @rdname rowWeightedMads\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowWeightedMads\", \"ANY\", make_default_method_def(\"rowWeightedMads\"))\n\n\n\n#' @export\n#' @rdname rowWeightedMads\nsetGeneric(\"colWeightedMads\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, constant = 1.4826, center = NULL, ..., useNames = TRUE) standardGeneric(\"colWeightedMads\"),\n           signature = \"x\"\n)\n\n.matrixStats_colWeightedMads <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE,  constant = 1.4826, center = NULL, ..., useNames = TRUE){\n  center <- normarg_center(center, ncol(x), \"ncol(x)\")\n  matrixStats::colWeightedMads(x, w = w, rows = rows, cols = cols, na.rm = na.rm, constant = constant, center = center, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedMads\nsetMethod(\"colWeightedMads\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colWeightedMads)\n\n#' @export\n#' @rdname rowWeightedMads\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colWeightedMads\", \"ANY\", make_default_method_def(\"colWeightedMads\"))\n\n",
        "rowWeightedMeans.R": "#' Calculates the weighted mean for each row (column) of a matrix-like object\n#'\n#' Calculates the weighted  mean for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowWeightedMeans\n#'\n#' @templateVar rowName rowWeightedMeans\n#' @templateVar colName colWeightedMeans\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template weightParam\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowWeightedMeans}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowWeightedMeans]{colWeightedMeans}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item See also [rowMeans2] for the corresponding unweighted function.\n#' }\n#'\n#' @template weightedExamples\n#'\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowWeightedMeans\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowWeightedMeans\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowWeightedMeans <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::rowWeightedMeans(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedMeans\nsetMethod(\"rowWeightedMeans\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowWeightedMeans)\n\n#' @export\n#' @rdname rowWeightedMeans\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowWeightedMeans\", \"ANY\", make_default_method_def(\"rowWeightedMeans\"))\n\n\n\n#' @export\n#' @rdname rowWeightedMeans\nsetGeneric(\"colWeightedMeans\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colWeightedMeans\"),\n           signature = \"x\"\n)\n\n.matrixStats_colWeightedMeans <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::colWeightedMeans(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedMeans\nsetMethod(\"colWeightedMeans\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colWeightedMeans)\n\n#' @export\n#' @rdname rowWeightedMeans\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colWeightedMeans\", \"ANY\", make_default_method_def(\"colWeightedMeans\"))\n\n",
        "rowWeightedMedians.R": "#' Calculates the weighted median for each row (column) of a matrix-like object\n#'\n#' Calculates the weighted median for each row (column) of a matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowWeightedMedians\n#'\n#' @templateVar rowName rowWeightedMedians\n#' @templateVar colName colWeightedMedians\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template weightParam\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats]{rowWeightedMedians}()} and\n#'   \\code{matrixStats::\\link[matrixStats:rowWeightedMedians]{colWeightedMedians}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item See also [rowMedians] for the corresponding unweighted function.\n#' }\n#'\n#' @template weightedExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowWeightedMedians\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowWeightedMedians\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowWeightedMedians <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::rowWeightedMedians(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedMedians\nsetMethod(\"rowWeightedMedians\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowWeightedMedians)\n\n#' @export\n#' @rdname rowWeightedMedians\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowWeightedMedians\", \"ANY\", make_default_method_def(\"rowWeightedMedians\"))\n\n\n\n#' @export\n#' @rdname rowWeightedMedians\nsetGeneric(\"colWeightedMedians\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colWeightedMedians\"),\n           signature = \"x\"\n)\n\n.matrixStats_colWeightedMedians <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::colWeightedMedians(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedMedians\nsetMethod(\"colWeightedMedians\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colWeightedMedians)\n\n#' @export\n#' @rdname rowWeightedMedians\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colWeightedMedians\", \"ANY\", make_default_method_def(\"colWeightedMedians\"))\n\n",
        "rowWeightedSds.R": "#' Calculates the weighted standard deviation for each row (column) of a\n#' matrix-like object\n#'\n#' Calculates the weighted standard deviation for each row (column) of a\n#' matrix-like object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowWeightedSds\n#'\n#' @templateVar rowName rowWeightedSds\n#' @templateVar colName colWeightedSds\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template weightParam\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:weightedVar]{rowWeightedSds}()} and\n#'   \\code{matrixStats::\\link[matrixStats:weightedVar]{colWeightedSds}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item See also [rowSds] for the corresponding unweighted function.\n#' }\n#'\n#' @template weightedExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowWeightedSds\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowWeightedSds\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowWeightedSds <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::rowWeightedSds(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedSds\nsetMethod(\"rowWeightedSds\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowWeightedSds)\n\n#' @export\n#' @rdname rowWeightedSds\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowWeightedSds\", \"ANY\", make_default_method_def(\"rowWeightedSds\"))\n\n\n\n#' @export\n#' @rdname rowWeightedSds\nsetGeneric(\"colWeightedSds\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colWeightedSds\"),\n           signature = \"x\"\n)\n\n.matrixStats_colWeightedSds <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::colWeightedSds(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedSds\nsetMethod(\"colWeightedSds\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colWeightedSds)\n\n#' @export\n#' @rdname rowWeightedSds\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colWeightedSds\", \"ANY\", make_default_method_def(\"colWeightedSds\"))\n\n",
        "rowWeightedVars.R": "#' Calculates the weighted variance for each row (column) of a matrix-like\n#' object\n#'\n#' Calculates the weighted variance for each row (column) of a matrix-like\n#' object.\n#'\n#' @include MatrixGenerics-package.R\n#'\n#' @export\n#' @name rowWeightedVars\n#'\n#' @templateVar rowName rowWeightedVars\n#' @templateVar colName colWeightedVars\n#'\n#' @template matrixStatsLink\n#'\n#' @template standardParameters\n#' @template weightParam\n#' @template na_rmParameter\n#' @template useNamesParameter\n#'\n#' @template returnVector\n#'\n#' @seealso\n#' \\itemize{\n#' \\item \\code{matrixStats::\\link[matrixStats:weightedVar]{rowWeightedVars}()} and\n#'   \\code{matrixStats::\\link[matrixStats:weightedVar]{colWeightedVars}()}\n#'   which are used when the input is a \\code{matrix} or \\code{numeric} vector.\n#' \\item See also [rowVars] for the corresponding unweighted function.\n#' }\n#'\n#' @template weightedExamples\n#'\n#' @keywords array iteration robust univar\nsetGeneric(\"rowWeightedVars\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"rowWeightedVars\"),\n           signature = \"x\"\n)\n\n.matrixStats_rowWeightedVars <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::rowWeightedVars(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedVars\nsetMethod(\"rowWeightedVars\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_rowWeightedVars)\n\n#' @export\n#' @rdname rowWeightedVars\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"rowWeightedVars\", \"ANY\", make_default_method_def(\"rowWeightedVars\"))\n\n\n\n#' @export\n#' @rdname rowWeightedVars\nsetGeneric(\"colWeightedVars\", function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE) standardGeneric(\"colWeightedVars\"),\n           signature = \"x\"\n)\n\n.matrixStats_colWeightedVars <- function(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE){\n  matrixStats::colWeightedVars(x, w = w, rows = rows, cols = cols, na.rm = na.rm, ..., useNames = useNames)\n}\n\n#' @export\n#' @rdname rowWeightedVars\nsetMethod(\"colWeightedVars\", \"matrix_OR_array_OR_table_OR_numeric\", .matrixStats_colWeightedVars)\n\n#' @export\n#' @rdname rowWeightedVars\n## Default method with user-friendly fallback mechanism.\nsetMethod(\"colWeightedVars\", \"ANY\", make_default_method_def(\"colWeightedVars\"))\n\n"
    },
    "S4Arrays": {
        "Array-class.R": "### =========================================================================\n### Array objects\n### -------------------------------------------------------------------------\n\n\n### A virtual class with no slots to be extended by concrete subclasses with\n### an array-like semantic.\nsetClass(\"Array\", representation(\"VIRTUAL\"))\n\n### Note that some objects with dimensions (i.e. with a non-NULL dim()) can\n### have a length() that is not 'prod(dim(x))' e.g. data-frame-like objects\n### (for which 'length(x)' is 'ncol(x)') and SummarizedExperiment derivatives\n### (for which 'length(x)' is 'nrow(x)').\n### Terminology: Should we still consider that these objects are \"array-like\"\n### or \"matrix-like\"? Or should these terms be used only for objects that\n### have dimensions **and** have a length() defined as 'prod(dim(x))'?\n\n### Even though prod() always returns a double, it seems that the length()\n### primitive function takes care of turning this double into an integer if\n### it's <= .Machine$integer.max\nsetMethod(\"length\", \"Array\", function(x) prod(dim(x)))\n\nsetMethod(\"isEmpty\", \"Array\", function(x) any(dim(x) == 0L))\n\n### 'subscripts' is assumed to be an integer vector parallel to 'dim(x)' and\n### with no out-of-bounds subscripts (i.e. 'all(subscripts >= 1)' and\n### 'all(subscripts <= dim(x))').\n### NOT exported for now but should probably be at some point (like\n### S4Vectors::getListElement() is).\nsetGeneric(\"getArrayElement\", signature=\"x\",\n    function(x, subscripts) standardGeneric(\"getArrayElement\")\n)\n\n### Support multidimensional and linear subsetting.\n### TODO: Multidimensional subsetting should support things like\n###       x[[5, 15, 2]] and x[[\"E\", 15, \"b\"]].\n### TODO: Linear subsetting should support a single *numeric* subscript.\nsetMethod(\"[[\", \"Array\",\n    function(x, i, j, ...)\n    {\n        if (missing(x))\n            stop(\"'x' is missing\")\n        Nindex <- extract_Nindex_from_syscall(sys.call(), parent.frame())\n        nsubscript <- length(Nindex)\n        x_dim <- dim(x)\n        x_ndim <- length(x_dim)\n        if (!(nsubscript == x_ndim || nsubscript == 1L))\n            stop(\"incorrect number of subscripts\")\n        ok <- vapply(Nindex, isSingleInteger, logical(1), USE.NAMES=FALSE)\n        if (!all(ok))\n            stop(wmsg(\"each subscript must be a single integer \",\n                      \"when subsetting an \", class(x), \" object with [[\"))\n        if (nsubscript == x_ndim) {\n            ## Multidimensional subsetting.\n            subscripts <- unlist(Nindex, use.names=FALSE)\n            if (!(all(subscripts >= 1L) && all(subscripts <= x_dim)))\n                stop(\"some subscripts are out of bounds\")\n        } else {\n            ## Linear subsetting.\n            ## We turn this into a multidimensional subsetting by\n            ## transforming the user-supplied linear index into an array\n            ## (i.e. multidimensional) index.\n            i <- Nindex[[1L]]\n            if (i < 1L || i > prod(x_dim))\n                stop(\"subscript is out of bounds\")\n            subscripts <- as.integer(arrayInd(i, x_dim))\n        }\n        getArrayElement(x, subscripts)\n    }\n)\n\n.SLICING_TIP <- c(\n    \"Consider reducing its number of effective dimensions by slicing it \",\n    \"first (e.g. x[8, 30, , 2, ]). Make sure that all the indices used for \",\n    \"the slicing have length 1 except at most 2 of them which can be of \",\n    \"arbitrary length or missing.\"\n)\n\n.from_Array_to_matrix <- function(x)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.matrix method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array in the extract_array.R\n        ## file for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" S3 as.matrix method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.matrix(x))\n        }\n    }\n    x_dim <- dim(x)\n    if (sum(x_dim != 1L) > 2L)\n        stop(wmsg(class(x), \" object has more than 2 effective dimensions \",\n                  \"--> cannot coerce it to a matrix. \", .SLICING_TIP))\n    ans <- drop(as.array(x))  # this could drop all the dimensions!\n    if (length(x_dim) == 2L) {\n        ans <- set_dim(ans, x_dim)\n        ans <- set_dimnames(ans, dimnames(x))\n    } else {\n        as.matrix(ans)\n    }\n    ans\n}\n\n### S3/S4 combo for as.matrix.Array\nas.matrix.Array <- function(x, ...) .from_Array_to_matrix(x, ...)\nsetMethod(\"as.matrix\", \"Array\", .from_Array_to_matrix)\n\n### S3/S4 combo for t.Array\n### t() will work out-of-the-box on any Array derivative that supports aperm().\nt.Array <- function(x)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any t method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array in the extract_array.R\n        ## file for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" S3 t method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::t(x))\n        }\n    }\n    if (length(dim(x)) != 2L)\n        stop(wmsg(\"the \", class(x), \" object to transpose \",\n                  \"must have exactly 2 dimensions\"))\n    aperm(x)\n}\nsetMethod(\"t\", \"Array\", t.Array)\n\n",
        "Array-kronecker-methods.R": "### =========================================================================\n### kronecker() methods for Array objects\n### -------------------------------------------------------------------------\n###\n\n\n.normarg_X <- function(X, ndim, argname=\"X\")\n{\n    X_dim <- dim(X)\n    if (is.null(X_dim))\n        stop(wmsg(\"'\", argname, \"' must be an array-like object (or a vector)\"))\n    if (length(X_dim) >= ndim)\n        return(X)\n    set_dim(X, rpad_dim(X_dim, ndim))\n}\n\n.make_kronecker_dinmames <- function(Ldimnames, Rdimnames, ndim)\n{\n    if (is.null(Ldimnames) && is.null(Rdimnames))\n        return(NULL)\n    lapply(seq_len(ndim),\n        function(along) {\n            Ldn <- Ldimnames[[along]]\n            Rdn <- Rdimnames[[along]]\n            ## base::kronecker() will still combine the dimnames along a\n            ## given dimension even if there's nothing to combine. As a result\n            ## the returned object gets a bunch of meaningless \":\" names along\n            ## that dimension. We don't do that.\n            if (is.null(Ldn) && is.null(Rdn))\n                return(NULL)\n            paste0(Ldn, \":\", Rdn)\n        })\n}\n\n### A simple re-implementation of base::kronecker() based on arep_times()\n### and arep_each() with the main difference that kronecker2() acts as an\n### endomorphism when 'X' and 'Y' have the same class.\nkronecker2 <- function(X, Y, FUN=\"*\", make.dimnames=FALSE, ...)\n{\n    FUN <- match.fun(FUN)\n    if (!isTRUEorFALSE(make.dimnames))\n        stop(wmsg(\"'make.dimnames' must be TRUE or FALSE\"))\n    if (is.vector(X))\n        X <- as.array(X)  # 1D-array\n    if (is.vector(Y))\n        Y <- as.array(Y)  # 1D-array\n    X <- .normarg_X(X, length(dim(Y)), argname=\"X\")\n    Y <- .normarg_X(Y, length(dim(X)), argname=\"Y\")\n    XX <- arep_each(X, each=dim(Y))\n    YY <- arep_times(Y, times=dim(X))\n    ans <- set_dim(FUN(XX, YY, ...), dim(XX))\n    if (make.dimnames) {\n        ans_dimnames <- .make_kronecker_dinmames(dimnames(XX), dimnames(YY),\n                                                 length(dim(ans)))\n    } else {\n        ans_dimnames <- NULL\n    }\n    set_dimnames(ans, ans_dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### kronecker() methods for Array objects\n###\n\nsetMethod(\"kronecker\", c(\"Array\", \"ANY\"), kronecker2)\nsetMethod(\"kronecker\", c(\"ANY\", \"Array\"), kronecker2)\nsetMethod(\"kronecker\", c(\"Array\", \"Array\"), kronecker2)\n\n",
        "Array-subassignment.R": "### =========================================================================\n### Array subassignment\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level generics to support subassignment of Array derivatives\n###\n### We define 4 low-level generics that are called by the \"[<-\" method for\n### Array objects defined below in this file. The aim is to falicitate the\n### implementation of subassignment operations on array-like S4 objects.\n###\n\nsetGeneric(\"subassign_Array_by_logical_array\", signature=\"x\",\n    function(x, y, value) standardGeneric(\"subassign_Array_by_logical_array\")\n)\nsetGeneric(\"subassign_Array_by_Lindex\", signature=\"x\",\n    function(x, Lindex, value) standardGeneric(\"subassign_Array_by_Lindex\")\n)\nsetGeneric(\"subassign_Array_by_Mindex\", signature=\"x\",\n    function(x, Mindex, value) standardGeneric(\"subassign_Array_by_Mindex\")\n)\nsetGeneric(\"subassign_Array_by_Nindex\", signature=\"x\",\n    function(x, Nindex, value) standardGeneric(\"subassign_Array_by_Nindex\")\n)\n\nsetMethod(\"subassign_Array_by_logical_array\", \"Array\",\n    function(x, y, value)\n        stop(wmsg(class(x)[[1L]], \" objects don't support this \",\n                  \"form of subassignment at the moment\"))\n)\n\nsetMethod(\"subassign_Array_by_Lindex\", \"Array\",\n    function(x, Lindex, value)\n        stop(wmsg(class(x)[[1L]], \" objects don't support this \",\n                  \"form of subassignment at the moment\"))\n)\n\n### Simply delegates to subassign_Array_by_Lindex().\n.subassign_Array_by_Mindex <- function(x, Mindex, value)\n{\n    stopifnot(is.matrix(Mindex), is.numeric(Mindex))\n    subassign_Array_by_Lindex(x, Mindex2Lindex(Mindex, dim(x)), value)\n}\n\nsetMethod(\"subassign_Array_by_Mindex\", \"Array\", .subassign_Array_by_Mindex)\n\nsetMethod(\"subassign_Array_by_Nindex\", \"Array\",\n    function(x, Nindex, value)\n        stop(wmsg(class(x)[[1L]], \" objects don't support this \",\n                  \"form of subassignment at the moment\"))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"[<-\" method for Array objects\n###\n\n### Works on any array-like object that supports the 4 low-level generics\n### above.\n.subassign_Array <- function(x, i, j, ..., value)\n{\n    if (missing(x))\n        stop(wmsg(\"'x' is missing\"))\n    Nindex <- extract_Nindex_from_syscall(sys.call(), parent.frame())\n    nsubscript <- length(Nindex)\n    x_dim <- dim(x)\n    x_ndim <- length(x_dim)\n    if (nsubscript == 1L) {\n        i <- Nindex[[1L]]\n        if (type(i) == \"logical\" && identical(x_dim, dim(i)))\n            return(subassign_Array_by_logical_array(x, i, value))\n        if (is.matrix(i) && is.numeric(i))\n            return(subassign_Array_by_Mindex(x, i, value))\n        ## Linear single bracket subassignment e.g. x[5:2] <- 4.\n        return(subassign_Array_by_Lindex(x, i, value))\n    }\n    if (nsubscript != x_ndim)\n        stop(wmsg(\"incorrect number of subscripts\"))\n    Nindex <- normalize_Nindex(Nindex, x)\n    subassign_Array_by_Nindex(x, Nindex, value)\n}\n\nsetReplaceMethod(\"[\", \"Array\", .subassign_Array)\n\n",
        "Array-subsetting.R": "### =========================================================================\n### Array subsetting\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level generics to support subsetting of Array derivatives\n###\n### We define 4 low-level generics that are called by the \"[\" method for\n### Array objects defined below in this file. The aim is to falicitate the\n### implementation of subsetting operations on array-like S4 objects.\n###\n\nsetGeneric(\"subset_Array_by_logical_array\", signature=\"x\",\n    function(x, y) standardGeneric(\"subset_Array_by_logical_array\")\n)\nsetGeneric(\"subset_Array_by_Lindex\", signature=\"x\",\n    function(x, Lindex) standardGeneric(\"subset_Array_by_Lindex\")\n)\nsetGeneric(\"subset_Array_by_Mindex\", signature=\"x\",\n    function(x, Mindex) standardGeneric(\"subset_Array_by_Mindex\")\n)\nsetGeneric(\"subset_Array_by_Nindex\", signature=\"x\",\n    function(x, Nindex) standardGeneric(\"subset_Array_by_Nindex\")\n)\n\nsetMethod(\"subset_Array_by_logical_array\", \"Array\",\n    function(x, y)\n        stop(wmsg(class(x)[[1L]], \" objects don't support this \",\n                  \"form of subsetting at the moment\"))\n)\n\nsetMethod(\"subset_Array_by_Lindex\", \"Array\",\n    function(x, Lindex)\n        stop(wmsg(class(x)[[1L]], \" objects don't support this \",\n                  \"form of subsetting at the moment\"))\n)\n\n### Simply delegates to subset_Array_by_Lindex().\n.subset_Array_by_Mindex <- function(x, Mindex)\n{\n    stopifnot(is.matrix(Mindex), is.numeric(Mindex))\n    subset_Array_by_Lindex(x, Mindex2Lindex(Mindex, dim(x)))\n}\n\nsetMethod(\"subset_Array_by_Mindex\", \"Array\", .subset_Array_by_Mindex)\n\nsetMethod(\"subset_Array_by_Nindex\", \"Array\",\n    function(x, Nindex)\n        stop(wmsg(class(x)[[1L]], \" objects don't support this \",\n                  \"form of subsetting at the moment\"))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### \"[\" method for Array objects\n###\n\n### Works on any array-like object that supports the 4 low-level generics\n### above.\n.subset_Array <- function(x, i, j, ..., drop=TRUE)\n{\n    if (missing(x))\n        stop(wmsg(\"'x' is missing\"))\n    if (!isTRUEorFALSE(drop))\n        stop(wmsg(\"'drop' must be TRUE or FALSE\"))\n    Nindex <- extract_Nindex_from_syscall(sys.call(), parent.frame())\n    nsubscript <- length(Nindex)\n    if (nsubscript == 0L)\n        return(x)  # no-op\n    x_dim <- dim(x)\n    if (nsubscript == 1L && drop) {\n        i <- Nindex[[1L]]\n        if (type(i) == \"logical\" && identical(x_dim, dim(i)))\n            return(subset_Array_by_logical_array(x, i))\n        if (is.matrix(i))\n            return(subset_Array_by_Mindex(x, i))\n        if (is.numeric(i))\n            return(subset_Array_by_Lindex(x, i))\n    }\n    if (nsubscript != length(x_dim))\n        stop(wmsg(\"incorrect number of subscripts\"))\n    ## Note that this normalization will coerce the numeric subscripts\n    ## in 'Nindex' to integer. However this coercion is no longer necessary\n    ## because subset_Array_by_Nindex() should be able to handle subscripts\n    ## of type \"double\".\n    ## TODO: Consider using a normalization process here that preserves the\n    ## numeric subscripts.\n    Nindex <- normalize_Nindex(Nindex, x)\n    ans <- subset_Array_by_Nindex(x, Nindex)\n    if (drop)\n        ans <- drop(ans)\n    ans\n}\n\nsetMethod(\"[\", \"Array\", .subset_Array)\n\n",
        "ArrayGrid-class.R": "### =========================================================================\n### ArrayViewport and ArrayGrid objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### ArrayViewport objects\n###\n\nsetClass(\"ArrayViewport\",\n    contains=\"Array\",\n    representation(\n        \"VIRTUAL\",\n        refdim=\"integer\"  # Dimensions of \"the reference array\" i.e. the\n                          # array on top of which the viewport is defined\n                          # (a.k.a. \"the underlying array\").\n    )\n)\n\n### Represent a viewport that covers the whole reference array i.e. that\n### has the same dimensions as the reference array.\n### IMPORTANT NOTE: Unlike SafeArrayViewport objects below, the length\n### of a DummyArrayViewport object (i.e. the number of array elements\n### in the viewport) is allowed to be > .Machine$integer.max. This makes\n### these objects **unsafe** to use in some contexts. For example a\n### DummyArrayViewport object can be used to extract a sparse block\n### that is too big to be handled safely:\n###   library(Matrix)\n###   m0 <- sparseMatrix(i=1, j=1, x=8, dims=c(5e4, 5e4))\n###   block0 <- read_block(m0, DummyArrayViewport(x), as.sparse=TRUE)\n###   m <- as(block0, \"dgCMatrix\")\n###   m + 1\n###   #Error in asMethod(object) :\n###   #  Cholmod error 'problem too large' at file ../Core/cholmod_dense.c, line 105\nsetClass(\"DummyArrayViewport\", contains=\"ArrayViewport\")\n\n### Represent an arbitrary viewport on the reference array with the\n### restriction that the length of the viewport (i.e. the number of\n### array elements in the viewport) must be <= .Machine$integer.max.\n### Unlike DummyArrayViewport objects above, this restriction on their\n### length makes these objects always **safe** to use.\n### Note that we don't extend the IRanges class because we don't want\n### to inherit the full Ranges API (most operations in that API would\n### do the wrong thing on SafeArrayViewport objects).\nsetClass(\"SafeArrayViewport\",\n    contains=\"ArrayViewport\",\n    representation(\n        ranges=\"IRanges\"  # One range per dimension.\n    )\n)\n\n### Validity\n\n.validate_ArrayViewport <- function(x)\n{\n    msg <- validate_dim_slot(x, \"refdim\")\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\nsetValidity2(\"ArrayViewport\", .validate_ArrayViewport)\n\n.validate_ranges_slot <- function(x)\n{\n    x_ranges <- x@ranges\n    x_refdim <- x@refdim\n    if (length(x_ranges) != length(x_refdim))\n        return(\"'ranges' and 'refdim' slots must have the same length\")\n\n    ## Check that the viewport is contained in the reference array.\n    x_start <- start(x_ranges)\n    x_end <- end(x_ranges)\n    if (!(all(x_start >= 1L) && all(x_end <= x_refdim)))\n        return(paste0(\"object represents a viewport that is not \",\n                      \"within the bounds of the reference array\"))\n\n    ## A viewport cannot be longer than 2^31 - 1.\n    x_dim <- width(x_ranges)\n    if (prod(x_dim) > .Machine$integer.max)\n        return(\"a viewport cannot be longer than .Machine$integer.max\")\n\n    TRUE\n}\n.validate_SafeArrayViewport <- function(x)\n{\n    msg <- .validate_ranges_slot(x)\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\nsetValidity2(\"SafeArrayViewport\", .validate_SafeArrayViewport)\n\n### Getters\n\nsetGeneric(\"refdim\", function(x) standardGeneric(\"refdim\"))\n\nsetMethod(\"refdim\", \"ArrayViewport\", function(x) x@refdim)\n\n.dims2ranges <- function(dim) IRanges(rep.int(1L, length(dim)), dim)\n\nsetMethod(\"ranges\", \"DummyArrayViewport\", function(x) .dims2ranges(refdim(x)))\nsetMethod(\"ranges\", \"SafeArrayViewport\", function(x) x@ranges)\n\nsetMethod(\"start\", \"ArrayViewport\", function(x) start(ranges(x)))\n\nsetMethod(\"width\", \"ArrayViewport\", function(x) width(ranges(x)))\n\nsetMethod(\"end\", \"ArrayViewport\", function(x) end(ranges(x)))\n\n### 'width(x)' and 'dim(x)' are synonyms.\nsetMethod(\"dim\", \"ArrayViewport\", function(x) width(ranges(x)))\n\n### Constructors\n\nDummyArrayViewport <- function(refdim)\n    new2(\"DummyArrayViewport\", refdim=refdim, check=TRUE)\n\n### If 'ranges' is omitted, return a viewport that covers the whole\n### reference array.\nArrayViewport <- function(refdim, ranges=NULL)\n{\n    if (is.null(ranges))\n        ranges <- .dims2ranges(refdim)\n    new2(\"SafeArrayViewport\", refdim=refdim, ranges=ranges, check=TRUE)\n}\n\n### Show\n\nsetMethod(\"classNameForDisplay\", \"ArrayViewport\", function(x) \"ArrayViewport\")\n\nmake_string_from_ArrayViewport <- function(viewport, dimnames=NULL,\n                                           as.2Dslice=FALSE,\n                                           collapse=\",\", with.brackets=FALSE)\n{\n    if (!isTRUEorFALSE(as.2Dslice))\n        stop(\"'as.2Dslice' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(with.brackets))\n        stop(\"'with.brackets' must be TRUE or FALSE\")\n\n    viewport_ranges <- ranges(viewport)\n    ans <- as.character(viewport_ranges)\n\n    ## Place \"blank\" subscripts.\n    viewport_dim <- dim(viewport)\n    viewport_refdim <- refdim(viewport)\n    useblank <- viewport_dim == viewport_refdim\n    ndim <- length(viewport_dim)\n    if (as.2Dslice && ndim >= 3L)\n        useblank[3:ndim] <- FALSE\n    ans[useblank] <- \"\"\n\n    if (!is.null(dimnames)) {\n        stopifnot(is.list(dimnames), length(dimnames) == ndim)\n        usename_idx <- which(!useblank &\n                             viewport_dim == 1L &\n                             lengths(dimnames) != 0L)\n        ans[usename_idx] <- unlist(mapply(`[`,\n                                          dimnames[usename_idx],\n                                          start(viewport_ranges)[usename_idx],\n                                          SIMPLIFY=FALSE,\n                                          USE.NAMES=FALSE))\n    }\n    if (with.brackets)\n        ans <- lapply(ans, function(x) if (x == \"\") \" \" else x)\n    ans <- paste0(ans, collapse=collapse)\n    if (with.brackets)\n        ans <- paste0(\"[\", ans, \"]\")\n    ans\n}\n\nsetMethod(\"show\", \"ArrayViewport\",\n    function(object)\n    {\n        dim_in1string <- paste0(dim(object), collapse=\" x \")\n        refdim_in1string <- paste0(refdim(object), collapse=\" x \")\n        cat(dim_in1string, \" \", classNameForDisplay(object), \" object \",\n            \"on a \", refdim_in1string, \" array: \", sep=\"\")\n        s <- make_string_from_ArrayViewport(object, with.brackets=TRUE)\n        cat(s, \"\\n\", sep=\"\")\n    }\n)\n\n### makeNindexFromArrayViewport()\n\n### Used in HDF5Array!\nmakeNindexFromArrayViewport <- function(viewport, expand.RangeNSBS=FALSE)\n{\n    viewport_ranges <- ranges(viewport)\n    viewport_dim <- dim(viewport)\n    viewport_refdim <- refdim(viewport)\n    ndim <- length(viewport_dim)\n    Nindex <- vector(\"list\", length=ndim)\n    is_not_missing <- viewport_dim < viewport_refdim\n    if (expand.RangeNSBS) {\n        expand_idx <- which(is_not_missing)\n    } else {\n        viewport_starts <- start(viewport_ranges)\n        viewport_ends <- end(viewport_ranges)\n        is_width1 <- viewport_dim == 1L\n        expand_idx <- which(is_not_missing & is_width1)\n        RangeNSBS_idx <- which(is_not_missing & !is_width1)\n        Nindex[RangeNSBS_idx] <- lapply(RangeNSBS_idx,\n            function(i) {\n                range_start <- viewport_starts[[i]]\n                range_end <- viewport_ends[[i]]\n                upper_bound <- viewport_refdim[[i]]\n                new2(\"RangeNSBS\", subscript=c(range_start, range_end),\n                                  upper_bound=upper_bound,\n                                  check=FALSE)\n            }\n        )\n    }\n    if (length(expand_idx) != 0L)\n        Nindex[expand_idx] <- as.list(as(viewport_ranges[expand_idx],\n                                         \"CompressedIntegerList\"))\n    Nindex\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### ArrayGrid objects\n###\n### An ArrayGrid object represents a grid on top of an array (called \"the\n### reference array\" or \"the underlying array\"). The ArrayGrid class is a\n### virtual class with 3 concrete subclasses, ArbitraryArrayGrid and\n### RegularArrayGrid, for representing an arbitrarily-spaced or a\n### regularly-spaced grid, respectively. The API we implement on these objects\n### is divided into 3 groups of methods:\n###   1) One special method:\n###      - refdim(x): Return the dimensions of the reference array.\n###   2) Methods from the array API (an ArrayGrid object can be seen as an\n###      array of ArrayViewport objects that cover the reference array without\n###      overlapping with each others):\n###      - dim(x): Return the number of grid elements (i.e. viewports) along\n###        each dimension of the reference array.\n###      - x[[i_1, i_2, ..., i_n]]: Multidimensional double bracket\n###        subsetting. Return an ArrayViewport object.\n###   3) Methods from the list API:\n###      - length(): Return the total number of grid elements.\n###      - x[[i]]: Linear double bracket subsetting. Return an ArrayViewport\n###        object.\n### Groups 2) and 3) give these objects 2 semantics: array-like and list-like.\n### Note that length() and \"linear double bracket subsetting\" are consistent\n### with dim() and \"multidimensional double bracket subsetting\", respectively.\n### So the array-like and list-like semantics are compatible.\n###\n\nsetClass(\"ArrayGrid\",\n    contains=c(\"Array\", \"List\"),\n    representation(\"VIRTUAL\"),\n    prototype(elementType=\"ArrayViewport\")\n)\n\nsetClass(\"DummyArrayGrid\",\n    contains=\"ArrayGrid\",\n    representation(\n        refdim=\"integer\"    # Dimensions of the reference array.\n    ),\n    prototype(elementType=\"DummyArrayViewport\")\n)\n\nsetClass(\"ArbitraryArrayGrid\",\n    contains=\"ArrayGrid\",\n    representation(\n        tickmarks=\"list\"    # A list of integer vectors, one along each\n                            # dimension of the reference array,\n                            # representing the tickmarks along that\n                            # dimension. Each integer vector must be sorted\n                            # in ascending order.\n    ),\n    prototype(elementType=\"SafeArrayViewport\")\n)\n\nsetClass(\"RegularArrayGrid\",\n    contains=\"ArrayGrid\",\n    representation(\n        refdim=\"integer\",   # Dimensions of the reference array.\n        spacings=\"integer\"  # Grid spacing along each dimension.\n    ),\n    prototype(elementType=\"SafeArrayViewport\")\n)\n\n### Low-level helpers\n\n.prod2 <- function(x)\n{\n    p <- prod(x)\n    ## We only use .prod2() in a context where 'x' is guaranteed to contain\n    ## non-negative values so 'p' will always be >= 0.\n    if (p <= .Machine$integer.max) as.integer(p) else p\n}\n\n.get_DummyArrayGrid_spacings_along <- function(x, along) x@refdim[[along]]\n\n.get_ArbitraryArrayGrid_spacings_along <- function(x, along)\n    S4Vectors:::diffWithInitialZero(x@tickmarks[[along]])\n\n.get_ArbitraryArrayGrid_max_spacings <- function(x)\n{\n    vapply(seq_along(x@tickmarks),\n        function(along)\n            max(0L, .get_ArbitraryArrayGrid_spacings_along(x, along)),\n        integer(1),\n        USE.NAMES=FALSE\n    )\n}\n\n### Get length of biggest viewport in ArbitraryArrayGrid object 'x'.\n.get_ArbitraryArrayGrid_maxlength <- function(x)\n{\n    .prod2(.get_ArbitraryArrayGrid_max_spacings(x))\n}\n\n### Get length of biggest viewport in RegularArrayGrid object 'x'.\n.get_RegularArrayGrid_maxlength <- function(x) .prod2(x@spacings)\n\nget_RegularArrayGrid_dim <- function(refdim, spacings)\n{\n    ans <- refdim %/% spacings + (refdim %% spacings != 0L)\n    ans[is.na(ans)] <- 1L\n    ans\n}\n\n.get_RegularArrayGrid_spacings_along <- function(x, along)\n{\n    D <- x@refdim[[along]]\n    if (D == 0L)\n        return(0L)\n    spacing <- x@spacings[[along]]\n    ans <- rep.int(spacing, D %/% spacing)\n    r <- D %% spacing\n    if (r != 0L)\n        ans <- c(ans, r)\n    ans\n}\n\n### Validity\n\n.validate_DummyArrayGrid <- function(x)\n{\n    msg <- validate_dim_slot(x, \"refdim\")\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\nsetValidity2(\"DummyArrayGrid\", .validate_DummyArrayGrid)\n\n.valid_tickmarks <- function(tm)\n{\n    is.integer(tm) && !S4Vectors:::anyMissingOrOutside(tm, 0L) && isSorted(tm)\n}\n.validate_ArbitraryArrayGrid <- function(x)\n{\n    x_tickmarks <- x@tickmarks\n    if (!is.list(x_tickmarks))\n        return(\"'tickmarks' slot must be a list\")\n    ok <- vapply(x_tickmarks, .valid_tickmarks, logical(1), USE.NAMES=FALSE)\n    if (!all(ok))\n        return(paste0(\"each list element in 'tickmarks' slot must be a \",\n                      \"sorted integer vector of non-negative values\"))\n    x_maxlen <- .get_ArbitraryArrayGrid_maxlength(x)\n    if (x_maxlen > .Machine$integer.max)\n        return(paste0(\"grid is too coarse (all grid elements must have a \",\n                      \"length <= .Machine$integer.max)\"))\n    TRUE\n}\nsetValidity2(\"ArbitraryArrayGrid\", .validate_ArbitraryArrayGrid)\n\n.validate_RegularArrayGrid <- function(x)\n{\n    msg <- validate_dim_slot(x, \"refdim\")\n    if (!isTRUE(msg))\n        return(msg)\n    msg <- validate_dim_slot(x, \"spacings\")\n    if (!isTRUE(msg))\n        return(msg)\n    x_spacings <- x@spacings\n    x_refdim <- x@refdim\n    if (length(x_spacings) != length(x_refdim))\n        return(\"'spacings' and 'refdim' slots must have the same length\")\n    if (!all(x_spacings <= x_refdim))\n        return(paste0(\"values in 'spacings' slot must be <= their \",\n                      \"corresponding value in 'refdim' slot\"))\n    if (any(x_spacings == 0L & x_refdim != 0L))\n        return(paste0(\"values in 'spacings' slot cannot be 0 unless their \",\n                      \"corresponding value in 'refdim' slot is also 0\"))\n    x_maxlen <- .get_RegularArrayGrid_maxlength(x)\n    if (x_maxlen > .Machine$integer.max)\n        return(paste0(\"grid is too coarse (all grid elements must have a \",\n                      \"length <= .Machine$integer.max)\"))\n    TRUE\n}\nsetValidity2(\"RegularArrayGrid\", .validate_RegularArrayGrid)\n\n### Getters\n\nsetMethod(\"refdim\", \"DummyArrayGrid\", function(x) x@refdim)\n\nsetMethod(\"refdim\", \"ArbitraryArrayGrid\",\n    function(x)\n    {\n        mapply(\n            function(tm, tm_len) if (tm_len == 0L) 0L else tm[[tm_len]],\n            x@tickmarks,\n            lengths(x@tickmarks),\n            USE.NAMES=FALSE\n        )\n    }\n)\n\nsetMethod(\"refdim\", \"RegularArrayGrid\", function(x) x@refdim)\n\nsetMethod(\"dim\", \"DummyArrayGrid\", function(x) rep.int(1L, length(refdim(x))))\n\nsetMethod(\"dim\", \"ArbitraryArrayGrid\", function(x) lengths(x@tickmarks))\n\nsetMethod(\"dim\", \"RegularArrayGrid\",\n    function(x) get_RegularArrayGrid_dim(refdim(x), x@spacings)\n)\n\n### Constructors\n\nDummyArrayGrid <- function(refdim)\n{\n    if (!is.numeric(refdim))\n        stop(wmsg(\"'refdim' must be an integer vector\"))\n    if (!is.integer(refdim))\n        refdim <- as.integer(refdim)\n    new2(\"DummyArrayGrid\", refdim=refdim, check=TRUE)\n}\n\nArbitraryArrayGrid <- function(tickmarks)\n{\n    if (!is.list(tickmarks))\n        stop(wmsg(\"'tickmarks' must be a list\"))\n    new2(\"ArbitraryArrayGrid\", tickmarks=tickmarks, check=TRUE)\n}\n\n### Note that none of the dimensions of an RegularArrayGrid object can be 0,\n### even when some dimensions of the reference array are 0 (in which case,\n### the corresponding dimensions of the grid object are set to 1). As a\n### consequence, an RegularArrayGrid object always contains at least 1 grid\n### element. Each dimension of the first grid element is always equal to the\n### spacing along that dimension i.e. for any RegularArrayGrid object,\n### 'dim(grid[[1]])' is identical to 'spacings'.\n### If 'spacings' is omitted, return a grid with a single grid element\n### covering the whole reference array.\nRegularArrayGrid <- function(refdim, spacings=refdim)\n{\n    if (!is.numeric(refdim))\n        stop(wmsg(\"'refdim' must be an integer vector\"))\n    if (!is.integer(refdim))\n        refdim <- as.integer(refdim)\n    if (!is.numeric(spacings))\n        stop(wmsg(\"'spacings' must be an integer vector\"))\n    if (!is.integer(spacings))\n        spacings <- as.integer(spacings)\n    if (length(refdim) != length(spacings))\n        stop(wmsg(\"'refdim' and 'spacings' must have the same length\"))\n    new2(\"RegularArrayGrid\", refdim=refdim, spacings=spacings, check=TRUE)\n}\n\n### [[\n\nsetMethod(\"getArrayElement\", \"DummyArrayGrid\",\n    function(x, subscripts)\n    {\n        stopifnot(is.integer(subscripts),\n                  identical(subscripts, rep.int(1L, length(subscripts))))\n        DummyArrayViewport(refdim(x))\n    }\n)\n\nsetMethod(\"getArrayElement\", \"ArbitraryArrayGrid\",\n    function(x, subscripts)\n    {\n        stopifnot(is.integer(subscripts))\n        x_refdim <- refdim(x)\n        ans_end <- mapply(`[[`, x@tickmarks, subscripts, USE.NAMES=FALSE)\n        ans_width <- mapply(\n            function(along, i)\n                .get_ArbitraryArrayGrid_spacings_along(x, along)[[i]],\n            seq_along(x_refdim),\n            subscripts,\n            USE.NAMES=FALSE\n        )\n        ans_ranges <- IRanges(end=ans_end, width=ans_width)\n        ArrayViewport(x_refdim, ans_ranges)\n    }\n)\n\nsetMethod(\"getArrayElement\", \"RegularArrayGrid\",\n    function(x, subscripts)\n    {\n        stopifnot(is.integer(subscripts))\n        x_refdim <- refdim(x)\n        ans_offset <- (subscripts - 1L) * x@spacings\n        ans_end <- pmin(ans_offset + x@spacings, refdim(x))\n        ans_ranges <- IRanges(start=ans_offset + 1L, end=ans_end)\n        ArrayViewport(x_refdim, ans_ranges)\n    }\n)\n\n### dims() and lengths()\n\n### NOT exported.\nsetGeneric(\"get_spacings_along\", signature=\"x\",\n    function(x, along) standardGeneric(\"get_spacings_along\")\n)\nsetMethod(\"get_spacings_along\", \"DummyArrayGrid\",\n    .get_DummyArrayGrid_spacings_along\n)\nsetMethod(\"get_spacings_along\", \"ArbitraryArrayGrid\",\n    .get_ArbitraryArrayGrid_spacings_along\n)\nsetMethod(\"get_spacings_along\", \"RegularArrayGrid\",\n    .get_RegularArrayGrid_spacings_along\n)\n\n### Equivalent to 't(vapply(x, dim, refdim(x)))' but faster.\nsetMethod(\"dims\", \"ArrayGrid\",\n    function(x)\n    {\n        ans <- as.matrix(get_spacings_along(x, 1L))\n        x_ndim <- length(refdim(x))\n        if (x_ndim >= 2L) {\n            for (along in 2:x_ndim) {\n                spacings_along <- get_spacings_along(x, along)\n                ans <- cbind(\n                    S4Vectors:::rep.int_along_ROWS(ans, length(spacings_along)),\n                    rep(spacings_along, each=nrow(ans))\n                )\n            }\n        }\n        ans\n    }\n)\n\n### Equivalent to 'vapply(x, length, integer(1))' or to 'rowProds(dims(x))'\n### but faster.\n### The sum of the hyper-volumes of all the grid elements should be equal\n### to the hyper-volume of the reference array.\n### More concisely: sum(lengths(x)) should be equal to 'prod(refdim(x))'.\nsetMethod(\"lengths\", \"ArrayGrid\",\n    function(x, use.names=TRUE)\n    {\n        ans <- get_spacings_along(x, 1L)\n        x_ndim <- length(refdim(x))\n        if (x_ndim >= 2L) {\n            for (along in 2:x_ndim) {\n                spacings_along <- get_spacings_along(x, along)\n                ans <- ans * rep(spacings_along, each=length(ans))\n            }\n        }\n        ans\n    }\n)\n\nsetMethod(\"lengths\", \"DummyArrayGrid\",\n    function(x, use.names=TRUE) .prod2(refdim(x))\n)\n\n### Equivalent to 'max(lengths(x))' except that when 'x' is an ArrayGrid\n### object this can be computed without computing 'lengths(x)' first so is\n### very efficient.\nsetGeneric(\"maxlength\", function(x) standardGeneric(\"maxlength\"))\nsetMethod(\"maxlength\", \"ANY\", function(x) max(lengths(x)))\nsetMethod(\"maxlength\", \"ArbitraryArrayGrid\", .get_ArbitraryArrayGrid_maxlength)\nsetMethod(\"maxlength\", \"RegularArrayGrid\", .get_RegularArrayGrid_maxlength)\n\n### Show\n\n### S3/S4 combo for as.character.ArrayGrid\n.as.character.ArrayGrid <- function(x, collapse=\",\", with.brackets=FALSE)\n{\n    data <- vapply(x,\n        function(viewport)\n            make_string_from_ArrayViewport(viewport,\n                                           collapse=collapse,\n                                           with.brackets=with.brackets),\n        character(1),\n        USE.NAMES=FALSE\n    )\n    array(data, dim(x))\n}\nas.character.ArrayGrid <- function(x, ...) .as.character.ArrayGrid(x, ...)\nsetMethod(\"as.character\", \"ArrayGrid\", .as.character.ArrayGrid)\n\nsetMethod(\"show\", \"ArrayGrid\",\n    function(object)\n    {\n        if (!is(object, \"DummyArrayGrid\")) {\n            dim_in1string <- paste0(dim(object), collapse=\" x \")\n            cat(dim_in1string, \" \")\n        }\n        refdim_in1string <- paste0(refdim(object), collapse=\" x \")\n        cat(class(object), \" object on a \", refdim_in1string, \" array:\\n\",\n            sep=\"\")\n        ## Turn 'object' into a character array.\n        print(as.character(object, with.brackets=TRUE),\n              quote=FALSE, right=TRUE)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### aperm()\n###\n### Like aperm2() defined in this package, the methods below extend\n### base::aperm() by allowing dropping and/or adding ineffective dimensions.\n###\n### NOTE: The methods below use normarg_perm() which doesn't perform a\n### full check of 'perm' e.g. it allows duplicates in it (see normarg_perm()\n### in aperm2.R). Instead we call replaceSlots() with 'check=TRUE' to trigger\n### validation of the modified ArrayGrid object with the expectation that it\n### will fail if for example 'perm' contains NAs or values > length(dim(a)).\n\n.aperm.DummyArrayGrid <- function(a, perm)\n{\n    perm <- normarg_perm(perm, dim(a))\n    ans_refdim <- a@refdim[perm]\n    ans_refdim[is.na(perm)] <- 1L\n    ## See above NOTE for why it's important to call replaceSlots()\n    ## with 'check=TRUE'.\n    BiocGenerics:::replaceSlots(a, refdim=ans_refdim, check=TRUE)\n}\n### S3/S4 combo for aperm.DummyArrayGrid\naperm.DummyArrayGrid <-\n    function(a, perm, ...) .aperm.DummyArrayGrid(a, perm, ...)\nsetMethod(\"aperm\", \"DummyArrayGrid\", aperm.DummyArrayGrid)\n\n.aperm.ArbitraryArrayGrid <- function(a, perm)\n{\n    perm <- normarg_perm(perm, dim(a))\n    ans_tickmarks <- a@tickmarks[perm]\n    ans_tickmarks[is.na(perm)] <- list(1L)\n    ## See above NOTE for why it's important to call replaceSlots()\n    ## with 'check=TRUE'.\n    BiocGenerics:::replaceSlots(a, tickmarks=ans_tickmarks, check=TRUE)\n}\n### S3/S4 combo for aperm.ArbitraryArrayGrid\naperm.ArbitraryArrayGrid <-\n    function(a, perm, ...) .aperm.ArbitraryArrayGrid(a, perm, ...)\nsetMethod(\"aperm\", \"ArbitraryArrayGrid\", aperm.ArbitraryArrayGrid)\n\n.aperm.RegularArrayGrid <- function(a, perm)\n{\n    perm <- normarg_perm(perm, dim(a))\n    ans_refdim <- a@refdim[perm]\n    ans_refdim[is.na(perm)] <- 1L\n    ans_spacings <- a@spacings[perm]\n    ans_spacings[is.na(perm)] <- 1L\n    ## See above NOTE for why it's important to call replaceSlots()\n    ## with 'check=TRUE'.\n    BiocGenerics:::replaceSlots(a, refdim=ans_refdim,\n                                   spacings=ans_spacings,\n                                   check=TRUE)\n}\n### S3/S4 combo for aperm.RegularArrayGrid\naperm.RegularArrayGrid <-\n    function(a, perm, ...) .aperm.RegularArrayGrid(a, perm, ...)\nsetMethod(\"aperm\", \"RegularArrayGrid\", aperm.RegularArrayGrid)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### downsample() generic and methods\n###\n### Reduce the \"resolution\" of a grid by the specified ratio.\n### Act as an endomorphism.\n###\n\nsetGeneric(\"downsample\", signature=\"x\",\n    function(x, ratio=1L) standardGeneric(\"downsample\")\n)\n\n.normarg_ratio <- function(ratio, x_dim)\n{\n    if (!is.numeric(ratio))\n        stop(wmsg(\"'ratio' must be an integer vector\"))\n    if (!is.integer(ratio))\n        ratio <- as.integer(ratio)\n    ndim <- length(x_dim)\n    if (length(ratio) != 1L && length(ratio) != ndim)\n        stop(wmsg(\"'length(ratio)' must be 1 or the sane as 'length(dim(x))'\"))\n    if (S4Vectors:::anyMissingOrOutside(ratio, 0L))\n        stop(wmsg(\"'ratio' cannot contain negative or NA values\"))\n    if (length(ratio) != ndim)\n        ratio <- rep.int(ratio, ndim)\n    if (any(ratio == 0L & x_dim != 0L))\n        stop(wmsg(\"values in 'ratio' cannot be 0 unless their \",\n                  \"corresponding dimension in 'x' is also 0\"))\n    ratio\n}\n\nsetMethod(\"downsample\", \"ArbitraryArrayGrid\",\n    function(x, ratio=1L)\n    {\n        ratio <- .normarg_ratio(ratio, dim(x))\n        ans_tickmarks <- mapply(\n            function(tm, tm_len, r) {\n                if (tm_len == 0L)\n                    return(integer(0))\n                tm[seq2(tm_len, r)]\n            },\n            x@tickmarks,\n            lengths(x@tickmarks),\n            ratio,\n            SIMPLIFY=FALSE,\n            USE.NAMES=FALSE\n        )\n        ArbitraryArrayGrid(ans_tickmarks)\n    }\n)\n\nsetMethod(\"downsample\", \"RegularArrayGrid\",\n    function(x, ratio=1L)\n    {\n        ratio <- .normarg_ratio(ratio, dim(x))\n        x_refdim <- refdim(x)\n        ## We turn 'ratio' into a double vector to prevent a potential\n        ## integer overflow.\n        ans_spacings <- pmin(x@spacings * as.double(ratio), x_refdim)\n        RegularArrayGrid(x_refdim, ans_spacings)\n    }\n)\n\n",
        "Nindex-utils.R": "### =========================================================================\n### Manipulating an Nindex\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n### An Nindex is a \"multidimensional subsetting index\". It's represented as a\n### list with one subscript per dimension in the array-like object to subset.\n### NULL list elements in it are interpreted as missing subscripts, that is, as\n### subscripts that run along the full extend of the corresponding dimension.\n### Before an Nindex can be used in a call to `[`, `[<-`, `[[` or `[[<-`, the\n### NULL list elements must be replaced with objects of class \"name\".\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Normalization of an Nindex\n###\n\n### NOT exported but used in the HDF5Array package!\nnormalizeSingleBracketSubscript2 <- function(i, x_len, x_names=NULL)\n{\n    ## We support subsetting by an array-like subscript but only if the\n    ## subscript is monodimensional, in which case we call as.vector() on\n    ## it. This will possibly trigger its realization e.g. if it's a\n    ## DelayedArray object.\n    i_dim <- dim(i)\n    if (!is.null(i_dim)) {\n        if (length(i_dim) != 1L)\n            stop(wmsg(\"subsetting a DelayedArray object with an array-like \",\n                      \"subscript is only supported if the subscript has a \",\n                      \"single dimension\"))\n        i <- as.vector(i)\n    }\n    ## We create an artificial object 'x' of length 'x_len' with 'x_names' on\n    ## it. normalizeSingleBracketSubscript() will only look at its length and\n    ## names so what the object really is doesn't matter. Hence we make it\n    ## with the smallest possible memory footprint.\n    ## TODO: Change the signature of normalizeSingleBracketSubscript() in\n    ## S4Vectors to take 'x_len' and 'x_names' instead of 'x' so we won't\n    ## have to use this kind of trick.\n    if (is.null(x_names)) {\n        x <- Rle(0L, x_len)\n    } else {\n        x <- setNames(raw(x_len), x_names)\n    }\n    normalizeSingleBracketSubscript(i, x)\n}\n\n### Normalize 'Nindex' i.e. check and turn each non-NULL list element\n### into a positive integer vector that is a valid subscript along the\n### corresponding dimension in 'x'.\nnormalize_Nindex <- function(Nindex, x)\n{\n    x_dim <- dim(x)\n    if (is.null(x_dim))\n        stop(wmsg(\"'x' must be an array-like object \",\n                  \"(i.e. it must have dimensions)\"))\n    x_ndim <- length(x_dim)\n    if (is.null(Nindex))\n        return(vector(\"list\", length=x_ndim))\n    if (!(is.list(Nindex) && length(Nindex) == x_ndim))\n        stop(wmsg(\"'Nindex' must be a list with one \",\n                  \"list element per dimension in 'x'\"))\n    x_dimnames <- dimnames(x)\n    lapply(seq_len(x_ndim),\n        function(along) {\n            subscript <- Nindex[[along]]\n            if (is.null(subscript))\n                return(NULL)\n            d <- x_dim[[along]]\n            i <- normalizeSingleBracketSubscript2(subscript, d,\n                                                  x_dimnames[[along]])\n            if (isSequence(i, of.length=d))\n                return(NULL)\n            i\n        })\n}\n\n### Assume 'Nindex' is normalized (see above).\n### Return a logical vector with one logical per dimension indicating\n### whether the corresponding subscript in 'Nindex' reaches all valid\n### positions along the dimension.\nsubscript_has_nogap <- function(Nindex, dim)\n{\n    stopifnot(is.list(Nindex), length(Nindex) == length(dim))\n    vapply(seq_along(Nindex),\n        function(along) {\n            Li <- Nindex[[along]]\n            if (is.null(Li))\n                return(TRUE)\n            d <- dim[[along]]\n            if (length(Li) < d)\n                return(FALSE)\n            hits <- logical(d)\n            hits[Li] <- TRUE\n            all(hits)\n        },\n        logical(1L),\n        USE.NAMES=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other Nindex utilities\n###\n\n### For use in \"[\", \"[<-\", \"[[\", or \"[[<-\" methods to extract the user\n### supplied subscripts as an Nindex. NULL subscripts are replace with\n### integer(0). Missing subscripts are set to NULL.\nextract_Nindex_from_syscall <- function(call, eframe)\n{\n    Nindex <- lapply(seq_len(length(call) - 2L),\n        function(i) {\n            subscript <- call[[2L + i]]\n            if (missing(subscript))\n                return(NULL)\n            subscript <- eval(subscript, envir=eframe, enclos=eframe)\n            if (is.null(subscript))\n                return(integer(0))\n            subscript\n        }\n    )\n    argnames <- tail(names(call), n=-2L)\n    if (!is.null(argnames))\n        Nindex <- Nindex[!(argnames %in% c(\"drop\", \"exact\", \"value\"))]\n    if (length(Nindex) == 1L && is.null(Nindex[[1L]]))\n        Nindex <- Nindex[0L]\n    Nindex\n}\n\n### Used in HDF5Array!\nexpand_Nindex_RangeNSBS <- function(Nindex)\n{\n    stopifnot(is.list(Nindex))\n    expand_idx <- which(vapply(Nindex, is, logical(1), \"RangeNSBS\"))\n    if (length(expand_idx) != 0L)\n        Nindex[expand_idx] <- lapply(Nindex[expand_idx], as.integer)\n    Nindex\n}\n\n.make_subscripts_from_Nindex <- function(Nindex, x)\n{\n    stopifnot(is.list(Nindex), length(Nindex) == length(dim(x)))\n\n    if (is.array(x) || is(x, \"sparseMatrix\"))\n        Nindex <- expand_Nindex_RangeNSBS(Nindex)\n\n    ## Replace NULLs with list elements of class \"name\".\n    subscripts <- rep.int(list(quote(expr=)), length(Nindex))\n    names(subscripts) <- names(Nindex)\n    not_missing_idx <- which(!S4Vectors:::sapply_isNULL(Nindex))\n    subscripts[not_missing_idx] <- Nindex[not_missing_idx]\n\n    subscripts\n}\n\nsubset_by_Nindex <- function(x, Nindex, drop=FALSE)\n{\n    subscripts <- .make_subscripts_from_Nindex(Nindex, x)\n    do.call(`[`, c(list(x), subscripts, list(drop=drop)))\n}\n\n### Return the modified array.\n### Work on any array-like object that supports subassignment ('[<-').\nreplace_by_Nindex <- function(x, Nindex, value)\n{\n    subscripts <- .make_subscripts_from_Nindex(Nindex, x)\n    do.call(`[<-`, c(list(x), subscripts, list(value=value)))\n}\n\nsubset_dimnames_by_Nindex <- function(dimnames, Nindex)\n{\n    stopifnot(is.list(Nindex))\n    if (is.null(dimnames))\n        return(NULL)\n    ndim <- length(Nindex)\n    stopifnot(is.list(dimnames), length(dimnames) == ndim)\n    ## Would mapply() be faster here?\n    ans <- lapply(setNames(seq_len(ndim), names(dimnames)),\n                  function(along) {\n                      dn <- dimnames[[along]]\n                      i <- Nindex[[along]]\n                      if (is.null(dn) || is.null(i))\n                          return(dn)\n                      extractROWS(dn, i)\n                  })\n    simplify_NULL_dimnames(ans)\n}\n\n### Used in HDF5Array!\n### Return the lengths of the subscripts in 'Nindex'. The length of a\n### missing subscript is the length it would have after expansion.\nget_Nindex_lengths <- function(Nindex, dim)\n{\n    stopifnot(is.list(Nindex), length(Nindex) == length(dim))\n    ans <- lengths(Nindex)\n    missing_idx <- which(S4Vectors:::sapply_isNULL(Nindex))\n    ans[missing_idx] <- dim[missing_idx]\n    ans\n}\n\n### Convert 'Nindex' to a \"linear index\".\n### Return the \"linear index\" as an integer vector if prod(dim) <=\n### .Machine$integer.max, otherwise as a vector of doubles.\nto_linear_index <- function(Nindex, dim)\n{\n    stopifnot(is.list(Nindex), is.integer(dim), length(Nindex) == length(dim))\n    if (prod(dim) <= .Machine$integer.max) {\n        ans <- p <- 1L\n    } else {\n        ans <- p <- 1\n    }\n    for (along in seq_along(Nindex)) {\n        d <- dim[[along]]\n        i <- Nindex[[along]]\n        if (is.null(i))\n            i <- seq_len(d)\n        ans <- rep((i - 1L) * p, each=length(ans)) + ans\n        p <- p * d\n    }\n    ans\n}\n\n",
        "abind.R": "### =========================================================================\n### Bind multidimensional arrays along an arbitrary dimension\n### -------------------------------------------------------------------------\n\n\n.normarg_along <- function(along)\n{\n    if (!isSingleNumber(along))\n        stop(wmsg(\"'along' must be a single number\"))\n    if (!is.integer(along))\n        along <- as.integer(along)\n    if (along <= 0L)\n        stop(wmsg(\"'along' must be a positive integer\"))\n    along\n}\n\n### Return a matrix with one row per dim and one column per object if the\n### objects are \"bindable\". Otherwise return a string describing why they\n### are not. This design allows the function to be used in the context of\n### a validity method.\nget_dims_to_bind <- function(objects, along)\n{\n    stopifnot(is.list(objects))\n    along <- .normarg_along(along)\n    dims <- lapply(objects, dim)\n    ndims <- lengths(dims)\n    if (any(ndims < along))\n        stop(wmsg(\"the array-like objects to bind must have at least \",\n                  along, \" dimensions for this binding operation\"))\n    ndim <- ndims[[1L]]\n    if (!all(ndims == ndim))\n        return(paste0(\"all the objects to bind must have \",\n                      \"the same number of dimensions\"))\n    tmp <- unlist(dims, use.names=FALSE)\n    if (is.null(tmp))\n        return(\"the objects to bind have no dimensions\")\n    dims <- matrix(tmp, nrow=ndim)\n    tmp <- dims[-along, , drop=FALSE]\n    if (!all(tmp == tmp[ , 1L]))\n        return(\"the objects to bind have incompatible dimensions\")\n    dims\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### combine_dims_along() and combine_dimnames_along()\n###\n### Compute the expected dims and dimnames of abind()'s result.\n### Both combine_dims_along() and combine_dimnames_along() generalize what\n### rbind/cbind do in the 2D case to the multidimensional case.\n###\n### A NOTE ABOUT CRAN PACKAGE abind 1.4-5: By default, abind::abind() does\n### NOT follow the same rules as rbind() and cbind() for propagation of the\n### dimnames. This is despite its man page (?abind::abind) claiming that it\n### does (see documentation of the 'use.first.dimnames' argument), when in\n### fact it has it backward! Very misleading!\n### The abind0() function defined below in this file is a simple wrapper\n### around abind::abind() that fixes that.\n\n### Combine the dims the rbind/cbind way.\ncombine_dims_along <- function(dims, along)\n{\n    stopifnot(is.matrix(dims))\n    along <- .normarg_along(along)\n    stopifnot(along <= nrow(dims))\n    ans_dim <- dims[ , 1L]\n    ans_dim[[along]] <- sum(dims[along, ])\n    ans_dim\n}\n\n### Assume all the arrays in 'objects' have the same number of dimensions.\n.combine_dimnames <- function(objects)\n{\n    lapply(seq_along(dim(objects[[1L]])),\n        function(n) {\n            for (object in objects) {\n                dn <- dimnames(object)[[n]]\n                if (!is.null(dn))\n                    return(dn)\n            }\n            NULL\n        })\n}\n\n### Combine the dimnames the rbind/cbind way.\ncombine_dimnames_along <- function(objects, dims, along)\n{\n    stopifnot(is.matrix(dims),\n              isSingleInteger(along), along >= 1L, along <= nrow(dims))\n    dimnames <- .combine_dimnames(objects)\n    along_names <- lapply(objects, function(object) dimnames(object)[[along]])\n    along_names_lens <- lengths(along_names)\n    if (any(along_names_lens != 0L)) {\n        fix_idx <- which(along_names_lens != dims[along, ])\n        along_names[fix_idx] <- lapply(dims[along, fix_idx], character)\n    }\n    along_names <- unlist(along_names, use.names=FALSE)\n    if (!is.null(along_names))\n        dimnames[[along]] <- along_names\n    simplify_NULL_dimnames(dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### simple_abind()\n###\n\n### 'objects' is assumed to be a list of vector-like objects.\n### 'nblock' is assumed to be a single integer value (stored as a numeric)\n### that is a common divisor of the object lengths.\n.intertwine_blocks <- function(objects, nblock, ans_dim)\n{\n    x0 <- unlist(lapply(objects, `[`, 0L), recursive=FALSE, use.names=FALSE)\n    objects_lens <- lengths(objects)\n    if (all(objects_lens == 0L))\n        return(set_dim(x0, ans_dim))\n\n    idx <- which(vapply(objects,\n        function(object) { typeof(object) != typeof(x0) },\n        logical(1),\n        USE.NAMES=FALSE))\n    if (length(idx) != 0L)\n        objects[idx] <- lapply(objects[idx], `storage.mode<-`, typeof(x0))\n\n    .Call2(\"C_abind\", objects, nblock, ans_dim, PACKAGE=\"S4Arrays\")\n}\n\n### A stripped-down version of abind::abind().\n### Some differences:\n###   (a) Treatment of dimnames: simple_abind() treatment of dimnames is\n###       consistent with base::rbind() and base::cbind(). This is not the\n###       case for abind::abind() which does some strange things with the\n###       dimnames.\n###   (b) Performance: simple_abind() is much faster than abind::abind()\n###       (between 3x and 15x). Also note that in the 'along=1L' and 'along=2L'\n###       cases, it's generally as fast (and most of the time faster) than\n###       base::rbind() and base::cbind().\n###       For example, with 'm <- matrix(1:30000000, nrow=5000)',\n###       'simple_abind(m, m, m, along=1L)' is 14x faster than\n###       'abind::abind(m, m, m, along=1L)' and 11x faster than\n###       'base::rbind(m, m, m)'.\n###   (c) abind::abind() is broken on matrices of type \"list\".\nsimple_abind <- function(..., along)\n{\n    along <- .normarg_along(along)\n    objects <- S4Vectors:::delete_NULLs(list(...))\n    if (length(objects) == 0L)\n        return(NULL)\n\n    ## Check dim compatibility.\n    dims <- get_dims_to_bind(objects, along)\n    if (is.character(dims))\n        stop(wmsg(dims))\n    if (length(objects) == 1L)\n        return(objects[[1L]])\n\n    ## Perform the binding.\n    nblock <- prod(dims[-seq_len(along), 1L])  # numeric that can be >\n                                               # .Machine$integer.max\n    ans <- .intertwine_blocks(objects, nblock, combine_dims_along(dims, along))\n\n    ## Combine and set the dimnames.\n    set_dimnames(ans, combine_dimnames_along(objects, dims, along))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### simple_abind2()\n###\n### A wrapper to simple_abind() that adds some of the capabilities originally\n### found in abind::abind():\n### 1. Not all arrays (supplied via 'objects') are required to have the same\n###    number of dimensions. If N is the number of dimensions of the arrays\n###    with the most dimensions, then artifical (a.k.a. ineffective) dimensions\n###    are added to the arrays with less dimensions so that they also have\n###    N dimensions.\n### 2. 'along' can be any integer value between 1 and N+1. When set to N+1,\n###    then one more artifical dimension is added to all arrays.\n### 3. simple_abind2() supports the 'rev.along' argument which can be any\n###    value between 0 and N.\n### 4. Arguments 'along' and 'rev.along' can be omitted, in which case binding\n###    happens along the N-th dimension.\n\n.normarg_rev_along <- function(rev.along)\n{\n    if (!isSingleNumber(rev.along))\n        stop(wmsg(\"'rev.along' must be a single number\"))\n    if (!is.integer(rev.along))\n        rev.along <- as.integer(rev.along)\n    if (rev.along < 0L)\n        stop(wmsg(\"'rev.along' must be a non-negative integer\"))\n    rev.along\n}\n\n### To be re-used by other abind() methods e.g. by the method for SparseArray\n### objects.\nget_along <- function(N, along=NULL, rev.along=NULL)\n{\n    if (is.null(along) && is.null(rev.along))\n        return(N)\n    if (is.null(rev.along)) {\n        along <- .normarg_along(along)\n        if (along > N + 1L)\n            stop(wmsg(\"'along' must be <= N + 1, where N is the number of \",\n                      \"dimensions of the arrays with the most dimensions\"))\n    } else {\n        rev.along <- .normarg_rev_along(rev.along)\n        if (rev.along > N)\n            stop(wmsg(\"'rev.along' must be <= N, where N is the number of \",\n                      \"dimensions of the arrays with the most dimensions\"))\n        along <- N + 1L - rev.along\n    }\n    along\n}\n\n### 'ndim' is expected to be >= number of dimensions of the arrays with\n### the most dimensions.\n### To be re-used by other abind() methods e.g. by the method for SparseArray\n### objects.\nadd_missing_dims <- function(objects, ndim)\n{\n    stopifnot(is.list(objects), isSingleInteger(ndim))\n    lapply(objects,\n        function(object) {\n            object_dim <- dim(object)\n            object_ndim <- length(object_dim)\n            if (object_ndim >= ndim)\n                return(object)\n            set_dim(object, c(object_dim, rep.int(1L, ndim - object_ndim)))\n        }\n    )\n}\n\nsimple_abind2 <- function(objects, along=NULL, rev.along=NULL)\n{\n    stopifnot(is.list(objects))\n    objects <- S4Vectors:::delete_NULLs(objects)\n    if (length(objects) == 0L)\n        return(NULL)\n    ndims <- vapply(objects, function(object) length(dim(object)), integer(1))\n    N <- max(ndims)\n    along <- get_along(N, along=along, rev.along=rev.along)\n    ans_ndim <- max(N, along)\n    objects <- add_missing_dims(objects, ans_ndim)\n    do.call(simple_abind, c(objects, list(along=along)))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### abind0()\n###\n### A simple wrapper around abind::abind() that uses 'use.first.dimnames=TRUE'\n### by default to correct mishandling of the dimnames.\n### See \"A NOTE ABOUT CRAN PACKAGE abind 1.4-5\" above in this file.\n\nabind0 <- function(..., use.first.dimnames=TRUE)\n{\n    abind::abind(..., use.first.dimnames=use.first.dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The abind() generic and default method\n###\n\n### Like in the original abind::abind(), the default for 'along' is the last\n### dimension. However, here in the generic function, the default value is\n### NULL instead of 'N', but it means the same thing.\nsetGeneric(\"abind\", signature=\"...\",\n    function(..., along=NULL, rev.along=NULL) standardGeneric(\"abind\")\n)\n\n### All argument names of abind::abind(), ignoring the ellipsis.\n.ORGINAL_ABIND_ARGNAMES <- setdiff(names(formals(abind::abind)), \"...\")\n\n### Return the supplied objects in an ordinary list. Any argument that is\n### not a \"recognized\" argument of the original abind::abind() is considered\n### an object.\n.extract_objects <- function(...)\n{\n    objects <- list(...)\n    objects[.ORGINAL_ABIND_ARGNAMES] <- NULL\n    unname(S4Vectors:::delete_NULLs(objects))\n}\n\n### Return the list of supplied arguments that belong to the original\n### abind::abind() interface.\n.extract_crazy_args <- function(...)\n{\n    dots <- list(...)\n    dots[intersect(names(dots), .ORGINAL_ABIND_ARGNAMES)]\n}\n\n### One object in 'objects' **must** be an Array derivative, but not all!\n### Try to re-dispatch on an existing abind() method defined for some Array\n### derivative. If such method is found, then it should return an Array\n### derivative.\n.abind_as_Array <- function(objects, is_Array, is_array,\n                            along=NULL, rev.along=NULL)\n{\n    stopifnot(is.list(objects),\n              is.logical(is_Array), length(is_Array) == length(objects),\n              is.logical(is_array), length(is_array) == length(objects))\n    if (!all(is_Array | is_array))\n        stop(wmsg(\"all objects passed to abind() must be array-like \",\n                  \"objects when some of them are Array derivatives\"))\n\n    ## Avoid infinite recursion if re-dispatch fails to find an abind()\n    ## method defined for some Array derivatives.\n    if (all(is_Array)) {\n        x1 <- objects[[1L]]\n        stop(wmsg(\"no abind() method found for \", class(x1)[[1L]], \" objects\"))\n    }\n\n    ## Coerce all arrays or matrices to the class of the first Array\n    ## derivative found in 'objects'.\n    x1 <- objects[[which(is_Array)[[1L]]]]\n    objects[is_array] <- lapply(objects[is_array], S4Vectors:::coerce2, x1)\n\n    ## Call the abind() generic in the hope that method dispatch will find\n    ## a method defined for objects of class 'class(x1)'.\n    do.call(S4Arrays::abind, c(objects, list(along=along, rev.along=rev.along)))\n}\n\n### .default_abind() tries to dispatch on the following functions, in this\n### order:\n### 1. Dispatch on the abind() generic: If the objects to bind are supplied\n###    in a list then .default_abind() will dispatch on the abind() generic.\n###    However this time the objects are passed to abind() as individual\n###    arguments. This gives the abind() generic the opportunity to dispatch\n###    on the appropriate S4 method (e.g. on the abind() method for SparseArray\n###    objects if all the objects are SparseArray derivatives). If no specific\n###    S4 method is found then .default_abind() will be called again but note\n###    that infinite recursion is naturally avoided.\n### 2. Dispatch on .abind_as_Array(): If at least one of the objects to\n###    bind is an Array derivative then .default_abind() will dispatch\n###    on .abind_as_Array().\n### 3. Dispatch on simple_abind2(): When all the objects to bind are ordinary\n###    arrays (including matrices) and no \"crazy arguments\" are supplied,\n###    then .default_abind() will dispatch on simple_abind2(). Note that\n###    a \"crazy argument\" is any formal argument located after the ellipsis\n###    in abind::abind() except 'along' and 'rev.along'.\n### 4. Finally, if all the above fails, then dispatch on abind::abind()\n###    wrapper abind0().\n.default_abind <- function(..., along=NULL, rev.along=NULL)\n{\n    objects <- .extract_objects(...)\n    if (length(objects) == 0L)\n        return(NULL)\n    crazy_args <- .extract_crazy_args(...)\n    all_extra_args <- c(list(along=along, rev.along=rev.along), crazy_args)\n    ok1 <- vapply(objects, is.list, logical(1))\n    ok2 <- vapply(objects, is.array, logical(1))\n    ok3 <- vapply(objects, is, logical(1), \"Array\")\n    if (any(ok1 & !(ok2 | ok3))) {\n        ## 1. Dispatch on the abind() generic.\n        if (length(objects) != 1L)\n            stop(wmsg(\"when supplying a list, all the objects \",\n                      \"to bind must be supplied via the list\"))\n        x <- objects[[1L]]\n        return(do.call(S4Arrays::abind, c(x, all_extra_args)))\n    }\n    if (any(ok3)) {\n        ## 2. Dispatch on .abind_as_Array().\n        if (length(crazy_args) != 0L) {\n            argnames <- paste0(\"'\", names(crazy_args), \"'\", collapse=\",\")\n            stop(wmsg(\"unsupported argument(s) when calling abind() \",\n                      \"on Array derivatives: \", argnames))\n        }\n        return(.abind_as_Array(objects, ok3, ok2,\n                               along=along, rev.along=rev.along))\n    }\n    if (all(ok2) && length(crazy_args) == 0L) {\n        ## 3. Dispatch on simple_abind2(), which is significantly faster than\n        ##    abind::abind().\n        return(simple_abind2(objects, along=along, rev.along=rev.along))\n    }\n    ## 4. Dispatch on abind::abind() wrapper abind0().\n    all_extra_args <- S4Vectors:::delete_NULLs(all_extra_args)\n    do.call(abind0, c(objects, all_extra_args))\n}\n\nsetMethod(\"abind\", \"ANY\", .default_abind)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Bind arrays along their 1st or 2nd dimension\n###\n### TODO: No need for these functions to be generics. They should just be\n### simple wrappers to 'abind(..., along=1L)' and 'abind(..., along=2L)',\n### respectively.\n\nsetGeneric(\"arbind\", function(...) standardGeneric(\"arbind\"))\nsetGeneric(\"acbind\", function(...) standardGeneric(\"acbind\"))\n\nsetMethod(\"arbind\", \"ANY\", function(...) abind(..., along=1L))\nsetMethod(\"acbind\", \"ANY\", function(...) abind(..., along=2L))\n\n",
        "aperm2.R": "### =========================================================================\n### aperm2()\n### -------------------------------------------------------------------------\n###\n### Extend base::aperm() functionality by allowing dropping and/or\n### adding \"ineffective dimensions\" (i.e. dimensions with an extent of 1).\n### Like base::aperm(), aperm2() preserves the length of input array 'a'.\n###\n\n\n### Normalize 'perm' argument of extended aperm().\n### Only performs a shallow check of 'perm' e.g. won't say anything if 'perm'\n### contains values > length(a_dim) or duplicates. Use validate_perm() defined\n### below on the value returned by normarg_perm() for a full check.\nnormarg_perm <- function(perm, a_dim)\n{\n    if (missing(perm))\n        return(rev(seq_along(a_dim)))\n    if (is.null(perm))\n        return(seq_along(a_dim))\n    if (!is.numeric(perm))\n        stop(wmsg(\"'perm' must be an integer vector\"))\n    if (!is.integer(perm))\n        perm <- as.integer(perm)\n    perm\n}\n\n### Validate 'perm' argument of extended aperm().\n### Return TRUE if the argument is valid or a single string describing why\n### it's not. This design allows the function to be used in the context of\n### a validity method.\nvalidate_perm <- function(perm, a_dim)\n{\n    if (!is.integer(perm))\n        return(\"'perm' must be an integer vector\")\n    if (length(perm) == 0L)\n        return(\"'perm' cannot be an empty vector\")\n    perm0 <- perm[!is.na(perm)]\n    if (length(perm0) == 0L) {\n        dropped_dims <- a_dim\n    } else {\n        if (S4Vectors:::anyMissingOrOutside(perm0, 1L, length(a_dim)))\n            return(paste0(\"all non-NA values in 'perm' \",\n                          \"must be >= 1 and <= 'length(dim(a))'\"))\n        if (anyDuplicated(perm0))\n            return(\"'perm' cannot contain non-NA duplicates\")\n        dropped_dims <- a_dim[-perm0]\n    }\n    if (!all(dropped_dims == 1L))\n        return(\"only dimensions with an extent of 1 can be dropped\")\n    TRUE\n}\n\n### 'APERM.FUN' is the function that will actually take care of permuting\n### the dimensions. It only needs to know how to handle \"clean\" permutations\n### i.e. permutation vectors like those handled by base::aperm().\n### The current implementation assumes that array-like object 'a' supports\n### set_dim() and set_dimnames().\n### NOT exported but used in the SparseArray package!\nextended_aperm <- function(a, perm, APERM.FUN)\n{\n    a_dim <- dim(a)\n    a_dimnames <- dimnames(a)\n    perm <- normarg_perm(perm, a_dim)\n    msg <- validate_perm(perm, a_dim)\n    if (!isTRUE(msg))\n        stop(wmsg(msg))\n\n    nonNA_idx <- which(!is.na(perm))\n    perm0 <- perm[nonNA_idx]\n\n    ## 1. Drop the dimensions not present in 'perm0'. Even though the\n    ##    dimensions to drop are guaranteed to have an extent of 1, we should\n    ##    not use drop() for this because this would drop **all** the\n    ##    dimensions with an extent of 1, including some of the dimensions\n    ##    to keep (those can also have an extent of 1).\n    ans <- set_dim(a, a_dim[sort(perm0)])\n\n    ## 2. Permute the remaining dimensions.\n    ##    Note that by default rank() returns a numeric vector so we\n    ##    use 'ties.method=\"first\"' to get an integer vector (even\n    ##    though 'perm0' will never contain duplicates).\n    ans <- APERM.FUN(ans, perm=rank(perm0, ties.method=\"first\"))\n\n    ## 3. Add ineffective dimensions corresponding to NAs in 'perm'.\n    ans_dim <- rep.int(1L, length(perm))\n    ans_dim[nonNA_idx] <- dim(ans)\n    ans <- set_dim(ans, ans_dim)\n\n    ## 4. Take care of the dimnames.\n    if (!is.null(a_dimnames))\n        ans <- set_dimnames(ans, simplify_NULL_dimnames(a_dimnames[perm]))\n    ans\n}\n\n### Supports dropping and/or adding ineffective dimensions.\naperm2 <- function(a, perm)\n{\n    if (!is.array(a))\n        stop(wmsg(\"'a' must be an array\"))\n    extended_aperm(a, perm, base::aperm)\n}\n\n",
        "arep.R": "### =========================================================================\n### arep_times() & arep_each()\n### -------------------------------------------------------------------------\n###\n\n\n### Also used to normalize the 'each' argument of arep_each().\n.normarg_times <- function(times, x_dim, argname=\"times\")\n{\n    if (!(is.vector(times) && is.numeric(times)))\n        stop(wmsg(\"'\", argname, \"' must be a numeric vector\"))\n    if (!is.integer(times))\n        times <- as.integer(times)\n    if (length(times) != length(x_dim))\n        stop(wmsg(\"'\", argname, \"' must have one element per array \",\n                  \"dimension, that is, 'length(\", argname, \")' must \",\n                  \"equal 'length(dim(x))'\"))\n    if (isTRUE(any(times < 0L)))\n        stop(wmsg(\"'\", argname, \"' cannot contain negative values\"))\n    isna <- is.na(times)\n    if (any(isna & x_dim != 0L))\n        stop(wmsg(\"NAs in '\", argname, \"' are only allowed along \",\n                  \"array dimensions equal to zero\"))\n    times[isna] <- 1L\n    times\n}\n\n.check_returned_dim <- function(returned_dim, expected_dim, .Generic, x_class)\n{\n    ok <- length(returned_dim) == length(expected_dim) &&\n          all(returned_dim == expected_dim)\n    if (!ok)\n        stop(wmsg(\"the \", .Generic, \"() method for \", x_class, \" objects \",\n                  \"returned an array with incorrect dimensions\"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### arep_times()\n###\n\n### Multidimensional version of 'base::rep(x, times=)'.\n### The 'times' argument is expected to be an integer vector with the\n### same length as 'dim(x)'.\n### Must act as an endomorphism i.e. must return an array-like object\n### of the same class as 'x'.\n### Notes:\n### - output array is 'prod(times)' times bigger than input array!\n### - 'arep_times(x, rep.int(1, length(dim(x))))' should always act as a no-op.\nsetGeneric(\"arep_times\", signature=\"x\",\n    function(x, times)\n    {\n        x_dim <- dim(x)\n        if (is.null(x_dim))\n            stop(wmsg(\"the first argument to arep_times() must be an \",\n                      \"array-like object (i.e. it must have dimensions)\"))\n        times <- .normarg_times(times, x_dim)\n        ans <- standardGeneric(\"arep_times\")\n        .check_returned_dim(dim(ans), x_dim * times,\n                            \"arep_times\", class(x)[[1L]])\n        ans\n    }\n)\n\n### We can use subassignment with linear recycling if and only if all\n### the dimensions in 'x_dim' that are on the right of the first non-one\n### value in 'times' are ineffective dimensions (i.e. have an extent of 1).\n.can_use_linear_recycling <- function(x_dim, times)\n{\n    idx <- which(times != 1L)\n    if (length(idx) == 0L)\n        return(TRUE)\n    idx1 <- idx[[1L]]\n    all(tail(x_dim, n=-idx1) == 1L)\n}\n\n### Only for ordinary arrays at the moment.\n.arep_times_using_linear_recycling <- function(x, times)\n{\n    stopifnot(is.array(x), is.integer(times))\n    x_dim <- dim(x)\n    stopifnot(length(x_dim) == length(times))\n    array(x, dim=x_dim*times)\n}\n\n### Default method. Works on any array-like object 'x' that supports `[`.\n.default_arep_times <- function(x, times)\n{\n    ## The arep_times() generic already took care of checking/validating 'x'\n    ## and 'times'. See above.\n    x_dim <- dim(x)\n    if (.can_use_linear_recycling(x_dim, times) && is.array(x))\n        return(.arep_times_using_linear_recycling(x, times))\n    index <- lapply(seq_along(times),\n        function(along) rep.int(seq_len(x_dim[[along]]), times[[along]]))\n    subset_by_Nindex(x, index)  # relies on `[`\n}\n\n### An alternative to .default_arep_times() based on abind().\n### Timings on ordinary arrays indicate that .default_arep_times() tend to\n### be significantly faster than .default_arep_times2(), except when 'x' is\n### big and the values in 'times' are small (e.g. 'prod(times)' < 100), in\n### which case the latter is only marginally faster. So not worth it!\n.default_arep_times2 <- function(x, times)\n{\n    ## The arep_times() generic already took care of checking/validating 'x'\n    ## and 'times'. See above.\n    for (along in seq_along(times)) {\n        t <- times[[along]]\n        if (t == 1L)\n            next\n        args <- c(rep.int(list(x), t), list(along=along))\n        x <- do.call(abind, args)\n    }\n    x\n}\n\nsetMethod(\"arep_times\", \"ANY\", .default_arep_times)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### arep_each()\n###\n\n### Multidimensional version of 'base::rep(x, each=)'.\n### The 'each' argument is expected to be an integer vector with the\n### same length as 'dim(x)'.\n### Must act as an endomorphism i.e. must return an array-like object\n### of the same class as 'x'.\n### Notes:\n### - output array is 'prod(each)' times bigger than input array!\n### - 'arep_each(x, rep.int(1, length(dim(x))))' should always act as a no-op.\nsetGeneric(\"arep_each\", signature=\"x\",\n    function(x, each)\n    {\n        x_dim <- dim(x)\n        if (is.null(x_dim))\n            stop(wmsg(\"the first argument to arep_each() must be an \",\n                      \"array-like object (i.e. it must have dimensions)\"))\n        each <- .normarg_times(each, x_dim, argname=\"each\")\n        ans <- standardGeneric(\"arep_each\")\n        .check_returned_dim(dim(ans), x_dim * each,\n                            \"arep_each\", class(x)[[1L]])\n        ans\n    }\n)\n\n### About 3x faster than 'base::rep(x, each=)'.\n.fast_rep_each <- function(x, each)\n{\n    stopifnot(isSingleInteger(each))\n    rep.int(x, rep.int(each, length(x)))\n}\n\n### Default method. Works on any array-like object 'x' that supports `[`.\n.default_arep_each <- function(x, each)\n{\n    ## The arep_each() generic already took care of checking/validating 'x'\n    ## and 'each'. See above.\n    x_dim <- dim(x)\n    index <- lapply(seq_along(each),\n        function(along) .fast_rep_each(seq_len(x_dim[[along]]), each[[along]]))\n    subset_by_Nindex(x, index)  # relies on `[`\n}\n\nsetMethod(\"arep_each\", \"ANY\", .default_arep_each)\n\n",
        "array_recycling.R": "### =========================================================================\n### Multidimensional array recycling a.k.a. \"tile recycling\"\n### -------------------------------------------------------------------------\n###\n### Typically used in the context of 'Ops' operations on arrays or array-like\n### objects.\n###\n### Motivating use case for this is to replace cumbersome, inefficient, and\n### obfuscated code like:\n###\n###     cs <- colSums(x)\n###     t(t(x) / cs)  # double transposition can be very expensive!\n###\n### with:\n###\n###     cs <- colSums(x)\n###     x / as_tile(cs, along=2)\n###\n### Sure, more typing, but the intention of the code is clearer and it's also\n### more efficient (it avoids the double transposition). E.g. it's 3x faster\n### on a 8000 x 20,000 matrix generated with 'matrix(runif(16e7), ncol=2e4)'.\n### The speedup is even more drastic (e.g. 10x or more) when 'x' is an\n### SVT_SparseMatrix object.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### as_tile()\n###\n\nsetClass(\"tile\", contains=\"array\")\n\n.vector_as_tile <- function(x, along=1L)\n{\n    stopifnot(is.vector(x))\n    if (!isSingleNumber(along))\n        stop(wmsg(\"'along' must be a single integer\"))\n    if (!is.integer(along))\n        along <- as.integer(along)\n    if (along <= 0L)\n        stop(wmsg(\"'along' must be a positive integer\"))\n    new(\"tile\", array(x, dim=c(rep.int(1L, along-1L), length(x))))\n}\n\n### Only returns an actual tile object when 'x' is an ordinary vector or\n### array. Otherwise, when 'x' is an array-like object that is **not** an\n### ordinary array, as_tile() acts as an endomorphism i.e. it preserves the\n### class of 'x' (note that this endomorphism is a no-op if 'dim' is not\n### specified). This is the case for example when 'x' is a dgCMatrix,\n### SparseArray, or DelayedArray object, etc.. or a tile object itself.\nas_tile <- function(x, along=1L, dim=NULL)\n{\n    if (is.vector(x)) {\n        if (is.null(dim))\n            return(.vector_as_tile(x, along=along))\n        if (!identical(along, 1L))\n            stop(wmsg(\"only one of 'along' or 'dim' can be specified\"))\n        dim(x) <- dim\n    } else {\n        if (is.null(dim(x)))\n            stop(wmsg(\"'x' must be an array-like object or a vector\"))\n        if (!identical(along, 1L))\n            stop(wmsg(\"'along' can only be used on a vector\"))\n        if (!is.null(dim))\n            x <- set_dim(x, dim)  # reshape the array (not all array-like\n                                  # objects will support this)\n        if (!is.array(x))\n            return(x)  # endomorphism (and no-op if 'dim' is NULL)\n    }\n    new(\"tile\", x)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### recycle_tile()\n###\n\n### 'tile_dim' and 'x_dim' must be \"parallel\" integer vectors (i.e. vectors\n### of same length). Returns another parallel integer vector.\n.compute_recycling_extent <- function(tile_dim, x_dim)\n{\n    stopifnot(is.integer(tile_dim), is.integer(x_dim))\n    if (length(tile_dim) != length(x_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n    ok <- all((x_dim %% tile_dim == 0L) | x_dim == 0L)\n    if (is.na(ok))\n        stop(wmsg(\"no tile dimension can be equal to 0 unless the  \",\n                  \"corresponding array dimension is also equal to 0\"))\n    if (!ok)\n        stop(wmsg(\"each array dimension must be a multiple \",\n                  \"of the corresponding tile dimension\"))\n    x_dim %/% tile_dim\n}\n\n### NOT exported for now.\n### Should **always** return an array-like object with dimensions 'x_dim'.\n### Preserves the class of 'tile' (endomorphism) except when it's a tile\n### object, in which case the class attribute is dropped and an ordinary\n### array or matrix is returned.\nrecycle_tile <- function(tile, x_dim)\n{\n    if (is.vector(tile))\n        tile <- as.array(tile)  # 1D-array\n    tile_dim <- dim(tile)\n    if (is.null(tile_dim))\n        stop(wmsg(\"'tile' must be an array-like object or a vector\"))\n    ndim <- length(x_dim)\n    if (length(tile_dim) < ndim) {\n        tile_dim <- rpad_dim(tile_dim, ndim)\n        tile <- set_dim(tile, tile_dim)\n    }\n    extent <- .compute_recycling_extent(tile_dim, x_dim)\n    arep_times(tile, extent)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Ops() methods for tile objects\n###\n\n### The returned array is guaranteed to have the dimensions of the left array.\nsetMethod(\"Ops\", c(\"array\", \"tile\"),\n    function(e1, e2)\n    {\n        e2 <- recycle_tile(e2, dim(e1))\n        callNextMethod()\n    }\n)\n\n### The returned array is guaranteed to have the dimensions of the right array.\nsetMethod(\"Ops\", c(\"tile\", \"array\"),\n    function(e1, e2)\n    {\n        e1 <- recycle_tile(e1, dim(e2))\n        callNextMethod()\n    }\n)\n\n### Returns one of \"L\", \"R\", \"LR\", or an error.\n.which_side_to_recycle <- function(Ldim, Rdim)\n{\n    if (length(Ldim) != length(Rdim))\n        stop(wmsg(\"non-conformable arrays\"))\n    errmsg <- \"neither array can be used as a tile to lay on the other array\"\n    L_is_zero <- Ldim == 0L\n    R_is_zero <- Rdim == 0L\n    cannot_be_left  <- any(L_is_zero > R_is_zero)\n    cannot_be_right <- any(L_is_zero < R_is_zero)\n    if (cannot_be_left && cannot_be_right)\n        stop(wmsg(errmsg))\n    could_be_left  <- all(Rdim %% Ldim == 0L, na.rm=TRUE)\n    could_be_right <- all(Ldim %% Rdim == 0L, na.rm=TRUE)\n    if (cannot_be_left) {\n        if (could_be_right)\n            return(\"R\")\n        stop(wmsg(errmsg))\n    }\n    if (cannot_be_right) {\n        if (could_be_left)\n            return(\"L\")\n        stop(wmsg(errmsg))\n    }\n    if (could_be_left && could_be_right)\n        return(\"LR\")  # means the 2 arrays are conformable (i.e. same dims)\n    if (could_be_left)\n        return(\"L\")\n    if (could_be_right)\n        return(\"R\")\n    stop(wmsg(errmsg))\n}\n\nsetMethod(\"Ops\", c(\"tile\", \"tile\"),\n    function(e1, e2)\n    {\n        dim1 <- dim(e1)\n        dim2 <- dim(e2)\n        ndim1 <- length(dim1)\n        ndim2 <- length(dim2)\n        if (ndim1 < ndim2) {\n            dim1 <- rpad_dim(dim1, ndim2)\n            e1 <- set_dim(e1, dim1)\n        } else if (ndim1 > ndim2) {\n            dim2 <- rpad_dim(dim2, ndim1)\n            e2 <- set_dim(e2, dim2)\n        }\n        side <- .which_side_to_recycle(dim1, dim2)\n        if (side == \"L\") {\n            e1 <- recycle_tile(e1, dim2)\n        } else if (side == \"R\") {\n            e2 <- recycle_tile(e2, dim1)\n        }\n        callGeneric()\n    }\n)\n\n",
        "array_selection.R": "### =========================================================================\n### Manipulation of array selections\n### -------------------------------------------------------------------------\n###\n\n### Note that Lindex2Mindex() and Mindex2Lindex() do not allow NAs at the\n### moment (they trigger an error) even though R base allows them in matrix\n### subsripts.\n### TODO: Allow NAs in the input of Lindex2Mindex() and Mindex2Lindex().\n### We could either always allow them or add an argument (e.g. 'allowNAs')\n### that the user would set to TRUE to allow them.\n\n### Like base::arrayInd() but faster and accepts a matrix for 'dim' (with 1\n### row per element in 'Lindex').\nLindex2Mindex <- function(Lindex, dim, use.names=FALSE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    ## 'dim' can be a matrix so it's important to use storage.mode()\n    ## instead of as.integer().\n    if (storage.mode(dim) == \"double\")\n        storage.mode(dim) <- \"integer\"\n    ## 'Lindex' and 'dim' will be fully checked at the C level.\n    .Call2(\"C_Lindex2Mindex\", Lindex, dim, use.names, PACKAGE=\"S4Arrays\")\n}\n\nMindex2Lindex <- function(Mindex, dim, use.names=FALSE, as.integer=FALSE)\n{\n    if (!isTRUEorFALSE(use.names))\n        stop(\"'use.names' must be TRUE or FALSE\")\n    if (!isTRUEorFALSE(as.integer))\n        stop(\"'as.integer' must be TRUE or FALSE\")\n    ## 'dim' and/or 'Mindex' can be matrices so it's important to use\n    ## storage.mode() instead of as.integer(). Also, unlike as.integer(),\n    ## this preserves the names/dimnames.\n    if (storage.mode(dim) == \"double\")\n        storage.mode(dim) <- \"integer\"\n    if (storage.mode(Mindex) == \"double\")\n        storage.mode(Mindex) <- \"integer\"\n    ## 'Mindex' and 'dim' will be fully checked at the C level.\n    .Call2(\"C_Mindex2Lindex\", Mindex, dim, use.names,\n                              as.integer, PACKAGE=\"S4Arrays\")\n}\n\n### NOT exported but used in the SparseArray and DelayedArray packages!\n### Returns an integer vector with one element per row in 'Mindex'.\nMindex_order <- function(Mindex)\n{\n    stopifnot(is.matrix(Mindex), ncol(Mindex) != 0L)\n    cols <- lapply(ncol(Mindex):1, function(j) Mindex[ , j])\n    do.call(order, cols)\n}\n\n### NOT exported but used in the SparseArray package!\n### Semantic is similar to Unix uniq command (i.e. it reports consecutive\n### repeated rows in matrix 'Mindex'). Note that it conceptually walks down\n### the rows from last to first. Concretely this means that all the rows in\n### a group of repeated rows are considered repeated except the last one.\n### Returns a logical vector with one element per row in 'Mindex'.\nMindex_row_is_repeated <- function(Mindex)\n{\n    stopifnot(is.matrix(Mindex), ncol(Mindex) != 0L)\n    Mindex_nrow <- nrow(Mindex)\n    if (Mindex_nrow <= 1L)\n        return(logical(Mindex_nrow))\n    m1 <- Mindex[         -1L, , drop=FALSE]\n    m2 <- Mindex[-Mindex_nrow, , drop=FALSE]\n    c(rowSums(m1 == m2) == ncol(Mindex), FALSE)\n}\n\n",
        "dim-tuning-utils.R": "### =========================================================================\n### Dim tuning utilities\n### -------------------------------------------------------------------------\n###\n### \"Dim tuning\" is the act of adding and/or dropping \"ineffective\n### dimensions\" to/from an array-like object, typically via the drop()\n### and/or dim() setter. The exact transformation to operate on the vector\n### of dimensions of the object can be precisely described by supplying\n### a 'dim_tuner' vector.\n### See src/dim_tuning_utils.c for additional information.\n\n\n### Checks that 'value' actually looks like a dim vector and that it\n### will preserve the length of the receiving array.\n### NOT exported but used in the DelayedArray package!\nnormalize_dim_replacement_value <- function(value, x_dim)\n{\n    if (is.null(value))\n        stop(wmsg(\"you can't do that, sorry\"))\n    value <- as_integer_dim(value, \"the supplied dim vector\")\n    prod1 <- prod(value)\n    prod2 <- prod(x_dim)\n    if (prod1 != prod2)\n        stop(wmsg(\"the supplied dims [product \", prod1, \"] do not match \",\n                  \"the length of object [\", prod2, \"]\"))\n    value\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The tune_Array_dims() low-level generic\n###\n### Array derivatives (e.g. SparseArray or DelayedArray objects) only need\n### to implement a tune_Array_dims() method to have drop() and the dim()\n### setter work out-of-the-box.\n###\n### Note that a \"dim tuning\" operation does NOT change the length of the\n### object (which is prod(dim(x))) or alter its content, and should always\n### be reversible (except when it drops ineffective dimensions with dimnames\n### on them). To revert a \"dim tuning\" operation, simply tune again\n### with '-dim_tuner' (i.e. with minus 'dim_tuner'). More precisely, for\n### tune_Array_dims(), 'x2' should always be identical to 'x' here:\n###\n###     y <- tune_Array_dims(x, dim_tuner)\n###     x2 <- tune_Array_dims(y, -dim_tuner)\n###     identical(x2, x)  # should be TRUE\n###\n### This should be the case for any array-like object 'x' (with no dimnames\n### on its ineffective dimensions) and any 'dim_tuner' vector compatible\n### with 'dim(x)'.\n\nsetGeneric(\"tune_Array_dims\", signature=\"x\",\n    function(x, dim_tuner) standardGeneric(\"tune_Array_dims\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### tune_dims() and tune_dimnames()\n###\n### NOT exported but used by the tune_Array_dims() method for SVT_SparseArray\n### objects defined in the SparseArray package.\n\ntune_dims <- function(dim, dim_tuner)\n{\n    stopifnot(is.integer(dim),\n              is.integer(dim_tuner))\n    .Call2(\"C_tune_dims\", dim, dim_tuner, PACKAGE=\"S4Arrays\")\n}\n\ntune_dimnames <- function(dimnames, dim_tuner)\n{\n    stopifnot(is.null(dimnames) || is.list(dimnames),\n              is.integer(dim_tuner))\n    .Call2(\"C_tune_dimnames\", dimnames, dim_tuner, PACKAGE=\"S4Arrays\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### drop() method\n###\n\n### base::drop() is kind of messed up in the 1D case. This is a replacement\n### that does the right thing.\n### NOT exported but used in the SparseArray package!\ndrop_even_if_1D <- function(a)\n{\n    stopifnot(is.array(a) || is.vector(a))\n    if (length(dim(a)) != 1L)\n        return(base::drop(a))\n    setNames(as.vector(a), names(a))\n}\n\n### Expected to be semantically equivalent to 'drop_even_if_1D(as.array(x))'.\n### Will work out-of-the-box on any Array derivative that supports\n### tune_Array_dims() and as.array(). Note that the latter is used\n### only if 'x' has at most one effective dimension.\n.drop_Array <- function(x)\n{\n    if (!isS4(x)) {\n        ## Avoid S4 dispatch on Array objects that are not S4 objects (e.g.\n        ## Array objects from the arrow package).\n        return(base::drop(x))\n    }\n    is_effective <- dim(x) != 1L\n    if (sum(is_effective) <= 1L)\n        return(drop_even_if_1D(as.array(x)))  # ordinary vector\n    dim_tuner <- -as.integer(!is_effective)\n    tune_Array_dims(x, dim_tuner)\n}\n\nsetMethod(\"drop\", \"Array\", .drop_Array)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### dim() setter\n###\n\n.diff_dims <- function(old_dim, new_dim, x_class)\n{\n    stopifnot(is.integer(old_dim), is.integer(new_dim))\n\n    cannot_map_msg <- c(\n        \"Cannot map the supplied dim vector to the current dimensions of \",\n        \"the object. On a \", x_class, \" object, the dim() setter can only \",\n        \"be used to drop and/or add \\\"ineffective dimensions\\\" (i.e. \",\n        \"dimensions equal to 1) to the object.\"\n    )\n    can_map_effective_dimensions <- function(effdim_idx1, effdim_idx2) {\n        if (length(effdim_idx1) != length(effdim_idx2))\n            return(FALSE)\n        if (length(effdim_idx1) == 0L)\n            return(TRUE)\n        all(old_dim[effdim_idx1] == new_dim[effdim_idx2])\n    }\n\n    ## Get index of old and new effective dimensions.\n    effdim_idx1 <- which(old_dim != 1L)\n    effdim_idx2 <- which(new_dim != 1L)\n\n    if (!can_map_effective_dimensions(effdim_idx1, effdim_idx2))\n        stop(wmsg(cannot_map_msg))\n\n    compute_dim_tuner <- function(effdim_idx1, effdim_idx2) {\n        idx1 <- c(effdim_idx1, length(old_dim) + 1L)\n        idx2 <- c(effdim_idx2, length(new_dim) + 1L)\n        diffs1 <- S4Vectors:::diffWithInitialZero(idx1)\n        diffs2 <- S4Vectors:::diffWithInitialZero(idx2)\n        deltas <- pmax(diffs1, diffs2)\n        nonzero_runlengths <- deltas - 1L\n        ans_len <- sum(nonzero_runlengths) + length(effdim_idx1)\n        ans <- integer(ans_len)\n        offsets <- c(0L, head(cumsum(deltas), n=-1L))\n        for (k in seq_along(idx1)) {\n            d <- diffs2[[k]] - diffs1[[k]]\n            op <- ifelse(d > 0L, 1L, -1L)\n            ans[offsets[[k]] + seq_len(abs(d))] <- rep.int(op, abs(d))\n        }\n        ans\n    }\n\n    compute_dim_tuner(effdim_idx1, effdim_idx2)\n}\n\n.set_Array_dim <- function(x, value)\n{\n    x_dim <- dim(x)\n    value <- normalize_dim_replacement_value(value, x_dim)\n    dim_tuner <- .diff_dims(x_dim, value, class(x))\n    ans <- tune_Array_dims(x, dim_tuner)\n    stopifnot(identical(dim(ans), value))  # sanity check\n    ans\n}\n\nsetReplaceMethod(\"dim\", \"Array\", .set_Array_dim)\n\n",
        "extract_array.R": "### =========================================================================\n### extract_array()\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level helpers\n###\n\n### Return the slice as a list.\n.extract_data_frame_slice <- function(x, index)\n{\n    slice <- subset_by_Nindex(x, index)\n    ## Turn into a list and replace factors with character vectors.\n    lapply(slice, as.vector)\n}\n\n.extract_DataFrame_slice0 <- function(x)\n{\n    ## Make sure that this remains consistent with .get_DataFrame_type()\n    ## defined in R/type.R\n    x0 <- x[0L, , drop=FALSE]\n    df0 <- as.data.frame(x0)\n    if (ncol(df0) != ncol(x))\n        stop(wmsg(\"DataFrame object 'x' can be used as the seed of \",\n                  \"a DelayedArray object only if as.data.frame(x) \",\n                  \"preserves the number of columns\"))\n    BiocGenerics:::extract_data_frame_slice0(df0)\n}\n\n.extract_DataFrame_slice <- function(x, index)\n{\n    slice <- subset_by_Nindex(x, index)\n    slice <- as.data.frame(slice)\n    ## Turn into a list and replace factors with character vectors.\n    lapply(slice, as.vector)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_array() generic and methods\n###\n### Note that extract_array() is part of the \"seed contract\" as defined in\n### the \"Implementing A DelayedArray Backend\" vignette from the DelayedArray\n### package.\n\n### Similar to SparseArray:::.contact_author_msg2().\n.contact_author_msg1 <- function(.Generic, x_class)\n{\n    msg <- c(\"Please contact the authors/maintainers of the \",\n             x_class, \" class\")\n    class_package <- attr(x_class, \"package\")\n    if (!is.null(class_package))\n        msg <- c(msg, \" (defined in the \", class_package, \" package)\")\n    c(msg, \" about this, and point them to the man page for the \",\n           .Generic, \"() generic function defined in the S4Arrays \",\n           \"package ('?S4Arrays::\", .Generic, \"').\")\n}\n\ncheck_returned_array <- function(ans, expected_dim, .Generic, x_class)\n{\n    if (!is.array(ans))\n        stop(wmsg(\"The \", .Generic, \"() method for \", x_class, \" \",\n                  \"objects didn't return an ordinary array. \",\n                  .Generic, \"() methods should **always** return an \",\n                  \"ordinary array. \",\n                  .contact_author_msg1(.Generic, x_class)))\n    if (!identical(dim(ans), expected_dim))\n        stop(wmsg(\"The \", .Generic, \"() method for \", x_class, \" \",\n                  \"objects returned an array with incorrect \",\n                  \"dimensions. \", .contact_author_msg1(.Generic, x_class)))\n    ans\n}\n\n### 'index' is expected to be an unnamed list of subscripts as positive\n### integer vectors, one vector per dimension in 'x'. *Missing* list elements\n### are allowed and represented by NULLs.\n### The extract_array() methods don't need to support anything else.\n### They must return an ordinary array. No need to propagate the dimnames.\nsetGeneric(\"extract_array\", signature=\"x\",\n    function(x, index)\n    {\n        x_dim <- dim(x)\n        if (is.null(x_dim))\n            stop(wmsg(\"the first argument to extract_array() must be an \",\n                      \"array-like object (i.e. it must have dimensions)\"))\n        ans <- standardGeneric(\"extract_array\")\n        expected_dim <- get_Nindex_lengths(index, x_dim)\n        check_returned_array(ans, expected_dim,\n                             \"extract_array\", class(x)[[1L]])\n    }\n)\n\n### subset_by_Nindex() uses `[` internally to perform the subsetting, so\n### this default extract_array() method will work on any object 'x' that\n### supports `[` and as.array().\nsetMethod(\"extract_array\", \"ANY\",\n    function(x, index)\n    {\n        slice <- subset_by_Nindex(x, index)\n        as.array(slice)\n    }\n)\n\nsetMethod(\"extract_array\", \"array\",\n    function(x, index) subset_by_Nindex(x, index)\n)\n\n### Equivalent to\n###\n###     subset_by_Nindex(as.matrix(x), index)\n###\n### but avoids the cost of turning the full data frame 'x' into a matrix so\n### memory footprint stays small when 'index' is small.\nsetMethod(\"extract_array\", \"data.frame\",\n    function(x, index)\n    {\n        slice0 <- BiocGenerics:::extract_data_frame_slice0(x)\n        slice <- .extract_data_frame_slice(x, index)\n        data <- unlist(c(slice0, slice), recursive=FALSE, use.names=FALSE)\n        array(data, dim=get_Nindex_lengths(index, dim(x)))\n    }\n)\n\n### Equivalent to\n###\n###     subset_by_Nindex(as.matrix(as.data.frame(x)), index)\n###\n### but avoids the cost of turning the full DataFrame 'x' first into a data\n### frame then into a matrix so memory footprint stays small when 'index' is\n### small.\nsetMethod(\"extract_array\", \"DataFrame\",\n    function(x, index)\n    {\n        slice0 <- .extract_DataFrame_slice0(x)\n        slice <- .extract_DataFrame_slice(x, index)\n        data <- unlist(c(slice0, slice), recursive=FALSE, use.names=FALSE)\n        array(data, dim=get_Nindex_lengths(index, dim(x)))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### A convenience wrapper around extract_array()\n###\n\n### An enhanced version of extract_array() that accepts an Nindex (see\n### Nindex-utils.R) and propagates the dimnames.\n### WARNING: The list elements in 'Nindex' can only be NULLs, integer\n### vectors, or RangeNSBS objects at the moment. extract_array_by_Nindex()\n### will break if they are not! See FIXME below.\nextract_array_by_Nindex <- function(x, Nindex)\n{\n    ## TODO: Once we have a full Nindex normalization mechanism in place\n    ## (see FIXME below), use it to normalize the supplied 'Nindex' in 2\n    ## steps: (1) by normalizing with something like 'as.NSBSlist=TRUE'\n    ## to produce an Nindex with NSBS list elements, then (2) by doing\n    ## something like:\n    ##\n    ##   lapply( , function(i) if (is.null(i)) NULL else as.integer(i))\n    ##\n    ## on the Nindex obtained at (1).\n    ## Pass the Nindex obtained at (1) to subset_dimnames_by_Nindex() and\n    ## the Nindex obtained at (2) to extract_array().\n    ans_dimnames <- subset_dimnames_by_Nindex(dimnames(x), Nindex)\n\n    ## FIXME: The list elements of an Nindex can be anything (see\n    ## Nindex-utils.R) so it's not enough to expand only those list elements\n    ## that are RangeNSBS objects. For example the call to extract_array()\n    ## below will fail if some subscripts in 'Nindex' are character vectors\n    ## or Rle objects. We need to perform a full normalization of 'Nindex'\n    ## like we do in new_DelayedSubset() (see DelayedOp-class.R). Note that\n    ## we're good for now because extract_array_by_Nindex() is only used\n    ## in the context of show_compact_array() and the default \"read_block\"\n    ## method where the supplied 'Nindex' is guaranteed to contain only\n    ## NULLs, integer vectors, or RangeNSBS objects.\n    ans <- extract_array(x, expand_Nindex_RangeNSBS(Nindex))\n\n    set_dimnames(ans, ans_dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### as.array(x) (in-memory realization of an array-like object)\n###\n\n### Realize the object i.e. execute all the delayed operations and turn the\n### object back into an ordinary array.\n.from_Array_to_array <- function(x, drop=FALSE)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.array method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array below for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" S3 as.array method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.array(x))\n        }\n    }\n    if (!isTRUEorFALSE(drop))\n        stop(\"'drop' must be TRUE or FALSE\")\n    index <- vector(\"list\", length=length(dim(x)))\n    ans <- extract_array(x, index)\n    ans <- set_dimnames(ans, dimnames(x))\n    if (drop)\n        ans <- drop(ans)\n    ans\n}\n\n### S3/S4 combo for as.array.Array\nas.array.Array <- function(x, ...) .from_Array_to_array(x, ...)\nsetMethod(\"as.array\", \"Array\", .from_Array_to_array)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Other coercions to in-memory representations\n###\n### All these coercions are based on as.array().\n###\n\n### S3/S4 combo for as.data.frame.Array\nas.data.frame.Array <- function(x, row.names=NULL, optional=FALSE, ...)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.data.frame method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array below for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.data.frame S3 method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.data.frame(x, row.names=row.names,\n                                          optional=optional, ...))\n        }\n    }\n    as.data.frame(as.array(x, drop=TRUE),\n                  row.names=row.names, optional=optional, ...)\n}\nsetMethod(\"as.data.frame\", \"Array\", as.data.frame.Array)\n\n### S3/S4 combo for as.vector.Array\n### Note that without the hack below this method breaks as.vector() on an\n### Array object (R6 object) from the arrow package. See\n### https://github.com/Bioconductor/DelayedArray/issues/114 for the details.\nas.vector.Array <- function(x, mode=\"any\")\n{\n    if (!isS4(x)) {\n        ## Ugly hack to accomodate Array objects (R6 objects) from the arrow\n        ## package. For these objects, class() returns the following:\n        ##   > library(arrow)\n        ##   > my_array <- Array$create(1:10)\n        ##   > class(my_array)\n        ##   [1] \"Array\"       \"ArrowDatum\"  \"ArrowObject\" \"R6\"\n        ## Note that the arrow package does NOT define the as.vector.Arrow\n        ## method. Instead it defines the as.vector.ArrowDatum method which\n        ## is what we must call here. However, we don't call\n        ## arrow:::as.vector.ArrowDatum explicitly to avoid introducing a\n        ## dependency on the arrow package, and also to make the hack a little\n        ## bit more generic.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.vector S3 method (will be as.vector.ArrowDatum\n            ## if 'x' is an arrow::Array object).\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.vector(x, mode))\n        }\n    }\n    ans <- as.array(x, drop=TRUE)\n    as.vector(ans, mode=mode)\n}\nsetMethod(\"as.vector\", \"Array\", as.vector.Array)\n\n### S3/S4 combo for as.logical.Array\nas.logical.Array <- function(x, ...)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.logical method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array above for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.logical S3 method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.logical(x, ...))\n        }\n    }\n    as.vector(x, mode=\"logical\", ...)\n}\nsetMethod(\"as.logical\", \"Array\", as.logical.Array)\n\n### S3/S4 combo for as.integer.Array\nas.integer.Array <- function(x, ...)\n{\n    if (!isS4(x)) {\n        ## Ugly hack to accomodate Array objects (R6 objects) from the arrow\n        ## package. See as.vector.Array above for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.integer S3 method (will be\n            ## arrow:::as.integer.ArrowDatum if 'x' is an arrow::Array object).\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.integer(x, ...))\n        }\n    }\n    as.vector(x, mode=\"integer\", ...)\n}\nsetMethod(\"as.integer\", \"Array\", as.integer.Array)\n\n### S3/S4 combo for as.numeric.Array\nas.numeric.Array <- function(x, ...)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.numeric method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array above for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.numeric S3 method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.numeric(x, ...))\n        }\n    }\n    as.vector(x, mode=\"numeric\", ...)\n}\nsetMethod(\"as.numeric\", \"Array\", as.numeric.Array)\n\n### S3/S4 combo for as.complex.Array\nas.complex.Array <- function(x, ...)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.complex method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array above for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.complex S3 method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.complex(x, ...))\n        }\n    }\n    as.vector(x, mode=\"complex\", ...)\n}\nsetMethod(\"as.complex\", \"Array\", as.complex.Array)\n\n### S3/S4 combo for as.character.Array\nas.character.Array <- function(x, ...)\n{\n    if (!isS4(x)) {\n        ## Ugly hack to accomodate Array objects (R6 objects) from the arrow\n        ## package. See as.vector.Array above for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.character S3 method (will be\n            ## as.character.ArrowDatum if 'x' is an arrow::Array object).\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.character(x, ...))\n        }\n    }\n    as.vector(x, mode=\"character\", ...)\n}\nsetMethod(\"as.character\", \"Array\", as.character.Array)\n\n### S3/S4 combo for as.raw.Array\nas.raw.Array <- function(x)\n{\n    if (!isS4(x)) {\n        ## The arrow package does not define any as.raw method for\n        ## arrow::Array objects (or their ancestors) at the moment, so this is\n        ## a preventive hack only. See as.vector.Array above for the details.\n        x_class <- class(x)\n        if (length(x_class) >= 2L) {\n            ## Call \"next\" as.raw S3 method.\n            class(x) <- tail(x_class, n=-1L)\n            on.exit(class(x) <- x_class)\n            return(base::as.raw(x))\n        }\n    }\n    as.vector(x, mode=\"raw\")\n}\nsetMethod(\"as.raw\", \"Array\", as.raw.Array)\n\n",
        "is_sparse.R": "### =========================================================================\n### The is_sparse() and `is_sparse<-`() generics\n### -------------------------------------------------------------------------\n###\n\n### IMPORTANT: Array-like objects for which is_sparse() is TRUE **must**\n### support SparseArray::extract_sparse_array(). More about this in the\n### extract_sparse_array.R file from the SparseArray package where the\n### extract_sparse_array() generic is defined.\n\nsetGeneric(\"is_sparse\", function(x) standardGeneric(\"is_sparse\"))\n\n### By default, nothing is considered sparse.\nsetMethod(\"is_sparse\", \"ANY\", function(x) FALSE)\n\n### All [C|R|T]sparseMatrix derivatives are considered sparse. Note that\n### they all support SparseArray::extract_sparse_array() via the default\n### extract_sparse_array() method defined in the SparseArray package.\nsetMethod(\"is_sparse\", \"CsparseMatrix\", function(x) TRUE)\nsetMethod(\"is_sparse\", \"RsparseMatrix\", function(x) TRUE)\nsetMethod(\"is_sparse\", \"TsparseMatrix\", function(x) TRUE)\n\n\nsetGeneric(\"is_sparse<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"is_sparse<-\")\n)\n\n",
        "mapToGrid.R": "### =========================================================================\n### Map reference array positions to grid positions and vice-versa\n### -------------------------------------------------------------------------\n\n\nsetGeneric(\"mapToGrid\", signature=\"grid\",\n    function(Mindex, grid, linear=FALSE) standardGeneric(\"mapToGrid\")\n)\n\nsetGeneric(\"mapToRef\", signature=\"grid\",\n    function(major, minor, grid, linear=FALSE) standardGeneric(\"mapToRef\")\n)\n\n### Return an integer matrix with 1 column per dimension.\n.normarg_Mindex <- function(Mindex, ndim, what=\"'Mindex'\")\n{\n    if (!is.numeric(Mindex))\n        stop(wmsg(what, \" must be a numeric vector or matrix\"))\n    if (is.matrix(Mindex)) {\n        if (ncol(Mindex) != ndim)\n            stop(wmsg(what, \" must have one column (or element \",\n                      \"if a vector) per dimension\"))\n    } else {\n        if (is.array(Mindex))\n            stop(wmsg(what, \" must be a numeric vector or matrix\"))\n        if (length(Mindex) != ndim)\n            stop(wmsg(what, \" must have one element (or column \",\n                      \"if a matrix) per dimension\"))\n        Mindex <- matrix(Mindex, nrow=1)\n    }\n    if (storage.mode(Mindex) != \"integer\")\n        storage.mode(Mindex) <- \"integer\"\n    Mindex\n}\n\n### Return a numeric vector.\n.normarg_ind <- function(ind, what=\"'ind'\")\n{\n    if (!is.numeric(ind))\n        stop(wmsg(what, \" must be a numeric vector\"))\n    if (is.matrix(ind))\n        stop(wmsg(what, \" cannot be a matrix\"))\n    if (suppressWarnings(min(ind, na.rm=TRUE)) < 1)\n        stop(wmsg(what, \" must contain positive indices\"))\n    ind\n}\n\n.major_minor_as_list <- function(major, minor, grid, linear=FALSE)\n{\n    if (linear) {\n        major <- Mindex2Lindex(major, dim(grid))\n        ## 'as.integer=TRUE' is safe to use here because the viewports in\n        ## an ArrayGrid object cannot be longer than 2^31 - 1 (this in turn\n        ## translates in 'all(rowProds(dims(grid)) < .Machine$integer.max)').\n        minor <- Mindex2Lindex(minor, dims(grid)[major, , drop=FALSE],\n                               as.integer=TRUE)\n    }\n    list(major=major, minor=minor)\n}\n\nsetMethod(\"mapToGrid\", \"ArbitraryArrayGrid\",\n    function(Mindex, grid, linear=FALSE)\n    {\n        if (!isTRUEorFALSE(linear))\n            stop(\"'linear' must be TRUE or FALSE\")\n        ndim <- length(grid@tickmarks)\n        Mindex <- .normarg_Mindex(Mindex, ndim)\n        major <- lapply(seq_len(ndim),\n            function(along) {\n              1L + findInterval(Mindex[ , along], grid@tickmarks[[along]] + 1L)\n            }\n        )\n        minor <- lapply(seq_len(ndim),\n            function(along) {\n                tm <- grid@tickmarks[[along]]\n                tm_len <- length(tm)\n                if (tm_len == 0L)\n                    return(rep.int(NA_integer_, nrow(Mindex)))\n                offset <- c(0L, tm[-tm_len])\n                Mindex[ , along] - offset[major[[along]]]\n            }\n        )\n        major <- do.call(cbind, major)\n        minor <- do.call(cbind, minor)\n        .major_minor_as_list(major, minor, grid, linear=linear)\n    }\n)\n\n.normargs_major_minor <- function(major, minor, grid, linear)\n{\n    if (!isTRUEorFALSE(linear))\n        stop(\"'linear' must be TRUE or FALSE\")\n    if (linear) {\n        major <- .normarg_ind(major, what=\"when 'linear=TRUE', 'major'\")\n        minor <- .normarg_ind(minor, what=\"when 'linear=TRUE', 'minor'\")\n        if (length(major) != length(minor))\n            stop(wmsg(\"when 'linear=TRUE', 'major' and 'minor' \",\n                      \"must have the same length\"))\n        minor <- Lindex2Mindex(minor, dims(grid)[major, , drop=FALSE])\n        major <- Lindex2Mindex(major, dim(grid))\n    } else {\n        ndim <- length(refdim(grid))\n        major <- .normarg_Mindex(major, ndim, what=\"'major'\")\n        minor <- .normarg_Mindex(minor, ndim, what=\"'minor'\")\n        if (nrow(major) != nrow(minor))\n            stop(wmsg(\"'major' and 'minor' must have the same number of rows\"))\n    }\n    list(major=major, minor=minor)\n}\n\nsetMethod(\"mapToRef\", \"ArbitraryArrayGrid\",\n    function(major, minor, grid, linear=FALSE)\n    {\n        majmin <- .normargs_major_minor(major, minor, grid, linear)\n        ans <- majmin$minor\n        for (along in seq_len(ncol(ans))) {\n            tm <- grid@tickmarks[[along]]\n            tm_len <- length(tm)\n            if (tm_len == 0L)\n                next\n            offset <- c(0L, tm[-tm_len])\n            ans[ , along] <- ans[ , along] + offset[majmin$major[ , along]]\n        }\n        ans\n    }\n)\n\nsetMethod(\"mapToGrid\", \"RegularArrayGrid\",\n    function(Mindex, grid, linear=FALSE)\n    {\n        if (!isTRUEorFALSE(linear))\n            stop(\"'linear' must be TRUE or FALSE\")\n        ndim <- length(grid@spacings)\n        Mindex <- .normarg_Mindex(Mindex, ndim)\n        d <- rep(grid@spacings, each=nrow(Mindex))\n        Mindex0 <- Mindex - 1L  # 0-based indices\n        major <- 1L + Mindex0 %/% d\n        minor <- 1L + Mindex0 %% d\n        .major_minor_as_list(major, minor, grid, linear=linear)\n    }\n)\n\nsetMethod(\"mapToRef\", \"RegularArrayGrid\",\n    function(major, minor, grid, linear=FALSE)\n    {\n        majmin <- .normargs_major_minor(major, minor, grid, linear)\n        d <- rep(grid@spacings, each=nrow(majmin$major))\n        (majmin$major - 1L) * d + majmin$minor\n    }\n)\n\n",
        "read_block.R": "### =========================================================================\n### read_block()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The read_block_as_dense() generic\n###\n### Not meant to be called directly by the end user. They should call\n### higher-level user-facing read_block() function instead, with\n### the 'as.sparse' argument set to FALSE.\n### Must return an ordinary array.\n### Note that the read_block() frontend will take care of propagating the\n### dimnames, so, for the sake of efficiency, individual methods should not\n### try to do it.\n\nsetGeneric(\"read_block_as_dense\", signature=\"x\",\n    function(x, viewport) standardGeneric(\"read_block_as_dense\")\n)\n\n### This default read_block_as_dense() method will work on any object 'x'\n### that supports extract_array() e.g. an ordinary array, a sparseMatrix\n### derivative from the Matrix package, a SparseArray derivative,\n### a DelayedArray object, a DelayedOp object, an HDF5ArraySeed object, etc...\n### Does NOT propagate the dimnames.\nsetMethod(\"read_block_as_dense\", \"ANY\",\n    function(x, viewport)\n    {\n        Nindex <- makeNindexFromArrayViewport(viewport, expand.RangeNSBS=TRUE)\n        extract_array(x, Nindex)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### read_block()\n###\n\n.load_SparseArray_for_read_block <- function(...)\n    load_package_gracefully(\"SparseArray\", \"calling read_block() \", ...)\n\n.read_block <- function(x, viewport, as.sparse=NA)\n{\n    if (is_sparse(x)) {\n        .load_SparseArray_for_read_block(\"on a \", class(x), \" object \")\n        ## Should return a SparseArray derivative (COO_SparseArray or\n        ## SVT_SparseArray) from the SparseArray package.\n        ans <- SparseArray::read_block_as_sparse(x, viewport)\n        SparseArray:::check_returned_SparseArray(\n                             ans, dim(viewport),\n                             \"read_block_as_sparse\", class(x))\n        if (isFALSE(as.sparse))\n            ans <- as.array(ans)\n    } else {\n        ## Should return an ordinary array (i.e. dense).\n        ans <- read_block_as_dense(x, viewport)\n        check_returned_array(ans, dim(viewport),\n                             \"read_block_as_dense\", class(x))\n        if (isTRUE(as.sparse)) {\n            .load_SparseArray_for_read_block(\"with 'as.sparse=TRUE'\")\n            ans <- as(ans, \"SparseArray\")\n        }\n    }\n    ans\n}\n\n### A user-facing frontend for read_block_as_dense() and\n### SparseArray::read_block_as_sparse().\n### Reads a block of data from array-like object 'x'. Depending on the value\n### of argument 'as.sparse', the block is returned either as an ordinary\n### array (dense representation) or a SparseArray object (sparse\n### representation).\n### 'as.sparse' can be TRUE, FALSE, or NA. If FALSE, the block is returned\n### as an ordinary array. If TRUE, it's returned as a SparseArray object.\n### Using 'as.sparse=NA' (the default) is equivalent to\n### using 'as.sparse=is_sparse(x)'. This is the most efficient way to read\n### a block.\n### Propagates the dimnames.\nread_block <- function(x, viewport, as.sparse=NA)\n{\n    x_dim <- dim(x)\n    if (is.null(x_dim))\n        stop(wmsg(\"the first argument to read_block() must be an \",\n                  \"array-like object (i.e. it must have dimensions)\"))\n    stopifnot(is(viewport, \"ArrayViewport\"),\n              identical(refdim(viewport), x_dim),\n              is.logical(as.sparse),\n              length(as.sparse) == 1L)\n\n    ans <- .read_block(x, viewport, as.sparse=as.sparse)\n\n    ## Individual read_block_as_dense() and read_block_as_sparse() methods\n    ## are not expected to propagate the dimnames so we take care of this\n    ## now.\n    Nindex <- makeNindexFromArrayViewport(viewport)\n    ans_dimnames <- subset_dimnames_by_Nindex(dimnames(x), Nindex)\n    set_dimnames(ans, ans_dimnames)\n}\n\n",
        "rowsum.R": "### =========================================================================\n### The rowsum() and colsum() S4 generics\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .fast_rowsum() and .fast_colsum()\n###\n\n### NOT exported but used in the SparseArray and DelayedArray packages!\ncompute_ugroup <- function(group, expected_group_len, reorder=TRUE)\n{\n    if (!(is.vector(group) || is.factor(group)))\n        stop(wmsg(\"'group' must be a vector or factor\"))\n    if (length(group) != expected_group_len)\n        stop(wmsg(\"incorrect length for 'group'\"))\n    if (!isTRUEorFALSE(reorder))\n        stop(wmsg(\"'reorder' must be TRUE or FALSE\"))\n    ## Taken from base::rowsum.default().\n    ugroup <- unique(group)\n    if (anyNA(ugroup))\n        warning(wmsg(\"missing values for 'group'\"))\n    if (reorder)\n        ugroup <- sort(ugroup, na.last=TRUE, method=\"quick\")\n    ugroup\n}\n\n### A fast re-implementation of base::rowsum().\n.fast_rowsum <- function(x, group, reorder=TRUE, na.rm=FALSE)\n{\n    stopifnot(is.matrix(x))\n    ugroup <- compute_ugroup(group, nrow(x), reorder)\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    group <- match(group, ugroup)\n    ans <- .Call2(\"C_rowsum\", x, group, length(ugroup), na.rm,\n                              PACKAGE=\"S4Arrays\")\n    set_dimnames(ans, list(as.character(ugroup), colnames(x)))\n}\n\n.fast_colsum <- function(x, group, reorder=TRUE, na.rm=FALSE)\n{\n    stopifnot(is.matrix(x))\n    ugroup <- compute_ugroup(group, ncol(x), reorder)\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    group <- match(group, ugroup)\n    ans <- .Call2(\"C_colsum\", x, group, length(ugroup), na.rm,\n                              PACKAGE=\"S4Arrays\")\n    set_dimnames(ans, list(rownames(x), as.character(ugroup)))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The rowsum() and colsum() S4 generics and methods\n###\n\n### The base package provides rowsum() only (as an S3 generic).\n### TODO: Maybe move these generics to the BiocGenerics or MatrixGenerics\n### package?\nsetGeneric(\"rowsum\", signature=\"x\")\n\nsetGeneric(\"colsum\", signature=\"x\",\n    function(x, group, reorder=TRUE, ...)\n        standardGeneric(\"colsum\")\n)\n\nsetMethod(\"colsum\", \"ANY\",\n    function(x, group, reorder=TRUE, ...)\n        t(rowsum(t(x), group, reorder=reorder, ...))\n)\n\nsetMethod(\"colsum\", \"matrix\",\n    function(x, group, reorder=TRUE, ...)\n        .fast_colsum(x, group, reorder=reorder, ...)\n)\n\n",
        "show-utils.R": "### =========================================================================\n### Compact display of an array-like object\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some wrappers around extract_array_by_Nindex()\n###\n### All of them return a list of 2 ordinary arrays. The dimnames need to\n### propagate so we use extract_array_by_Nindex() instead of extract_array().\n###\n\n.extract_two_1Darrays <- function(x, i1, i2)\n{\n    a <- extract_array_by_Nindex(x, list(c(i1, i2)))\n    ii1 <- seq_along(i1)\n    ii2 <- seq_along(i2) + length(i1)\n    x1 <- a[ii1, drop=FALSE]\n    x2 <- a[ii2, drop=FALSE]\n    list(x1, x2)\n}\n\n.extract_two_matrices_by_row <- function(x, i1, i2)\n{\n    a <- extract_array_by_Nindex(x, list(c(i1, i2), NULL))\n    ii1 <- seq_along(i1)\n    ii2 <- seq_along(i2) + length(i1)\n    x1 <- a[ii1, , drop=FALSE]\n    x2 <- a[ii2, , drop=FALSE]\n    list(x1, x2)\n}\n\n.extract_two_matrices_by_col <- function(x, j1, j2)\n{\n    a <- extract_array_by_Nindex(x, list(NULL, c(j1, j2)))\n    jj1 <- seq_along(j1)\n    jj2 <- seq_along(j2) + length(j1)\n    x1 <- a[ , jj1, drop=FALSE]\n    x2 <- a[ , jj2, drop=FALSE]\n    list(x1, x2)\n}\n\n.extract_four_matrices <- function(x, i1, i2, j1, j2)\n{\n    a <- extract_array_by_Nindex(x, list(c(i1, i2), c(j1, j2)))\n    ii1 <- seq_along(i1)\n    ii2 <- seq_along(i2) + length(i1)\n    jj1 <- seq_along(j1)\n    jj2 <- seq_along(j2) + length(j1)\n    x11 <- a[ii1, jj1, drop=FALSE]\n    x21 <- a[ii2, jj1, drop=FALSE]\n    x12 <- a[ii1, jj2, drop=FALSE]\n    x22 <- a[ii2, jj2, drop=FALSE]\n    list(x11, x21, x12, x22)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some wrappers around format()\n###\n\n### 'x' must be an ordinary vector or matrix of atomic or recursive type.\n### 'max.width' takes effect only if 'x' is character or list (i.e. if the\n### underlying type inherits from character or list when 'x' is a matrix).\n.format2 <- function(x, justify, quote=TRUE, max.width=22L)\n{\n    if (is.character(x) && length(x) != 0L && quote) {\n        na_idx <- which(is.na(x))\n        x <- paste0(\"\\\"\", x, \"\\\"\")\n        x[na_idx] <- \"NA\"\n    }\n    ans <- format(x, justify=justify)\n    if ((is.character(x) || is.list(x)) && length(x) != 0L) {\n        truncate_me <- nchar(ans) > max.width\n        stop <- ifelse(truncate_me, max.width - 2L, nchar(ans))\n        ans <- substr(ans, 1L, stop)\n        ans <- paste0(ans, ifelse(truncate_me, \"..\", \"\"))\n    }\n    ans\n}\n\n.format_as_character_vector <- function(x, justify, quote=TRUE)\n{\n    x_names <- names(x)\n    x <- as.vector(x)\n    ans <- .format2(x, justify, quote)\n    names(ans) <- x_names\n    ans\n}\n\n.format_as_character_matrix <- function(x, justify, quote=TRUE)\n{\n    x_dim <- dim(x)\n    x_dimnames <- dimnames(x)\n    x <- as.matrix(x)\n    ans <- .format2(x, justify, quote)\n    ans <- set_dim(ans, x_dim)\n    set_dimnames(ans, x_dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Some low-level utilities to handle array names/dimnames\n###\n\n.wrap_subscripts <- function(i, x_names=NULL, left=\"[\", right=\"]\")\n{\n    if (length(i) == 0L)\n        return(character(0))\n    if (is.null(x_names))\n        return(paste0(left, i, right, sep=\"\"))\n    x_names[i]\n}\n\n.make_1Darray_names <- function(i1, i2, x_names, justify)\n{\n    s1 <- .wrap_subscripts(i1, x_names)\n    s2 <- .wrap_subscripts(i2, x_names)\n    format(c(s1, \".\", s2), justify=justify)\n}\n\n.make_rownames <- function(i1, i2, x_rownames, justify)\n{\n    s1 <- .wrap_subscripts(i1, x_rownames, right=\",]\")\n    s2 <- .wrap_subscripts(i2, x_rownames, right=\",]\")\n    max_width <- max(nchar(s1, type=\"width\"), nchar(s2, type=\"width\"))\n    if (max_width <= 1L) {\n        ellipsis <- \".\"\n    } else if (max_width == 2L) {\n        ellipsis <- \"..\"\n    } else {\n        ellipsis <- \"...\"\n    }\n    format(c(s1, ellipsis, s2), justify=justify)\n}\n\n.make_colnames <- function(j1, j2, x_colnames, justify)\n{\n    s1 <- .wrap_subscripts(j1, x_colnames, left=\"[,\")\n    s2 <- .wrap_subscripts(j2, x_colnames, left=\"[,\")\n    ans <- format(c(s1, s2), justify=justify)\n    c(head(ans, n=length(s1)), \"...\", tail(ans, n=length(s2)))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The extract_and_stitch_* family of helpers\n###\n\n.extract_and_stitch_two_1Darrays <- function(x, i1, i2,\n                                             justify, quote=TRUE)\n{\n    x12 <- .extract_two_1Darrays(x, i1, i2)\n    ans1 <- .format_as_character_vector(x12[[1L]], justify, quote=quote)\n    ans2 <- .format_as_character_vector(x12[[2L]], justify, quote=quote)\n\n    ans <- c(ans1, \".\", ans2)\n\n    names(ans) <- .make_1Darray_names(i1, i2, names(x), justify)\n    ans\n}\n\n.extract_and_stitch_two_matrices_by_row <- function(x, i1, i2,\n                                                    justify, quote=TRUE)\n{\n    x12 <- .extract_two_matrices_by_row(x, i1, i2)\n    ans1 <- .format_as_character_matrix(x12[[1L]], justify, quote=quote)\n    ans2 <- .format_as_character_matrix(x12[[2L]], justify, quote=quote)\n\n    hdots <- rep.int(\".\", ncol(ans1))\n    ans <- rbind(ans1, matrix(hdots, nrow=1L), ans2)\n\n    rownames(ans) <- .make_rownames(i1, i2, rownames(x), justify)\n    ans\n}\n\n.extract_and_stitch_two_matrices_by_col <- function(x, j1, j2,\n                                                    justify, quote=TRUE)\n{\n    x12 <- .extract_two_matrices_by_col(x, j1, j2)\n    ans1 <- .format_as_character_matrix(x12[[1L]], justify, quote=quote)\n    ans2 <- .format_as_character_matrix(x12[[2L]], justify, quote=quote)\n\n    vdots <- rep.int(\".\", nrow(ans1))\n    ans <- cbind(ans1, matrix(vdots, ncol=1L), ans2)\n\n    colnames(ans) <- .make_colnames(j1, j2, colnames(x), justify)\n    ans\n}\n\n.extract_and_stitch_four_matrices <- function(x, i1, i2, j1, j2,\n                                              justify, quote=TRUE)\n{\n    x1234 <- .extract_four_matrices(x, i1, i2, j1, j2)\n    ans11 <- .format_as_character_matrix(x1234[[1L]], justify, quote=quote)\n    ans21 <- .format_as_character_matrix(x1234[[2L]], justify, quote=quote)\n    ans12 <- .format_as_character_matrix(x1234[[3L]], justify, quote=quote)\n    ans22 <- .format_as_character_matrix(x1234[[4L]], justify, quote=quote)\n\n    hdots <- rep.int(\".\", ncol(ans11))\n    ans1 <- rbind(ans11, matrix(hdots, nrow=1L), ans21)\n\n    hdots <- rep.int(\".\", ncol(ans12))\n    ans2 <- rbind(ans12, matrix(hdots, nrow=1L), ans22)\n\n    vdots <- rep.int(\".\", nrow(ans1))\n    ans <- cbind(ans1, matrix(vdots, ncol=1L), ans2)\n\n    rownames(ans) <- .make_rownames(i1, i2, rownames(x), justify)\n    colnames(ans) <- .make_colnames(j1, j2, colnames(x), justify)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 1D array\n###\n\n.prepare_1Darray_sample <- function(x, n1, n2, justify, quote=TRUE)\n{\n    x_len <- length(x)\n    x_names <- names(x)\n    if (x_len <= n1 + n2 + 1L) {\n        ans <- .format_as_character_vector(x, justify, quote=quote)\n        i1 <- seq_len(x_len)\n        i2 <- integer(0)\n        names(ans) <- .make_1Darray_names(i1, i2, x_names, justify)[i1]\n    } else {\n        i1 <- seq_len(n1)\n        i2 <- seq(to=x_len, by=1L, length.out=n2)\n        ans <- .extract_and_stitch_two_1Darrays(x, i1, i2, justify, quote=quote)\n    }\n    ans\n}\n\n.print_1Darray_data <- function(x, n1, n2, quote=TRUE)\n{\n    stopifnot(length(dim(x)) == 1L)\n    right <- type(x) != \"character\"\n    justify <- if (right) \"right\" else \"left\"\n    out <- .prepare_1Darray_sample(x, n1, n2, justify, quote=quote)\n    print(out, quote=FALSE, right=right, max=length(out))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 2D array\n###\n\n.rsplit_2Darray_data <- function(x, m1, m2, justify, quote=TRUE)\n{\n    x_nrow <- nrow(x)\n    i1 <- seq_len(m1)\n    i2 <- seq(to=x_nrow, by=1L, length.out=m2)\n    .extract_and_stitch_two_matrices_by_row(x, i1, i2, justify, quote=quote)\n}\n\n.csplit_2Darray_data <- function(x, n1, n2, justify, quote=TRUE)\n{\n    x_ncol <- ncol(x)\n    j1 <- seq_len(n1)\n    j2 <- seq(to=x_ncol, by=1L, length.out=n2)\n    .extract_and_stitch_two_matrices_by_col(x, j1, j2, justify, quote=quote)\n}\n\n.split_2Darray_data <- function(x, m1, m2, n1, n2, justify, quote=TRUE)\n{\n    x_nrow <- nrow(x)\n    i1 <- seq_len(m1)\n    i2 <- seq(to=x_nrow, by=1L, length.out=m2)\n    x_ncol <- ncol(x)\n    j1 <- seq_len(n1)\n    j2 <- seq(to=x_ncol, by=1L, length.out=n2)\n    .extract_and_stitch_four_matrices(x, i1, i2, j1, j2, justify, quote=quote)\n}\n\n.prepare_2Darray_sample <- function(x, m1, m2, n1, n2, justify, quote=TRUE)\n{\n    ## An attempt at reducing the nb of columns to display when 'x' has\n    ## dimnames so the object fits in getOption(\"width\"). Won't necessarily\n    ## pick up the optimal nb of columns so should be revisited at some point.\n    x_rownames <- rownames(x)\n    if (is.null(x_rownames)) {\n        rownames_width <- 6L\n    } else {\n        rownames_width <- nchar(x_rownames[[1L]])\n    }\n    half_width <- (getOption(\"width\") - rownames_width) / 2\n    x_colnames <- colnames(x)\n    if (!is.null(x_colnames)) {\n        colnames1 <- head(x_colnames, n=n1)\n        colnames2 <- tail(x_colnames, n=n2)\n        n1 <- pmax(sum(cumsum(nchar(colnames1) + 1L) < half_width), 1L)\n        n2 <- pmax(sum(cumsum(nchar(colnames2) + 1L) < half_width), 1L)\n    }\n\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    if (x_nrow <= m1 + m2 + 1L) {\n        if (x_ncol <= n1 + n2 + 1L) {\n            ans <- .format_as_character_matrix(x, justify, quote=quote)\n            ## Only needed because of this bug in base::print.default:\n            ##   https://stat.ethz.ch/pipermail/r-devel/2016-March/072479.html\n            ## TODO: Remove when the bug is fixed.\n            if (is.null(colnames(ans))) {\n                j1 <- seq_len(ncol(ans))\n                j2 <- integer(0)\n                colnames(ans) <- .make_colnames(j1, j2, NULL, justify)[j1]\n            }\n        } else {\n            ans <- .csplit_2Darray_data(x, n1, n2, justify, quote=quote)\n        }\n    } else {\n        if (x_ncol <= n1 + n2 + 1L) {\n            ans <- .rsplit_2Darray_data(x, m1, m2, justify, quote=quote)\n            ## Only needed because of this bug in base::print.default:\n            ##   https://stat.ethz.ch/pipermail/r-devel/2016-March/072479.html\n            ## TODO: Remove when the bug is fixed.\n            if (is.null(colnames(ans))) {\n                j1 <- seq_len(ncol(ans))\n                j2 <- integer(0)\n                colnames(ans) <- .make_colnames(j1, j2, NULL, justify)[j1]\n            }\n        } else {\n            ans <- .split_2Darray_data(x, m1, m2, n1, n2, justify, quote=quote)\n        }\n    }\n    ans\n}\n\n.print_2Darray_data <- function(x, m1, m2, n1, n2, quote=TRUE)\n{\n    stopifnot(length(dim(x)) == 2L)\n    right <- type(x) != \"character\"\n    justify <- if (right) \"right\" else \"left\"\n    out <- .prepare_2Darray_sample(x, m1, m2, n1, n2, justify, quote=quote)\n    print(out, quote=FALSE, right=right, max=length(out))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Array of arbitrary dimensions\n###\n\n.print_2D_slices <- function(x, m1, m2, n1, n2, grid, idx, quote=TRUE)\n{\n    x_dimnames <- dimnames(x)\n    for (i in idx) {\n        viewport <- grid[[i]]\n        s <- make_string_from_ArrayViewport(viewport, dimnames=x_dimnames,\n                                            as.2Dslice=TRUE)\n        cat(s, \"\\n\", sep=\"\")\n        Nindex <- makeNindexFromArrayViewport(viewport)\n        slice <- extract_array_by_Nindex(x, Nindex)\n        slice <- set_dim(slice, dim(slice)[1:2])\n        .print_2Darray_data(slice, m1, m2, n1, n2, quote=quote)\n        cat(\"\\n\")\n    }\n}\n\n.print_nDarray_data <- function(x, n1, n2, quote=TRUE)\n{\n    x_dim <- dim(x)\n    x_nrow <- x_dim[[1L]]\n    x_ncol <- x_dim[[2L]]\n    if (x_ncol <= 5L) {\n        if (x_nrow <= 3L) {\n            m1 <- m2 <- 3L  # print all rows of each slice\n            z1 <- z2 <- 3L  # print first 3 and last 3 slices\n        } else {\n            m1 <- m2 <- 2L  # print first 2 and last 2 rows of each slice\n            z1 <- z2 <- 1L  # print only first and last slices\n        }\n    } else {\n        if (x_nrow <= 3L) {\n            m1 <- m2 <- 2L  # print first 2 and last 2 rows of each slice\n            z1 <- z2 <- 2L  # print first 2 and last 2 slices\n        } else {\n            m1 <- m2 <- 2L  # print first 2 and last 2 rows of each slice\n            z1 <- z2 <- 1L  # print only first and last slices\n        }\n    }\n    spacings <- x_dim\n    spacings[-(1:2)] <- 1L\n    grid <- RegularArrayGrid(x_dim, spacings)\n    nblock <- length(grid)  # should be equal to prod(x_dim[-(1:2)])\n    if (nblock <= z1 + z2 + 1L) {\n        idx <- seq_len(nblock)\n        .print_2D_slices(x, m1, m2, n1, n2, grid, idx, quote=quote)\n    } else {\n        idx1 <- seq_len(z1)\n        idx2 <- seq(to=nblock, by=1L, length.out=z2)\n        .print_2D_slices(x, m1, m2, n1, n2, grid, idx1, quote=quote)\n        cat(\"...\\n\\n\")\n        .print_2D_slices(x, m1, m2, n1, n2, grid, idx2, quote=quote)\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### show_compact_array()\n###\n\n.print_array_data <- function(x, n1, n2, quote=TRUE)\n{\n    x_dim <- dim(x)\n    if (length(x_dim) == 1L)\n        return(.print_1Darray_data(x, n1, n2, quote=quote))\n    if (length(x_dim) == 2L) {\n        nhead <- get_showHeadLines()\n        ntail <- get_showTailLines()\n        return(.print_2Darray_data(x, nhead, ntail, n1, n2, quote=quote))\n    }\n    .print_nDarray_data(x, n1, n2, quote=quote)\n}\n\n### NOT exported but used in the HDF5Array package!\narray_as_one_line_summary <- function(x)\n{\n    x_dim <- dim(x)\n    sprintf(\"<%s>%s %s object of type \\\"%s\\\"\",\n            paste0(x_dim, collapse=\" x \"),\n            if (is_sparse(x)) \" sparse\" else \"\",\n            class(x)[[1L]],\n            type(x))\n}\n\n### NOT exported but used in the SparseArray package!\nprint_some_array_elements <- function(x)\n{\n    if (type(x) == \"integer\") {\n        n1 <- n2 <- 4L\n    } else {\n        n1 <- 3L\n        n2 <- 2L\n    }\n    .print_array_data(x, n1, n2)\n}\n\n### Work on any array-like object that complies with the \"seed contract\" i.e.\n### that supports dim(), dimnames(), and extract_array().\n### NOT exported.\nshow_compact_array <- function(object)\n{\n    #grey <- make_style(\"grey\")\n    #cat(grey(array_as_one_line_summary(object)))\n    cat(array_as_one_line_summary(object))\n    if (any(dim(object) == 0L)) {\n        cat(\"\\n\")\n        return()\n    }\n    #cat(grey(\":\"), \"\\n\", sep=\"\")\n    cat(\":\\n\", sep=\"\")\n    print_some_array_elements(object)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### showAsCell()\n###\n\n### A re-implementation of S4Vectors:::.showAsCell_array() that avoids doing\n### the \"reshaping\" of the object. Should work on any array-like object that\n### supports extract_array().\n.showAsCell_array_like <- function(object)\n{\n    dim1 <- dim(object)[-1L]\n    p1 <- prod(dim1)\n    if (p1 == 0L)\n        return(rep.int(\"\", nrow(object)))\n    first_cols <- lapply(seq_len(min(p1, 3L)),\n        function(i1) {\n            subscripts <- arrayInd(i1, dim1)\n            index <- c(list(NULL), as.list(subscripts))\n            as.character(extract_array(object, index))\n        }\n    )\n    ans <- do.call(paste, c(first_cols, list(sep=\":\")))\n    if (p1 > 3L)\n        ans <- paste0(ans, \":...\")\n    ans\n}\n\nsetMethod(\"showAsCell\", \"Array\", .showAsCell_array_like)\n\n",
        "type.R": "### =========================================================================\n### type()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default type() method\n###\n\n### Perform 'extract_array(x, list(integer(0), ..., integer(0)))'.\n### 'x' is **trusted** to be an array-like object.\nextract_empty_array <- function(x)\n{\n    index <- rep.int(list(integer(0)), length(dim(x)))\n    extract_array(x, index)\n}\n\n### The default type() method (the generic is defined in BiocGenerics)\n### implements the 'typeof(as.array(x))' semantic. It will work out-of-the-box\n### on any array-like object that supports extract_array().\nsetMethod(\"type\", \"ANY\",\n    function(x)\n    {\n        x_dim <- dim(x)\n        if (is.null(x_dim))\n            stop(wmsg(\"the default type() method only supports \",\n                      \"array-like objects\"))\n        type(extract_empty_array(x))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### type() method for DataFrame objects\n###\n\n.get_DataFrame_type <- function(x)\n{\n    ## Make sure that this remains consistent with .extract_DataFrame_slice0()\n    ## defined in R/extract_array.R\n    x0 <- x[0L, , drop=FALSE]\n    df0 <- as.data.frame(x0)\n    if (ncol(df0) != ncol(x))\n        stop(wmsg(\"the type() method for DataFrame objects only suports \",\n                  \"objects for which 'as.data.frame(x)' preserves the \",\n                  \"number of columns\"))\n    type(df0)\n}\n\n### Equivalent to 'typeof(as.matrix(as.data.frame(x)))' (granted\n### that 'as.data.frame(x)' preserves the number of columns) but with an\n### almost-zero memory footprint (it avoids the cost of turning 'x' first\n### into a data frame then into a matrix).\nsetMethod(\"type\", \"DataFrame\", .get_DataFrame_type)\n\n",
        "utils.R": "### =========================================================================\n### Some low-level utilities\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n\n\n### TODO: Move this to S4Vectors (or BiocBaseUtils).\nload_package_gracefully <- function(package, ...)\n{\n    if (!requireNamespace(package, quietly=TRUE))\n        stop(\"Could not load package \", package, \". Is it installed?\\n\\n  \",\n             wmsg(\"Note that \", ..., \" requires the \", package, \" package. \",\n                  \"Please install it with:\"),\n             \"\\n\\n    BiocManager::install(\\\"\", package, \"\\\")\")\n}\n\n### TODO: This should probably go to S4Vectors (but maybe find a better name\n### for it first).\nseq2 <- function(to, by)\n{\n    stopifnot(isSingleNumber(to), isSingleNumber(by))\n    ans <- seq_len(to %/% by) * by\n    if (to %% by != 0L)\n        ans <- c(ans, to)\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### bplapply2()\n###\n### A simple wrapper to BiocParallel::bplapply() that falls back to lapply()\n### if 'length(X)' <= 1 or 'BPPARAM' is NULL or 'bpnworkers(BPPARAM)' <= 1.\n###\n### Also disable HDF5 file locking for the duration of the bplapply() loop,\n### just in case the user is dealing with HDF5-backed DelayedArray objects\n### or other objects that involve HDF5 files. This is needed for concurrent\n### access to a single dataset from multiple processes, even for read-only\n### access!\n### See https://portal.hdfgroup.org/display/knowledge/Questions+about+thread-safety+and+concurrent+access\n###\n\nbplapply2 <- function(X, FUN, ..., BPPARAM=NULL)\n{\n    if (length(X) <= 1L || is.null(BPPARAM))\n        return(lapply(X, FUN, ...))\n    if (!requireNamespace(\"BiocParallel\", quietly=TRUE))\n        stop(wmsg(\"Couldn't load the BiocParallel package. Please \",\n                  \"install the BiocParallel package and try again.\"))\n    ## The only value that is allowed for HDF5_USE_FILE_LOCKING is \"FALSE\"\n    ## (all uppercase).\n    ## Note sure this is actually a good idea so commenting out for now.\n    #if (Sys.getenv(\"HDF5_USE_FILE_LOCKING\") != \"FALSE\") {\n    #    Sys.setenv(HDF5_USE_FILE_LOCKING=\"FALSE\")\n    #    on.exit(Sys.unsetenv(\"HDF5_USE_FILE_LOCKING\"))\n    #}\n    if (!is(BPPARAM, \"BiocParallelParam\"))\n        stop(wmsg(\"'BPPARAM' must be a BiocParallelParam derivative\"))\n    if (BiocParallel::bpnworkers(BPPARAM) <= 1L)\n        return(lapply(X, FUN, ...))\n    BiocParallel::bplapply(X, FUN, ..., BPPARAM=BPPARAM)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Greatest common divisor and least common multiple of 2 integers\n###\n### Currently not used.\n###\n### TODO: Maybe should go to S4Vectors (and be implemented in C).\n###\n\nif (FALSE) {  # ------------ BEGIN DISABLED CODE ------------\n\n### Greatest common divisor of 2 integers.\n### Can be about 10x faster than this recursive (and vectorized) solution\n### from SO:\n###   https://stackoverflow.com/questions/21502181/finding-the-gcd-without-looping-r\n### Also check user input and handle edge cases.\nGCD <- function(x, y)\n{\n    stopifnot(isSingleNumber(x), isSingleNumber(y))\n    if (!is.integer(x))\n        x <- as.integer(x)\n    if (!is.integer(y))\n        y <- as.integer(y)\n    if (y == 0L) {\n        if (x == 0L)\n            return(NA_integer_)\n        return(x)\n    }\n    while (TRUE) {\n        r <- x %% y\n        if (r == 0L)\n            return(y)\n        x <- y\n        y <- r\n    }\n}\n\n### Least common multiple of 2 integers.\nLCM <- function(x, y)\n{\n    stopifnot(isSingleNumber(x), isSingleNumber(y))\n    if (!is.integer(x))\n        x <- as.integer(x)\n    if (!is.integer(y))\n        y <- as.integer(y)\n    gcd <- GCD(x, y)\n    (x %/% gcd) * y  # could overflow\n}\n}             # ------------- END DISABLED CODE -------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### as_integer_dim(), normarg_dim() and normarg_dimnames()\n###\n\nas_integer_dim <- function(dim, what)\n{\n    if (!(is.numeric(dim) && is.vector(dim)))\n        stop(wmsg(what, \" must be an integer vector\"))\n    if (length(dim) == 0L)\n        stop(wmsg(what, \" cannot be an empty vector\"))\n    if (any(is.na(dim)))\n        stop(wmsg(what, \" cannot contain NAs\"))\n    if (any(dim < 0))\n        stop(wmsg(what, \" cannot contain negative values\"))\n    if (!is.integer(dim)) {\n        if (any(dim > .Machine$integer.max))\n            stop(wmsg(what, \" cannot contain values greater \",\n                      \"than 2^31-1 (= .Machine$integer.max)\"))\n        dim <- as.integer(dim)\n    }\n    dim\n}\n\nnormarg_dim <- function(dim, argname=\"dim\")\n{\n    as_integer_dim(dim, paste0(\"'\", argname, \"'\"))\n}\n\nnormarg_dimnames <- function(dimnames, dim)\n{\n    ndim <- length(dim)\n    if (missing(dimnames) || is.null(dimnames))\n        return(vector(\"list\", length=ndim))\n    if (!is.list(dimnames))\n        stop(wmsg(\"the supplied 'dimnames' must be NULL or a list\"))\n    if (length(dimnames) < ndim) {\n        ## Append NULLs to the list.\n        length(dimnames) <- ndim\n    } else if (length(dimnames) > ndim) {\n        stop(wmsg(\"the supplied 'dimnames' must have one list element \",\n                  \"per dimension\"))\n    }\n    lapply(setNames(seq_len(ndim), names(dimnames)),\n        function(along) {\n            dn <- dimnames[[along]]\n            if (is.null(dn))\n                return(dn)\n            if (!(is.vector(dn) && is.atomic(dn) || is.factor(dn)))\n                stop(wmsg(\"each list element in the supplied 'dimnames' \",\n                          \"must be NULL or a character vector\"))\n            if (!is.character(dn))\n                dn <- as.character(dn)\n            if (length(dn) != dim[[along]])\n                stop(wmsg(\"length of 'dimnames[[\", along, \"]]' \",\n                          \"(\", length(dn), \") must equal the \",\n                          \"array extent (\", dim[[along]], \")\"))\n            dn\n        }\n    )\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Right-pad dim vector with ones\n###\n\nrpad_dim <- function(dim, ndim)\n{\n    stopifnot(is.integer(dim), isSingleInteger(ndim))\n    nd <- ndim - length(dim)\n    if (nd > 0L)\n        dim <- c(dim, rep.int(1L, nd))\n    dim\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 2 wrappers to dim<- and dimnames<- that try to avoid unnecessary copies\n### of 'x'\n###\n\n### Preserves the dimnames when dropping or adding **rightmost dimensions**\n### (a.k.a. outermost or slowest moving dimensions in the memory layout).\nset_dim <- function(x, value)\n{\n    if (is.numeric(value)) {\n        if (!is.integer(value))\n            value <- as.integer(value)\n    } else {\n        stopifnot(is.null(value))\n    }\n    x_dim <- dim(x)\n    if (identical(x_dim, value))\n        return(x)\n\n    if (is.null(x_dim)) {\n        ## Treat vector as 1D array.\n        x <- as.array(x)\n        x_dim <- dim(x)\n    }\n    x_dimnames <- simplify_NULL_dimnames(dimnames(x))\n    dim(x) <- value\n    if (!is.null(x_dimnames)) {\n        old_ndim <- length(x_dim)\n        new_ndim <- length(value)\n        n <- min(old_ndim, new_ndim)\n        if (identical(head(x_dim, n=n), head(value, n=n)))\n            dimnames(x) <- x_dimnames[seq_len(new_ndim)]\n    }\n    x\n}\n\nset_dimnames <- function(x, value)\n{\n    stopifnot(is.null(value) || is.list(value))\n    if (identical(dimnames(x), value))\n        return(x)\n    dimnames(x) <- value\n    x\n}\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### set_or_check_dim()\n###\n\nset_or_check_dim <- function(x, dim)\n{\n    x_dim <- dim(x)\n    if (is.null(x_dim)) {\n        dim(x) <- dim\n    } else {\n        stopifnot(identical(x_dim, dim))\n    }\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### get_first_non_NULL_dimnames()\n###\n\n### Implement (and extend to the N-ary case) propagation of the dimnames\n### following the \"first array with dimnames wins\" rule that seems to be\n### used by all the binary operations from the Arith (e.g. \"+\", \"^\", etc...),\n### Compare (e.g. \"==\", \">=\", etc...) and Logic (\"&\", \"|\") groups.\n### Only makes sense to use if all the array-like objects in 'objects'\n### have the same dimensions.\n### Note that rbind() and cbind() use a different rule for propagation of\n### the dimnames. This rule is implemented (and extended to the N-ary case)\n### by combine_dimnames_along() defined in abind.R\nget_first_non_NULL_dimnames <- function(objects)\n{\n    for (object in objects) {\n        object_dimnames <- dimnames(object)\n        if (!is.null(object_dimnames))\n            return(object_dimnames)\n    }\n    NULL\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### simplify_NULL_dimnames()\n###\n\nsimplify_NULL_dimnames <- function(dimnames)\n{\n    if (all(S4Vectors:::sapply_isNULL(dimnames)))\n        return(NULL)\n    dimnames\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### normarg_array_type()\n###\n### Typical usage in a type() setter:\n###     value <- normarg_array_type(value, \"the supplied type\")\n###\n\nnormarg_array_type <- function(type, what=\"'type'\")\n{\n    if (!isSingleString(type))\n        stop(wmsg(what, \" must be a single string\"))\n    if (type == \"list\")\n        return(type)\n    if (type == \"numeric\")\n        return(\"double\")\n    tmp <- try(vector(type), silent=TRUE)\n    if (inherits(tmp, \"try-error\") || !is.atomic(tmp))\n            stop(wmsg(what, \" must be an R atomic type \",\n                      \"(e.g. \\\"integer\\\"), or \\\"list\\\"\"))\n    type\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### combine_array_objects()\n###\n### NOT exported but used in unit tests.\n###\n\n### 'objects' must be a list of array-like objects that support as.vector().\ncombine_array_objects <- function(objects)\n{\n    if (!is.list(objects))\n        stop(\"'objects' must be a list\")\n    NULL_idx <- which(S4Vectors:::sapply_isNULL(objects))\n    if (length(NULL_idx) != 0L)\n        objects <- objects[-NULL_idx]\n    if (length(objects) == 0L)\n        return(NULL)\n    unlist(lapply(objects, as.vector), recursive=FALSE, use.names=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Used in validity methods\n###\n\n### NOT exported but used in the HDF5Array package!\nvalidate_dim_slot <- function(x, slotname=\"dim\")\n{\n    x_dim <- slot(x, slotname)\n    if (!is.integer(x_dim))\n        return(paste0(\"'\", slotname, \"' slot must be an integer vector\"))\n    if (length(x_dim) == 0L)\n        return(paste0(\"'\", slotname, \"' slot cannot be empty\"))\n    if (S4Vectors:::anyMissingOrOutside(x_dim, 0L))\n        return(paste0(\"'\", slotname, \"' slot cannot contain negative \",\n                      \"or NA values\"))\n    TRUE\n}\n\nvalidate_dimnames_slot <- function(x, dim, slotname=\"dimnames\")\n{\n    x_dimnames <- slot(x, slotname)\n    if (!is.list(x_dimnames))\n        return(paste0(\"'\", slotname, \"' slot must be a list\"))\n    if (length(x_dimnames) != length(dim))\n        return(paste0(\"'\", slotname, \"' slot must have \",\n                      \"one list element per dimension in the object\"))\n    ok <- vapply(seq_along(dim),\n                 function(along) {\n                   dn <- x_dimnames[[along]]\n                   if (is.null(dn))\n                       return(TRUE)\n                   is.character(dn) && length(dn) == dim[[along]]\n                 },\n                 logical(1),\n                 USE.NAMES=FALSE)\n    if (!all(ok))\n        return(paste0(\"each list element in '\", slotname, \"' slot \",\n                      \"must be NULL or a character vector along \",\n                      \"the corresponding dimension in the object\"))\n    TRUE\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Zero-filled arrays\n###\n### The \"zero\" value used to fill the array is the \"zero\" associated with the\n### specified 'type' e.g. the empty string (\"\") if 'type' is \"character\",\n### FALSE if it's \"logical\", etc... More generally, the \"zero\" element is\n### whatever 'vector(type, length=1L)' produces.\n###\n\nmake_zero_filled_array <- function(type, dim)\n{\n    array(vector(type, length=prod(dim)), dim=dim)\n}\n\n### Make an array with a single \"zero\" element.\nmake_one_zero_array <- function(type, ndim)\n{\n    ans_dim <- rep.int(1L, ndim)\n    make_zero_filled_array(type, ans_dim)\n}\n\nis_filled_with_zeros <- function(x)\n{\n    stopifnot(is.vector(x) || is.array(x))\n    ## Do NOT use a '=='-based solution (e.g. 'all(x == vector(type(x),\n    ## length=1))') cause it won't work as expected if 'x' contains NAs.\n    identical(as.vector(x), vector(type(x), length=length(x)))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### outer2()\n###\n### Outer product of an arbitrary number of objects. Typically used on\n### objects that are vectors and/or arrays.\n###\n\nouter2 <- function(objects, FUN=\"*\", ...)\n{\n    stopifnot(is.list(objects), length(objects) != 0L)\n    nobject <- length(objects)\n    ans <- objects[[1L]]\n    if (nobject >= 2L) {\n        for (i in 2:nobject) {\n            idx <- objects[[i]]\n            ans <- outer(ans, idx, FUN=FUN, ...)\n        }\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Translate an index into the whole to an index into the parts\n###\n### This is .rowidx2rowkeys() from BSgenome/R/OnDiskLongTable-class.R, copied\n### here and renamed get_part_index() !\n### TODO: Put it somewhere else where it can be shared.\n###\n\n.breakpoints2offsets <- function(breakpoints)\n{\n    breakpoints_len <- length(breakpoints)\n    if (breakpoints_len == 0L)\n        return(integer(0))\n    c(0L, breakpoints[-breakpoints_len])\n}\n\n### breakpoints: integer vector of break points that define the parts.\n### idx:         index into the whole as an integer vector.\n### Return a list of 2 integer vectors parallel to 'idx'. The 1st vector\n### contains part numbers and the 2nd vector indices into the parts.\n### In addition, if 'breakpoints' has names (part names) then they are\n### propagated to the 1st vector.\nget_part_index <- function(idx, breakpoints)\n{\n    part_idx <- findInterval(idx, breakpoints + 1L) + 1L\n    names(part_idx) <- names(breakpoints)[part_idx]\n    rel_idx <- idx - .breakpoints2offsets(unname(breakpoints))[part_idx]\n    list(part_idx, rel_idx)\n}\n\nsplit_part_index <- function(part_index, npart)\n{\n    ans <- rep.int(list(integer(0)), npart)\n    tmp <- split(unname(part_index[[2L]]), part_index[[1L]])\n    ans[as.integer(names(tmp))] <- tmp\n    ans\n}\n\nget_rev_index <- function(part_index)\n{\n    f <- part_index[[1L]]\n    idx <- split(seq_along(f), f)\n    idx <- unlist(idx, use.names=FALSE)\n    rev_idx <- integer(length(idx))\n    rev_idx[idx] <- seq_along(idx)\n    rev_idx\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### set_user_option() / get_user_option()\n###\n\nif (FALSE) {  # ------------ BEGIN DISABLED CODE ------------\n\n### In the context of BiocParallel::bplapply() and family, we want the workers\n### to inherit the user-controlled options defined on the master. Workers can\n### also modify the inherited options or define new user-controlled options\n### but this should not affect the options defined on the master (one-way\n### communication). This mechanism should also work with nested levels of\n### parallelization i.e. if workers start subworkers and so on.\n### The mechanism implemented below achieves that. It relies on 2 important\n### assumptions:\n### 1st assumption: Environment variables defined in the environment of a\n###                 master R session are **always** inherited by the workers\n###                 started by BiocParallel::bplapply() and family. \"Always\"\n###                 here means \"whatever the BPPARAM backend is\".\n### 2nd assumption: The workers can access the tempdir() of their master.\n###                 WARNING: It has been reported that with some cluster\n###                 configurations the nodes don't have access to the\n###                 tempdir() of the head. So this is NOT a safe assumption!\n\n.make_new_filepath_for_my_own_file <- function(my_pid)\n{\n    filename <- paste0(\"DelayeArray-options.\", my_pid)\n    file.path(tempdir(), filename)\n}\n\n.filepath_is_mine <- function(filepath, my_pid)\n{\n    filename <- basename(filepath)\n    if (!grepl(\".\", filename, fixed=TRUE))\n        return(FALSE)\n    ## We extract the PID embedded in the filename by grabbing everything\n    ## that is after the last occurence of '.'.\n    pid_from_filename <- sub(\"(.*)\\\\.([^.]*)$\", \"\\\\2\", filename)\n    pid_from_filename == my_pid\n}\n\n### Create a file with no options in it.\n.create_root_file <- function(my_pid)\n{\n    new_filepath <- .make_new_filepath_for_my_own_file(my_pid)\n    saveRDS(list(), new_filepath)\n    new_filepath\n}\n\n### If the 2nd assumption (see above) turns out to be incorrect then we want\n### to fail early and graciously. So perform the check below before trying\n### to read or copy the file located at 'filepath'.\n.check_2nd_assumption <- function(filepath)\n{\n    if (!file.exists(filepath))\n        stop(wmsg(\"worker cannot access file \", filepath,\n                  \" created by master\"))\n}\n\n.copy_file_if_not_mine <- function(filepath, my_pid)\n{\n    is_mine <- .filepath_is_mine(filepath, my_pid)\n    if (is_mine)\n        return(filepath)\n    ## If the file is not mine then the current process is a worker that\n    ## was started by a master, so I'm not allowed to write to the file.\n    ## I need to make my own copy it first.\n    .check_2nd_assumption(filepath)\n    new_filepath <- .make_new_filepath_for_my_own_file(my_pid)\n    ok <- file.copy(filepath, new_filepath)\n    if (!ok)\n        stop(wmsg(\"worker was not able to copy file \", filepath,\n                  \" created by master\"))\n    new_filepath\n}\n\n### Name of the environment variable that contains the path to the RDS file\n### containing the serialized options.\n.env_var_name <- \"S4Arrays_OPTIONS_FILEPATH\"\n\n.get_user_options_filepath <- function() Sys.getenv(.env_var_name)\n\n.set_user_options_filepath <- function(filepath)\n{\n    do.call(Sys.setenv, setNames(list(filepath), .env_var_name))\n}\n\nuser_options_file_exists <- function() .get_user_options_filepath() != \"\"\n\n### Implements a copy-on-write mechanism in the context of multiple workers.\nset_user_option <- function(name, value)\n{\n    stopifnot(isSingleString(name))\n    filepath <- .get_user_options_filepath()\n    my_pid <- as.character(Sys.getpid())\n    if (filepath == \"\") {\n        ## Options file doesn't exist yet. This means that the current\n        ## process is the root of the (possibly nested) master/workers tree,\n        ## that is, the R session explicitely started by the user at the\n        ## command line (or via RStudio).\n        writable_filepath <- .create_root_file(my_pid)\n    } else {\n        ## The current process is a worker (which in turn could itself\n        ## become the master of some subworkers at some point).\n        writable_filepath <- .copy_file_if_not_mine(filepath, my_pid)\n    }\n    if (writable_filepath != filepath)\n        .set_user_options_filepath(writable_filepath)\n    user_options <- readRDS(writable_filepath)\n    ## We use 'x[name] <- list(value)' instead of 'x[[name]] <- value'\n    ## because the latter removes the list element if value is NULL and\n    ## we don't want that.\n    user_options[name] <- list(value)\n    saveRDS(user_options, writable_filepath)\n    invisible(value)\n}\n\nget_user_options <- function()\n{\n    ## Only 2 possibilities: either the current process \"owns\" 'filepath'\n    ## or not. In the latter case it means that the current process is a\n    ## worker that was started by a master.\n    filepath <- .get_user_options_filepath()\n    .check_2nd_assumption(filepath)\n    user_options <- try(readRDS(filepath), silent=TRUE)\n    if (inherits(user_options, \"try-error\"))\n        stop(wmsg(\"worker was not able to read file \", filepath,\n                  \" created by master\"))\n    user_options\n}\n\nget_user_option <- function(name)\n{\n    stopifnot(isSingleString(name))\n    user_options <- get_user_options()\n    ## 'user_options' should be a list.\n    idx <- match(name, names(user_options))\n    if (is.na(idx))\n        stop(wmsg(\"Unkown S4Arrays user-controlled global option: \", name))\n    user_options[[idx]]\n}\n}             # ------------- END DISABLED CODE -------------\n\nset_user_option <- function(name, value)\n{\n    stopifnot(isSingleString(name))\n    name <- paste0(\"S4Arrays.\", name)\n    options(setNames(list(value), name))\n    invisible(value)\n}\n\nget_user_option <- function(name)\n{\n    stopifnot(isSingleString(name))\n    name <- paste0(\"S4Arrays.\", name)\n    getOption(name)\n}\n\nuser_option_is_set <- function(name)\n{\n    stopifnot(isSingleString(name))\n    name <- paste0(\"S4Arrays.\", name)\n    name %in% names(.Options)\n}\n\n",
        "write_block.R": "### =========================================================================\n### write_block()\n### -------------------------------------------------------------------------\n\n\n### 'sink' must be a **writable** array-like object, typically a\n### RealizationSink concrete subclass (RealizationSink is a virtual class\n### defined in the DelayedArray package), but not necessarily. See default\n### write_block() method below.\n### Note that for now dispatch is only on the first argument ('sink') but\n### we could change that in the future to also dispatch on the third\n### argument ('block') if the need arises.\n### Must return the modified 'sink'.\nsetGeneric(\"write_block\", signature=\"sink\",\n    function(sink, viewport, block)\n    {\n        sink_dim <- dim(sink)\n        if (is.null(sink_dim))\n            stop(wmsg(\"the first argument to write_block() must be an \",\n                      \"array-like object (i.e. it must have dimensions)\"))\n        stopifnot(is(viewport, \"ArrayViewport\"),\n                  identical(refdim(viewport), sink_dim),\n                  identical(dim(block), dim(viewport)))\n        standardGeneric(\"write_block\")\n    }\n)\n\n### Based on replace_by_Nindex() which is based on subassignment ('[<-'),\n### so work on any array-like object 'sink' that supports subassignment.\n### Thanks to this method, write_block() will work out-of-the-box on an\n### ordinary array and other in-memory array-like object that supports\n### subassignment (e.g. SparseArray object from the SparseArray package\n### or sparseMatrix derivative from the Matrix package).\nsetMethod(\"write_block\", \"ANY\",\n    function(sink, viewport, block)\n    {\n        if (is.array(sink)) {\n            ## Subassignment of an ordinary array only works if the right\n            ## value is also an ordinary array.\n            if (!is.array(block))\n                block <- as.array(block)\n            sink_type <- type(sink)\n            if (type(block) != sink_type)\n                type(block) <- sink_type\n        } else if (is(sink, \"sparseMatrix\")) {\n            ## Subassignment of a sparseMatrix derivative (e.g. dgCMatrix\n            ## object) only works if the right value is a sparseMatrix\n            ## derivative or ordinary array.\n            if (!(is(block, \"sparseMatrix\") || is.array(block))) {\n                if (is_sparse(block))\n                    block <- as(block, \"sparseMatrix\")\n                else\n                    block <- as.array(block)\n            }\n        }\n        Nindex <- makeNindexFromArrayViewport(viewport)\n        replace_by_Nindex(sink, Nindex, block)\n    }\n)\n\n",
        "zzz.R": ".onLoad <- function(libname, pkgname)\n{\n}\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"S4Arrays\", libpath)\n}\n\n"
    },
    "SparseArray": {
        "COO_SparseArray-class.R": "### =========================================================================\n### COO_SparseArray objects\n### -------------------------------------------------------------------------\n###\n### Use COO layout to store the sparse data.\n###\n### Same as SparseArraySeed objects in the DelayedArray package.\n### Extends the Coordinate List (COO) layout used for sparse matrices to\n### multiple dimensions.\n### See https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_(COO)\n### This layout is also used by https://sparse.pydata.org/\n###\n### The COO_SparseArray API:\n### - The SparseArray API (see SparseArray-class.R)\n### - Getters nzcoo() and nzdata()\n### - Coercion from array to COO_SparseArray\n### - Back and forth coercion between COO_SparseArray and [d|l]g[C|R]Matrix\n###   objects from the Matrix package\n###\n\nsetClass(\"COO_SparseArray\",\n    contains=\"SparseArray\",\n    representation(\n        nzcoo=\"matrix\",  # M-index containing the coordinates of the\n                         # nonzero elements.\n        nzdata=\"vector\"  # A vector (atomic or list) of length 'nrow(nzcoo)'\n                         # containing the nonzero elements.\n    ),\n    prototype(\n        nzcoo=matrix(integer(0), ncol=1L),\n        nzdata=logical(0)\n    )\n)\n\nsetClass(\"COO_SparseMatrix\",\n    contains=c(\"COO_SparseArray\", \"SparseMatrix\"),\n    prototype=prototype(\n        dim=c(0L, 0L),\n        dimnames=list(NULL, NULL),\n        nzcoo=matrix(integer(0), ncol=2L)\n    )\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between COO_SparseArray and COO_SparseMatrix\n###\n\n### --- From COO_SparseArray to COO_SparseMatrix ---\n\n### The user should NOT be able to promote a COO_SparseArray object to\n### COO_SparseMatrix. Problem is that the automatic coercion method from\n### COO_SparseArray to COO_SparseMatrix silently returns a broken object\n### (unfortunately these dummy automatic coercion methods don't bother to\n### validate the object they return). So we overwrite it with a method that\n### will fail (as expected) thanks to the validity method for SparseMatrix\n### objects.\nsetAs(\"COO_SparseArray\", \"COO_SparseMatrix\",\n    function(from) new(\"COO_SparseMatrix\", from)\n)\n\n### --- From COO_SparseMatrix to COO_SparseArray ---\n\n### The user should NOT be able to demote a COO_SparseMatrix object to\n### COO_SparseArray, so 'as(x, \"COO_SparseArray\")' and 'as(x, \"SparseArray\")'\n### should fail or do nothing when 'x' is a COO_SparseMatrix object, even\n### when called with 'strict=TRUE'. Making these coercions behave like no-ops\n### seems to be the easiest (and safest) way to go.\n\nsetAs(\"COO_SparseMatrix\", \"COO_SparseArray\", function(from) from)  # no-op\n\n### Do NOT use setAs() here! setAs() does really bad things if used to define\n### this coercion method e.g. for some reason it calls setIs() internally to\n### make COO_SparseMatrix a **direct** extension of SparseArray, thus\n### altering (and breaking) our class hierarchy. This is not only conceptually\n### wrong but it also seems to break dispatch e.g. calling 'show(x)' on\n### COO_SparseMatrix object 'x' does not find the method for SparseArray\n### objects despite 'is(x, \"SparseArray\")' being TRUE.\n### Worst part is that this seems to be a \"feature\" (apparently setAs() tries\n### to be really smart here!) but it's just a big mess.\nsetMethod(\"coerce\", c(\"COO_SparseMatrix\", \"SparseArray\"),\n    function(from, to, strict=TRUE) from  # no-op\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.validate_nzcoo_slot <- function(x)\n{\n    x_nzcoo <- x@nzcoo\n    if (!(is.matrix(x_nzcoo) && typeof(x_nzcoo) == \"integer\"))\n        return(\"'nzcoo' slot must be an integer matrix\")\n    x_dim <- x@dim\n    if (ncol(x_nzcoo) != length(x_dim))\n        return(paste0(\"'nzcoo' slot must be a matrix with \",\n                      \"one column per dimension\"))\n    for (along in seq_along(x_dim)) {\n        not_ok <- S4Vectors:::anyMissingOrOutside(x_nzcoo[ , along],\n                                                  1L, x_dim[[along]])\n        if (not_ok)\n            return(paste0(\"'nzcoo' slot must contain valid indices, \",\n                          \"that is, indices that are not NA and are \",\n                          \">= 1 and <= their corresponding dimension\"))\n    }\n    TRUE\n}\n\n.validate_nzdata_slot <- function(x)\n{\n    x_nzdata <- x@nzdata\n    if (!(is.vector(x_nzdata) && length(x_nzdata) == nrow(x@nzcoo)))\n        return(paste0(\"'nzdata' slot must be a vector of length \",\n                      \"the number of rows in the 'nzcoo' slot\"))\n    TRUE\n}\n\n.validate_COO_SparseArray <- function(x)\n{\n    msg <- .validate_nzcoo_slot(x)\n    if (!isTRUE(msg))\n        return(msg)\n    msg <- .validate_nzdata_slot(x)\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\nsetValidity2(\"COO_SparseArray\", .validate_COO_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Getters\n###\n\nsetMethod(\"type\", \"COO_SparseArray\", function(x) type(x@nzdata))\n\nsetGeneric(\"nzcoo\", function(x) standardGeneric(\"nzcoo\"))\nsetMethod(\"nzcoo\", \"COO_SparseArray\", function(x) x@nzcoo)\n\nsetGeneric(\"nzdata\", function(x) standardGeneric(\"nzdata\"))\nsetMethod(\"nzdata\", \"COO_SparseArray\", function(x) x@nzdata)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### type() setter\n###\n\n.set_COO_SparseArray_type <- function(x, value)\n{\n    stopifnot(is(x, \"COO_SparseArray\"))\n\n    value <- S4Arrays:::normarg_array_type(value, \"the supplied type\")\n    x_type <- type(x)\n    if (value == x_type)\n        return(x)\n\n    new_nzdata <- x@nzdata\n    storage.mode(new_nzdata) <- value\n    nzidx <- default_nzwhich(new_nzdata)\n    new_nzcoo <- x@nzcoo[nzidx, , drop=FALSE]\n    new_nzdata <- new_nzdata[nzidx]\n    BiocGenerics:::replaceSlots(x, nzcoo=new_nzcoo,\n                                   nzdata=new_nzdata,\n                                   check=FALSE)\n}\n\nsetReplaceMethod(\"type\", \"COO_SparseArray\", .set_COO_SparseArray_type)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .normalize_COO_SparseArray()\n###\n### The internal representation of a COO_SparseArray object 'x' is considered\n### normalized if 'x@nzcoo' and 'x@nzdata' are both normalized:\n###   1. 'x@nzcoo' is normalized if it's moving along the innermost dimension\n###      (a.k.a fastest moving dimension) of the object first. This is\n###      equivalent to 'Mindex2Lindex(x@nzcoo, dim(x))' being strictly sorted.\n###   2. 'x@nzdata' is normalized if it contains no zeros.\n\n### Normalizes the 'nzdata' slot of COO_SparseArray object 'x' by removing\n### zeros from it.\n.normalize_nzdata_slot <- function(x)\n{\n    stopifnot(is(x, \"COO_SparseArray\"))\n    zero <- vector_of_zeros(type(x@nzdata), length=1L)\n    idx0 <- which(x@nzdata == zero)\n    if (length(idx0) == 0L)\n        return(x)\n    new_nzdata <- x@nzdata[-idx0]\n    ## Keep 'nzcoo' slot parallel to 'nzdata' slot.\n    new_nzcoo <- x@nzcoo[-idx0, , drop=FALSE]\n    BiocGenerics:::replaceSlots(x, nzcoo=new_nzcoo,\n                                   nzdata=new_nzdata,\n                                   check=FALSE)\n}\n\n### Normalizes the 'nzcoo' slot of COO_SparseArray object 'x' by sorting\n### its rows and removing duplicated rows from it.\n### TODO: The current implementations does not rely on Mindex2Lindex() but\n### maybe it should. Would this be more efficient?\n.normalize_nzcoo_slot <- function(x)\n{\n    stopifnot(is(x, \"COO_SparseArray\"))\n    new_nzcoo <- x@nzcoo\n    new_nzdata <- x@nzdata\n    oo <- S4Arrays:::Mindex_order(new_nzcoo)\n    nzcoo_is_unsorted <- is.unsorted(oo)\n    if (nzcoo_is_unsorted) {\n        new_nzcoo <- new_nzcoo[oo, , drop=FALSE]\n        ## Keep 'nzdata' slot parallel to 'nzcoo' slot.\n        new_nzdata <- new_nzdata[oo]\n    }\n    dup_idx <- which(S4Arrays:::Mindex_row_is_repeated(new_nzcoo))\n    if (length(dup_idx) == 0L) {\n        if (!nzcoo_is_unsorted) {\n            ## 'x@nzcoo' was already in normal form --> no need to touch 'x'.\n            return(x)\n        }\n    } else {\n        new_nzcoo <- new_nzcoo[-dup_idx, , drop=FALSE]\n        ## Keep 'nzdata' slot parallel to 'nzcoo' slot.\n        new_nzdata <- new_nzdata[-dup_idx]\n    }\n    ## 'x@nzcoo' was not in normal form --> update 'x@nzcoo' and 'x@nzdata'.\n    BiocGenerics:::replaceSlots(x, nzcoo=new_nzcoo,\n                                   nzdata=new_nzdata,\n                                   check=FALSE)\n}\n\n.normalize_COO_SparseArray <- function(x)\n{\n    ## Order of the two calls should not matter but is one order more\n    ## efficient than the other?\n    .normalize_nzcoo_slot(.normalize_nzdata_slot(x))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_nonzero(), nzcount(), nzwhich(), nzvals(), `nzvals<-`()\n###\n\n### Returns a \"logical\" COO_SparseArray object.\n.is_nonzero_COO <- function(x)\n{\n    x <- .normalize_COO_SparseArray(x)\n    new_nzdata <- rep.int(TRUE, length(nzdata(x)))\n    BiocGenerics:::replaceSlots(x, nzdata=new_nzdata, check=FALSE)\n}\n\nsetMethod(\"is_nonzero\", \"COO_SparseArray\", .is_nonzero_COO)\n\n### length(nzdata(x)) and nrow(nzcoo(x)) are guaranteed to be the same but\n### the former should be slightly more efficient.\nsetMethod(\"nzcount\", \"COO_SparseArray\",\n    function(x) length(nzdata(.normalize_COO_SparseArray(x)))\n)\n\n\n### Returns an integer vector of length nzcount(x) if 'arr.ind=FALSE', or\n### a matrix with nzcount(x) rows if 'arr.ind=TRUE'.\n.nzwhich_COO <- function(x, arr.ind=FALSE)\n{\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    ans <- .normalize_COO_SparseArray(x)@nzcoo\n    if (arr.ind)\n        return(ans)\n    Mindex2Lindex(ans, dim=dim(x))\n}\n\nsetMethod(\"nzwhich\", \"COO_SparseArray\", .nzwhich_COO)\n\nsetMethod(\"nzvals\", \"COO_SparseArray\",\n    function(x) .normalize_COO_SparseArray(x)@nzdata\n)\n\n### As a side effect, the returned COO_SparseArray object is normalized.\nsetReplaceMethod(\"nzvals\", \"COO_SparseArray\",\n    function(x, value)\n    {\n        if (!is.vector(value))\n            stop(wmsg(\"replacement value must be a vector\"))\n        x <- .normalize_COO_SparseArray(x)\n        x@nzdata[] <- value\n        .normalize_nzdata_slot(x)\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level constructor\n###\n\nnew_COO_SparseArray <- function(dim, dimnames=NULL,\n                                nzcoo=NULL, nzdata=NULL, check=TRUE)\n{\n    stopifnot(is.integer(dim))\n    if (length(dim) == 2L) {\n        ans_class <- \"COO_SparseMatrix\"\n    } else {\n        ans_class <- \"COO_SparseArray\"\n    }\n    dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    new2(ans_class, dim=dim, dimnames=dimnames,\n                    nzcoo=nzcoo, nzdata=nzdata, check=check)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Constructor\n###\n\n.normarg_nzdata <- function(nzdata, length.out)\n{\n    if (is.null(nzdata))\n        stop(wmsg(\"'nzdata' cannot be NULL when 'nzcoo' is not NULL\"))\n    if (!is.vector(nzdata))\n        stop(wmsg(\"'nzdata' must be a vector\"))\n    ## Same logic as S4Vectors:::V_recycle().\n    nzdata_len <- length(nzdata)\n    if (nzdata_len == length.out)\n        return(nzdata)\n    if (nzdata_len > length.out && nzdata_len != 1L)\n        stop(wmsg(\"'length(nzdata)' is greater than 'nrow(nzcoo)'\"))\n    if (nzdata_len == 0L)\n        stop(wmsg(\"'length(nzdata)' is 0 but 'nrow(nzcoo)' is not\"))\n    if (length.out %% nzdata_len != 0L)\n        warning(wmsg(\"'nrow(nzcoo)' is not a multiple of 'length(nzdata)'\"))\n    rep(nzdata, length.out=length.out)\n}\n\nCOO_SparseArray <- function(dim, nzcoo=NULL, nzdata=NULL, dimnames=NULL,\n                                 check=TRUE)\n{\n    if (!is.numeric(dim))\n        stop(wmsg(\"'dim' must be an integer vector\"))\n    if (!is.integer(dim))\n        dim <- as.integer(dim)\n    if (is.null(nzcoo)) {\n        if (is.null(nzdata)) {\n            nzdata <- logical(0)  # vector()\n        } else if (!(is.vector(nzdata) && length(nzdata) == 0L)) {\n            stop(wmsg(\"'nzdata' must be NULL or a vector of length 0 \",\n                      \"when 'nzcoo' is NULL\"))\n        }\n        nzcoo <- matrix(integer(0), ncol=length(dim))\n    } else {\n        if (!is.matrix(nzcoo))\n            stop(wmsg(\"'nzcoo' must be a matrix\"))\n        if (storage.mode(nzcoo) == \"double\")\n            storage.mode(nzcoo) <- \"integer\"\n        if (!is.null(dimnames(nzcoo)))\n            dimnames(nzcoo) <- NULL\n        nzdata <- .normarg_nzdata(nzdata, nrow(nzcoo))\n    }\n    new_COO_SparseArray(dim, dimnames, nzcoo, nzdata, check=check)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .dense2sparse() and .sparse2dense()\n###\n\n### Works on any array-like object 'x' that supports nzwhich(x) and nzvals(x).\n### Returns a COO_SparseArray object.\n.dense2sparse <- function(x)\n{\n    x_dim <- dim(x)\n    if (is.null(x_dim))\n        stop(wmsg(\"'x' must be an array-like object\"))\n    ans_nzcoo <- nzwhich(x, arr.ind=TRUE)  # M-index\n    ans_nzdata <- nzvals(x)\n    COO_SparseArray(x_dim, ans_nzcoo, ans_nzdata, dimnames(x), check=FALSE)\n}\n\n### 'coo' must be a COO_SparseArray object.\n### Return an ordinary array.\n.sparse2dense <- function(coo)\n{\n    if (!is(coo, \"COO_SparseArray\"))\n        stop(wmsg(\"'coo' must be a COO_SparseArray object\"))\n    coo_nzdata <- nzdata(coo)\n    zero <- vector_of_zeros(typeof(coo_nzdata), length=1L)\n    ans <- array(zero, dim=dim(coo))\n    ans[nzcoo(coo)] <- coo_nzdata\n    S4Arrays:::set_dimnames(ans, dimnames(coo))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### as.array.COO_SparseArray() and default coercion to COO_SparseArray or\n### COO_SparseMatrix\n###\n\n### S3/S4 combo for as.array.COO_SparseArray\nas.array.COO_SparseArray <- function(x, ...) .sparse2dense(x)\nsetMethod(\"as.array\", \"COO_SparseArray\", as.array.COO_SparseArray)\n\nsetAs(\"ANY\", \"COO_SparseArray\", function(from) .dense2sparse(from))\nsetAs(\"ANY\", \"COO_SparseMatrix\",\n    function(from) as(.dense2sparse(from), \"COO_SparseMatrix\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between COO_SparseMatrix and [C|R|T]sparseMatrix\n###\n\n### --- From COO_SparseMatrix to [C|R|T]sparseMatrix ---\n\n### Note that:\n### - Constructing the [C|R|T]sparseMatrix derivative is taken care of by\n###   the last line which calls one of the 3 specialized *sparseMatrix()\n###   constructor functions defined in this package (in sparseMatrix-utils.R).\n### - We only normalize the '@nzdata' slot of the COO_SparseMatrix\n###   object, not its '@nzcoo' slot, before turning the object into\n###   a [C|R|T]sparseMatrix derivative, so the latter is guaranteed\n###   to have a \"clean\" '@x' slot (i.e. no zeros in it). In particular, we\n###   do NOT try to fully normalize the COO_SparseMatrix object as this can\n###   be costly and is not needed.\n### - If the requested layout is \"T\", then the (i,j,x) triplets in the\n###   returned TsparseMatrix derivative are not stored in any particular order.\n.make_sparseMatrix_from_COO_SparseMatrix <-\n    function(from, one_letter_type=c(\"d\", \"l\", \"n\"), layout=c(\"C\", \"R\", \"T\"))\n{\n    stopifnot(is(from, \"COO_SparseMatrix\"))\n    one_letter_type <- match.arg(one_letter_type)\n    layout <- match.arg(layout)\n\n    if (one_letter_type != \"n\") {\n        to_type <- if (one_letter_type == \"d\") \"double\" else \"logical\"\n        if (type(from@nzdata) != to_type)\n            storage.mode(from@nzdata) <- to_type  # can introduce zeros\n    }\n\n    ## Get rid of zeros originally in '@nzdata' slot or possibly introduced\n    ## by type switching above.\n    from <- .normalize_nzdata_slot(from)\n\n    i <- from@nzcoo[ , 1L]\n    j <- from@nzcoo[ , 2L]\n    nzdata <- if (one_letter_type == \"n\") NULL else from@nzdata\n\n    ## Call specialized *sparseMatrix() constructor function defined in\n    ## sparseMatrix-utils.R.\n    FUN <- get(paste0(layout, \"sparseMatrix\"), mode=\"function\")\n    FUN(dim(from), i, j, nzdata, dimnames=dimnames(from))\n}\n\nsetAs(\"COO_SparseMatrix\", \"dgCMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"d\", \"C\")\n)\nsetAs(\"COO_SparseMatrix\", \"lgCMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"l\", \"C\")\n)\nsetAs(\"COO_SparseMatrix\", \"ngCMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"n\", \"C\")\n)\n\nsetAs(\"COO_SparseMatrix\", \"dgRMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"d\", \"R\")\n)\nsetAs(\"COO_SparseMatrix\", \"lgRMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"l\", \"R\")\n)\nsetAs(\"COO_SparseMatrix\", \"ngRMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"n\", \"R\")\n)\n\nsetAs(\"COO_SparseMatrix\", \"dgTMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"d\", \"T\")\n)\nsetAs(\"COO_SparseMatrix\", \"lgTMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"l\", \"T\")\n)\nsetAs(\"COO_SparseMatrix\", \"ngTMatrix\",\n    function(from) .make_sparseMatrix_from_COO_SparseMatrix(from, \"n\", \"T\")\n)\n\nsetAs(\"COO_SparseMatrix\", \"sparseMatrix\",\n    function(from) as(from, \"TsparseMatrix\")\n)\n\n### --- From [C|R|T]sparseMatrix to COO_SparseMatrix ---\n\n### Note that, of the 3 helper functions below, only the first one is\n### guaranteed to return a COO_SparseArray object with a '@nzcoo' slot\n### that is normalized.\n### Also none of them tries to remove zeros from the '@x' slot of the\n### supplied sparseMatrix derivative, so these zeros will eventually end\n### up in the '@nzdata' slot of the returned COO_SparseArray object.\n\n.make_COO_SparseMatrix_from_CsparseMatrix <- function(from, use.dimnames=TRUE)\n{\n    ans_dimnames <- if (use.dimnames) dimnames(from) else NULL\n    i <- from@i + 1L\n    j <- rep.int(seq_len(ncol(from)), diff(from@p))\n    ans_nzcoo <- cbind(i, j, deparse.level=0L)\n    ans_nzdata <- if (is(from, \"nMatrix\")) nzvals(from) else from@x\n    new_COO_SparseArray(dim(from), ans_dimnames, ans_nzcoo, ans_nzdata,\n                        check=FALSE)\n}\n\n.make_COO_SparseMatrix_from_RsparseMatrix <- function(from, use.dimnames=TRUE)\n{\n    ans_dimnames <- if (use.dimnames) dimnames(from) else NULL\n    i <- rep.int(seq_len(nrow(from)), diff(from@p))\n    j <- from@j + 1L\n    ans_nzcoo <- cbind(i, j, deparse.level=0L)\n    ans_nzdata <- if (is(from, \"nMatrix\")) nzvals(from) else from@x\n    new_COO_SparseArray(dim(from), ans_dimnames, ans_nzcoo, ans_nzdata,\n                        check=FALSE)\n}\n\nsetAs(\"dgCMatrix\", \"COO_SparseMatrix\",\n    function(from) .make_COO_SparseMatrix_from_CsparseMatrix(from)\n)\nsetAs(\"lgCMatrix\", \"COO_SparseMatrix\",\n    function(from) .make_COO_SparseMatrix_from_CsparseMatrix(from)\n)\nsetAs(\"ngCMatrix\", \"COO_SparseMatrix\",\n    function(from) .make_COO_SparseMatrix_from_CsparseMatrix(from)\n)\n\nsetAs(\"dgRMatrix\", \"COO_SparseMatrix\",\n    function(from) .make_COO_SparseMatrix_from_RsparseMatrix(from)\n)\nsetAs(\"lgRMatrix\", \"COO_SparseMatrix\",\n    function(from) .make_COO_SparseMatrix_from_RsparseMatrix(from)\n)\nsetAs(\"ngRMatrix\", \"COO_SparseMatrix\",\n    function(from) .make_COO_SparseMatrix_from_RsparseMatrix(from)\n)\n\n### We first coerce to CsparseMatrix. Maybe not as efficient as copying\n### the (i,j,x) triplets directly from the TsparseMatrix derivative to\n### the 'nzcoo' and 'nzdata' slots of the COO_SparseMatrix to return.\n### However, doing so would not handle properly a TsparseMatrix derivative\n### that contains (i,j,x) triplets with duplicated (i,j) coordinates.\nsetAs(\"TsparseMatrix\", \"COO_SparseMatrix\",\n    function(from) as(as(from, \"CsparseMatrix\"), \"COO_SparseMatrix\")\n)\n\nsetAs(\"Matrix\", \"COO_SparseArray\", function(from) as(from, \"COO_SparseMatrix\"))\n\n### Coercing a sparseMatrix derivative (e.g. a CsparseMatrix or TsparseMatrix\n### derivative) to SparseMatrix produces an SVT_SparseMatrix object.\n### RsparseMatrix is the exception.\nsetAs(\"RsparseMatrix\", \"SparseMatrix\",\n    function(from) as(from, \"COO_SparseMatrix\")\n)\n\n",
        "NaArray-Arith-methods.R": "### =========================================================================\n### 'Arith' operations on NaArray objects\n### -------------------------------------------------------------------------\n###\n### 'Arith' operations: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n###\n### See '?S4groupGeneric' for more information.\n###\n### We also implement unary \"+\" and \"-\" for NaArray objects.\n###\n\n\nerror_on_left_NAsparsity_not_preserved <- function(op, when)\n{\n    flipped_op <- flip_Compare_op(op)\n    show_flipped_op <- flipped_op != op || op_is_commutative(op)\n    if (show_flipped_op) {\n        msg <- c(\"'x \", op, \" y' and 'y \", flipped_op, \" x': operations\")\n    } else {\n        msg <- c(\"x \", op, \" y: operation\")\n    }\n    stop(wmsg(msg, \" not supported on NaArray object x \",\n              \"when \", when, \" (result wouldn't be \\\"non-NA sparse\\\")\"))\n}\n\nerror_on_right_NAsparsity_not_preserved <- function(op, when)\n{\n    flipped_op <- flip_Compare_op(op)\n    show_flipped_op <- flipped_op != op || op_is_commutative(op)\n    if (show_flipped_op) {\n        msg <- c(\"'x \", op, \" y' and 'y \", flipped_op, \" x': operations\")\n    } else {\n        msg <- c(\"x \", op, \" y: operation\")\n    }\n    stop(wmsg(msg, \" not supported on NaArray object y \",\n              \"when \", when, \" (result wouldn't be \\\"non-NA sparse\\\")\"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Unary \"+\" and \"-\"\n###\n\n.unary_plus_NaArray <- function(x)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_Arith_input_type(type(x), \"NaArray object\")\n    x  # no-op\n}\n\n.unary_minus_NaArray <- function(x)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_Arith_input_type(type(x), \"NaArray object\")\n    check_svt_version(x)\n    new_NaSVT <- SparseArray.Call(\"C_unary_minus_SVT\", x@dim, x@type, x@NaSVT)\n    BiocGenerics:::replaceSlots(x, NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"+\", c(\"NaArray\", \"missing\"),\n    function(e1, e2) .unary_plus_NaArray(e1)\n)\n\nsetMethod(\"-\", c(\"NaArray\", \"missing\"),\n    function(e1, e2) .unary_minus_NaArray(e1)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Arith' group\n###\n\n### Supports all 'Arith' ops: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Returns an NaArray object.\n.Arith_NaSVT1_v2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Check types.\n    check_Arith_input_type(type(x), \"NaArray object\")\n    if (!is.atomic(y))\n        stop(wmsg(\"arithmetic operations between NaArray objects \",\n                  \"and non-atomic vectors are not supported\"))\n    if (!(type(y) %in% ARITH_INPUT_TYPES))\n        stop(wmsg(\"arithmetic operations between NaArray objects \",\n                  \"and \", class(y), \" vectors are not supported\"))\n\n    ## Check 'y'.\n    check_vector_operand_length(length(y), dim(x), 1L, \"NaArray object\")\n    if ((op == \"^\") && (any(y %in% c(0, NaN))))\n        error_on_left_NAsparsity_not_preserved(op,\n                 \"y contains zeros or NaN values\")\n    if ((op == \"%%\") && any(y %in% 0))\n        error_on_left_NAsparsity_not_preserved(op,\n                 \"y contains zeros\")\n\n    ## Compute 'ans_type'.\n    if (type(x) == \"double\" && type(y) == \"integer\" || op %in% c(\"/\", \"^\"))\n        type(y) <- \"double\"  # cheap\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    new_NaSVT <- SparseArray.Call(\"C_Arith_SVT1_v2\",\n                                  x@dim, x@type, x@NaSVT, TRUE,\n                                  y, 1L, op, ans_type)\n    BiocGenerics:::replaceSlots(x, type=ans_type, NaSVT=new_NaSVT, check=FALSE)\n}\n\n### Supports all 'Arith' ops: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Returns an NaArray object.\n.Arith_v1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(y, \"NaArray\"))\n    check_svt_version(y)\n\n    ## Check types.\n    check_Arith_input_type(type(y), \"NaArray object\")\n    if (!is.atomic(x))\n        stop(wmsg(\"arithmetic operations between NaArray objects \",\n                  \"and non-atomic vectors are not supported\"))\n    if (!(type(x) %in% ARITH_INPUT_TYPES))\n        stop(wmsg(\"arithmetic operations between NaArray objects \",\n                  \"and \", class(x), \" vectors are not supported\"))\n\n    ## Check 'x'.\n    check_vector_operand_length(length(x), dim(y), 1L, \"NaArray object\",\n                                side=\"left\")\n    if (op == \"^\" && any(x %in% 1))\n        error_on_right_NAsparsity_not_preserved(op,\n                 \"x contains ones\")\n\n    ## Compute 'ans_type'.\n    if (type(x) == \"integer\" && type(y) == \"double\" || op %in% c(\"/\", \"^\"))\n        type(x) <- \"double\"  # cheap\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    new_NaSVT <- SparseArray.Call(\"C_Arith_v1_SVT2\",\n                                  x, y@dim, y@type, y@NaSVT, TRUE, op, ans_type)\n    BiocGenerics:::replaceSlots(y, type=ans_type, NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Arith\", c(\"NaArray\", \"vector\"),\n    function(e1, e2) .Arith_NaSVT1_v2(.Generic, e1, e2)\n)\n\nsetMethod(\"Arith\", c(\"vector\", \"NaArray\"),\n    function(e1, e2) .Arith_v1_NaSVT2(.Generic, e1, e2)\n)\n\n### Supports all 'Arith' ops: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Returns an NaArray object.\n.Arith_NaSVT1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"), is(y, \"NaArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Arith_input_type(type(x), \"NaArray object\")\n    check_Arith_input_type(type(y), \"NaArray object\")\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Compute 'ans_type'.\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Arith_SVT1_SVT2\",\n                                  x_dim, x@type, x@NaSVT, TRUE,\n                                  y_dim, y@type, y@NaSVT, TRUE, op, ans_type)\n    new_NaArray(x_dim, ans_dimnames, ans_type, ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Arith\", c(\"NaArray\", \"NaArray\"),\n    function(e1, e2) .Arith_NaSVT1_NaSVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Arith\", c(\"NaArray\", \"array\"),\n    function(e1, e2) .Arith_NaSVT1_NaSVT2(.Generic, e1, as(e2, \"NaArray\"))\n)\n\nsetMethod(\"Arith\", c(\"array\", \"NaArray\"),\n    function(e1, e2) .Arith_NaSVT1_NaSVT2(.Generic, as(e1, \"NaArray\"), e2)\n)\n\n### Supports all 'Arith' ops: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Returns an NaArray object.\n.Arith_NaSVT1_SVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"), is(y, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Arith_input_type(type(x), \"NaArray object\")\n    check_Arith_input_type(type(y), \"SparseArray object\")\n\n    ## Make sure that result will be \"non-NA sparse\".\n    if (op == \"^\")\n        stop(wmsg(\"'x ^ y' is not supported when 'x' is an NaArray object \",\n                  \"and 'y' a SparseArray object (result wouldn't be \",\n                  \"\\\"non-NA sparse\\\" in general)\"))\n    if (op == \"%%\" && (type(x) == \"double\" || type(y) == \"double\"))\n        stop(wmsg(\"'x %% y' is not supported when 'x' is an NaArray object \",\n                  \"and 'y' a SparseArray object, and when 'x' or 'y' is of \",\n                  \"type \\\"double\\\" (result wouldn't be \\\"non-NA sparse\\\" in \",\n                  \"general)\"))\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Compute 'ans_type'.\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Arith_SVT1_SVT2\",\n                                  x_dim, x@type, x@NaSVT, TRUE,\n                                  y_dim, y@type, y@SVT, FALSE, op, ans_type)\n    new_NaArray(x_dim, ans_dimnames, ans_type, ans_NaSVT, check=FALSE)\n}\n\n### Supports all 'Arith' ops: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Returns an NaArray object.\n.Arith_SVT1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"), is(y, \"NaArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Arith_input_type(type(x), \"SparseArray object\")\n    check_Arith_input_type(type(y), \"NaArray object\")\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Compute 'ans_type'.\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Arith_SVT1_SVT2\",\n                                  x_dim, x@type, x@SVT, FALSE,\n                                  y_dim, y@type, y@NaSVT, TRUE, op, ans_type)\n    new_NaArray(x_dim, ans_dimnames, ans_type, ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Arith\", c(\"NaArray\", \"SVT_SparseArray\"),\n    function(e1, e2) .Arith_NaSVT1_SVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Arith\", c(\"SVT_SparseArray\", \"NaArray\"),\n    function(e1, e2) .Arith_SVT1_NaSVT2(.Generic, e1, e2)\n)\n\n",
        "NaArray-Compare-methods.R": "### =========================================================================\n### 'Compare' operations on NaArray objects\n### -------------------------------------------------------------------------\n###\n### 'Compare' operations: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n###\n### See '?S4groupGeneric' for more information.\n###\n\n\n### Supports all 'Compare' ops: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n### Returns a \"logical\" NaArray object.\n.Compare_NaSVT1_v2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Check types.\n    x_type <- type(x)\n    check_Compare_input_type(x_type, \"NaArray object\")\n    if (!(type(y) %in% COMPARE_INPUT_TYPES))\n        stop(wmsg(\"comparison operations between NaArray objects \",\n                  \"and \", class(y), \" vectors are not supported\"))\n    check_Compare_op_on_complex_vals(op, x_type, type(y))\n\n    ## Check 'y'.\n    if (length(y) != 1L)\n        stop(wmsg(\"comparison operations are not supported between an \",\n                  \"NaArray object and a vector of length != 1\"))\n\n    biggest_type <- type(c(vector(x_type), y))\n    type(y) <- biggest_type\n\n    ## Handle situations where we need to change the type() of 'x' to\n    ## the type() of 'y'. This is possibly expensive so we do it only\n    ## after all the above checks have passed.\n    if (must_homogenize_for_Compare(type(x), type(y)))\n        type(x) <- type(y)\n\n    ## 'type(y)' is guaranteed to be the same as 'type(x)' or a \"bigger\" type,\n    ## considering raw < logical < integer < double < complex < character.\n    new_NaSVT <- SparseArray.Call(\"C_Compare_SVT1_v2\",\n                                  x@dim, x@type, x@NaSVT, TRUE, y, op)\n    BiocGenerics:::replaceSlots(x, type=\"logical\", NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Compare\", c(\"NaArray\", \"vector\"),\n    function(e1, e2) .Compare_NaSVT1_v2(.Generic, e1, e2)\n)\n\nsetMethod(\"Compare\", c(\"vector\", \"NaArray\"),\n    function(e1, e2) .Compare_NaSVT1_v2(flip_Compare_op(.Generic), e2, e1)\n)\n\n### Supports all 'Compare' ops: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n### Returns a \"logical\" NaArray object.\n.Compare_NaSVT1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"), is(y, \"NaArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Compare_input_type(type(x), \"NaArray object\")\n    check_Compare_input_type(type(y), \"NaArray object\")\n    check_Compare_op_on_complex_vals(op, type(x), type(y))\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Homogenization is possibly expensive so we do it only after all\n    ## the above checks have passed.\n    if (must_homogenize_for_Compare(type(x), type(y)))\n        type(x) <- type(y) <- type(c(vector(type(x)), vector(type(y))))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Compare_SVT1_SVT2\",\n                                  x_dim, x@type, x@NaSVT, TRUE,\n                                  y_dim, y@type, y@NaSVT, TRUE, op)\n    new_NaArray(x_dim, ans_dimnames, \"logical\", ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Compare\", c(\"NaArray\", \"NaArray\"),\n    function(e1, e2) .Compare_NaSVT1_NaSVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Compare\", c(\"NaArray\", \"array\"),\n    function(e1, e2) .Compare_NaSVT1_NaSVT2(.Generic, e1, as(e2, \"NaArray\"))\n)\n\nsetMethod(\"Compare\", c(\"array\", \"NaArray\"),\n    function(e1, e2) .Compare_NaSVT1_NaSVT2(.Generic, as(e1, \"NaArray\"), e2)\n)\n\n### Supports all 'Compare' ops: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n### Returns a \"logical\" NaArray object.\n.Compare_NaSVT1_SVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"), is(y, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Compare_input_type(type(x), \"NaArray object\")\n    check_Compare_input_type(type(y), \"SparseArray object\")\n    check_Compare_op_on_complex_vals(op, type(x), type(y))\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Homogenization is possibly expensive so we do it only after all\n    ## the above checks have passed.\n    if (must_homogenize_for_Compare(type(x), type(y)))\n        type(x) <- type(y) <- type(c(vector(type(x)), vector(type(y))))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Compare_SVT1_SVT2\",\n                                  x_dim, x@type, x@NaSVT, TRUE,\n                                  y_dim, y@type, y@SVT, FALSE, op)\n    new_NaArray(x_dim, ans_dimnames, \"logical\", ans_NaSVT, check=FALSE)\n}\n\n### Supports all 'Compare' ops: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n### Returns a \"logical\" NaArray object.\n.Compare_SVT1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"), is(y, \"NaArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Compare_input_type(type(x), \"SparseArray object\")\n    check_Compare_input_type(type(y), \"NaArray object\")\n    check_Compare_op_on_complex_vals(op, type(x), type(y))\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Homogenization is possibly expensive so we do it only after all\n    ## the above checks have passed.\n    if (must_homogenize_for_Compare(type(x), type(y)))\n        type(x) <- type(y) <- type(c(vector(type(x)), vector(type(y))))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Compare_SVT1_SVT2\",\n                                  x_dim, x@type, x@SVT, FALSE,\n                                  y_dim, y@type, y@NaSVT, TRUE, op)\n    new_NaArray(x_dim, ans_dimnames, \"logical\", ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Compare\", c(\"NaArray\", \"SVT_SparseArray\"),\n    function(e1, e2) .Compare_NaSVT1_SVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Compare\", c(\"SVT_SparseArray\", \"NaArray\"),\n    function(e1, e2) .Compare_SVT1_NaSVT2(.Generic, e1, e2)\n)\n\n",
        "NaArray-Logic-methods.R": "### =========================================================================\n### 'Logic' operations on NaArray objects\n### -------------------------------------------------------------------------\n###\n### 'Logic' operations:   \"&\", \"|\"\n###\n### See '?S4groupGeneric' for more information.\n###\n### We also implement a logical negation (\"!\") method for NaArray objects.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Logical negation\n###\n\n.logical_neg_NaArray <- function(x)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Check types.\n    x_type <- type(x)\n    if (!(x_type %in% LOGIC_INPUT_TYPES))\n        stop(wmsg(\"logical negation (\\\"!\\\") of an NaArray object \",\n                  \"of type() \\\"\", x_type, \"\\\" is not supported\"))\n\n    new_NaSVT <- SparseArray.Call(\"C_logical_neg_NaSVT\", x@dim, x@type, x@NaSVT)\n    BiocGenerics:::replaceSlots(x, type=\"logical\", NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"!\", \"NaArray\", .logical_neg_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Logic' group\n###\n\n.Logic_NaSVT1_v2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Check types.\n    x_type <- type(x)\n    check_Logic_input_type(x_type, \"NaArray object\")\n    if (!(type(y) %in% LOGIC_INPUT_TYPES))\n        stop(wmsg(\"\\\"\", op, \"\\\" between an NaArray object \",\n                  \"and a \", class(y), \" vector is not supported\"))\n\n    ## Check 'y'.\n    if (length(y) != 1L)\n        stop(wmsg(\"\\\"\", op, \"\\\" between an NaArray object \",\n                  \"and a vector of length != 1 is not supported\"))\n\n    if (is.na(y)) {\n        new_NaSVT <- SparseArray.Call(\"C_Logic_NaSVT1_na\",\n                                      x@dim, x@type, x@NaSVT, op)\n        BiocGenerics:::replaceSlots(x, type=\"logical\", NaSVT=new_NaSVT,\n                                    check=FALSE)\n    } else {\n        if (op == \"&\" && isFALSE(y))\n            error_on_left_NAsparsity_not_preserved(op, \"y is FALSE\")\n        if (op == \"|\" && isTRUE(y))\n            error_on_left_NAsparsity_not_preserved(op, \"y is TRUE\")\n        x\n    }\n}\n\nsetMethod(\"Logic\", c(\"NaArray\", \"vector\"),\n    function(e1, e2) .Logic_NaSVT1_v2(.Generic, e1, e2)\n)\n\nsetMethod(\"Logic\", c(\"vector\", \"NaArray\"),\n    function(e1, e2) .Logic_NaSVT1_v2(.Generic, e2, e1)\n)\n\n### Returns an NaArray object.\n.Logic_NaSVT1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"), is(y, \"NaArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Logic_input_type(type(x), \"NaArray object\")\n    check_Logic_input_type(type(y), \"NaArray object\")\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ans_NaSVT <- SparseArray.Call(\"C_Logic_SVT1_SVT2\",\n                                  x_dim, x@type, x@NaSVT, TRUE,\n                                  y_dim, y@type, y@NaSVT, TRUE, op)\n    new_NaArray(x_dim, ans_dimnames, NaSVT=ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Logic\", c(\"NaArray\", \"NaArray\"),\n    function(e1, e2) .Logic_NaSVT1_NaSVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Logic\", c(\"NaArray\", \"array\"),\n    function(e1, e2) .Logic_NaSVT1_NaSVT2(.Generic, e1, as(e2, \"NaArray\"))\n)\n\nsetMethod(\"Logic\", c(\"array\", \"NaArray\"),\n    function(e1, e2) .Logic_NaSVT1_NaSVT2(.Generic, as(e1, \"NaArray\"), e2)\n)\n\n### Returns an NaArray object if 'op' is \"|\" (because NA | FALSE is NA),\n### and a SparseArray if 'op' is \"&\" (because NA & FALSE is FALSE).\n.Logic_NaSVT1_SVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"), is(y, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Logic_input_type(type(x), \"NaArray object\")\n    check_Logic_input_type(type(y), \"SparseArray object\")\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ans_SVT <- SparseArray.Call(\"C_Logic_SVT1_SVT2\",\n                                x_dim, x@type, x@NaSVT, TRUE,\n                                y_dim, y@type, y@SVT, FALSE, op)\n    if (op == \"|\")\n        return(new_NaArray(x_dim, ans_dimnames, NaSVT=ans_SVT, check=FALSE))\n    new_SVT_SparseArray(x_dim, ans_dimnames, SVT=ans_SVT, check=FALSE)\n}\n\n### Returns an NaArray object if 'op' is \"|\" (because FALSE | NA is NA),\n### and a SparseArray if 'op' is \"&\" (because FALSE & NA is FALSE).\n.Logic_SVT1_NaSVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"), is(y, \"NaArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Logic_input_type(type(x), \"SparseArray object\")\n    check_Logic_input_type(type(y), \"NaArray object\")\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ans_SVT <- SparseArray.Call(\"C_Logic_SVT1_SVT2\",\n                                x_dim, x@type, x@SVT, FALSE,\n                                y_dim, y@type, y@NaSVT, TRUE, op)\n    if (op == \"|\")\n        return(new_NaArray(x_dim, ans_dimnames, NaSVT=ans_SVT, check=FALSE))\n    new_SVT_SparseArray(x_dim, ans_dimnames, SVT=ans_SVT, check=FALSE)\n}\n\nsetMethod(\"Logic\", c(\"NaArray\", \"SVT_SparseArray\"),\n    function(e1, e2) .Logic_NaSVT1_SVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Logic\", c(\"SVT_SparseArray\", \"NaArray\"),\n    function(e1, e2) .Logic_SVT1_NaSVT2(.Generic, e1, e2)\n)\n\n",
        "NaArray-Math-methods.R": "### =========================================================================\n### 'Math' and 'Math2' methods for NaArray objects\n### -------------------------------------------------------------------------\n###\n### See '?S4groupGeneric' for which functions belong to the 'Math'\n### and 'Math2' groups.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Math' group\n###\n\n### NaArray objects only support functions from the 'Math' group that\n### propagate NAs.\n.SUPPORTED_NAARRAY_MATH_OPS <- c(SUPPORTED_MATH_OPS,\n    \"log\", \"log10\", \"log2\", \"exp\",\n    \"cos\", \"acos\", \"cosh\", \"acosh\", \"cospi\",\n    \"gamma\", \"lgamma\", \"digamma\", \"trigamma\"\n)\n\n.check_NaArray_Math_op <- function(op)\n{\n    if (!(op %in% .SUPPORTED_NAARRAY_MATH_OPS))\n        stop(wmsg(op, \"() is not supported on NaArray objects \",\n                  \"(result wouldn't be \\\"non-NA sparse\\\" in general)\"))\n}\n\n.Math_NaSVT <- function(op, x)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n    .check_NaArray_Math_op(op)\n    if (type(x) != \"double\")\n        stop(wmsg(\"the \", op, \"() method for NaArray objects \",\n                  \"only supports input of type \\\"double\\\" at the moment\"))\n    new_NaSVT <- SparseArray.Call(\"C_Math_SVT\",\n                                  x@dim, x@type, x@NaSVT, TRUE, op, 0.0)\n    BiocGenerics:::replaceSlots(x, type=\"double\", NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"Math\", \"NaArray\", function(x) .Math_NaSVT(.Generic, x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Math2' group\n###\n\n.Math2_NaSVT <- function(op, x, digits)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n    if (type(x) != \"double\")\n        stop(wmsg(\"the \", op, \"() method for NaArray objects \",\n                  \"only supports input of type \\\"double\\\" at the moment\"))\n    if (!isSingleNumber(digits))\n        stop(wmsg(\"'digits' must be a single number\"))\n    if (!is.double(digits))\n        digits <- as.double(digits)\n    new_NaSVT <- SparseArray.Call(\"C_Math_SVT\",\n                                  x@dim, x@type, x@NaSVT, TRUE, op, digits)\n    BiocGenerics:::replaceSlots(x, type=\"double\", NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"round\", \"NaArray\",\n    function(x, digits=0) .Math2_NaSVT(\"round\", x, digits)\n)\n\nsetMethod(\"signif\", \"NaArray\",\n    function(x, digits=6) .Math2_NaSVT(\"signif\", x, digits)\n)\n\n",
        "NaArray-abind.R": "### =========================================================================\n### Combining multidimensional NaArray objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### abind()\n###\n\n.abind_NaArray_objects <- function(..., along=NULL, rev.along=NULL)\n{\n    objects <- S4Vectors:::delete_NULLs(list(...))\n    if (length(objects) == 0L)\n        return(NULL)\n\n    ndims <- vapply(objects, function(object) length(dim(object)), integer(1))\n    N <- max(ndims)\n    along <- S4Arrays:::get_along(N, along=along, rev.along=rev.along)\n    ans_ndim <- max(N, along)\n    objects <- S4Arrays:::add_missing_dims(objects, ans_ndim)\n\n    ## Check dim compatibility.\n    dims <- S4Arrays:::get_dims_to_bind(objects, along)\n    if (is.character(dims))\n        stop(wmsg(dims))\n    x <- objects[[1L]]\n    if (length(objects) == 1L)\n        return(x)\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::combine_dimnames_along(objects, dims, along)\n\n    ## Compute 'ans_type'.\n    ans_type <- type(unlist(\n        lapply(objects, function(object) vector(type(object)))\n    ))\n    objects <- lapply(objects, `type<-`, ans_type)\n\n    ## Returns 'ans_dim' and 'ans_NaSVT' in a list of length 2.\n    C_ans <- SparseArray.Call(\"C_abind_SVT_SparseArray_objects\",\n                              objects, \"NaSVT\", along, ans_type)\n    ans_dim <- C_ans[[1L]]\n    ans_NaSVT <- C_ans[[2L]]\n\n    new_NaArray(ans_dim, ans_dimnames, ans_type, ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"abind\", \"NaArray\", .abind_NaArray_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### rbind(), cbind()\n###\n\n### TODO: The methods below are defined for NaArray objects but it seems\n### that they could as well be defined more generally for Array objects.\n\n### The generics have the 'deparse.level' argument. We ignore it.\nsetMethod(\"rbind\", \"NaArray\", function(...) arbind(...))\nsetMethod(\"cbind\", \"NaArray\", function(...) acbind(...))\n\n### Arguments 'use.names', 'ignore.mcols', and 'check' are ignored.\nsetMethod(\"bindROWS\", \"NaArray\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        args <- c(list(x), unname(objects))\n        do.call(rbind, args)\n    }\n)\n\n",
        "NaArray-aperm.R": "### =========================================================================\n### Transposition of an NaArray object\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Transposition\n###\n\n### S3/S4 combo for t.NaMatrix\nt.NaMatrix <- function(x)\n{\n    check_svt_version(x)\n    new_NaSVT <- SparseArray.Call(\"C_transpose_2D_SVT\", x@dim, x@type, x@NaSVT)\n    BiocGenerics:::replaceSlots(x, dim=rev(x@dim),\n                                   dimnames=rev(x@dimnames),\n                                   NaSVT=new_NaSVT,\n                                   check=FALSE)\n}\nsetMethod(\"t\", \"NaMatrix\", t.NaMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### aperm()\n###\n### Supports S4Arrays::aperm2() extended semantic.\n###\n\n.aperm_NaSVT <- function(a, perm, .NAME=c(\"C_aperm_SVT\", \"C_aperm0_SVT\"))\n{\n    stopifnot(is(a, \"NaArray\"))\n    check_svt_version(a)\n\n    .NAME <- match.arg(.NAME)\n\n    aperm0_NaSVT <- function(x, perm) {\n        new_NaSVT <- SparseArray.Call(.NAME, x@dim, x@type, x@NaSVT, perm)\n        BiocGenerics:::replaceSlots(x, dim=x@dim[perm],\n                                       dimnames=x@dimnames[perm],\n                                       NaSVT=new_NaSVT,\n                                       check=FALSE)\n    }\n    S4Arrays:::extended_aperm(a, perm, aperm0_NaSVT)\n}\n\n### S3/S4 combo for aperm.NaArray\naperm.NaArray <- function(a, perm, ...) .aperm_NaSVT(a, perm, ...)\nsetMethod(\"aperm\", \"NaArray\", aperm.NaArray)\n\n",
        "NaArray-class.R": "### =========================================================================\n### NaArray objects\n### -------------------------------------------------------------------------\n###\n### Like SVT_SparseArray objects but the background value is NA instead of\n### zero.\n###\n\nsetClass(\"NaArray\",\n    contains=\"Array\",\n    representation(\n        dim=\"integer\",\n        dimnames=\"list\",\n        type=\"character\",\n        NaSVT=\"NULL_OR_list\",  # NULL or na-Sparse Vector Tree (NaSVT)\n        .svt_version=\"integer\"\n    ),\n    prototype(\n        dim=0L,\n        dimnames=list(NULL),\n        type=\"logical\",\n        .svt_version=SVT_VERSION\n    )\n)\n\n.SUPPORTED_NAARRAY_TYPES <-\n    c(\"integer\", \"logical\", \"double\", \"complex\", \"character\")\n\n.validate_NaArray <- function(x)\n{\n    if (!isSingleString(x@type))\n        return(\"'type' slot must be a single string\")\n    if (!(x@type %in% .SUPPORTED_NAARRAY_TYPES)) {\n        in1string <- paste(paste0('\"', .SUPPORTED_NAARRAY_TYPES, '\"'),\n                           collapse=\", \")\n        return(paste0(\"'type' slot must be one of \", in1string))\n    }\n    TRUE\n}\nsetValidity2(\"NaArray\", .validate_NaArray)\n\n### Extending RectangularData gives us a few things for free (e.g. validity\n### method for RectangularData objects, head(), tail(), etc...). Note\n### that even though NaMatrix already extends Array (via NaArray),\n### we need to make it a *direct* child of Array, and to list Array *before*\n### RectangularData in the 'contains' field below. This will ensure that\n### method dispatch will always choose the method for Array in case a generic\n### has methods defined for both, Array and RectangularData.\n### Note that the fact that we need this \"hack\" is a hint that we could\n### achieve a cleaner class hierarchy by inserting a Matrix class in it.\n### Matrix would contain Array and RectangularData (in that order). Then\n### NaMatrix would contain NaArray and Matrix (in that order).\n### Unfortunately the Matrix package already defines a Matrix class so\n### we would need to use a different name.\nsetClass(\"NaMatrix\",\n    contains=c(\"NaArray\", \"Array\", \"RectangularData\"),\n    prototype=prototype(\n        dim=c(0L, 0L),\n        dimnames=list(NULL, NULL)\n    )\n)\n\n.validate_NaMatrix <- function(x)\n{\n    if (length(x@dim) != 2L)\n        return(\"'dim' slot must be an integer vector of length 2\")\n    TRUE\n}\nsetValidity2(\"NaMatrix\", .validate_NaMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between NaArray and NaMatrix\n###\n\n### --- From NaArray to NaMatrix ---\n\nsetAs(\"NaArray\", \"NaMatrix\",\n    function(from) new(\"NaMatrix\", from)\n)\n\n### --- From NaMatrix to NaArray ---\n\nsetAs(\"NaMatrix\", \"NaArray\", function(from) from)  # no-op\n\nsetMethod(\"coerce\", c(\"NaMatrix\", \"NaArray\"),\n    function(from, to, strict=TRUE) from  # no-op\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### dim(), dimnames(), and `dimnames<-`()\n###\n\nsetMethod(\"dim\", \"NaArray\", function(x) x@dim)\n\nsetMethod(\"dimnames\", \"NaArray\",\n    function(x) S4Arrays:::simplify_NULL_dimnames(x@dimnames)\n)\n\nsetReplaceMethod(\"dimnames\", \"NaArray\",\n    function(x, value)\n    {\n        x@dimnames <- S4Arrays:::normarg_dimnames(value, dim(x))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### type() getter and setter\n###\n\nsetMethod(\"type\", \"NaArray\", function(x) x@type)\n\n.normarg_NaArray_type <- function(type, what=\"'type'\")\n{\n    if (!isSingleString(type))\n        stop(wmsg(what, \" must be a single string\"))\n    if (type == \"numeric\")\n        return(\"double\")\n    if (!(type %in% .SUPPORTED_NAARRAY_TYPES)) {\n        in1string <- paste(paste0('\"', .SUPPORTED_NAARRAY_TYPES, '\"'),\n                           collapse=\", \")\n        stop(wmsg(what, \" must be one of \", in1string))\n    }\n    type\n}\n\n.set_NaArray_type <- function(x, value)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    value <- .normarg_NaArray_type(value, \"the supplied type\")\n    x_type <- type(x)\n    if (value == x_type)\n        return(x)\n\n    new_NaSVT <- SparseArray.Call(\"C_set_SVT_type\",\n                                  x@dim, x@type, x@NaSVT, TRUE, value)\n    BiocGenerics:::replaceSlots(x, type=value, NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetReplaceMethod(\"type\", \"NaArray\", .set_NaArray_type)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_nonna(), nnacount(), nnawhich(), nnavals(), `nnavals<-`()\n###\n\n### Returns a \"logical\" **SVT_SparseArray** object!\n.is_nonna_NaSVT <- function(x)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n    ans_SVT <- SparseArray.Call(\"C_is_nonzero_SVT\", x@dim, x@NaSVT)\n    new_SVT_SparseArray(x@dim, x@dimnames, \"logical\", ans_SVT, check=FALSE)\n}\n\nsetMethod(\"is_nonna\", \"NaArray\", .is_nonna_NaSVT)\n\n### Note that like for the length of atomic vectors in base R, the \"non-NA\n### count\" will be returned as a double if it's > .Machine$integer.max\n.nnacount_NaSVT <- function(x)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n    SparseArray.Call(\"C_nzcount_SVT\", x@dim, x@NaSVT)\n}\nsetMethod(\"nnacount\", \"NaArray\", .nnacount_NaSVT)\n\n### Returns an integer vector of length nnacount(x) if 'arr.ind=FALSE', or\n### a matrix with nnacount(x) rows if 'arr.ind=TRUE'.\n.nnawhich_NaSVT <- function(x, arr.ind=FALSE)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    SparseArray.Call(\"C_nzwhich_SVT\", x@dim, x@NaSVT, arr.ind)\n}\nsetMethod(\"nnawhich\", \"NaArray\", .nnawhich_NaSVT)\n\n### TODO: Implement optimized nnavals() and `nnavals<-`() methods for\n### NaArray objects.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level constructor\n###\n\nnew_NaArray <- function(dim, dimnames=NULL,\n                        type=\"logical\", NaSVT=NULL, check=TRUE)\n{\n    stopifnot(is.integer(dim))\n    if (length(dim) == 2L) {\n        ans_class <- \"NaMatrix\"\n    } else {\n        ans_class <- \"NaArray\"\n    }\n    dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    new2(ans_class, dim=dim, dimnames=dimnames,\n                    type=type, NaSVT=NaSVT, check=check)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between NaArray objects and ordinary arrays\n###\n\n.from_NaArray_to_array <- function(from)\n{\n    stopifnot(is(from, \"NaArray\"))\n    check_svt_version(from)\n    SparseArray.Call(\"C_from_SVT_SparseArray_to_Rarray\",\n                     from@dim, dimnames(from), from@type, from@NaSVT, TRUE)\n}\n\n### S3/S4 combo for as.array.NaArray\nas.array.NaArray <- function(x, ...) .from_NaArray_to_array(x)\nsetMethod(\"as.array\", \"NaArray\", as.array.NaArray)\n\n.build_NaArray_from_array <- function(x, dimnames=NULL, type=NA)\n{\n    stopifnot(is.array(x))\n    if (is.null(dimnames)) {\n        ans_dimnames <- dimnames(x)\n    } else {\n        ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim(x))\n    }\n    if (identical(type, NA))\n        type <- type(x)\n    ans_NaSVT <- SparseArray.Call(\"C_build_SVT_from_Rarray\", x, type, TRUE)\n    new_NaArray(dim(x), ans_dimnames, type, ans_NaSVT, check=FALSE)\n}\n\nsetAs(\"array\", \"NaArray\",\n    function(from) .build_NaArray_from_array(from)\n)\nsetAs(\"matrix\", \"NaMatrix\",\n    function(from) .build_NaArray_from_array(from)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### NaArray() constructor\n###\n\n.new_empty_NaArray <- function(type=NA)\n{\n    if (identical(type, NA))\n        type <- \"logical\"\n    new2(\"NaArray\", type=type, check=FALSE)\n}\n\n.NaArray <- function(x, dimnames=NULL, type=NA)\n{\n    if (is.array(x))\n        return(.build_NaArray_from_array(x, dimnames=dimnames, type=type))\n\n    ans <- as(x, \"NaArray\")\n    ans <- S4Arrays:::set_dimnames(ans, dimnames)\n    if (!identical(type, NA))\n        type(ans) <- type\n    ans\n}\n\nNaArray <- function(x, dim=NULL, dimnames=NULL, type=NA)\n{\n    if (!identical(type, NA))\n        type <- .normarg_NaArray_type(type, \"the requested type\")\n\n    if (is.null(dim)) {\n        if (missing(x))\n            return(.new_empty_NaArray(type))\n        return(.NaArray(x, dimnames=dimnames, type=type))\n    }\n\n    dim <- S4Arrays:::normarg_dim(dim)\n    ans <- new_NaArray(dim, dimnames=dimnames, check=FALSE)\n    if (!missing(x)) {\n        nnaidx <- nnawhich(x)\n        ans[nnaidx] <- as.vector(x[nnaidx])\n    }\n    if (!identical(type, NA))\n        type(ans) <- type\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### show()\n###\n\n.show_nnacount <- function(x)\n{\n    x_nnacount <- nnacount(x)\n    x_density <- x_nnacount / length(x)\n    sprintf(\"[nnacount=%s (%s%%)]\", format(x_nnacount),\n                                    signif(100 * x_density, digits=2))\n}\n\nsetMethod(\"show\", \"NaArray\",\n    function(object)\n    {\n        ## Only reason we print the headline in 2 steps is because we\n        ## want to make sure to print at least something (part1) even\n        ## when printing part2 is going to fail. This will happen for\n        ## example if the call to nnacount() in .show_nnacount() fails.\n        cat(show_headline_part1(object))\n        cat(.show_nnacount(object))\n        if (any(dim(object) == 0L)) {\n            cat(\"\\n\")\n            return()\n        }\n        cat(\":\\n\", sep=\"\")\n        S4Arrays:::print_some_array_elements(object)\n    }\n)\n\n",
        "NaArray-matrixStats.R": "### =========================================================================\n### matrixStats methods for NaMatrix and NaArray objects\n### -------------------------------------------------------------------------\n###\n### See notes at beginning of NaArray-matrixStats.R for matrixStats usage\n### in Bioconductor.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .colStats_NaArray() and .rowStats_NaArray()\n###\n### Workhorses behind all the matrixStats methods for NaArray objects, with\n### the exception of the colMedians()/rowMedians() methods at the moment.\n###\n\n### Returns an ordinary array with 'length(dim(x)) - dims' dimensions.\n.colStats_NaArray <- function(op, x, na.rm=FALSE, center=NULL, dims=1L,\n                              useNames=NA)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Normalize and check 'dims'.\n    dims <- normarg_dims(dims)\n    if (dims <= 0L || dims > length(x@dim))\n        stop(wmsg(\"'dims' must be a single integer that is \",\n                  \"> 0 and <= length(dim(x)) for the col*() functions, and \",\n                  \">= 0 and < length(dim(x)) for the row*() functions\"))\n\n    ## Check 'na.rm'.\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    ## Check and normalize 'center'.\n    if (is.null(center)) {\n        center <- NA_real_\n    } else {\n        if (!isSingleNumberOrNA(center))\n            stop(wmsg(\"'center' must be NULL or a single number\"))\n        if (!is.double(center))\n            center <- as.double(center)\n    }\n\n    ## Normalize 'useNames'.\n    useNames <- normarg_useNames(useNames)\n\n    x_dimnames <- if (useNames) x@dimnames else NULL\n    SparseArray.Call(\"C_colStats_SVT\",\n                     x@dim, x_dimnames, x@type, x@NaSVT, TRUE,\n                     op, na.rm, center, dims)\n}\n\n### Returns an ordinary array where the number of dimensions is 'dims'.\n.rowStats_NaArray <- function(op, x, na.rm=FALSE, center=NULL, dims=1L,\n                              useNames=NA)\n{\n    stopifnot(isSingleString(op), is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Normalize and check 'dims'.\n    dims <- normarg_dims(dims)\n    if (dims < 0L || dims >= length(x@dim))\n        stop(wmsg(\"'dims' must be a single integer that is \",\n                  \"> 0 and <= length(dim(x)) for the col*() functions, and \",\n                  \">= 0 and < length(dim(x)) for the row*() functions\"))\n\n    if (dims == 0L)\n        return(.colStats_NaArray(op, x, na.rm=na.rm, center=center,\n                                 dims=length(x@dim), useNames=useNames))\n\n    ## Check 'na.rm'.\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    ## Check and normalize 'center'.\n    if (!is.null(center)) {\n        ## Unlike for .colStats_NaArray() where 'center' can only be NULL\n        ## or a single number, here it can also be an ordinary numeric array\n        ## of the same dimensions as the result of .rowStats_NaArray()\n        ## (i.e. of dimensions 'head(dim(x), n=dims)'), or a numeric vector\n        ## of the same length as the result of .rowStats_NaArray().\n        if (!is.numeric(center))\n            stop(wmsg(\"'center' must be NULL, a single number, \",\n                      \"or an ordinary array\"))\n        ans_dim <- head(dim(x), n=dims)\n        if (is.array(center)) {\n            if (!identical(dim(center), ans_dim))\n                stop(wmsg(\"unexpected 'center' dimensions\"))\n            if (storage.mode(center) != \"double\")\n                storage.mode(center) <- \"double\"\n        } else if (length(center) %in% c(1L, prod(ans_dim))) {\n            center <- array(as.double(center), dim=ans_dim)\n        } else {\n            stop(wmsg(\"unexpected 'center' length\"))\n        }\n    }\n\n    ## Normalize 'useNames'.\n    useNames <- normarg_useNames(useNames)\n\n    x_dimnames <- if (useNames) x@dimnames else NULL\n    SparseArray.Call(\"C_rowStats_SVT\",\n                     x@dim, x_dimnames, x@type, x@NaSVT, TRUE,\n                     op, na.rm, center, dims)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colCountNAs/rowCountNAs\n###\n### Not part of the matrixStats API!\n\n.colCountNAs_NaArray <- function(x, dims=1, useNames=NA)\n{\n    .colStats_NaArray(\"countNAs\", x, dims=dims, useNames=useNames)\n}\n#setMethod(\"colCountNAs\", \"NaArray\", .colCountNAs_NaArray)\n\n.rowCountNAs_NaArray <- function(x, dims=1, useNames=NA)\n{\n    .rowStats_NaArray(\"countNAs\", x, dims=dims, useNames=useNames)\n}\n#setMethod(\"rowCountNAs\", \"NaArray\", .rowCountNAs_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .colCountVals_NaArray()/.rowCountVals_NaArray()\n###\n### Count the number of non-NA vals per column/row.\n###\n### Both functions return a single value if 'na.rm' is FALSE, or an unnamed\n### ordinary vector, matrix, or array if 'na.rm' is TRUE.\n\n.colCountVals_NaArray <- function(x, na.rm=FALSE, dims=1)\n{\n    stopifnot(is(x, \"NaArray\"))\n    dims <- normarg_dims(dims)\n    ans <- prod(head(dim(x), n=dims))\n    if (na.rm) {\n        count_nas <- .colCountNAs_NaArray(x, dims=dims, useNames=FALSE)\n        ans <- ans - count_nas\n    }\n    ans\n}\n\n.rowCountVals_NaArray <- function(x, na.rm=FALSE, dims=1)\n{\n    stopifnot(is(x, \"NaArray\"))\n    dims <- normarg_dims(dims)\n    ans <- prod(tail(dim(x), n=-dims))\n    if (na.rm) {\n        count_nas <- .rowCountNAs_NaArray(x, dims=dims, useNames=FALSE)\n        ans <- ans - count_nas\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colAnyNAs/rowAnyNAs\n###\n\n.colAnyNAs_NaArray <-\n    function(x, rows=NULL, cols=NULL, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colAnyNAs\", \"NaArray\")\n    .colStats_NaArray(\"anyNA\", x, dims=dims, useNames=useNames)\n}\nsetMethod(\"colAnyNAs\", \"NaArray\", .colAnyNAs_NaArray)\n\n.rowAnyNAs_NaArray <-\n    function(x, rows=NULL, cols=NULL, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowAnyNAs\", \"NaArray\")\n    .rowStats_NaArray(\"anyNA\", x, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowAnyNAs\", \"NaArray\", .rowAnyNAs_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colAnys/rowAnys and colAlls/rowAlls\n###\n\n.colAnys_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colAnys\", \"NaArray\")\n    .colStats_NaArray(\"any\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colAnys\", \"NaArray\", .colAnys_NaArray)\n\n.rowAnys_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowAnys\", \"NaArray\")\n    .rowStats_NaArray(\"any\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\n#setMethod(\"rowAnys\", \"NaArray\", .rowAnys_NaArray)\n\n.colAlls_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colAlls\", \"NaArray\")\n    .colStats_NaArray(\"all\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colAlls\", \"NaArray\", .colAlls_NaArray)\n\n.rowAlls_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowAlls\", \"NaArray\")\n    .rowStats_NaArray(\"all\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\n#setMethod(\"rowAlls\", \"NaArray\", .rowAlls_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colMins/rowMins, colMaxs/rowMaxs, and colRanges/rowRanges\n###\n\n.colMins_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colMins\", \"NaArray\")\n    .colStats_NaArray(\"min\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colMins\", \"NaArray\", .colMins_NaArray)\n\n.rowMins_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowMins\", \"NaArray\")\n    .rowStats_NaArray(\"min\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowMins\", \"NaArray\", .rowMins_NaArray)\n\n.colMaxs_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colMaxs\", \"NaArray\")\n    .colStats_NaArray(\"max\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colMaxs\", \"NaArray\", .colMaxs_NaArray)\n\n.rowMaxs_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowMaxs\", \"NaArray\")\n    .rowStats_NaArray(\"max\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowMaxs\", \"NaArray\", .rowMaxs_NaArray)\n\n.bind_mins_maxs <- function(mins, maxs, just.use.c)\n{\n    ## Bind 'mins' and 'maxs' together.\n    if (just.use.c)\n        return(c(mins, maxs))\n    if (is.null(dim(mins))) {\n        ans <- cbind(mins, maxs, deparse.level=0L)\n        dimnames(ans) <- S4Arrays:::simplify_NULL_dimnames(dimnames(ans))\n        return(ans)\n    }\n    ans_dimnames <- dimnames(mins)\n    dim(mins) <- c(dim(mins), 1L)\n    dim(maxs) <- c(dim(maxs), 1L)\n    ans <- S4Arrays:::simple_abind(mins, maxs, along=length(dim(mins)))\n    S4Arrays:::set_dimnames(ans, ans_dimnames)\n}\n\n.colRanges_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colRanges\", \"NaArray\")\n    ## Using two passes at the moment and binding the two results in R.\n    ## TODO: Do all this in a single pass by calling\n    ## '.colStats_NaArray(\"range\", ...)' and modifying .Call ENTRY POINT\n    ## C_colStats_SVT to perform the binding from the very start at the C level.\n    mins <- .colStats_NaArray(\"min\", x, na.rm=na.rm, dims=dims,\n                                         useNames=useNames)\n    maxs <- .colStats_NaArray(\"max\", x, na.rm=na.rm, dims=dims,\n                                         useNames=FALSE)\n    .bind_mins_maxs(mins, maxs, dims == length(dim(x)))\n}\nsetMethod(\"colRanges\", \"NaArray\", .colRanges_NaArray)\n\n.rowRanges_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowRanges\", \"NaArray\")\n    ## Using two passes at the moment and binding the two results in R.\n    ## TODO: Do all this in a single pass by calling\n    ## '.rowStats_NaArray(\"range\", ...)' and modifying .Call ENTRY POINT\n    ## C_colStats_SVT to perform the binding from the very start at the C level.\n    mins <- .rowStats_NaArray(\"min\", x, na.rm=na.rm, dims=dims,\n                                         useNames=useNames)\n    maxs <- .rowStats_NaArray(\"max\", x, na.rm=na.rm, dims=dims,\n                                         useNames=FALSE)\n    .bind_mins_maxs(mins, maxs, dims == 0L)\n}\nsetMethod(\"rowRanges\", \"NaArray\", .rowRanges_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colSums/rowSums, colProds/rowProds, and colMeans/rowMeans\n###\n### The colSums/rowSums/colMeans/rowMeans functions in base R propagate the\n### dimnames so we do the same.\n\n.colSums_NaArray <- function(x, na.rm=FALSE, dims=1)\n{\n    .colStats_NaArray(\"sum\", x, na.rm=na.rm, dims=dims)\n}\nsetMethod(\"colSums\", \"NaArray\", .colSums_NaArray)\n\n.rowSums_NaArray <- function(x, na.rm=FALSE, dims=1)\n{\n    .rowStats_NaArray(\"sum\", x, na.rm=na.rm, dims=dims)\n}\nsetMethod(\"rowSums\", \"NaArray\", .rowSums_NaArray)\n\n.colProds_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colProds\", \"NaArray\")\n    .colStats_NaArray(\"prod\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colProds\", \"NaArray\", .colProds_NaArray)\n\n.rowProds_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowProds\", \"NaArray\")\n    .rowStats_NaArray(\"prod\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\n#setMethod(\"rowProds\", \"NaArray\", .rowProds_NaArray)\n\n.colMeans_NaArray <- function(x, na.rm=FALSE, dims=1)\n{\n    .colStats_NaArray(\"mean\", x, na.rm=na.rm, dims=dims)\n}\nsetMethod(\"colMeans\", \"NaArray\", .colMeans_NaArray)\n\n.rowMeans_NaArray <- function(x, na.rm=FALSE, dims=1)\n{\n    sums <- .rowSums_NaArray(x, na.rm=na.rm, dims=dims)\n    nvals <- .rowCountVals_NaArray(x, na.rm=na.rm, dims=dims)\n    sums / nvals\n}\n#setMethod(\"rowMeans\", \"NaArray\", .rowMeans_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colSums2/rowSums2 and colMeans2/rowMeans2\n###\n\n.colSums2_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colSums2\", \"NaArray\")\n    .colStats_NaArray(\"sum\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colSums2\", \"NaArray\", .colSums2_NaArray)\n\n.rowSums2_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowSums2\", \"NaArray\")\n    .rowStats_NaArray(\"sum\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowSums2\", \"NaArray\", .rowSums2_NaArray)\n\n.colMeans2_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colMeans2\", \"NaArray\")\n    .colStats_NaArray(\"mean\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colMeans2\", \"NaArray\", .colMeans2_NaArray)\n\n.rowMeans2_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowMeans2\", \"NaArray\")\n    .rowStats_NaArray(\"mean\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\n#setMethod(\"rowMeans2\", \"NaArray\", .rowMeans2_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colVars/rowVars and colSds/rowSds\n###\n\n### Equivalent to 'var(c(x, integer(padding)), ...)' but doesn't actually\n### realize the padding with zeros.\n.padded_var <- function(x, padding=0L, na.rm=FALSE, center=NULL)\n{\n    if (na.rm)\n        x <- x[!is.na(x)]\n    nvals <- length(x) + padding\n    if (nvals <= 1L)\n        return(NA_real_)\n    if (is.null(center)) {\n        center <- sum(x) / nvals\n    } else {\n        stopifnot(isSingleNumberOrNA(center))\n    }\n    delta <- x - center\n    s <- sum(delta * delta) + center * center * padding\n    s / (nvals - 1L)\n}\n\n### Returns a numeric vector of length 'ncol(x)'.\n.normarg_center <- function(center, x, na.rm=FALSE)\n{\n    if (is.null(center))\n        return(colMeans(x, na.rm=na.rm))\n    if (!is.numeric(center))\n        stop(wmsg(\"'center' must be NULL or a numeric vector\"))\n    x_ncol <- ncol(x)\n    if (length(center) != x_ncol) {\n        if (length(center) != 1L)\n            stop(wmsg(\"'center' must have one element per row \",\n                      \"or column in the SparseMatrix object\"))\n        center <- rep.int(center, x_ncol)\n    }\n    center\n}\n\n.colVars_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colVars\", \"NaArray\")\n    .colStats_NaArray(\"var1\", x, na.rm=na.rm, center=center,\n                                  dims=dims, useNames=useNames)\n}\nsetMethod(\"colVars\", \"NaArray\", .colVars_NaArray)\n\n.rowVars_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowVars\", \"NaArray\")\n    nvals <- .rowCountVals_NaArray(x, na.rm=na.rm, dims=dims)\n    if (is.null(center)) {\n        sums <- .rowSums_NaArray(x, na.rm=na.rm, dims=dims)\n        center <- sums / nvals\n    }\n    centered_X2_sums <- .rowStats_NaArray(\"centered_X2_sum\",\n                                              x, na.rm=na.rm, center=center,\n                                              dims=dims, useNames=useNames)\n    centered_X2_sums / (nvals - 1)\n}\n#setMethod(\"rowVars\", \"NaArray\", .rowVars_NaArray)\n\n.colSds_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colSds\", \"NaArray\")\n    .colStats_NaArray(\"sd1\", x, na.rm=na.rm, center=center,\n                                 dims=dims, useNames=useNames)\n}\nsetMethod(\"colSds\", \"NaArray\", .colSds_NaArray)\n\n.rowSds_NaArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowSds\", \"NaArray\")\n    row_vars <- .rowVars_NaArray(x, na.rm=na.rm, center=center,\n                                     dims=dims, useNames=useNames)\n    sqrt(row_vars)\n}\n#setMethod(\"rowSds\", \"NaArray\", .rowSds_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colMedians/rowMedians\n###\n### TODO: How hard would it be to replace current \"pure R\" implementation\n### with C implementation available thru .Call ENTRY POINT C_colStats_SVT ?\n\n### All values in 'x' are **assumed** to be >= 0 but we don't check this!\n### 'padding' is expected to be < length(x).\n.positive_padded_median <- function(x, padding=0L)\n{\n    x_len <- length(x)\n    stopifnot(padding < x_len)\n    n <- x_len + padding\n    if (n %% 2L == 1L) {\n        middle <- (n + 1L) %/% 2L\n        partial <- middle - padding\n        return(sort(x, partial=partial)[partial])\n    }\n    i1 <- n %/% 2L - padding\n    i2 <- i1 + 1L\n    mean(sort(x, partial=i2)[i1:i2])\n}\n\n### Equivalent to 'median(c(x, integer(padding)), ...)' but doesn't actually\n### realize the padding with zeros.\n.padded_median <- function(x, padding=0L, na.rm=FALSE)\n{\n    if (na.rm) {\n        x <- x[!is.na(x)]\n    } else {\n        if (anyNA(x))\n            return(NA_real_)\n    }\n    n <- length(x) + padding\n    if (n == 0L)\n        return(NA_real_)\n    if (padding > length(x))\n        return(0)\n\n    ## Handle case where we have more positive values than non-positive values.\n    pos_idx <- which(x > 0L)\n    pos_count <- length(pos_idx)\n    nonpos_count <- n - pos_count\n    if (pos_count > nonpos_count) {\n        ans <- .positive_padded_median(x[pos_idx], padding=nonpos_count)\n        return(ans)\n    }\n\n    ## Handle case where we have more negative values than non-negative values.\n    neg_count <- length(x) - pos_count\n    nonneg_count <- n - neg_count\n    if (neg_count > nonneg_count) {\n        ans <- - .positive_padded_median(-x[-pos_idx], padding=nonneg_count)\n        return(ans)\n    }\n\n    if (n %% 2L == 1L)\n        return(0)\n\n    half <- n %/% 2L\n    if (pos_count == half) {\n        right <- min(x[pos_idx])\n    } else {\n        right <- 0\n    }\n    if (neg_count == half) {\n        left <- max(x[-pos_idx])\n    } else {\n        left <- 0\n    }\n    (left + right) * 0.5\n}\n\n.colMedians_NaMatrix <- function(x, na.rm=FALSE, useNames=NA)\n{\n    stopifnot(is(x, \"NaMatrix\"))\n    check_svt_version(x)\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    useNames <- normarg_useNames(useNames)\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    if (x_nrow == 0L) {\n        ans <- rep.int(NA_real_, x_ncol)\n    } else {\n        ans <- numeric(x_ncol)\n        if (!is.null(x@NaSVT)) {\n            ans <- vapply(seq_along(x@NaSVT),\n                function(i) {\n                    lv <- x@NaSVT[[i]]\n                    if (is.null(lv))\n                        return(ans[[i]])\n                    lv_vals <- lv[[2L]]\n                    padding <- x_nrow - length(lv_vals)\n                    .padded_median(lv_vals, padding, na.rm=na.rm)\n                }, numeric(1), USE.NAMES=FALSE)\n        }\n    }\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\n#setMethod(\"colMedians\", \"NaArray\",\n#    function(x, rows=NULL, cols=NULL, na.rm=FALSE, ..., useNames=NA)\n#    {\n#        check_unused_arguments(...)\n#        stopifnot_2D_object(x, \"colMedians\", \"NaArray\", \"NaMatrix\")\n#        check_rows_cols(rows, cols, \"colMedians\", \"NaArray\")\n#        .colMedians_NaMatrix(x, na.rm=na.rm, useNames=useNames)\n#    }\n#)\n\n#setMethod(\"rowMedians\", \"NaArray\",\n#    function(x, rows=NULL, cols=NULL, na.rm=FALSE, ..., useNames=NA)\n#    {\n#        check_unused_arguments(...)\n#        stopifnot_2D_object(x, \"rowMedians\", \"NaArray\", \"NaMatrix\")\n#        check_rows_cols(rows, cols, \"rowMedians\", \"NaArray\")\n#        tx <- t(x)\n#        .colMedians_NaMatrix(tx, na.rm=na.rm, useNames=useNames, ...)\n#    }\n#)\n\n",
        "NaArray-misc-methods.R": "### =========================================================================\n### Miscellaneous operations on NaArray objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Various \"unary isometric\" array transformations\n###\n### A \"unary isometric\" array transformation is a transformation that returns\n### an array-like object with the same dimensions as the input and where each\n### element is the result of applying a function to the corresponding element\n### in the input.\n###\n### Note that:\n### - Some \"unary isometric\" transformations preserve sparsity when applied\n###   to an NaArray object (e.g. is.nan(), is.finite(), nchar(), etc...) and\n###   others don't (e.g. is.na()). NaArray objects only need to support the\n###   former.\n### - All operations from the 'Math' and 'Math2' groups are \"unary isometric\"\n###   transformations (see '?S4groupGeneric'). The corresponding methods for\n###   NaArray objects are implemented in R/NaArray-Math-methods.R\n### - All the \"unary isometric\" methods implemented below return an array-like\n###   object of the same class as the input (endomorphism).\n\n### Returns a \"logical\" **SVT_SparseArray** object!\n.isFUN_NaSVT <- function(isFUN, x)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n    ans_SVT <- SparseArray.Call(\"C_SVT_apply_isFUN\",\n                                x@dim, x@type, x@NaSVT, isFUN)\n    new_SVT_SparseArray(x@dim, x@dimnames, \"logical\", ans_SVT, check=FALSE)\n}\n\nsetMethod(\"is.na\", \"NaArray\",\n    function(x) stop(wmsg(\"is.na() is not supported on NaArray objects \",\n                          \"(result wouldn't be sparse in general). Maybe \",\n                          \"try is_nonna() instead (see '?is_nonna').\"))\n)\nsetMethod(\"is.nan\", \"NaArray\",\n    function(x) .isFUN_NaSVT(\"is.nan\", x)\n)\nsetMethod(\"is.infinite\", \"NaArray\",\n    function(x) .isFUN_NaSVT(\"is.infinite\", x)\n)\n\n### TODO: Support more methods!\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Various \"N-ary isometric\" array transformations\n###\n### An \"N-ary isometric\" array transformation is a transformation that takes\n### one or more array-like objects of the same dimensions (a.k.a. conformable\n### arrays) and returns an array-like object of the same dimensions.\n###\n\n### COMING SOON...\n\n",
        "NaArray-subassignment.R": "### =========================================================================\n### NaArray subassignment\n### -------------------------------------------------------------------------\n###\n\n\n.subassign_NaSVT_by_Lindex <- function(x, Lindex, value)\n{\n    x <- adjust_left_type(x, value)\n    stopifnot(is.vector(Lindex), is.numeric(Lindex))\n\n    ## No-op (except for type adjustment above) if selection is empty.\n    if (length(Lindex) == 0L)\n        return(x)\n\n    value <- .normalize_right_value(value, type(x), length(Lindex))\n\n    new_NaSVT <- SparseArray.Call(\"C_subassign_SVT_by_Lindex\",\n                                  x@dim, x@type, x@NaSVT, TRUE, Lindex, value)\n    BiocGenerics:::replaceSlots(x, NaSVT=new_NaSVT, check=FALSE)\n}\n\nsetMethod(\"subassign_Array_by_Lindex\", \"NaArray\",\n    function(x, Lindex, value) .subassign_NaSVT_by_Lindex(x, Lindex, value)\n)\n\n",
        "NaArray-subsetting.R": "### =========================================================================\n### NaArray subsetting\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### tune_Array_dims() method NaArray objects\n###\n### This is the workhorse behind drop() and dim<-() on NaArray objects.\n###\n### Unlike with S4Arrays:::tune_dims() and S4Arrays:::tune_dimnames(),\n### the 'dim_tuner' vector passed to .tune_NaArray_dims() must be\n### normalized. See src/SparseArray_dim_tuning.c for more information.\n\n.tune_NaArray_dims <- function(x, dim_tuner)\n{\n    stopifnot(is(x, \"NaArray\"), is.integer(dim_tuner))\n    check_svt_version(x)\n\n    ans_NaSVT <- SparseArray.Call(\"C_tune_SVT_dims\",\n                                  x@dim, x@type, x@NaSVT, dim_tuner)\n    ans_dim <- S4Arrays:::tune_dims(x@dim, dim_tuner)\n    ans_dimnames <- S4Arrays:::tune_dimnames(x@dimnames, dim_tuner)\n\n    new_NaArray(ans_dim, ans_dimnames, x@type, ans_NaSVT, check=FALSE)\n}\n\nsetMethod(\"tune_Array_dims\", \"NaArray\", .tune_NaArray_dims)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .subset_NaSVT_by_Lindex()\n### .subset_NaSVT_by_Mindex()\n###\n### Both return a vector (atomic or list) of the same type() as 'x'.\n###\n\n### 'Lindex' must be a numeric vector (integer or double), possibly a long one.\n### NA indices are accepted.\n.subset_NaSVT_by_Lindex <- function(x, Lindex)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n    stopifnot(is.vector(Lindex), is.numeric(Lindex))\n    on.exit(free_global_OPBufTree())\n    ans <- SparseArray.Call(\"C_subset_SVT_by_Lindex\",\n                            x@dim, x@type, x@NaSVT, TRUE, Lindex)\n    propagate_names_if_1D(ans, dimnames(x), Lindex)\n}\n\nsetMethod(\"subset_Array_by_Lindex\", \"NaArray\", .subset_NaSVT_by_Lindex)\n\n### Alright, '.subset_NaSVT_by_Mindex(x, Mindex)' could just have done:\n###\n###     .subset_NaSVT_by_Lindex(x, Mindex2Lindex(Mindex, dim(x)))\n###\n### However, the C code in C_subset_NaSVT_by_Mindex() avoids the Mindex2Lindex()\n### step and so should be slightly more efficient, at least in theory. But is\n### it? Some quick testing suggests that there's actually no significant\n### difference!\n### TODO: Investigate this more.\n.subset_NaSVT_by_Mindex <- function(x, Mindex)\n{\n    stopifnot(is(x, \"NaArray\"))\n    check_svt_version(x)\n    stopifnot(is.matrix(Mindex))\n    x_dimnames <- dimnames(x)\n    if (!is.numeric(Mindex)) {\n        if (!is.character(Mindex))\n            stop(wmsg(\"invalid matrix subscript type \\\"\", type(Mindex), \"\\\"\"))\n        if (is.null(x_dimnames))\n            stop(wmsg(\"NaArray object to subset has no dimnames\"))\n        ## Subsetting an ordinary array with dimnames on it by a character\n        ## matrix is supported in base R but we don't support this yet for\n        ## NaArray objects.\n        stop(\"subsetting an NaArray object by a character matrix \",\n             \"is not supported at the moment\")\n    }\n    on.exit(free_global_OPBufTree())\n    ans <- SparseArray.Call(\"C_subset_SVT_by_Mindex\",\n                            x@dim, x@type, x@NaSVT, TRUE, Mindex)\n    propagate_names_if_1D(ans, x_dimnames, Mindex)\n}\n\nsetMethod(\"subset_Array_by_Mindex\", \"NaArray\", .subset_NaSVT_by_Mindex)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### subset_NaSVT_by_Nindex()\n###\n### In addition to being one of the workhorses behind `[` on an\n### NaArray object (see below), this is **the** workhorse behind the\n### extract_na_array() and extract_array() methods for NaArray objects.\n###\n### 'Nindex' must be an N-index, that is, a list of numeric vectors (or NULLs),\n### one along each dimension in the array to subset. Note that, strictly\n### speaking, the vectors in an N-index are expected to be integer vectors,\n### but subset_NaSVT_by_Nindex() can handle subscripts of type \"double\".\n### This differs from the 'index' argument in 'extract_array()' where the\n### subscripts **must** be integer vectors.\n###\n### Returns an NaArray object of the same type() as 'x' (endomorphism).\n\nsubset_NaSVT_by_Nindex <- function(x, Nindex, ignore.dimnames=FALSE)\n{\n    stopifnot(is(x, \"NaArray\"),\n              is.list(Nindex),\n              length(Nindex) == length(x@dim),\n              isTRUEorFALSE(ignore.dimnames))\n    check_svt_version(x)\n\n    ## Returns 'new_dim' and 'new_NaSVT' in a list of length 2.\n    C_ans <- SparseArray.Call(\"C_subset_SVT_by_Nindex\",\n                              x@dim, x@type, x@NaSVT, Nindex)\n    new_dim <- C_ans[[1L]]\n    new_NaSVT <- C_ans[[2L]]\n\n    ## Compute 'new_dimnames'.\n    if (is.null(dimnames(x)) || ignore.dimnames) {\n        new_dimnames <- vector(\"list\", length(x@dim))\n    } else {\n        new_dimnames <- S4Arrays:::subset_dimnames_by_Nindex(x@dimnames, Nindex)\n    }\n    BiocGenerics:::replaceSlots(x, dim=new_dim,\n                                   dimnames=new_dimnames,\n                                   NaSVT=new_NaSVT,\n                                   check=FALSE)\n}\n\nsetMethod(\"subset_Array_by_Nindex\", \"NaArray\",\n    function(x, Nindex) subset_NaSVT_by_Nindex(x, Nindex)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_na_array() and extract_array() methods for NaArray objects\n###\n\nsetGeneric(\"extract_na_array\", signature=\"x\",\n    function(x, index) standardGeneric(\"extract_na_array\")\n)\n\n### No need to propagate the dimnames.\nsetMethod(\"extract_na_array\", \"NaArray\",\n    function(x, index) subset_NaSVT_by_Nindex(x, index, ignore.dimnames=TRUE)\n)\n\n### Note that the default extract_array() method would do the job but it\n### relies on single-bracket subsetting so would needlessly go thru the\n### complex .subset_NaArray() machinery above to finally call\n### subset_NaSVT_by_Nindex(). It would also propagate the dimnames which\n### extract_array() does not need to do. The method below completely bypasses\n### all this complexity by calling subset_NaSVT_by_Nindex() directly.\nsetMethod(\"extract_array\", \"NaArray\",\n    function(x, index)\n        as.array(subset_NaSVT_by_Nindex(x, index, ignore.dimnames=TRUE))\n)\n\n",
        "NaArray-summarization.R": "### =========================================================================\n### Summarization methods for NaArray objects\n### -------------------------------------------------------------------------\n###\n### Summarization methods:\n###   - anyNA()\n###   - 'Summary' group: any(), all(), min(), max(), range(), sum(), prod()\n###   - mean()\n###   - Unary var(), sd()\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### anyNA(), countNAs()\n###\n\n.anyNA_NaArray <- function(x, recursive=FALSE)\n{\n    if (!identical(recursive, FALSE))\n        stop(wmsg(\"the anyNA() method for NaArray objects \",\n                  \"does not support the 'recursive' argument\"))\n\n    summarize_SVT(\"anyNA\", x)\n}\nsetMethod(\"anyNA\", \"NaArray\", .anyNA_NaArray)\n\n### NOT USED! There's no countNAs() generic yet!\n### TODO: Define the countNAs() in BiocGenerics, and the colCountNAs() and\n### rowCountNAs() generics in MatrixGenerics.\n.countNAs_NaArray <- function(x, recursive=FALSE)\n{\n    if (!identical(recursive, FALSE))\n        stop(wmsg(\"the countNAs() method for NaArray objects \",\n                  \"does not support the 'recursive' argument\"))\n\n    summarize_SVT(\"countNAs\", x)\n}\n#setMethod(\"countNAs\", \"NaArray\", .countNAs_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Summary' group\n###\n\nsetMethod(\"Summary\", \"NaArray\",\n    function(x, ..., na.rm=FALSE)\n    {\n        if (length(list(...)) != 0L)\n            stop(wmsg(\"the \", .Generic, \"() method for NaArray \",\n                      \"objects only accepts a single object\"))\n        summarize_SVT(.Generic, x, na.rm=na.rm)\n    }\n)\n\n### We override the range() methods defined via the Summary() methods\n### above because we want to support the 'finite' argument like S3 method\n### base::range.default() does. One might wonder why base::range.default()\n### supports the 'finite' argument but min() and max() don't. Or more\n### precisely, they seem to take it but they don't do exactly the same thing\n### with it:\n###\n###     > max(c(0, -Inf), finite=TRUE)\n###     [1] 1\n###\n### Another story for another day...\n\n### S3/S4 combo for range.NaArray\nrange.NaArray <- function(..., na.rm=FALSE, finite=FALSE)\n{\n    if (!identical(finite, FALSE))\n        stop(wmsg(\"the range() method for NaArray objects \",\n                  \"does not support the 'finite' argument\"))\n    objects <- list(...)\n    if (length(objects) != 1L)\n        stop(wmsg(\"the range() method for NaArray objects \",\n                  \"only accepts a single object\"))\n    x <- objects[[1L]]\n    summarize_SVT(\"range\", x, na.rm=na.rm)\n}\n### The signature of all the members in the 'Summary' group generic is\n### 'x, ..., na.rm' (see getGeneric(\"range\")) which means that methods\n### cannot add arguments after 'na.rm'. So we add the 'finite' argument\n### before.\nsetMethod(\"range\", \"NaArray\",\n    function(x, ..., finite=FALSE, na.rm=FALSE)\n        range.NaArray(x, ..., na.rm=na.rm, finite=finite)\n\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### mean()\n###\n\n.mean_NaArray <- function(x, na.rm=FALSE)\n{\n    summarize_SVT(\"mean\", x, na.rm=na.rm)\n}\n\n### S3/S4 combo for mean.NaArray\nmean.NaArray <- function(x, na.rm=FALSE, ...)\n    .mean_NaArray(x, na.rm=na.rm, ...)\nsetMethod(\"mean\", \"NaArray\", .mean_NaArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### var(), sd()\n###\n\nsetMethod(\"var\", c(\"NaArray\", \"ANY\"),\n    function(x, y=NULL, na.rm=FALSE, use)\n    {\n        if (!is.null(y))\n            stop(wmsg(\"the var() method for NaArray objects \",\n                      \"does not support the 'y' argument\"))\n        if (!missing(use))\n            stop(wmsg(\"the var() method for NaArray objects \",\n                      \"does not support the 'use' argument\"))\n        summarize_SVT(\"var1\", x, na.rm=na.rm)\n    }\n)\n\nsetMethod(\"sd\", \"NaArray\",\n    function(x, na.rm=FALSE) summarize_SVT(\"sd1\", x, na.rm=na.rm)\n)\n\n",
        "OPBufTree.R": "\nfree_global_OPBufTree <- function()\n    invisible(.Call2(\"C_free_global_OPBufTree\", PACKAGE=\"SparseArray\"))\n\n",
        "SVT_SparseArray-class.R": "### =========================================================================\n### SVT_SparseArray objects\n### -------------------------------------------------------------------------\n###\n### Use SVT layout to store the sparse data.\n###\n### An SVT_SparseArray object stores its nonzero data in a \"Sparse Vector\n### Tree\" (SVT).\n###\n### If the sparse array is empty (i.e. has no nonzero data), the 'SVT' slot\n### must be set to NULL.\n###\n### IMPORTANT NOTES:\n### - All the \"leaf vectors\" in the SVT are guaranteed to have a\n###   length <= the first dimension of the SVT_SparseArray object, which\n###   itself is guaranteed to be <= INT_MAX (2^31 - 1).\n### - The cumulated length of the \"leaf vectors\" in the SVT is the number\n###   of nonzero elements (i.e. nzcount) in the SVT_SparseArray object.\n###   There is no upper limit to this number.\n###   In other words, unlike *gCMatrix objects where this number is\n###   limited to INT_MAX, an SVT_SparseArray can store an arbitrary number\n###   of nonzero elements.\n###\n\nsetClassUnion(\"NULL_OR_list\", c(\"NULL\", \"list\"))\n\nSVT_VERSION <- 1L\n\nsetClass(\"SVT_SparseArray\",\n    contains=\"SparseArray\",\n    representation(\n        type=\"character\",\n        SVT=\"NULL_OR_list\",  # NULL or Sparse Vector Tree (SVT)\n        .svt_version=\"integer\"\n    ),\n    prototype(\n        type=\"logical\",\n        .svt_version=SVT_VERSION\n    )\n)\n\nsetClass(\"SVT_SparseMatrix\",\n    contains=c(\"SVT_SparseArray\", \"SparseMatrix\"),\n    prototype=prototype(\n        dim=c(0L, 0L),\n        dimnames=list(NULL, NULL)\n    )\n)\n\n### Not exported (for internal use only).\nsvt_version <- function(x)\n{\n    stopifnot(is(x, \"SVT_SparseArray\") || is(x, \"NaArray\"))\n    if (.hasSlot(x, \".svt_version\")) x@.svt_version else 0L\n}\n\ncheck_svt_version <- function(x)\n{\n    if (svt_version(x) != 0L ||\n        is(x, \"SVT_SparseArray\") && is.null(x@SVT) ||\n        is(x, \"NaArray\") && is.null(x@NaSVT))\n    {\n        return(invisible(NULL))\n    }\n    pkg_version <- as.character(packageVersion(\"SparseArray\"))\n    stop(wmsg(\"Old \", class(x)[[1L]], \" object detected: object uses \",\n              \"version 0 of the SVT internal layout which is not \",\n              \"compatible with versions >= 1.5.0 of the SparseArray \",\n              \"package (your version is \", pkg_version, \").\"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Validity\n###\n\n.validate_SVT_SparseArray <- function(x)\n{\n    if (!isSingleString(x@type))\n        return(\"'type' slot must be a single string\")\n    TRUE\n}\nsetValidity2(\"SVT_SparseArray\", .validate_SVT_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between SVT_SparseArray and SVT_SparseMatrix\n###\n\n### --- From SVT_SparseArray to SVT_SparseMatrix ---\n\n### The user should NOT be able to promote an SVT_SparseArray object to\n### SVT_SparseMatrix. Problem is that the automatic coercion method from\n### SVT_SparseArray to SVT_SparseMatrix silently returns a broken object\n### (unfortunately these dummy automatic coercion methods don't bother to\n### validate the object they return). So we overwrite it with a method that\n### will fail (as expected) thanks to the validity method for SparseMatrix\n### objects.\nsetAs(\"SVT_SparseArray\", \"SVT_SparseMatrix\",\n    function(from) new(\"SVT_SparseMatrix\", from)\n)\n\n### --- From SVT_SparseMatrix to SVT_SparseArray ---\n\n### The user should NOT be able to demote an SVT_SparseMatrix object to\n### SVT_SparseArray, so 'as(x, \"SVT_SparseArray\")' and 'as(x, \"SparseArray\")'\n### should fail or do nothing when 'x' is an SVT_SparseMatrix object, even\n### when called with 'strict=TRUE'. Making these coercions behave like no-ops\n### seems to be the easiest (and safest) way to go.\n\nsetAs(\"SVT_SparseMatrix\", \"SVT_SparseArray\", function(from) from)  # no-op\n\n### Do NOT use setAs() here! setAs() does really bad things if used to define\n### this coercion method e.g. for some reason it calls setIs() internally to\n### make SVT_SparseMatrix a **direct** extension of SparseArray, thus\n### altering (and breaking) our class hierarchy. This is not only conceptually\n### wrong but it also seems to break dispatch e.g. calling 'show(x)' on\n### SVT_SparseMatrix object 'x' does not find the method for SparseArray\n### objects despite 'is(x, \"SparseArray\")' being TRUE.\n### Worst part is that this seems to be a \"feature\" (apparently setAs() tries\n### to be really smart here!) but it's just a big mess.\nsetMethod(\"coerce\", c(\"SVT_SparseMatrix\", \"SparseArray\"),\n    function(from, to, strict=TRUE) from  # no-op\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### type() getter and setter\n###\n\nsetMethod(\"type\", \"SVT_SparseArray\", function(x) x@type)\n\n.set_SVT_SparseArray_type <- function(x, value)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n\n    value <- S4Arrays:::normarg_array_type(value, \"the supplied type\")\n    x_type <- type(x)\n    if (value == x_type)\n        return(x)\n\n    new_SVT <- SparseArray.Call(\"C_set_SVT_type\",\n                                x@dim, x@type, x@SVT, FALSE, value)\n    BiocGenerics:::replaceSlots(x, type=value, SVT=new_SVT, check=FALSE)\n}\n\nsetReplaceMethod(\"type\", \"SVT_SparseArray\", .set_SVT_SparseArray_type)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_nonzero(), nzcount(), nzwhich(), nzvals(), `nzvals<-`()\n###\n\n### Returns a \"logical\" SVT_SparseArray object.\n.is_nonzero_SVT <- function(x)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    new_SVT <- SparseArray.Call(\"C_is_nonzero_SVT\", x@dim, x@SVT)\n    BiocGenerics:::replaceSlots(x, type=\"logical\", SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"is_nonzero\", \"SVT_SparseArray\", .is_nonzero_SVT)\n\n### Note that like for the length of atomic vectors in base R, the \"nonzero\n### count\" will be returned as a double if it's > .Machine$integer.max\n.nzcount_SVT <- function(x)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    SparseArray.Call(\"C_nzcount_SVT\", x@dim, x@SVT)\n}\n\nsetMethod(\"nzcount\", \"SVT_SparseArray\", .nzcount_SVT)\n\n### Returns an integer vector of length nzcount(x) if 'arr.ind=FALSE', or\n### a matrix with nzcount(x) rows if 'arr.ind=TRUE'.\n.nzwhich_SVT <- function(x, arr.ind=FALSE)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    SparseArray.Call(\"C_nzwhich_SVT\", x@dim, x@SVT, arr.ind)\n}\n\nsetMethod(\"nzwhich\", \"SVT_SparseArray\", .nzwhich_SVT)\n\n### TODO: Implement optimized nzvals() and `nzvals<-`() methods for\n### SVT_SparseArray objects.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level constructor\n###\n\nnew_SVT_SparseArray <- function(dim, dimnames=NULL,\n                                type=\"logical\", SVT=NULL, check=TRUE)\n{\n    stopifnot(is.integer(dim))\n    if (length(dim) == 2L) {\n        ans_class <- \"SVT_SparseMatrix\"\n    } else {\n        ans_class <- \"SVT_SparseArray\"\n    }\n    dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    new2(ans_class, dim=dim, dimnames=dimnames,\n                    type=type, SVT=SVT, check=check)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between SVT_SparseArray objects and ordinary arrays\n###\n\n.from_SVT_SparseArray_to_array <- function(from)\n{\n    stopifnot(is(from, \"SVT_SparseArray\"))\n    check_svt_version(from)\n    SparseArray.Call(\"C_from_SVT_SparseArray_to_Rarray\",\n                     from@dim, dimnames(from), from@type, from@SVT, FALSE)\n}\n\n### S3/S4 combo for as.array.SVT_SparseArray\nas.array.SVT_SparseArray <- function(x, ...) .from_SVT_SparseArray_to_array(x)\nsetMethod(\"as.array\", \"SVT_SparseArray\", as.array.SVT_SparseArray)\n\n.build_SVT_SparseArray_from_array <- function(x, dimnames=NULL, type=NA)\n{\n    stopifnot(is.array(x))\n    if (is.null(dimnames)) {\n        ans_dimnames <- dimnames(x)\n    } else {\n        ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim(x))\n    }\n    if (identical(type, NA))\n        type <- type(x)\n    ans_SVT <- SparseArray.Call(\"C_build_SVT_from_Rarray\", x, type, FALSE)\n    new_SVT_SparseArray(dim(x), ans_dimnames, type, ans_SVT, check=FALSE)\n}\n\nsetAs(\"array\", \"SVT_SparseArray\",\n    function(from) .build_SVT_SparseArray_from_array(from)\n)\nsetAs(\"array\", \"SparseArray\",\n    function(from) .build_SVT_SparseArray_from_array(from)\n)\nsetAs(\"matrix\", \"SVT_SparseMatrix\",\n    function(from) .build_SVT_SparseArray_from_array(from)\n)\nsetAs(\"matrix\", \"SparseMatrix\",\n    function(from) .build_SVT_SparseArray_from_array(from)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Make an SVT_SparseMatrix object from CSC components\n###\n\n### NOT exported but used in the HDF5Array package!\n### 'row_indices' must be an integer vector containing 0-based or 1-based\n### row indices. Note that the indices in 'row_indices' are not required\n### to be increasing within columns. However, 'row_indices' should NOT\n### contain duplicates within columns. This is NOT checked!\nmake_SVT_SparseMatrix_from_CSC <- function(dim, indptr, data, row_indices,\n                                           indices.are.1based=FALSE,\n                                           dimnames=NULL)\n{\n    stopifnot(is.integer(row_indices), isTRUEorFALSE(indices.are.1based))\n    ans_SVT <- SparseArray.Call(\"C_build_SVT_from_CSC\",\n                                dim, indptr, data, row_indices,\n                                indices.are.1based)\n    new_SVT_SparseArray(dim, dimnames, type(data), ans_SVT, check=FALSE)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between SVT_SparseMatrix and CsparseMatrix\n###\n\n.make_CsparseMatrix_from_SVT_SparseMatrix <- function(from, to_type=NULL)\n{\n    stopifnot(is(from, \"SVT_SparseMatrix\"))\n    check_svt_version(from)\n\n    if (!is.null(to_type)) {\n        ## Late type switching tends to be slightly more memory efficient.\n        ## However, switching to a smaller type (e.g. from \"complex\" to \"double\"\n        ## or from \"integer\" to \"logical\") can introduce zeros. In this case,\n        ## we must switch the type early. Otherwise we will end up with zeros\n        ## in the \"x\" slot of the resulting dgCMatrix or lgCMatrix object.\n        switch_type_early <- coercion_can_introduce_zeros(from@type, to_type)\n        if (switch_type_early)\n            type(from) <- to_type  # early type switching\n    }\n\n    ## Returns 'ans_p', 'ans_i', and 'ans_x', in a list of length 3.\n    C_ans <- SparseArray.Call(\"C_from_SVT_SparseMatrix_to_CsparseMatrix\",\n                              from@dim, from@type, from@SVT, is.null(to_type))\n    ans_p <- C_ans[[1L]]\n    ans_i <- C_ans[[2L]]\n    ans_x <- C_ans[[3L]]  # NULL (if 'is.null(to_type)') or same type as 'from'\n\n    if (!is.null(to_type)) {\n        ## This type switching is safe only if it does not introduce zeros.\n        if (!switch_type_early)\n            storage.mode(ans_x) <- to_type  # late type switching\n    }\n\n    new_CsparseMatrix(from@dim, ans_p, ans_i, ans_x, dimnames=from@dimnames)\n}\n\n.from_SVT_SparseMatrix_to_dgCMatrix <- function(from)\n    .make_CsparseMatrix_from_SVT_SparseMatrix(from, \"double\")\n.from_SVT_SparseMatrix_to_lgCMatrix <- function(from)\n    .make_CsparseMatrix_from_SVT_SparseMatrix(from, \"logical\")\n.from_SVT_SparseMatrix_to_ngCMatrix <- function(from)\n    .make_CsparseMatrix_from_SVT_SparseMatrix(from)\n\nsetAs(\"SVT_SparseMatrix\", \"dgCMatrix\", .from_SVT_SparseMatrix_to_dgCMatrix)\nsetAs(\"SVT_SparseMatrix\", \"lgCMatrix\", .from_SVT_SparseMatrix_to_lgCMatrix)\nsetAs(\"SVT_SparseMatrix\", \"ngCMatrix\", .from_SVT_SparseMatrix_to_ngCMatrix)\n\n.build_SVT_SparseMatrix_from_CsparseMatrix <- function(x, dimnames=NULL,\n                                                          type=NA)\n{\n    stopifnot(is(x, \"CsparseMatrix\"))\n\n    ## Turn any [d|l|n]gCMatrix derivative (e.g. TestColMatrix object 'y'\n    ## defined in alabaster.matrix/tests/testthat/test-SparseMatrix.R) into\n    ## a [d|l|n]gCMatrix **instance**. We should not need to do this. Only\n    ## reason we do it is because we don't know how to test for inheritance\n    ## at the C level (Rf_inherits() doesn't seem to work properly on S4\n    ## objects). More precisely, without this coercion, C function\n    ## get_gCMatrix_subtype() defined in src/SVT_SparseArray_class.c won't\n    ## be able to recognize a [d|l|n]gCMatrix derivative so will reject it.\n    x <- as(x, \"CsparseMatrix\")\n\n    if (is.null(dimnames)) {\n        ans_dimnames <- dimnames(x)\n    } else {\n        ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim(x))\n    }\n    if (identical(type, NA))\n        type <- type(x)\n    ans_SVT <- SparseArray.Call(\"C_build_SVT_from_CsparseMatrix\", x, type)\n    new_SVT_SparseArray(dim(x), ans_dimnames, type, ans_SVT, check=FALSE)\n}\n\nsetAs(\"CsparseMatrix\", \"SVT_SparseMatrix\",\n    function(from) .build_SVT_SparseMatrix_from_CsparseMatrix(from)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between SVT_SparseMatrix and TsparseMatrix\n###\n\nsetAs(\"SVT_SparseMatrix\", \"dgTMatrix\",\n    function(from) as(as(from, \"dgCMatrix\"), \"TsparseMatrix\")\n)\nsetAs(\"SVT_SparseMatrix\", \"lgTMatrix\",\n    function(from) as(as(from, \"lgCMatrix\"), \"TsparseMatrix\")\n)\nsetAs(\"SVT_SparseMatrix\", \"ngTMatrix\",\n    function(from) as(as(from, \"ngCMatrix\"), \"TsparseMatrix\")\n)\n\nsetAs(\"TsparseMatrix\", \"SVT_SparseMatrix\",\n    function(from) as(as(from, \"CsparseMatrix\"), \"SVT_SparseMatrix\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from a Matrix derivative to SparseMatrix or SparseArray\n###\n\n### Coercing a sparseMatrix derivative (e.g. a CsparseMatrix or TsparseMatrix\n### derivative) to SparseMatrix produces an SVT_SparseMatrix object.\n### RsparseMatrix is the exception (see COO_SparseArray-class.R).\nsetAs(\"sparseMatrix\", \"SparseMatrix\",\n    function(from) as(from, \"SVT_SparseMatrix\")\n)\n\nsetAs(\"Matrix\", \"SparseArray\",\n    function(from) as(from, \"SparseMatrix\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Going back and forth between SVT_SparseArray and COO_SparseArray objects\n###\n\n.from_SVT_SparseArray_to_COO_SparseArray <- function(from)\n{\n    stopifnot(is(from, \"SVT_SparseArray\"))\n    check_svt_version(from)\n    ## Returns 'ans_nzcoo' and 'ans_nzdata' in a list of length 2.\n    C_ans <- SparseArray.Call(\"C_from_SVT_SparseArray_to_COO_SparseArray\",\n                              from@dim, from@type, from@SVT)\n    ans_nzcoo <- C_ans[[1L]]\n    ans_nzdata <- C_ans[[2L]]\n    new_COO_SparseArray(from@dim, from@dimnames,\n                        ans_nzcoo, ans_nzdata, check=FALSE)\n}\n\nsetAs(\"SVT_SparseArray\", \"COO_SparseArray\",\n    .from_SVT_SparseArray_to_COO_SparseArray\n)\nsetAs(\"SVT_SparseMatrix\", \"COO_SparseMatrix\",\n    .from_SVT_SparseArray_to_COO_SparseArray\n)\n\n.build_SVT_SparseArray_from_COO_SparseArray <- function(x, dimnames=NULL,\n                                                           type=NA)\n{\n    stopifnot(is(x, \"COO_SparseArray\"))\n    if (is.null(dimnames)) {\n        ans_dimnames <- dimnames(x)\n    } else {\n        ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim(x))\n    }\n    if (identical(type, NA)) {\n        type <- type(x)\n    } else {\n        ## Some quick testing/benchmarking seemed to suggest that it's\n        ## slightly more efficient to change the type of the input\n        ## COO_SparseArray object than that of the output SVT_SparseArray\n        ## object.\n        type(x) <- type\n    }\n    ## We start with an allzero SVT_SparseArray object and subassign\n    ## the nonzero data to it.\n    ans <- new_SVT_SparseArray(x@dim, ans_dimnames, type, check=FALSE)\n    ans[x@nzcoo] <- x@nzdata\n    ans\n}\n\nsetAs(\"COO_SparseArray\", \"SVT_SparseArray\",\n    function(from) .build_SVT_SparseArray_from_COO_SparseArray(from)\n)\nsetAs(\"COO_SparseMatrix\", \"SVT_SparseMatrix\",\n    function(from) .build_SVT_SparseArray_from_COO_SparseArray(from)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Default coercions to SparseArray or SVT_SparseArray\n###\n### Given a DelayedArray object or any out-of-memory array-like object 'x':\n### - as.array(x) is the standard way to realize it as an ordinary array, that\n###   is, as a **dense** array);\n### - as(x, \"SparseArray\") is the standard way to realize it in memory as a\n###   SparseArray derivative (SVT_SparseArray or COO_SparseArray object), that\n###   is as a **sparse** array;\n### - as(x, \"SVT_SparseArray\") is the standard way to realize it in memory\n###   as an SVT_SparseArray object.\n###\n\n### Similar to as.array() method for Array object (defined in the S4Arrays\n### package) but based on extract_sparse_array() instead of extract_array(),\n### and without the 'drop' argument.\n### Returns an SVT_SparseArray or COO_SparseArray object.\n.as_SparseArray <- function(x)\n{\n    if (!is_sparse(x)) {\n        ## Go thru .dense2sparse().\n        return(as(x, \"COO_SparseArray\"))\n    }\n    index <- vector(\"list\", length=length(dim(x)))\n    ans <- extract_sparse_array(x, index)\n    S4Arrays:::set_dimnames(ans, dimnames(x))\n}\nsetAs(\"ANY\", \"SparseArray\", function(from) .as_SparseArray(from))\n\n.as_SparseMatrix <- function(x)\n{\n    x_ndim <- length(dim(x))\n    if (x_ndim != 2L)\n        stop(wmsg(\"cannot coerce \", class(x)[[1L]], \" object \",\n                  \"with \", x_ndim, \" dimensions to SparseMatrix \",\n                  \"(object to coerce must have 2 dimensions)\"))\n    .as_SparseArray(x)\n}\nsetAs(\"ANY\", \"SparseMatrix\", function(from) .as_SparseMatrix(from))\n\nsetAs(\"ANY\", \"SVT_SparseArray\",\n    function(from) as(as(from, \"SparseArray\"), \"SVT_SparseArray\")\n)\nsetAs(\"ANY\", \"SVT_SparseMatrix\",\n    function(from) as(as(from, \"SparseMatrix\"), \"SVT_SparseMatrix\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The SVT_SparseArray() constructor\n###\n\n.new_empty_SVT_SparseArray <- function(type=NA)\n{\n    if (identical(type, NA))\n        type <- \"logical\"\n    new2(\"SVT_SparseArray\", type=type, check=FALSE)\n}\n\n.SVT_SparseArray <- function(x, dimnames=NULL, type=NA)\n{\n    if (is.array(x))\n        return(.build_SVT_SparseArray_from_array(x,\n                                      dimnames=dimnames, type=type))\n\n    if (is(x, \"CsparseMatrix\"))\n        return(.build_SVT_SparseMatrix_from_CsparseMatrix(x,\n                                      dimnames=dimnames, type=type))\n\n    if (is(x, \"COO_SparseArray\"))\n        return(.build_SVT_SparseArray_from_COO_SparseArray(x,\n                                      dimnames=dimnames, type=type))\n\n    ans <- as(x, \"SVT_SparseArray\")\n    if (!is.null(dimnames))\n        ans <- S4Arrays:::set_dimnames(ans, dimnames)\n    if (!identical(type, NA))\n        type(ans) <- type\n    ans\n}\n\nSVT_SparseArray <- function(x, dim=NULL, dimnames=NULL, type=NA)\n{\n    if (!identical(type, NA))\n        type <- S4Arrays:::normarg_array_type(type, \"the requested type\")\n\n    if (is.null(dim)) {\n        if (missing(x))\n            return(.new_empty_SVT_SparseArray(type))\n        return(.SVT_SparseArray(x, dimnames=dimnames, type=type))\n    }\n\n    dim <- S4Arrays:::normarg_dim(dim)\n    ans <- new_SVT_SparseArray(dim, dimnames=dimnames, check=FALSE)\n    if (!missing(x)) {\n        nzidx <- nzwhich(x)\n        ans[nzidx] <- as.vector(x[nzidx])\n    }\n    if (!identical(type, NA))\n        type(ans) <- type\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### The SparseArray() constructor\n###\n\n### Preference is given to the SVT_SparseArray representation.\nSparseArray <- function(x, type=NA)\n{\n    if (!identical(type, NA))\n        type <- S4Arrays:::normarg_array_type(type, \"the requested type\")\n\n    if (missing(x))\n        return(.new_empty_SVT_SparseArray(type))\n\n    if (is(x, \"SparseArray\")) {\n        if (is(x, \"SVT_SparseArray\"))\n            check_svt_version(x)\n        if (!identical(type, NA))\n            type(x) <- type\n        return(x)\n    }\n\n    ## Calling SparseArray() on a sparseMatrix derivative (e.g. on a\n    ## CsparseMatrix or TsparseMatrix object) produces an SVT_SparseMatrix\n    ## object. RsparseMatrix is the exception.\n    if (is(x, \"RsparseMatrix\")) {\n        ans <- as(x, \"COO_SparseMatrix\")\n        if (!identical(type, NA))\n            type(ans) <- type\n        return(ans)\n    }\n\n    .SVT_SparseArray(x, type=type)\n}\n\n",
        "SparseArray-Arith-methods.R": "### =========================================================================\n### 'Arith' operations on SparseArray objects\n### -------------------------------------------------------------------------\n###\n### 'Arith' operations: \"+\", \"-\", \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n###\n### See '?S4groupGeneric' for more information.\n###\n### We also implement unary \"+\" and \"-\" for SparseArray objects.\n###\n\n\nARITH_INPUT_TYPES <- c(\"integer\", \"double\", \"complex\")\n\ncheck_Arith_input_type <- function(type, what)\n{\n    if (!(type %in% ARITH_INPUT_TYPES))\n        stop(wmsg(\"arithmetic operation not supported \",\n                  \"on \", what, \" of type() \\\"\", type , \"\\\"\"))\n}\n\ncheck_vector_operand_length <- function(y_len, x_dim, recycle.along,\n                                        what_x, side=c(\"right\", \"left\"))\n{\n    stopifnot(isSingleInteger(y_len),\n              is.integer(x_dim),\n              isSingleInteger(recycle.along),\n              isSingleString(what_x))\n    side <- match.arg(side)\n\n    dim1 <- x_dim[[recycle.along]]\n    if (y_len == dim1 || y_len == 1L)\n        return()\n    operand <- paste(side, \"vector\")\n    if (recycle.along == 1L) {\n        which_dim <- \"first (a.k.a. innermost) dimension\"\n    } else if (recycle.along == length(x_dim)) {\n        which_dim <- \"last (a.k.a. outermost) dimension\"\n    } else {\n\tth <- switch(as.character(recycle.along %% 10L),\n                     `2`=\"nd\", `3`=\"rd\", \"th\")\n        which_dim <- paste0(recycle.along, th, \" dimension\")\n    }\n    what <- paste(which_dim, \" of \", what_x)\n    if (y_len > dim1)\n        stop(wmsg(operand, \" is longer than \", what))\n    if (y_len == 0L)\n        stop(wmsg(operand, \" length cannot be 0 unless \", what, \" is 0\"))\n    if (dim1 %% y_len != 0L)\n        warning(wmsg(what, \" is not a multiple of \", operand, \" length\"))\n}\n\nop_is_commutative <- function(op)\n    (op %in% c(\"+\", \"*\", \"==\", \"!=\", \"&\", \"|\"))\n\nerror_on_left_sparsity_not_preserved <- function(op, when)\n{\n    flipped_op <- flip_Compare_op(op)\n    show_flipped_op <- flipped_op != op || op_is_commutative(op)\n    if (show_flipped_op) {\n        msg <- c(\"'x \", op, \" y' and 'y \", flipped_op, \" x': operations\")\n    } else {\n        msg <- c(\"x \", op, \" y: operation\")\n    }\n    stop(wmsg(msg, \" not supported on SparseArray object x \",\n              \"when \", when, \" (result wouldn't be sparse)\"))\n}\n\nget_Arith_output_type <- function(op, x_type, y_type)\n{\n    if (op %in% c(\"/\", \"^\") && x_type == \"integer\" && y_type == \"integer\")\n        return(\"double\")\n    output_type <- type(c(vector(x_type), vector(y_type)))\n    if (output_type == \"complex\") {\n        ## temporary\n        stop(wmsg(\"'x \", op, \" y' is not supported yet when 'x' or 'y' \",\n                  \"is an SVT_SparseArray or NaArray object \",\n                  \"of type() \\\"complex\\\"\"))\n    }\n    if (op %in% c(\"%%\", \"%/%\") && output_type == \"complex\")\n        stop(wmsg(\"unimplemented complex operation\"))\n    output_type\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Unary \"+\" and \"-\"\n###\n\n.unary_plus_SparseArray <- function(x)\n{\n    check_Arith_input_type(type(x), \"SparseArray object\")\n    x  # no-op\n}\n\n.unary_minus_SparseArray <- function(x)\n{\n    check_Arith_input_type(type(x), \"SparseArray object\")\n    if (is(x, \"COO_SparseArray\")) {\n        ans <- BiocGenerics:::replaceSlots(x, nzdata=-x@nzdata, check=FALSE)\n    } else if (is(x, \"SVT_SparseArray\")) {\n        check_svt_version(x)\n        new_SVT <- SparseArray.Call(\"C_unary_minus_SVT\", x@dim, x@type, x@SVT)\n        ans <- BiocGenerics:::replaceSlots(x, SVT=new_SVT, check=FALSE)\n    } else {\n        stop(wmsg(\"unary \\\"-\\\" is not supported on \", class(x), \" objects\"))\n    }\n    ans\n}\n\nsetMethod(\"+\", c(\"SparseArray\", \"missing\"),\n    function(e1, e2) .unary_plus_SparseArray(e1)\n)\n\nsetMethod(\"-\", c(\"SparseArray\", \"missing\"),\n    function(e1, e2) .unary_minus_SparseArray(e1)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Arith' group\n###\n\n.check_right_vector_for_Arith_SVT1_v2 <- function(y, x_dim, op,\n                                                  recycle.along=1L)\n{\n    check_vector_operand_length(length(y), x_dim, recycle.along,\n                                \"SparseArray object\")\n    if (anyNA(y))\n        error_on_left_sparsity_not_preserved(op,\n                 \"y contains NA or NaN values\")\n    if (op == \"*\" && any(is.infinite(y)))\n        error_on_left_sparsity_not_preserved(op,\n                 \"y contains infinite values\")\n    if (op == \"^\" && any(y <= 0))\n        error_on_left_sparsity_not_preserved(op,\n                 \"y contains non-positive values\")\n    if (op != \"*\" && any(y == 0))\n        error_on_left_sparsity_not_preserved(op,\n                 \"y contains zeros\")\n}\n\n### Supports: \"*\", \"/\", \"^\", \"%%\", \"%/%\"\n### Returns an SVT_SparseArray object.\n.Arith_SVT1_v2 <- function(op, x, y, recycle.along=1L)\n{\n    stopifnot(isSingleString(op),\n              is(x, \"SVT_SparseArray\"),\n              isSingleInteger(recycle.along))\n    check_svt_version(x)\n\n    ## Check types.\n    check_Arith_input_type(type(x), \"SparseArray object\")\n    if (!is.atomic(y))\n        stop(wmsg(\"arithmetic operations between SparseArray objects \",\n                  \"and non-atomic vectors are not supported\"))\n    if (!(type(y) %in% ARITH_INPUT_TYPES))\n        stop(wmsg(\"arithmetic operations between SparseArray objects \",\n                  \"and \", class(y), \" vectors are not supported\"))\n\n    ## Check 'op'.\n    if (!(op %in% c(\"*\", \"/\", \"^\", \"%%\", \"%/%\")))\n        stop(wmsg(\"\\\"\", op, \"\\\" is not supported between a SparseArray \",\n                  \"object and a \", class(y), \" vector (result wouldn't \",\n                  \"be sparse in general)\"))\n\n    ## Check 'y'.\n    .check_right_vector_for_Arith_SVT1_v2(y, dim(x), op,\n                                          recycle.along=recycle.along)\n\n    ## Compute 'ans_type'.\n    if (type(x) == \"double\" && type(y) == \"integer\" || op %in% c(\"/\", \"^\"))\n        type(y) <- \"double\"  # cheap\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    new_SVT <- SparseArray.Call(\"C_Arith_SVT1_v2\",\n                                x@dim, x@type, x@SVT, FALSE,\n                                y, recycle.along, op, ans_type)\n    BiocGenerics:::replaceSlots(x, type=ans_type, SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"Arith\", c(\"SVT_SparseArray\", \"vector\"),\n    function(e1, e2) .Arith_SVT1_v2(.Generic, e1, e2)\n)\n\nsetMethod(\"Arith\", c(\"vector\", \"SVT_SparseArray\"),\n    function(e1, e2) {\n        if (.Generic != \"*\")\n            stop(wmsg(\"\\\"\", .Generic, \"\\\" is not supported between \",\n                      \"a \", class(e1), \" vector on the left and an \",\n                      \"SVT_SparseArray object on the right (result \",\n                      \"wouldn't be sparse in general)\"))\n        .Arith_SVT1_v2(.Generic, e2, e1)\n    }\n)\n\n### Supports: \"+\", \"-\", \"*\"\n### Returns an SVT_SparseArray object.\n.Arith_SVT1_SVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op),\n              is(x, \"SVT_SparseArray\"),\n              is(y, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Arith_input_type(type(x), \"SparseArray object\")\n    check_Arith_input_type(type(y), \"SparseArray object\")\n\n    ## Check 'op'.\n    if (!(op %in% c(\"+\", \"-\", \"*\")))\n        stop(wmsg(\"\\\"\", op, \"\\\" is not supported between SparseArray \",\n                  \"objects (result wouldn't be sparse in general)\"))\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Compute 'ans_type'.\n    ans_type <- get_Arith_output_type(op, type(x), type(y))\n\n    ans_SVT <- SparseArray.Call(\"C_Arith_SVT1_SVT2\",\n                                x_dim, x@type, x@SVT, FALSE,\n                                y_dim, y@type, y@SVT, FALSE, op, ans_type)\n    new_SVT_SparseArray(x_dim, ans_dimnames, ans_type, ans_SVT, check=FALSE)\n}\n\nsetMethod(\"Arith\", c(\"SVT_SparseArray\", \"SVT_SparseArray\"),\n    function(e1, e2) .Arith_SVT1_SVT2(.Generic, e1, e2)\n)\n\n### We could either:\n###  (a) Turn 'e2' into an SVT_SparseArray object and return an\n###      SVT_SparseArray object. This is the dgCMatrix approach.\n###  (b) Turn 'e1' into an ordinary array and return an ordinary array.\n### We choose to do (a). Note that there's no best choice in general as it\n### really depends on the 'Arith' operation (i.e. \"+\", \"-\", or \"*\") and\n### whether 'e2' has a lot of zeros or not. If it has no or very little\n### zeros, then (a) will tend to be less memory efficient than (b) when\n### doing \"+\" or \"-\". When doing \"*\", (a) should be always more memory\n### efficient than (b), no matter what.\n### The cautious user would typically make that choice upfront anyway, by\n### coercing one or the other object before calling the 'Arith' op on them.\nsetMethod(\"Arith\", c(\"SVT_SparseArray\", \"array\"),\n    function(e1, e2) .Arith_SVT1_SVT2(.Generic, e1, as(e2, \"SVT_SparseArray\"))\n)\n\nsetMethod(\"Arith\", c(\"array\", \"SVT_SparseArray\"),\n    function(e1, e2) .Arith_SVT1_SVT2(.Generic, as(e1, \"SVT_SparseArray\"), e2)\n)\n\n",
        "SparseArray-Compare-methods.R": "### =========================================================================\n### 'Compare' operations on SparseArray objects\n### -------------------------------------------------------------------------\n###\n### 'Compare' operations: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n###\n### See '?S4groupGeneric' for more information.\n###\n\n\n### All the atomic vector types (i.e. all vector types except \"list\").\nCOMPARE_INPUT_TYPES <- c(\"logical\", \"integer\", \"double\", \"complex\",\n                         \"character\", \"raw\")\n\ncheck_Compare_input_type <- function(type, what)\n{\n    if (!(type %in% COMPARE_INPUT_TYPES))\n        stop(wmsg(\"comparison operation not supported \",\n                  \"on \", what, \" of type() \\\"\", type , \"\\\"\"))\n}\n\nflip_Compare_op <- function(op)\n    switch(op, `<=`=\">=\", `>=`=\"<=\", `<`=\">\", `>`=\"<\", op)\n\ncheck_Compare_op_on_complex_vals <- function(op, x_type, y_type)\n{\n    if ((x_type == \"complex\" || y_type == \"complex\")\n     && op %in% c(\"<=\", \">=\", \"<\", \">\"))\n        stop(wmsg(\"invalid comparison with complex values\"))\n}\n\nmust_homogenize_for_Compare <- function(x_type, y_type)\n{\n    if (x_type == \"raw\" && y_type == \"logical\" ||\n        x_type == \"logical\" && y_type == \"raw\")\n    {\n        ## This is a case where C-level Compare_Rbyte_int() function\n        ## (defined in src/leaf_vector_Compare.c) won't compare the\n        ## Rbyte values in one object with the int values in the other\n        ## object in a meaningful way. That's because the nonzero Rbyte\n        ## values can be anything between 1 and 255 while the nonzero\n        ## int values are always 1.\n        ## An easy workaround is to set the type() of both objects\n        ## to \"logical\".\n        return(TRUE)\n    }\n    if (x_type == \"character\" || y_type == \"character\") {\n        ## Temporary.\n        stop(wmsg(\"comparison operations are not implemented yet between \",\n                  \"SVT_SparseArray objects, or between an SVT_SparseArray \",\n                  \"object and a single value, when one or the other is of \",\n                  \"type() \\\"character\\\"\"))\n        return(TRUE)\n    }\n    FALSE\n}\n\n### Supports all 'Compare' ops: \"==\", \"!=\", \"<=\", \">=\", \"<\", \">\"\n### Returns a \"logical\" SVT_SparseArray object.\n.Compare_SVT1_v2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n\n    ## Check types.\n    x_type <- type(x)\n    check_Compare_input_type(x_type, \"SparseArray object\")\n    if (!(type(y) %in% COMPARE_INPUT_TYPES))\n        stop(wmsg(\"comparison operations between SparseArray objects \",\n                  \"and \", class(y), \" vectors are not supported\"))\n    check_Compare_op_on_complex_vals(op, x_type, type(y))\n\n    ## Check 'y'.\n    if (length(y) != 1L)\n        stop(wmsg(\"comparison operations are not supported between a \",\n                  \"SparseArray object and a vector of length != 1\"))\n    if (is.na(y))\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is NA or NaN\")\n    if (type(y) %in% c(\"logical\", \"raw\") && op %in% c(\"<=\", \"<\"))\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is a logical or raw value\")\n\n    biggest_type <- type(c(vector(x_type), y))\n    if (biggest_type == \"character\" && op %in% c(\"<=\", \"<\"))\n        error_on_left_sparsity_not_preserved(op,\n                    \"type(x) is \\\"character\\\" or y is a string\")\n\n    type(y) <- biggest_type\n    zero <- vector_of_zeros(type(y), length=1L)\n    if (op == \"==\" && y == zero)\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is 0 or FALSE or the empty string\")\n    if (op == \"!=\" && y != zero)\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is not 0, FALSE, or the empty string\")\n    if (op == \"<=\" && y >= zero)\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is >= 0\")\n    if (op == \">=\" && y <= zero)\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is <= 0, or FALSE, or the empty string\")\n    if (op == \"<\" && y > zero)\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is > 0\")\n    if (op == \">\" && y < zero)\n        error_on_left_sparsity_not_preserved(op,\n                    \"y is < 0\")\n\n    ## Handle situations where we need to change the type() of 'x' to\n    ## the type() of 'y'. This is possibly expensive so we do it only\n    ## after all the above checks have passed.\n    if (must_homogenize_for_Compare(type(x), type(y)))\n        type(x) <- type(y)\n\n    ## 'type(y)' is guaranteed to be the same as 'type(x)' or a \"bigger\" type,\n    ## considering raw < logical < integer < double < complex < character.\n    new_SVT <- SparseArray.Call(\"C_Compare_SVT1_v2\",\n                                x@dim, x@type, x@SVT, FALSE, y, op)\n    BiocGenerics:::replaceSlots(x, type=\"logical\", SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"Compare\", c(\"SVT_SparseArray\", \"vector\"),\n    function(e1, e2) .Compare_SVT1_v2(.Generic, e1, e2)\n)\n\nsetMethod(\"Compare\", c(\"vector\", \"SVT_SparseArray\"),\n    function(e1, e2) .Compare_SVT1_v2(flip_Compare_op(.Generic), e2, e1)\n)\n\n### Supports: \"!=\", \"<\", \">\"\n### Returns a \"logical\" SVT_SparseArray object.\n.Compare_SVT1_SVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op),\n              is(x, \"SVT_SparseArray\"),\n              is(y, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Compare_input_type(type(x), \"SparseArray object\")\n    check_Compare_input_type(type(y), \"SparseArray object\")\n    check_Compare_op_on_complex_vals(op, type(x), type(y))\n\n    ## Check 'op'.\n    if (!(op %in% c(\"!=\", \"<\", \">\"))) {\n        suggest <- switch(op, `==`=\"!=\", `<=`=\"<\", `>=`=\">\")\n        suggest <- if (is.null(suggest)) \"\" else\n                       paste0(\", but \\\"\", suggest, \"\\\" is\")\n        stop(wmsg(\"\\\"\", op, \"\\\" is not supported between SparseArray \",\n                  \"objects (result wouldn't be sparse in general)\", suggest))\n    }\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ## Homogenization is possibly expensive so we do it only after all\n    ## the above checks have passed.\n    if (must_homogenize_for_Compare(type(x), type(y)))\n        type(x) <- type(y) <- type(c(vector(type(x)), vector(type(y))))\n\n    ans_SVT <- SparseArray.Call(\"C_Compare_SVT1_SVT2\",\n                                x_dim, x@type, x@SVT, FALSE,\n                                y_dim, y@type, y@SVT, FALSE, op)\n    new_SVT_SparseArray(x_dim, ans_dimnames, \"logical\", ans_SVT, check=FALSE)\n}\n\nsetMethod(\"Compare\", c(\"SVT_SparseArray\", \"SVT_SparseArray\"),\n    function(e1, e2) .Compare_SVT1_SVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Compare\", c(\"SVT_SparseArray\", \"array\"),\n    function(e1, e2) .Compare_SVT1_SVT2(.Generic, e1, as(e2, \"SVT_SparseArray\"))\n)\n\nsetMethod(\"Compare\", c(\"array\", \"SVT_SparseArray\"),\n    function(e1, e2) .Compare_SVT1_SVT2(.Generic, as(e1, \"SVT_SparseArray\"), e2)\n)\n\n",
        "SparseArray-Complex-methods.R": "### =========================================================================\n### 'Complex' methods for SparseArray objects\n### -------------------------------------------------------------------------\n###\n### The 'Complex' group consists of the following methods:\n###   Re, Im, Mod, Arg, Conj\n###\n### See '?S4groupGeneric' for more information.\n###\n### The corresponding base functions all accept an array of type \"complex\",\n### \"double\", or \"integer\", and they all return an array of same dimensions\n### as the input array.\n### Re(), Im(), Mod(), Arg() return an array of type \"double\" (whatever\n### the type of the input array).\n### Conj() returns an array of type \"complex\" if the input array is of type\n### \"complex', and an array of type \"double\" otherwise.\n### \n\n\n.SVT_SparseArray_Complex <- function(op, z)\n{\n    stopifnot(isSingleString(op), is(z, \"SVT_SparseArray\"))\n    check_svt_version(z)\n\n    if (type(z) != \"complex\")\n        stop(wmsg(\"the \", op, \"() method for SVT_SparseArray objects \",\n                  \"only supports input of type \\\"complex\\\" at the moment\"))\n\n    ## Returns 'ans_type' and 'ans_SVT' in a list of length 2.\n    C_ans <- SparseArray.Call(\"C_Complex_SVT\", z@dim, z@type, z@SVT, op)\n    ans_type <- C_ans[[1L]]\n    ans_SVT <- C_ans[[2L]]\n\n    new_SVT_SparseArray(z@dim, z@dimnames, ans_type, ans_SVT, check=FALSE)\n}\n\nsetMethod(\"Complex\", \"SVT_SparseArray\",\n    function(z) .SVT_SparseArray_Complex(.Generic, z)\n)\n\n",
        "SparseArray-Logic-methods.R": "### =========================================================================\n### 'Logic' operations on SparseArray objects\n### -------------------------------------------------------------------------\n###\n### 'Logic' operations:   \"&\", \"|\"\n###\n### See '?S4groupGeneric' for more information.\n###\n### We also implement a dummy logical negation (\"!\") method for SparseArray\n### objects.\n###\n\n\n### In base R, \"&\" and \"|\" support input of type() \"logical\", \"integer\",\n### \"double\", and \"complex\". We only support \"logical\" for now.\nLOGIC_INPUT_TYPES <- \"logical\"\n\ncheck_Logic_input_type <- function(type, what)\n{\n    if (!(type %in% LOGIC_INPUT_TYPES))\n        stop(wmsg(\"'Logic' operation \\\"&\\\" and \\\"|\\\" not supported \",\n                  \"on \", what, \" of type() \\\"\", type , \"\\\"\"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Dummy logical negation\n###\n\nsetMethod(\"!\", \"SparseArray\",\n    function(x)\n    {\n        stop(wmsg(\"logical negation (\\\"!\\\") is not supported on SparseArray \",\n                  \"objects (result wouldn't be sparse in general)\"))\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Logic' group\n###\n\n.Logic_SVT1_v2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n\n    ## Check types.\n    x_type <- type(x)\n    check_Logic_input_type(x_type, \"SparseArray object\")\n    if (!(type(y) %in% LOGIC_INPUT_TYPES))\n        stop(wmsg(\"\\\"\", op, \"\\\" between a SparseArray object \",\n                  \"and a \", class(y), \" vector is not supported\"))\n\n    ## Check 'y'.\n    if (length(y) != 1L)\n        stop(wmsg(\"\\\"\", op, \"\\\" between a SparseArray object \",\n                  \"and a vector of length != 1 is not supported\"))\n    if (is.na(y))\n        error_on_left_sparsity_not_preserved(op, \"y is NA\")\n\n    if (op == \"&\" && isFALSE(y))\n        return(BiocGenerics:::replaceSlots(x, SVT=NULL, check=FALSE))\n    if (op == \"|\" && isTRUE(y))\n        error_on_left_sparsity_not_preserved(op, \"y is TRUE\")\n    x\n}\n\nsetMethod(\"Logic\", c(\"SVT_SparseArray\", \"vector\"),\n    function(e1, e2) .Logic_SVT1_v2(.Generic, e1, e2)\n)\n\nsetMethod(\"Logic\", c(\"vector\", \"SVT_SparseArray\"),\n    function(e1, e2) .Logic_SVT1_v2(.Generic, e2, e1)\n)\n\n.Logic_SVT1_SVT2 <- function(op, x, y)\n{\n    stopifnot(isSingleString(op),\n              is(x, \"SVT_SparseArray\"),\n              is(y, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    check_svt_version(y)\n\n    ## Check types.\n    check_Logic_input_type(type(x), \"SparseArray object\")\n    check_Logic_input_type(type(y), \"SparseArray object\")\n\n    ## Check array conformability.\n    x_dim <- dim(x)\n    y_dim <- dim(y)\n    if (!identical(x_dim, y_dim))\n        stop(wmsg(\"non-conformable arrays\"))\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n\n    ans_SVT <- SparseArray.Call(\"C_Logic_SVT1_SVT2\",\n                                x_dim, x@type, x@SVT, FALSE,\n                                y_dim, y@type, y@SVT, FALSE, op)\n    new_SVT_SparseArray(x_dim, ans_dimnames, \"logical\", ans_SVT, check=FALSE)\n}\n\nsetMethod(\"Logic\", c(\"SVT_SparseArray\", \"SVT_SparseArray\"),\n    function(e1, e2) .Logic_SVT1_SVT2(.Generic, e1, e2)\n)\n\nsetMethod(\"Logic\", c(\"SVT_SparseArray\", \"array\"),\n    function(e1, e2) .Logic_SVT1_SVT2(.Generic, e1, as(e2, \"SVT_SparseArray\"))\n)\n\nsetMethod(\"Logic\", c(\"array\", \"SVT_SparseArray\"),\n    function(e1, e2) .Logic_SVT1_SVT2(.Generic, as(e1, \"SVT_SparseArray\"), e2)\n)\n\n",
        "SparseArray-Math-methods.R": "### =========================================================================\n### 'Math' and 'Math2' methods for SparseArray objects\n### -------------------------------------------------------------------------\n###\n### The 'Math' group consists of the following methods:\n### - abs, sign, sqrt, floor, ceiling, trunc\n### - cummax, cummin, cumprod, cumsum\n### - log, log10, log2, log1p, exp, expm1\n### - sin, asin, sinh, asinh, sinpi,\n### - cos, acos, cosh, acosh, cospi,\n### - tan, atan, tanh, atanh, tanpi,\n### - gamma, lgamma, digamma, trigamma\n###\n### The 'Math2' group consists of the following methods: round, signif\n###\n### See '?S4groupGeneric' for more information.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Math' group\n###\n\n### SparseArray objects only support functions from the 'Math' group that\n### propagate zeros.\nSUPPORTED_MATH_OPS <- c(\n    \"abs\", \"sign\", \"sqrt\", \"floor\", \"ceiling\", \"trunc\",\n    \"log1p\", \"expm1\",\n    \"sin\", \"asin\", \"sinh\", \"asinh\", \"sinpi\",\n    \"tan\", \"atan\", \"tanh\", \"atanh\", \"tanpi\"\n)\n\n.check_Math_op <- function(op)\n{\n    if (!(op %in% SUPPORTED_MATH_OPS))\n        stop(wmsg(op, \"() is not supported on SparseArray \",\n                  \"objects (result wouldn't be sparse in general)\"))\n}\n\n.Math_SVT <- function(op, x)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    .check_Math_op(op)\n    if (type(x) != \"double\")\n        stop(wmsg(\"the \", op, \"() method for SVT_SparseArray objects \",\n                  \"only supports input of type \\\"double\\\" at the moment\"))\n    new_SVT <- SparseArray.Call(\"C_Math_SVT\",\n                                x@dim, x@type, x@SVT, FALSE, op, 0.0)\n    BiocGenerics:::replaceSlots(x, type=\"double\", SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"Math\", \"SVT_SparseArray\", function(x) .Math_SVT(.Generic, x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Math2' group\n###\n\n.Math2_SVT <- function(op, x, digits)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    if (type(x) != \"double\")\n        stop(wmsg(\"the \", op, \"() method for SVT_SparseArray objects \",\n                  \"only supports input of type \\\"double\\\" at the moment\"))\n    if (!isSingleNumber(digits))\n        stop(wmsg(\"'digits' must be a single number\"))\n    if (!is.double(digits))\n        digits <- as.double(digits)\n    new_SVT <- SparseArray.Call(\"C_Math_SVT\",\n                                x@dim, x@type, x@SVT, FALSE, op, digits)\n    BiocGenerics:::replaceSlots(x, type=\"double\", SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"round\", \"SVT_SparseArray\",\n    function(x, digits=0) .Math2_SVT(\"round\", x, digits)\n)\n\nsetMethod(\"signif\", \"SVT_SparseArray\",\n    function(x, digits=6) .Math2_SVT(\"signif\", x, digits)\n)\n\n",
        "SparseArray-abind.R": "### =========================================================================\n### Combining multidimensional SparseArray objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### abind()\n###\n\n.abind_COO_SparseArray_objects <- function(objects, dims, along, ans_dimnames)\n{\n    ## Compute 'ans_dim'.\n    ans_dim <- S4Arrays:::combine_dims_along(dims, along)\n\n    ## Combine the \"nzcoo\" slots.\n    offsets <- cumsum(dims[along, -ncol(dims)])\n    nzcoo_list <- lapply(seq_along(objects),\n        function(i) {\n            object <- objects[[i]]\n            nzcoo <- object@nzcoo\n            if (i >= 2L)\n                nzcoo[ , along] <- nzcoo[ , along, drop=FALSE] +\n                                   offsets[[i - 1L]]\n            nzcoo\n        }\n    )\n    ans_nzcoo <- do.call(rbind, nzcoo_list)\n\n    ## Combine the @nzdata slots.\n    ans_nzdata <- unlist(lapply(objects, slot, \"nzdata\"), use.names=FALSE)\n\n    COO_SparseArray(ans_dim, ans_nzcoo, ans_nzdata, ans_dimnames, check=FALSE)\n}\n\n### NOT exported but used in the DelayedArray package!\nabind_SVT_SparseArray_objects <- function(objects, along, ans_dimnames)\n{\n    ## Compute 'ans_type'.\n    ans_type <- type(unlist(\n        lapply(objects, function(object) vector(type(object)))\n    ))\n    objects <- lapply(objects, `type<-`, ans_type)\n\n    ## Returns 'ans_dim' and 'ans_SVT' in a list of length 2.\n    C_ans <- SparseArray.Call(\"C_abind_SVT_SparseArray_objects\",\n                              objects, \"SVT\", along, ans_type)\n    ans_dim <- C_ans[[1L]]\n    ans_SVT <- C_ans[[2L]]\n\n    new_SVT_SparseArray(ans_dim, ans_dimnames, ans_type, ans_SVT, check=FALSE)\n}\n\n.abind_SparseArray_objects <- function(..., along=NULL, rev.along=NULL)\n{\n    objects <- S4Vectors:::delete_NULLs(list(...))\n    if (length(objects) == 0L)\n        return(NULL)\n\n    ndims <- vapply(objects, function(object) length(dim(object)), integer(1))\n    N <- max(ndims)\n    along <- S4Arrays:::get_along(N, along=along, rev.along=rev.along)\n    ans_ndim <- max(N, along)\n    objects <- S4Arrays:::add_missing_dims(objects, ans_ndim)\n\n    ## Check dim compatibility.\n    dims <- S4Arrays:::get_dims_to_bind(objects, along)\n    if (is.character(dims))\n        stop(wmsg(dims))\n    x <- objects[[1L]]\n    if (length(objects) == 1L)\n        return(x)\n\n    ## Compute 'ans_dimnames'.\n    ans_dimnames <- S4Arrays:::combine_dimnames_along(objects, dims, along)\n\n    if (is(x, \"COO_SparseArray\"))\n        return(.abind_COO_SparseArray_objects(objects, dims, along,\n                                              ans_dimnames))\n    if (is(x, \"SVT_SparseArray\")) {\n        check_svt_version(x)\n        return(abind_SVT_SparseArray_objects(objects, along,\n                                             ans_dimnames))\n    }\n    stop(wmsg(class(x)[[1L]], \" objects are not supported\"))\n}\n\nsetMethod(\"abind\", \"SparseArray\", .abind_SparseArray_objects)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### rbind(), cbind()\n###\n\n### TODO: The methods below are defined for SparseArray objects but it seems\n### that they could as well be defined more generally for Array objects.\n\n### The generics have the 'deparse.level' argument. We ignore it.\nsetMethod(\"rbind\", \"SparseArray\", function(...) arbind(...))\nsetMethod(\"cbind\", \"SparseArray\", function(...) acbind(...))\n\n### Arguments 'use.names', 'ignore.mcols', and 'check' are ignored.\nsetMethod(\"bindROWS\", \"SparseArray\",\n    function(x, objects=list(), use.names=TRUE, ignore.mcols=FALSE, check=TRUE)\n    {\n        args <- c(list(x), unname(objects))\n        do.call(rbind, args)\n    }\n)\n\n",
        "SparseArray-aperm.R": "### =========================================================================\n### Transposition of a SparseArray object\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Transposition\n###\n\n### S3/S4 combo for t.SVT_SparseMatrix\nt.SVT_SparseMatrix <- function(x)\n{\n    check_svt_version(x)\n    new_SVT <- SparseArray.Call(\"C_transpose_2D_SVT\", x@dim, x@type, x@SVT)\n    BiocGenerics:::replaceSlots(x, dim=rev(x@dim),\n                                   dimnames=rev(x@dimnames),\n                                   SVT=new_SVT,\n                                   check=FALSE)\n}\nsetMethod(\"t\", \"SVT_SparseMatrix\", t.SVT_SparseMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### aperm()\n###\n### Both .aperm_COO() and .aperm_SVT() support S4Arrays::aperm2() extended\n### semantic.\n###\n\n.aperm_COO <- function(a, perm)\n{\n    stopifnot(is(a, \"COO_SparseArray\"))\n    perm <- S4Arrays:::normarg_perm(perm, a@dim)\n    msg <- S4Arrays:::validate_perm(perm, a@dim)\n    if (!isTRUE(msg))\n        stop(wmsg(msg))\n    ans_dim <- a@dim[perm]\n    ans_dim[is.na(perm)] <- 1L\n    ans_nzcoo <- a@nzcoo[ , perm, drop=FALSE]\n    ans_nzcoo[ , is.na(perm)] <- 1L\n    ans_dimnames <- a@dimnames[perm]\n    new_COO_SparseArray(ans_dim, ans_dimnames,\n                        ans_nzcoo, a@nzdata, check=FALSE)\n}\n\n.aperm_SVT <- function(a, perm, .NAME=c(\"C_aperm_SVT\", \"C_aperm0_SVT\"))\n{\n    stopifnot(is(a, \"SVT_SparseArray\"))\n    check_svt_version(a)\n\n    .NAME <- match.arg(.NAME)\n\n    aperm0_SVT <- function(x, perm) {\n        new_SVT <- SparseArray.Call(.NAME, x@dim, x@type, x@SVT, perm)\n        BiocGenerics:::replaceSlots(x, dim=x@dim[perm],\n                                       dimnames=x@dimnames[perm],\n                                       SVT=new_SVT,\n                                       check=FALSE)\n    }\n    S4Arrays:::extended_aperm(a, perm, aperm0_SVT)\n}\n\n### S3/S4 combo for aperm.COO_SparseArray\naperm.COO_SparseArray <- function(a, perm, ...) .aperm_COO(a, perm, ...)\nsetMethod(\"aperm\", \"COO_SparseArray\", aperm.COO_SparseArray)\n\n### S3/S4 combo for aperm.SVT_SparseArray\naperm.SVT_SparseArray <- function(a, perm, ...) .aperm_SVT(a, perm, ...)\nsetMethod(\"aperm\", \"SVT_SparseArray\", aperm.SVT_SparseArray)\n\n",
        "SparseArray-class.R": "### =========================================================================\n### SparseArray objects\n### -------------------------------------------------------------------------\n\n\n### SparseArray is virtual class with 2 concrete subclasses: COO_SparseArray\n### and SVT_SparseArray.\n###\n### The SparseArray API:\n### 1) Implemented in this file:\n###    - Getters dim(), length(), dimnames(), type()\n###    - Setters `dimnames<-`() and `type<-`()\n###    - An is_sparse() method that returns TRUE\n### 2) Implemented elsewhere:\n###    - nzcount(), nzwhich(), nzvals(), and `nzvals<-`()\n###    - as.array()\n###    - extract_array() and extract_sparse_array()\n###    - Subsetting (`[`) and subassignment (`[<-`)\n###    - read_block_as_dense() and read_block_as_sparse()\n###    - abind(), arbind(), acbind()\n###    - aperm()\n\nsetClass(\"SparseArray\",\n    contains=\"Array\",\n    representation(\n        \"VIRTUAL\",\n        dim=\"integer\",\n        dimnames=\"list\"    # List with one list element per dimension. Each\n                           # list element must be NULL or a character vector.\n    ),\n    prototype(\n        dim=0L,\n        dimnames=list(NULL)\n    )\n)\n\n.validate_SparseArray <- function(x)\n{\n    msg <- S4Arrays:::validate_dim_slot(x, \"dim\")\n    if (!isTRUE(msg))\n        return(msg)\n    msg <- S4Arrays:::validate_dimnames_slot(x, x@dim)\n    if (!isTRUE(msg))\n        return(msg)\n    TRUE\n}\nsetValidity2(\"SparseArray\", .validate_SparseArray)\n\n### Extending RectangularData gives us a few things for free (e.g. validity\n### method for RectangularData objects, head(), tail(), etc...). Note\n### that even though SparseMatrix already extends Array (via SparseArray),\n### we need to make it a *direct* child of Array, and to list Array *before*\n### RectangularData in the 'contains' field below. This will ensure that\n### method dispatch will always choose the method for Array in case a generic\n### has methods defined for both, Array and RectangularData.\n### Note that the fact that we need this \"hack\" is a hint that we could\n### achieve a cleaner class hierarchy by inserting a Matrix class in it.\n### Matrix would contain Array and RectangularData (in that order). Then\n### SparseMatrix would contain SparseArray and Matrix (in that order).\n### Unfortunately the Matrix package already defines a Matrix class so\n### we would need to use a different name.\nsetClass(\"SparseMatrix\",\n    contains=c(\"SparseArray\", \"Array\", \"RectangularData\"),\n    representation(\"VIRTUAL\"),\n    prototype(\n        dim=c(0L, 0L),\n        dimnames=list(NULL, NULL)\n    )\n)\n\n.validate_SparseMatrix <- function(x)\n{\n    if (length(x@dim) != 2L)\n        return(\"'dim' slot must be an integer vector of length 2\")\n    TRUE\n}\nsetValidity2(\"SparseMatrix\", .validate_SparseMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### dim(), dimnames(), and `dimnames<-`()\n###\n\nsetMethod(\"dim\", \"SparseArray\", function(x) x@dim)\n\nsetMethod(\"dimnames\", \"SparseArray\",\n    function(x) S4Arrays:::simplify_NULL_dimnames(x@dimnames)\n)\n\nsetReplaceMethod(\"dimnames\", \"SparseArray\",\n    function(x, value)\n    {\n        x@dimnames <- S4Arrays:::normarg_dimnames(value, dim(x))\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_sparse() method\n###\n\nsetMethod(\"is_sparse\", \"SparseArray\", function(x) TRUE)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### show()\n###\n\nsetMethod(\"classNameForDisplay\", \"SparseArray\", function(x) \"SparseArray\")\nsetMethod(\"classNameForDisplay\", \"SparseMatrix\", function(x) \"SparseMatrix\")\n\nshow_headline_part1 <- function(x)\n{\n    sprintf(\"<%s %s> of type \\\"%s\\\" \", paste0(dim(x), collapse=\" x \"),\n                                       classNameForDisplay(x), type(x))\n}\n\n.show_nzcount <- function(x)\n{\n    ## Calling nzcount(x) will fail if 'x' is an SVT_SparseArray object\n    ## that uses version 0 of the SVT internal layout.\n    x_nzcount <- nzcount(x)\n    x_density <- x_nzcount / length(x)\n    sprintf(\"[nzcount=%s (%s%%)]\", format(x_nzcount),\n                                   signif(100 * x_density, digits=2))\n}\n\nsetMethod(\"show\", \"SparseArray\",\n    function(object)\n    {\n        ## Only reason we print the headline in 2 steps is because we\n        ## want to make sure to print at least something (part1) even\n        ## when printing part2 is going to fail. This will happen for\n        ## example if the call to nzcount() in .show_nzcount() fails.\n        cat(show_headline_part1(object))\n        cat(.show_nzcount(object))\n        if (any(dim(object) == 0L)) {\n            cat(\"\\n\")\n            return()\n        }\n        cat(\":\\n\", sep=\"\")\n        S4Arrays:::print_some_array_elements(object)\n    }\n)\n\n",
        "SparseArray-dim-tuning.R": "### =========================================================================\n### Dim tuning of a SparseArray object\n### -------------------------------------------------------------------------\n###\n### See R/dim-tuning-utils.R in the S4Arrays package for more information\n### about \"dim tuning\" and the tune_Array_dims() generic.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### tune_Array_dims() method for SVT_SparseArray objects\n###\n### This is the workhorse behind drop() and dim<-() on SVT_SparseArray\n### objects.\n###\n### Unlike with S4Arrays:::tune_dims() and S4Arrays:::tune_dimnames(),\n### the 'dim_tuner' vector passed to .tune_SVT_SparseArray_dims() must\n### be normalized. See src/SparseArray_dim_tuning.c for more information.\n\n.tune_SVT_SparseArray_dims <- function(x, dim_tuner)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"), is.integer(dim_tuner))\n    check_svt_version(x)\n\n    ans_SVT <- SparseArray.Call(\"C_tune_SVT_dims\",\n                                x@dim, x@type, x@SVT, dim_tuner)\n    ans_dim <- S4Arrays:::tune_dims(x@dim, dim_tuner)\n    ans_dimnames <- S4Arrays:::tune_dimnames(x@dimnames, dim_tuner)\n\n    new_SVT_SparseArray(ans_dim, ans_dimnames, x@type, ans_SVT, check=FALSE)\n}\n\nsetMethod(\"tune_Array_dims\", \"SVT_SparseArray\", .tune_SVT_SparseArray_dims)\n\n",
        "SparseArray-matrixStats.R": "### =========================================================================\n### matrixStats methods for SparseMatrix and SparseArray objects\n### -------------------------------------------------------------------------\n###\n### About matrixStats usage in Bioconductor: Based on some quick grep-based\n### inspection, the matrixStats operations used by Bioconductor software\n### packages are (looking at the col* functions only):\n###   (1) Heavily used: colSums, colMeans, colMedians, colVars, colSds,\n###       colMaxs, colMins, colMeans2, colSums2\n###   (2) Not so heavily used: colRanges, colRanks, colQuantiles, colMads,\n###       colIQRs\n###   (3) Marginally used: colAlls, colCumsums, colWeightedMeans, colAnyNAs\n###\n### Notes:\n### - colSums() and colMeans() are functions actually defined in the base\n###   package but we still count them as part of the matrixStats family.\n### - All other matrix col/row summarization operations are from the\n###   matrixStats package.\n### - The MatrixGenerics package defines S4 generics for all the matrix\n###   col/row summarization functions.\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level helpers\n###\n\nnormarg_dims <- function(dims)\n{\n    if (!isSingleNumber(dims))\n        stop(wmsg(\"'dims' must be a single integer\"))\n    if (!is.integer(dims))\n        dims <- as.integer(dims)\n    dims\n}\n\n### Returns TRUE or FALSE.\nnormarg_useNames <- function(useNames=NA)\n{\n    if (!(is.logical(useNames) && length(useNames) == 1L))\n        stop(wmsg(\"'useNames' must be a single logical value\"))\n    !isFALSE(useNames)\n}\n\ncheck_rows_cols <- function(rows, cols, method, class)\n{\n    if (!(is.null(rows) && is.null(cols)))\n        stop(wmsg(\"the \", method, \"() method for \", class, \" objects \",\n                  \"does not support the 'rows' or 'cols' argument\"))\n}\n\nstopifnot_2D_object <- function(x, method, class1, class2)\n{\n    if (length(dim(x)) != 2L)\n        stop(wmsg(\"the \", method, \"() method for \", class1, \" objects \",\n                  \"only supports 2D objects (i.e. \", class2, \" objects) \",\n                  \"at the moment\"))\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .colStats_SparseArray() and .rowStats_SparseArray()\n###\n### Workhorses behind all the matrixStats methods for SparseArray objects,\n### with the exception of the colMedians()/rowMedians() methods at the moment.\n###\n\n### Returns an ordinary array with 'length(dim(x)) - dims' dimensions.\n.colStats_SparseArray <- function(op, x, na.rm=FALSE, center=NULL, dims=1L,\n                                  useNames=NA)\n{\n    stopifnot(isSingleString(op), is(x, \"SparseArray\"))\n\n    ## Normalize and check 'dims'.\n    dims <- normarg_dims(dims)\n    if (dims <= 0L || dims > length(x@dim))\n        stop(wmsg(\"'dims' must be a single integer that is \",\n                  \"> 0 and <= length(dim(x)) for the col*() functions, and \",\n                  \">= 0 and < length(dim(x)) for the row*() functions\"))\n\n    if (is(x, \"SVT_SparseArray\")) {\n        check_svt_version(x)\n    } else {\n        x <- as(x, \"SVT_SparseArray\")\n    }\n\n    ## Check 'na.rm'.\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    ## Check and normalize 'center'.\n    if (is.null(center)) {\n        center <- NA_real_\n    } else {\n        if (!isSingleNumberOrNA(center))\n            stop(wmsg(\"'center' must be NULL or a single number\"))\n        if (!is.double(center))\n            center <- as.double(center)\n    }\n\n    ## Normalize 'useNames'.\n    useNames <- normarg_useNames(useNames)\n\n    x_dimnames <- if (useNames) x@dimnames else NULL\n    SparseArray.Call(\"C_colStats_SVT\",\n                     x@dim, x_dimnames, x@type, x@SVT, FALSE,\n                     op, na.rm, center, dims)\n}\n\n### .OLD_rowStats_SparseArray(): A lazy and inefficient implementation\n### that passes the ball to .colStats_SparseArray() to actually do the job.\n### TODO: Drop it once .rowStats_SparseArray() below supports all ops.\n### The naive implementation for .OLD_rowStats_SparseArray() would be to\n### simply do:\n###\n###   aperm(.colStats_SparseArray(op, aperm(x), ..., dims=length(dim(x))-dims))\n###\n### This is semantically correct for any number of dimensions. However,\n### it is VERY inefficient when 'x' is a SVT_SparseArray object with more\n### than 2 dimensions because multidimensional transposition of 'x' (i.e.\n### 'aperm(x)') is VERY expensive in that case. So we use some tricks below\n### to avoid this multidimensional transposition.\n.OLD_rowStats_SparseArray <- function(op, x, na.rm=FALSE, center=NULL, dims=1L,\n                                      useNames=NA)\n{\n    ## Normalize 'useNames'.\n    useNames <- normarg_useNames(useNames)\n\n    x_ndim <- length(x@dim)\n\n    if (is(x, \"COO_SparseArray\")) {\n        ans <- .colStats_SparseArray(op, as(aperm(x), \"SVT_SparseArray\"),\n                                     na.rm=na.rm, center=center,\n                                     dims=x_ndim-dims, useNames=useNames)\n        if (!is.null(dim(ans)))\n            ans <- aperm(ans)\n        return(ans)\n    }\n\n    check_svt_version(x)\n    if (x_ndim <= 2L || length(x) == 0L) {\n        if (x_ndim >= 2L)\n            x <- aperm(x)\n        ans <- .colStats_SparseArray(op, x, na.rm=na.rm, center=center,\n                                     dims=x_ndim-dims, useNames=useNames)\n        if (!is.null(dim(ans)))\n            ans <- aperm(ans)\n        return(ans)\n    }\n\n    extract_j_slice <- function(j) {\n        index <- vector(\"list\", x_ndim)\n        index[[2L]] <- j\n        slice <- subset_SVT_by_Nindex(x, index, ignore.dimnames=TRUE)\n        dim(slice) <- dim(x)[-2L]  # 'x_ndim - 1' dimensions\n        slice\n    }\n\n    if (dims == 1L) {\n        x <- aperm(x, perm=c(2:1, 3:x_ndim))\n        ## We summarize the individual slices obtained by walking along the\n        ## 2nd dimension of 'x'. Each slice has 'x_ndim - 1' dimensions.\n        ans <- sapply(seq_len(x@dim[[2L]]),\n            function(j) {\n                slice <- extract_j_slice(j)  # 'x_ndim - 1' dimensions\n                .colStats_SparseArray(op, slice, na.rm=na.rm, center=center,\n                                      dims=x_ndim-1L, useNames=FALSE)\n            })\n        if (useNames)\n            names(ans) <- x@dimnames[[2L]]\n        return(ans)\n    }\n\n    if (dims == 2L) {\n        ## We summarize the individual slices obtained by walking along the\n        ## 2nd dimension of 'x'. Each slice has 'x_ndim - 1' dimensions.\n        ans_cols <- lapply(seq_len(x@dim[[2L]]),\n            function(j) {\n                slice <- extract_j_slice(j)  # 'x_ndim - 1' dimensions\n                .OLD_rowStats_SparseArray(op, slice, na.rm=na.rm,\n                                          center=center, useNames=FALSE)\n            })\n        ans <- do.call(cbind, ans_cols)\n        if (useNames)\n            dimnames(ans) <- dimnames(x)[1:2]\n        return(ans)\n    }\n\n    stop(wmsg(\"row*(<SVT_SparseArray>) summarizations \",\n              \"don't support 'dims' >= 3 yet\"))\n}\n\n### Returns an ordinary array where the number of dimensions is 'dims'.\n### TODO: Speed up more row summarization methods by supporting natively\n### more operations in .Call entry point C_rowStats_SVT. Note that doing\n### this for \"sum\" led to a 20x or more speedup on big SVT_SparseArray\n### objects.\n.rowStats_SparseArray <- function(op, x, na.rm=FALSE, center=NULL, dims=1L,\n                                  useNames=NA)\n{\n    stopifnot(isSingleString(op), is(x, \"SparseArray\"))\n\n    ## Normalize and check 'dims'.\n    dims <- normarg_dims(dims)\n    if (dims < 0L || dims >= length(x@dim))\n        stop(wmsg(\"'dims' must be a single integer that is \",\n                  \"> 0 and <= length(dim(x)) for the col*() functions, and \",\n                  \">= 0 and < length(dim(x)) for the row*() functions\"))\n\n    if (dims == 0L)\n        return(.colStats_SparseArray(op, x, na.rm=na.rm, center=center,\n                                     dims=length(x@dim), useNames=useNames))\n\n    if (!(op %in% c(\"countNAs\", \"anyNA\", \"min\", \"max\",\n                    \"sum\", \"centered_X2_sum\")))\n        return(.OLD_rowStats_SparseArray(op, x, na.rm=na.rm,\n                                         center=center, dims=dims,\n                                         useNames=useNames))\n\n    if (is(x, \"SVT_SparseArray\")) {\n        check_svt_version(x)\n    } else {\n        x <- as(x, \"SVT_SparseArray\")\n    }\n\n    ## Check 'na.rm'.\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    ## Check and normalize 'center'.\n    if (!is.null(center)) {\n        ## Unlike for .colStats_SparseArray() where 'center' can only be NULL\n        ## or a single number, here it can also be an ordinary numeric array\n        ## of the same dimensions as the result of .rowStats_SparseArray()\n        ## (i.e. of dimensions 'head(dim(x), n=dims)'), or a numeric vector\n        ## of the same length as the result of .rowStats_SparseArray().\n        if (!is.numeric(center))\n            stop(wmsg(\"'center' must be NULL, a single number, \",\n                      \"or an ordinary array\"))\n        ans_dim <- head(dim(x), n=dims)\n        if (is.array(center)) {\n            if (!identical(dim(center), ans_dim))\n                stop(wmsg(\"unexpected 'center' dimensions\"))\n            if (storage.mode(center) != \"double\")\n                storage.mode(center) <- \"double\"\n        } else if (length(center) %in% c(1L, prod(ans_dim))) {\n            center <- array(as.double(center), dim=ans_dim)\n        } else {\n            stop(wmsg(\"unexpected 'center' length\"))\n        }\n    }\n\n    ## Normalize 'useNames'.\n    useNames <- normarg_useNames(useNames)\n\n    x_dimnames <- if (useNames) x@dimnames else NULL\n    SparseArray.Call(\"C_rowStats_SVT\",\n                     x@dim, x_dimnames, x@type, x@SVT, FALSE,\n                     op, na.rm, center, dims)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colCountNAs/rowCountNAs\n###\n### Not part of the matrixStats API!\n\n.colCountNAs_SparseArray <- function(x, dims=1, useNames=NA)\n{\n    .colStats_SparseArray(\"countNAs\", x, dims=dims, useNames=useNames)\n}\n#setMethod(\"colCountNAs\", \"SparseArray\", .colCountNAs_SparseArray)\n\n.rowCountNAs_SparseArray <- function(x, dims=1, useNames=NA)\n{\n    .rowStats_SparseArray(\"countNAs\", x, dims=dims, useNames=useNames)\n}\n#setMethod(\"rowCountNAs\", \"SparseArray\", .rowCountNAs_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .colCountVals_SparseArray()/.rowCountVals_SparseArray()\n###\n### Count the number of non-NA vals per column/row.\n###\n### Both functions return a single value if 'na.rm' is FALSE, or an unnamed\n### ordinary vector, matrix, or array if 'na.rm' is TRUE.\n\n.colCountVals_SparseArray <- function(x, na.rm=FALSE, dims=1)\n{\n    stopifnot(is(x, \"SparseArray\"))\n    dims <- normarg_dims(dims)\n    ans <- prod(head(dim(x), n=dims))\n    if (na.rm) {\n        count_nas <- .colCountNAs_SparseArray(x, dims=dims, useNames=FALSE)\n        ans <- ans - count_nas\n    }\n    ans\n}\n\n.rowCountVals_SparseArray <- function(x, na.rm=FALSE, dims=1)\n{\n    stopifnot(is(x, \"SparseArray\"))\n    dims <- normarg_dims(dims)\n    ans <- prod(tail(dim(x), n=-dims))\n    if (na.rm) {\n        count_nas <- .rowCountNAs_SparseArray(x, dims=dims, useNames=FALSE)\n        ans <- ans - count_nas\n    }\n    ans\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colAnyNAs/rowAnyNAs\n###\n\n.colAnyNAs_SparseArray <-\n    function(x, rows=NULL, cols=NULL, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colAnyNAs\", \"SparseArray\")\n    .colStats_SparseArray(\"anyNA\", x, dims=dims, useNames=useNames)\n}\nsetMethod(\"colAnyNAs\", \"SparseArray\", .colAnyNAs_SparseArray)\n\n.rowAnyNAs_SparseArray <-\n    function(x, rows=NULL, cols=NULL, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowAnyNAs\", \"SparseArray\")\n    .rowStats_SparseArray(\"anyNA\", x, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowAnyNAs\", \"SparseArray\", .rowAnyNAs_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colAnys/rowAnys and colAlls/rowAlls\n###\n\n.colAnys_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colAnys\", \"SparseArray\")\n    .colStats_SparseArray(\"any\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colAnys\", \"SparseArray\", .colAnys_SparseArray)\n\n.rowAnys_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowAnys\", \"SparseArray\")\n    .rowStats_SparseArray(\"any\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowAnys\", \"SparseArray\", .rowAnys_SparseArray)\n\n.colAlls_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colAlls\", \"SparseArray\")\n    .colStats_SparseArray(\"all\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colAlls\", \"SparseArray\", .colAlls_SparseArray)\n\n.rowAlls_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowAlls\", \"SparseArray\")\n    .rowStats_SparseArray(\"all\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowAlls\", \"SparseArray\", .rowAlls_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colMins/rowMins, colMaxs/rowMaxs, and colRanges/rowRanges\n###\n\n.colMins_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colMins\", \"SparseArray\")\n    .colStats_SparseArray(\"min\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colMins\", \"SparseArray\", .colMins_SparseArray)\n\n.rowMins_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowMins\", \"SparseArray\")\n    .rowStats_SparseArray(\"min\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowMins\", \"SparseArray\", .rowMins_SparseArray)\n\n.colMaxs_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colMaxs\", \"SparseArray\")\n    .colStats_SparseArray(\"max\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colMaxs\", \"SparseArray\", .colMaxs_SparseArray)\n\n.rowMaxs_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowMaxs\", \"SparseArray\")\n    .rowStats_SparseArray(\"max\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowMaxs\", \"SparseArray\", .rowMaxs_SparseArray)\n\n.bind_mins_maxs <- function(mins, maxs, just.use.c)\n{\n    ## Bind 'mins' and 'maxs' together.\n    if (just.use.c)\n        return(c(mins, maxs))\n    if (is.null(dim(mins))) {\n        ans <- cbind(mins, maxs, deparse.level=0L)\n        dimnames(ans) <- S4Arrays:::simplify_NULL_dimnames(dimnames(ans))\n        return(ans)\n    }\n    ans_dimnames <- dimnames(mins)\n    dim(mins) <- c(dim(mins), 1L)\n    dim(maxs) <- c(dim(maxs), 1L)\n    ans <- S4Arrays:::simple_abind(mins, maxs, along=length(dim(mins)))\n    S4Arrays:::set_dimnames(ans, ans_dimnames)\n}\n\n.colRanges_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colRanges\", \"SparseArray\")\n    ## Using two passes at the moment and binding the two results in R.\n    ## TODO: Do all this in a single pass by calling\n    ## '.colStats_SparseArray(\"range\", ...)' and modifying .Call ENTRY POINT\n    ## C_colStats_SVT to perform the binding from the very start at the C level.\n    mins <- .colStats_SparseArray(\"min\", x, na.rm=na.rm, dims=dims,\n                                         useNames=useNames)\n    maxs <- .colStats_SparseArray(\"max\", x, na.rm=na.rm, dims=dims,\n                                         useNames=FALSE)\n    .bind_mins_maxs(mins, maxs, dims == length(dim(x)))\n}\nsetMethod(\"colRanges\", \"SparseArray\", .colRanges_SparseArray)\n\n.rowRanges_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowRanges\", \"SparseArray\")\n    ## Using two passes at the moment and binding the two results in R.\n    ## TODO: Do all this in a single pass by calling\n    ## '.rowStats_SparseArray(\"range\", ...)' and modifying .Call ENTRY POINT\n    ## C_colStats_SVT to perform the binding from the very start at the C level.\n    mins <- .rowStats_SparseArray(\"min\", x, na.rm=na.rm, dims=dims,\n                                         useNames=useNames)\n    maxs <- .rowStats_SparseArray(\"max\", x, na.rm=na.rm, dims=dims,\n                                         useNames=FALSE)\n    .bind_mins_maxs(mins, maxs, dims == 0L)\n}\nsetMethod(\"rowRanges\", \"SparseArray\", .rowRanges_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colSums/rowSums, colProds/rowProds, and colMeans/rowMeans\n###\n### The colSums/rowSums/colMeans/rowMeans functions in base R propagate the\n### dimnames so we do the same.\n\n.colSums_SparseArray <- function(x, na.rm=FALSE, dims=1)\n{\n    .colStats_SparseArray(\"sum\", x, na.rm=na.rm, dims=dims)\n}\nsetMethod(\"colSums\", \"SparseArray\", .colSums_SparseArray)\n\n.rowSums_SparseArray <- function(x, na.rm=FALSE, dims=1)\n{\n    .rowStats_SparseArray(\"sum\", x, na.rm=na.rm, dims=dims)\n}\nsetMethod(\"rowSums\", \"SparseArray\", .rowSums_SparseArray)\n\n.colProds_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colProds\", \"SparseArray\")\n    .colStats_SparseArray(\"prod\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colProds\", \"SparseArray\", .colProds_SparseArray)\n\n.rowProds_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowProds\", \"SparseArray\")\n    .rowStats_SparseArray(\"prod\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowProds\", \"SparseArray\", .rowProds_SparseArray)\n\n.colMeans_SparseArray <- function(x, na.rm=FALSE, dims=1)\n{\n    .colStats_SparseArray(\"mean\", x, na.rm=na.rm, dims=dims)\n}\nsetMethod(\"colMeans\", \"SparseArray\", .colMeans_SparseArray)\n\n.rowMeans_SparseArray <- function(x, na.rm=FALSE, dims=1)\n{\n    sums <- .rowSums_SparseArray(x, na.rm=na.rm, dims=dims)\n    nvals <- .rowCountVals_SparseArray(x, na.rm=na.rm, dims=dims)\n    sums / nvals\n}\nsetMethod(\"rowMeans\", \"SparseArray\", .rowMeans_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colSums2/rowSums2 and colMeans2/rowMeans2\n###\n\n.colSums2_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colSums2\", \"SparseArray\")\n    .colStats_SparseArray(\"sum\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colSums2\", \"SparseArray\", .colSums2_SparseArray)\n\n.rowSums2_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowSums2\", \"SparseArray\")\n    .rowStats_SparseArray(\"sum\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowSums2\", \"SparseArray\", .rowSums2_SparseArray)\n\n.colMeans2_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colMeans2\", \"SparseArray\")\n    .colStats_SparseArray(\"mean\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"colMeans2\", \"SparseArray\", .colMeans2_SparseArray)\n\n.rowMeans2_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowMeans2\", \"SparseArray\")\n    .rowStats_SparseArray(\"mean\", x, na.rm=na.rm, dims=dims, useNames=useNames)\n}\nsetMethod(\"rowMeans2\", \"SparseArray\", .rowMeans2_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colVars/rowVars and colSds/rowSds\n###\n\n### Equivalent to 'var(c(x, integer(padding)), ...)' but doesn't actually\n### realize the padding with zeros.\n.padded_var <- function(x, padding=0L, na.rm=FALSE, center=NULL)\n{\n    if (na.rm)\n        x <- x[!is.na(x)]\n    nvals <- length(x) + padding\n    if (nvals <= 1L)\n        return(NA_real_)\n    if (is.null(center)) {\n        center <- sum(x) / nvals\n    } else {\n        stopifnot(isSingleNumberOrNA(center))\n    }\n    delta <- x - center\n    s <- sum(delta * delta) + center * center * padding\n    s / (nvals - 1L)\n}\n\n### Returns a numeric vector of length 'ncol(x)'.\n.normarg_center <- function(center, x, na.rm=FALSE)\n{\n    if (is.null(center))\n        return(colMeans(x, na.rm=na.rm))\n    if (!is.numeric(center))\n        stop(wmsg(\"'center' must be NULL or a numeric vector\"))\n    x_ncol <- ncol(x)\n    if (length(center) != x_ncol) {\n        if (length(center) != 1L)\n            stop(wmsg(\"'center' must have one element per row \",\n                      \"or column in the SparseMatrix object\"))\n        center <- rep.int(center, x_ncol)\n    }\n    center\n}\n\n### Original \"pure R\" implementation. Was originally used by the colVars()\n### method for SVT_SparseMatrix objects. No longer used!\n.colVars_SparseMatrix <-\n    function(x, na.rm=FALSE, center=NULL, useNames=NA)\n{\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    useNames <- normarg_useNames(useNames)\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    if (x_nrow <= 1L) {\n        ans <- rep.int(NA_real_, x_ncol)\n    } else {\n        center <- .normarg_center(center, x, na.rm=na.rm)\n        ans <- center * center * x_nrow / (x_nrow - 1L)\n        if (!is.null(x@SVT)) {\n            ans <- vapply(seq_along(x@SVT),\n                function(i) {\n                    lv <- x@SVT[[i]]\n                    if (is.null(lv))\n                        return(ans[[i]])\n                    lv_vals <- lv[[2L]]\n                    padding <- x_nrow - length(lv_vals)\n                    .padded_var(lv_vals, padding, na.rm=na.rm,\n                                center=center[[i]])\n                }, numeric(1), USE.NAMES=FALSE)\n        }\n    }\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\n.colVars_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colVars\", \"SparseArray\")\n    .colStats_SparseArray(\"var1\", x, na.rm=na.rm, center=center,\n                                  dims=dims, useNames=useNames)\n}\nsetMethod(\"colVars\", \"SparseArray\", .colVars_SparseArray)\n\n.rowVars_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowVars\", \"SparseArray\")\n    nvals <- .rowCountVals_SparseArray(x, na.rm=na.rm, dims=dims)\n    if (is.null(center)) {\n        sums <- .rowSums_SparseArray(x, na.rm=na.rm, dims=dims)\n        center <- sums / nvals\n    }\n    centered_X2_sums <- .rowStats_SparseArray(\"centered_X2_sum\",\n                                              x, na.rm=na.rm, center=center,\n                                              dims=dims, useNames=useNames)\n    centered_X2_sums / (nvals - 1)\n}\nsetMethod(\"rowVars\", \"SparseArray\", .rowVars_SparseArray)\n\n.colSds_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"colSds\", \"SparseArray\")\n    .colStats_SparseArray(\"sd1\", x, na.rm=na.rm, center=center,\n                                 dims=dims, useNames=useNames)\n}\nsetMethod(\"colSds\", \"SparseArray\", .colSds_SparseArray)\n\n.rowSds_SparseArray <-\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, center=NULL,\n                dims=1, ..., useNames=NA)\n{\n    check_unused_arguments(...)\n    check_rows_cols(rows, cols, \"rowSds\", \"SparseArray\")\n    row_vars <- .rowVars_SparseArray(x, na.rm=na.rm, center=center,\n                                     dims=dims, useNames=useNames)\n    sqrt(row_vars)\n}\nsetMethod(\"rowSds\", \"SparseArray\", .rowSds_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colMedians/rowMedians\n###\n### TODO: How hard would it be to replace current \"pure R\" implementation\n### with C implementation available thru .Call ENTRY POINT C_colStats_SVT ?\n\n### All values in 'x' are **assumed** to be >= 0 but we don't check this!\n### 'padding' is expected to be < length(x).\n.positive_padded_median <- function(x, padding=0L)\n{\n    x_len <- length(x)\n    stopifnot(padding < x_len)\n    n <- x_len + padding\n    if (n %% 2L == 1L) {\n        middle <- (n + 1L) %/% 2L\n        partial <- middle - padding\n        return(sort(x, partial=partial)[partial])\n    }\n    i1 <- n %/% 2L - padding\n    i2 <- i1 + 1L\n    mean(sort(x, partial=i2)[i1:i2])\n}\n\n### Equivalent to 'median(c(x, integer(padding)), ...)' but doesn't actually\n### realize the padding with zeros.\n.padded_median <- function(x, padding=0L, na.rm=FALSE)\n{\n    if (na.rm) {\n        x <- x[!is.na(x)]\n    } else {\n        if (anyNA(x))\n            return(NA_real_)\n    }\n    n <- length(x) + padding\n    if (n == 0L)\n        return(NA_real_)\n    if (padding > length(x))\n        return(0)\n\n    ## Handle case where we have more positive values than non-positive values.\n    pos_idx <- which(x > 0L)\n    pos_count <- length(pos_idx)\n    nonpos_count <- n - pos_count\n    if (pos_count > nonpos_count) {\n        ans <- .positive_padded_median(x[pos_idx], padding=nonpos_count)\n        return(ans)\n    }\n\n    ## Handle case where we have more negative values than non-negative values.\n    neg_count <- length(x) - pos_count\n    nonneg_count <- n - neg_count\n    if (neg_count > nonneg_count) {\n        ans <- - .positive_padded_median(-x[-pos_idx], padding=nonneg_count)\n        return(ans)\n    }\n\n    if (n %% 2L == 1L)\n        return(0)\n\n    half <- n %/% 2L\n    if (pos_count == half) {\n        right <- min(x[pos_idx])\n    } else {\n        right <- 0\n    }\n    if (neg_count == half) {\n        left <- max(x[-pos_idx])\n    } else {\n        left <- 0\n    }\n    (left + right) * 0.5\n}\n\n.colMedians_SVT_SparseMatrix <- function(x, na.rm=FALSE, useNames=NA)\n{\n    stopifnot(is(x, \"SVT_SparseMatrix\"))\n    check_svt_version(x)\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    useNames <- normarg_useNames(useNames)\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    if (x_nrow == 0L) {\n        ans <- rep.int(NA_real_, x_ncol)\n    } else {\n        ans <- numeric(x_ncol)\n        if (!is.null(x@SVT)) {\n            ans <- vapply(seq_along(x@SVT),\n                function(i) {\n                    lv <- x@SVT[[i]]\n                    if (is.null(lv))\n                        return(ans[[i]])\n                    lv_vals <- lv[[2L]]\n                    padding <- x_nrow - length(lv_vals)\n                    .padded_median(lv_vals, padding, na.rm=na.rm)\n                }, numeric(1), USE.NAMES=FALSE)\n        }\n    }\n    if (useNames)\n        names(ans) <- colnames(x)\n    ans\n}\n\nsetMethod(\"colMedians\", \"SparseArray\",\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, ..., useNames=NA)\n    {\n        check_unused_arguments(...)\n        stopifnot_2D_object(x, \"colMedians\", \"SparseArray\", \"SparseMatrix\")\n        check_rows_cols(rows, cols, \"colMedians\", \"SparseArray\")\n        if (!is(x, \"SVT_SparseArray\"))\n            x <- as(x, \"SVT_SparseArray\")\n        .colMedians_SVT_SparseMatrix(x, na.rm=na.rm, useNames=useNames)\n    }\n)\n\nsetMethod(\"rowMedians\", \"SparseArray\",\n    function(x, rows=NULL, cols=NULL, na.rm=FALSE, ..., useNames=NA)\n    {\n        check_unused_arguments(...)\n        stopifnot_2D_object(x, \"rowMedians\", \"SparseArray\", \"SparseMatrix\")\n        check_rows_cols(rows, cols, \"rowMedians\", \"SparseArray\")\n        tx <- t(x)\n        if (!is(tx, \"SVT_SparseArray\"))\n            tx <- as(tx, \"SVT_SparseArray\")\n        .colMedians_SVT_SparseMatrix(tx, na.rm=na.rm, useNames=useNames, ...)\n    }\n)\n\n",
        "SparseArray-misc-methods.R": "### =========================================================================\n### Miscellaneous operations on SparseArray objects\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Various \"unary isometric\" array transformations\n###\n### A \"unary isometric\" array transformation is a transformation that returns\n### an array-like object with the same dimensions as the input and where each\n### element is the result of applying a function to the corresponding element\n### in the input.\n###\n### Note that:\n### - Some \"unary isometric\" transformations preserve sparsity (e.g. is.na(),\n###   nchar(), round(), sqrt(), log1p(), etc...) and others don't (e.g.\n###   is.finite(), !, log(), etc..). SparseArray objects only need to support\n###   the former.\n### - All operations from the 'Math' and 'Math2' groups are \"unary isometric\"\n###   transformations (see '?S4groupGeneric'). The corresponding methods for\n###   SparseArray objects are implemented in R/SparseArray-Math-methods.R\n### - All the \"unary isometric\" methods implemented below return an array-like\n###   object of the same class as the input (endomorphism).\n\n### --- Methods for COO_SparseArray objects ---\n\n.isoFUN_COO <- function(isoFUN, x, ...)\n{\n    GENERIC <- match.fun(isoFUN)\n    new_nzdata <- GENERIC(x@nzdata, ...)\n    BiocGenerics:::replaceSlots(x, nzdata=new_nzdata, check=FALSE)\n}\n\nsetMethod(\"is.na\", \"COO_SparseArray\",\n    function(x) .isoFUN_COO(\"is.na\", x)\n)\nsetMethod(\"is.nan\", \"COO_SparseArray\",\n    function(x) .isoFUN_COO(\"is.nan\", x)\n)\nsetMethod(\"is.infinite\", \"COO_SparseArray\",\n    function(x) .isoFUN_COO(\"is.infinite\", x)\n)\nsetMethod(\"tolower\", \"COO_SparseArray\",\n    function(x) .isoFUN_COO(\"tolower\", x)\n)\nsetMethod(\"toupper\", \"COO_SparseArray\",\n    function(x) .isoFUN_COO(\"toupper\", x)\n)\nsetMethod(\"nchar\", \"COO_SparseArray\",\n    function(x, type=\"chars\", allowNA=FALSE, keepNA=NA)\n        .isoFUN_COO(\"nchar\", x, type=type, allowNA=allowNA, keepNA=keepNA)\n)\n\n### --- Methods for SVT_SparseArray objects ---\n\n### Returns a \"logical\" SVT_SparseArray object.\n.isFUN_SVT <- function(isFUN, x)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    new_SVT <- SparseArray.Call(\"C_SVT_apply_isFUN\",\n                                x@dim, x@type, x@SVT, isFUN)\n    BiocGenerics:::replaceSlots(x, type=\"logical\", SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"is.na\", \"SVT_SparseArray\",\n    function(x) .isFUN_SVT(\"is.na\", x)\n)\nsetMethod(\"is.nan\", \"SVT_SparseArray\",\n    function(x) .isFUN_SVT(\"is.nan\", x)\n)\nsetMethod(\"is.infinite\", \"SVT_SparseArray\",\n    function(x) .isFUN_SVT(\"is.infinite\", x)\n)\n\n### TODO: Support more methods!\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Various \"N-ary isometric\" array transformations\n###\n### An \"N-ary isometric\" array transformation is a transformation that takes\n### one or more array-like objects of the same dimensions (a.k.a. conformable\n### arrays) and returns an array-like object of the same dimensions.\n###\n### Note that:\n### - All operations from the 'Ops' group are \"N-ary isometric\"\n###   transformations (see '?S4groupGeneric'). The corresponding\n###   methods for SparseArray objects are implemented in files\n###   R/SparseArray-[Arith|Compare|Logic]-methods.R.\n### - If all the input arrays have the same class then the \"N-ary isometric\"\n###   methods implemented below return an array-like object of that class\n###   (endomorphism).\n\n### Binary pmin() and pmax() between two conformable array-like objects.\n### We go for a pure R implementation for now that relies on `<` (or `>`),\n### nzwhich(), linear subsetting (`[`), linear subassignment (`[<-`), and\n### is.na(), so it works on any array-like object that supports these\n### operations e.g. on ordinary arrays or dgCMatrix objects. However it\n### won't work on COO_SparseArray objects because these objects don't support\n### some of the required operations like `<` or linear subsetting. Sparsity\n### is preserved all along so it's pretty efficient. Of course nothing would\n### beat a C implementation but this is good enough for now.\n### About base::pmin() and base::pmax(): These are also pure R implementations\n### that would **almost** work on SVT_SparseArray objects except that they\n### rely on logical negation (!) of the array which SVT_SparseArray objects\n### don't support because it does NOT preserve sparsity. However this what\n### pmin()/pmax() use on dgCMatrix objects (there are no dedicated pmin()\n### or pmax() methods for dgCMatrix objects as of Matrix 1.7-0), which is\n### not very efficient.\n.pminmax2 <- function(op, x, y, na.rm=FALSE)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"), is(y, \"SVT_SparseArray\"))\n    op <- match.fun(op)\n    ans <- x\n    replace_idx <- nzwhich(op(y, x))\n    ## This subassignment will take care of setting the type of 'ans'\n    ## to the \"biggest\" of 'type(x)' and 'type(y)' so it's a good\n    ## idea to do it even if there's nothing to replace (i.e. even\n    ## if 'length(replace_idx)' is 0).\n    ans[replace_idx] <- y[replace_idx]\n\n    if (na.rm) {\n        ## The above replacement propagated NAs from 'y' to 'ans'.\n        ## We need to revert that.\n        is_na <- is.na(y)\n    } else {\n        ## The above replacement may have replaced NAs in 'ans' with\n        ## non-NA values from 'y'. We need to revert that.\n        is_na <- is.na(x)\n    }\n    restore_idx <- nzwhich(is_na)\n    ans[restore_idx] <- x[restore_idx]\n\n    ans_dimnames <- S4Arrays:::get_first_non_NULL_dimnames(list(x, y))\n    S4Arrays:::set_dimnames(ans, ans_dimnames)\n}\n\n.pmin2 <- function(x, y, na.rm=FALSE) .pminmax2(\"<\", x, y, na.rm=na.rm)\n.pmax2 <- function(x, y, na.rm=FALSE) .pminmax2(\">\", x, y, na.rm=na.rm)\n\n.psummarize <- function(NaryFUN, binaryFUN, ..., na.rm=FALSE)\n{\n    NaryFUN <- match.fun(NaryFUN)\n    binaryFUN <- match.fun(binaryFUN)\n    objects <- S4Vectors:::delete_NULLs(list(...))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    if (length(objects) == 0L)\n        stop(wmsg(\"no input\"))  # should never happen\n\n    x <- objects[[1L]]\n    if (length(objects) == 1L)\n        return(x)   # no-op\n\n    if (length(objects) == 2L) {\n        y <- objects[[2L]]\n    } else {\n        ## Recursive.\n        y <- do.call(NaryFUN, c(objects[-1L], list(na.rm=na.rm)))\n    }\n    binaryFUN(x, y, na.rm=na.rm)\n}\n\n### Method dispatch will select these methods if and only if **all** the\n### objects passed thru the ellipsis (...) are SparseArray derivatives.\n### Note that even though the methods are defined for SparseArray objects,\n### they will fail on COO_SparseArray objects (see comment for \"Binary pmin()\n### and pmax() between two conformable array-like objects\" above).\nsetMethod(\"pmin\", \"SparseArray\",\n    function(..., na.rm=FALSE) .psummarize(\"pmin\", .pmin2, ..., na.rm=na.rm)\n)\nsetMethod(\"pmax\", \"SparseArray\",\n    function(..., na.rm=FALSE) .psummarize(\"pmax\", .pmax2, ..., na.rm=na.rm)\n)\n\n",
        "SparseArray-subassignment.R": "### =========================================================================\n### SparseArray subassignment\n### -------------------------------------------------------------------------\n###\n\n\nadjust_left_type <- function(x, value)\n{\n    stopifnot(is(x, \"SVT_SparseArray\") || is(x, \"NaArray\"))\n    check_svt_version(x)\n    if (!is.vector(value))\n        stop(wmsg(\"the supplied value must be a vector for this form \",\n                  \"of subassignment to an SVT_SparseArray object\"))\n    ## Change 'x' type if necessary.\n    new_type <- type(c(vector(type(x)), vector(type(value))))\n    type(x) <- new_type\n    x\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### subassign_Array_by_Lindex() and subassign_Array_by_Mindex() methods for\n### SVT_SparseArray\n###\n\n### Adjust the type of 'value' and recycle it to the length of the\n### subassignment M/L-index.\n.normalize_right_value <- function(value, left_type, index_len)\n{\n    if (length(value) == 0L)\n        stop(wmsg(\"replacement has length zero\"))\n    storage.mode(value) <- left_type\n    S4Vectors:::recycleVector(value, index_len)\n}\n\n.subassign_SVT_by_Lindex <- function(x, Lindex, value, old=FALSE)\n{\n    x <- adjust_left_type(x, value)\n    stopifnot(is.vector(Lindex), is.numeric(Lindex))\n\n    ## No-op (except for type adjustment above) if selection is empty.\n    if (length(Lindex) == 0L)\n        return(x)\n\n    value <- .normalize_right_value(value, type(x), length(Lindex))\n\n    if (old) {\n        new_SVT <- SparseArray.Call(\"C_subassign_SVT_by_Lindex_OLD\",\n                                    x@dim, x@type, x@SVT, Lindex, value)\n    } else {\n        new_SVT <- SparseArray.Call(\"C_subassign_SVT_by_Lindex\",\n                                    x@dim, x@type, x@SVT, FALSE, Lindex, value)\n    }\n    BiocGenerics:::replaceSlots(x, SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"subassign_Array_by_Lindex\", \"SVT_SparseArray\",\n    function(x, Lindex, value) .subassign_SVT_by_Lindex(x, Lindex, value)\n)\n\n.subassign_SVT_by_Mindex <- function(x, Mindex, value)\n{\n    x <- adjust_left_type(x, value)\n    stopifnot(is.matrix(Mindex), is.numeric(Mindex))\n\n    ## No-op (except for type adjustment above) if selection is empty.\n    if (nrow(Mindex) == 0L)\n        return(x)\n\n    value <- .normalize_right_value(value, type(x), nrow(Mindex))\n\n    if (storage.mode(Mindex) != \"integer\")\n        storage.mode(Mindex) <- \"integer\"\n    new_SVT <- SparseArray.Call(\"C_subassign_SVT_by_Mindex_OLD\",\n                                x@dim, x@type, x@SVT, Mindex, value)\n    BiocGenerics:::replaceSlots(x, SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"subassign_Array_by_Mindex\", \"SVT_SparseArray\",\n    .subassign_SVT_by_Mindex\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### subassign_Array_by_Nindex() method for SVT_SparseArray\n###\n### Like the 'index' argument in 'extract_array()', the 'Nindex' argument in\n### all the functions below must be an N-index, that is, a list with one list\n### element per dimension in 'x'. Each list element must be an integer vector\n### of valid indices along the corresponding dimension in 'x', or a NULL.\n\n.subassign_SVT_with_short_Rvector <- function(x, Nindex, Rvector)\n{\n    stopifnot(is.vector(Rvector))\n    SparseArray.Call(\"C_subassign_SVT_with_short_Rvector\",\n                     x@dim, x@type, x@SVT, Nindex, Rvector)\n}\n\n.subassign_SVT_with_Rarray <- function(x, Nindex, Rarray)\n{\n    stopifnot(is.array(Rarray))\n    SparseArray.Call(\"C_subassign_SVT_with_Rarray\",\n                     x@dim, x@type, x@SVT, Nindex, Rarray)\n}\n\n.subassign_SVT_with_SVT <- function(x, Nindex, v)\n{\n    stopifnot(is(v, \"SVT_SparseArray\"))\n    check_svt_version(v)\n    SparseArray.Call(\"C_subassign_SVT_with_SVT\",\n                     x@dim, x@type, x@SVT, Nindex, v@dim, v@type, v@SVT)\n}\n\n.subassign_SVT_by_Nindex <- function(x, Nindex, value)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"), is.list(Nindex))\n    check_svt_version(x)\n    if (!is.vector(value) && !is.array(value) && !is(value, \"SVT_SparseArray\"))\n        stop(wmsg(\"the supplied value must be an ordinary vector or array, \",\n                  \"or an SVT_SparseArray object, for this subassignment\"))\n\n    ## Change 'x' type if necessary.\n    new_type <- type(c(vector(type(x)), vector(type(value))))\n    type(x) <- new_type\n\n    ## No-op (except for type change above) if selection is empty.\n    selection_dim <- S4Arrays:::get_Nindex_lengths(Nindex, x@dim)\n    if (any(selection_dim == 0L))\n        return(x)\n\n    if (is.vector(value)) {\n        value_len <- length(value)\n        if (value_len == 0L)\n            stop(wmsg(\"replacement has length zero\"))\n        selection_len <- prod(selection_dim)\n        if (value_len > selection_len)\n            stop(wmsg(\"the supplied value is longer than the selection\"))\n        storage.mode(value) <- new_type\n        if (value_len <= selection_dim[[1L]] &&\n            selection_dim[[1L]] %% value_len == 0L)\n        {\n            ## We want to support things like 'x[ , 1:2] <- 0'\n            ## or 'x[1:12, ] <- c(0.6, 0, 2.5)' in the most efficient\n            ## way so no recycling of 'value' at the R level.\n            new_SVT <- .subassign_SVT_with_short_Rvector(x, Nindex, value)\n        } else {\n            ## Turn 'value' into an ordinary array of the same dimensions\n            ## as the selection, with recycling if necessary.\n            a <- array(vector(typeof(value), 1L), dim=selection_dim)\n            a[] <- value\n            new_SVT <- .subassign_SVT_with_Rarray(x, Nindex, value)\n        }\n    } else {\n        if (!identical(selection_dim, unname(dim(value))))\n            stop(wmsg(\"the selection and supplied value must have \",\n                      \"the same dimensions\"))\n        if (is.array(value)) {\n            storage.mode(value) <- new_type\n            new_SVT <- .subassign_SVT_with_Rarray(x, Nindex, value)\n        } else {\n            type(value) <- new_type\n            new_SVT <- .subassign_SVT_with_SVT(x, Nindex, value)\n        }\n    }\n    BiocGenerics:::replaceSlots(x, SVT=new_SVT, check=FALSE)\n}\n\nsetMethod(\"subassign_Array_by_Nindex\", \"SVT_SparseArray\",\n    .subassign_SVT_by_Nindex\n)\n\n",
        "SparseArray-subsetting.R": "### =========================================================================\n### SparseArray subsetting\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### .subset_SVT_by_Lindex()\n### .subset_SVT_by_Mindex()\n###\n### Both return a vector (atomic or list) of the same type() as 'x'.\n###\n\npropagate_names_if_1D <- function(ans, x_dimnames, index)\n{\n    if (length(x_dimnames) != 1L)\n        return(ans)\n    stopifnot(is.list(x_dimnames))\n    x_names <- x_dimnames[[1L]]\n    if (is.null(x_names))\n        return(ans)\n    stopifnot(is.character(x_names),\n              identical(length(ans), length(index)))\n    setNames(ans, x_names[index])\n}\n\n### 'Lindex' must be a numeric vector (integer or double), possibly a long one.\n### NA indices are accepted.\n.subset_SVT_by_Lindex <- function(x, Lindex)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    stopifnot(is.vector(Lindex), is.numeric(Lindex))\n    on.exit(free_global_OPBufTree())\n    ans <- SparseArray.Call(\"C_subset_SVT_by_Lindex\",\n                            x@dim, x@type, x@SVT, FALSE, Lindex)\n    propagate_names_if_1D(ans, dimnames(x), Lindex)\n}\n\nsetMethod(\"subset_Array_by_Lindex\", \"SVT_SparseArray\", .subset_SVT_by_Lindex)\n\n### Alright, '.subset_SVT_by_Mindex(x, Mindex)' could just have done:\n###\n###     .subset_SVT_by_Lindex(x, Mindex2Lindex(Mindex, dim(x)))\n###\n### However, the C code in C_subset_SVT_by_Mindex() avoids the Mindex2Lindex()\n### step and so should be slightly more efficient, at least in theory. But is\n### it? Some quick testing suggests that there's actually no significant\n### difference!\n### TODO: Investigate this more.\n.subset_SVT_by_Mindex <- function(x, Mindex)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"))\n    check_svt_version(x)\n    stopifnot(is.matrix(Mindex))\n    x_dimnames <- dimnames(x)\n    if (!is.numeric(Mindex)) {\n        if (!is.character(Mindex))\n            stop(wmsg(\"invalid matrix subscript type \\\"\", type(Mindex), \"\\\"\"))\n        if (is.null(x_dimnames))\n            stop(wmsg(\"SparseArray object to subset has no dimnames\"))\n        ## Subsetting an ordinary array with dimnames on it by a character\n        ## matrix is supported in base R but we don't support this yet for\n        ## SparseArray objects.\n        stop(\"subsetting a SparseArray object by a character matrix \",\n             \"is not supported at the moment\")\n    }\n    on.exit(free_global_OPBufTree())\n    ans <- SparseArray.Call(\"C_subset_SVT_by_Mindex\",\n                            x@dim, x@type, x@SVT, FALSE, Mindex)\n    propagate_names_if_1D(ans, x_dimnames, Mindex)\n}\n\nsetMethod(\"subset_Array_by_Mindex\", \"SVT_SparseArray\", .subset_SVT_by_Mindex)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### subset_SVT_by_Nindex()\n###\n### In addition to being one of the workhorses behind `[` on an\n### SVT_SparseArray object (see below), this is **the** workhorse behind the\n### extract_sparse_array() and extract_array() methods for SVT_SparseArray\n### objects.\n###\n### 'Nindex' must be an N-index, that is, a list of numeric vectors (or NULLs),\n### one along each dimension in the array to subset. Note that, strictly\n### speaking, the vectors in an N-index are expected to be integer vectors,\n### but subset_SVT_by_Nindex() can handle subscripts of type \"double\".\n### This differs from the 'index' argument in 'extract_array()' where the\n### subscripts **must** be integer vectors.\n###\n### Returns an SVT_SparseArray object of the same type() as 'x' (endomorphism).\n\nsubset_SVT_by_Nindex <- function(x, Nindex, ignore.dimnames=FALSE)\n{\n    stopifnot(is(x, \"SVT_SparseArray\"),\n              is.list(Nindex),\n              length(Nindex) == length(x@dim),\n              isTRUEorFALSE(ignore.dimnames))\n    check_svt_version(x)\n\n    ## Returns 'new_dim' and 'new_SVT' in a list of length 2.\n    C_ans <- SparseArray.Call(\"C_subset_SVT_by_Nindex\",\n                              x@dim, x@type, x@SVT, Nindex)\n    new_dim <- C_ans[[1L]]\n    new_SVT <- C_ans[[2L]]\n\n    ## Compute 'new_dimnames'.\n    if (is.null(dimnames(x)) || ignore.dimnames) {\n        new_dimnames <- vector(\"list\", length(x@dim))\n    } else {\n        new_dimnames <- S4Arrays:::subset_dimnames_by_Nindex(x@dimnames, Nindex)\n    }\n    BiocGenerics:::replaceSlots(x, dim=new_dim,\n                                   dimnames=new_dimnames,\n                                   SVT=new_SVT,\n                                   check=FALSE)\n}\n\nsetMethod(\"subset_Array_by_Nindex\", \"SVT_SparseArray\",\n    function(x, Nindex) subset_SVT_by_Nindex(x, Nindex)\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_sparse_array() and extract_array() methods for SVT_SparseArray\n### objects\n###\n\n### No need to propagate the dimnames.\nsetMethod(\"extract_sparse_array\", \"SVT_SparseArray\",\n    function(x, index) subset_SVT_by_Nindex(x, index, ignore.dimnames=TRUE)\n)\n\n### Note that the default extract_array() method would do the job but it\n### relies on single-bracket subsetting so would needlessly go thru the\n### complex .subset_SVT_SparseArray() machinery above to finally call\n### subset_SVT_by_Nindex(). It would also propagate the dimnames which\n### extract_array() does not need to do. The method below completely bypasses\n### all this complexity by calling subset_SVT_by_Nindex() directly.\nsetMethod(\"extract_array\", \"SVT_SparseArray\",\n    function(x, index)\n        as.array(subset_SVT_by_Nindex(x, index, ignore.dimnames=TRUE))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### extract_sparse_array() and extract_array() methods for COO_SparseArray\n### objects\n###\n\n### IMPORTANT NOTE: The returned COO_SparseArray object is guaranteed to be\n### **correct** ONLY if the subscripts in 'index' do NOT contain duplicates!\n### If they contain duplicates, the correct COO_SparseArray object to return\n### should contain repeated nonzero data. However, in order to keep it as\n### efficient as possible, the code below does NOT repeat the nonzero data\n### that corresponds to duplicates subscripts. It does not check for\n### duplicates in 'index' either because this check could have a\n### significant cost.\n### All this is OK because .extract_COO_SparseArray_subset() should\n### always be used in a context where 'index' does NOT contain duplicates.\n### The only situation where 'index' CAN contain duplicates is when\n### .extract_COO_SparseArray_subset() is called by\n### .extract_array_from_COO_SparseArray(), in which case the\n### missing nonzero data are added later.\n.extract_COO_SparseArray_subset <- function(x, index)\n{\n    stopifnot(is(x, \"COO_SparseArray\"))\n    ans_dim <- S4Arrays:::get_Nindex_lengths(index, dim(x))\n    x_nzcoo <- x@nzcoo\n    for (along in seq_along(ans_dim)) {\n        i <- index[[along]]\n        if (is.null(i))\n            next\n        x_nzcoo[ , along] <- match(x_nzcoo[ , along], i)\n    }\n    ## Note that calling rowAnyNAs() on ordinary matrix 'x_nzcoo' would\n    ## also work as it would call the rowAnyNAs() S4 generic defined in\n    ## MatrixGenerics, and the latter would eventually dispatch on\n    ## matrixStats::rowAnyNAs(). However, calling matrixStats::rowAnyNAs()\n    ## should be slightly more efficient. Also note that this call is the\n    ## only reason why we list matrixStats in the Imports field.\n    keep_idx <- which(!matrixStats::rowAnyNAs(x_nzcoo))\n    ans_nzcoo <- x_nzcoo[keep_idx, , drop=FALSE]\n    ans_nzdata <- x@nzdata[keep_idx]\n    COO_SparseArray(ans_dim, ans_nzcoo, ans_nzdata, check=FALSE)\n}\nsetMethod(\"extract_sparse_array\", \"COO_SparseArray\",\n    .extract_COO_SparseArray_subset\n)\n\n.extract_array_from_COO_SparseArray <- function(x, index)\n{\n    coo0 <- .extract_COO_SparseArray_subset(x, index)\n    ## If the subscripts in 'index' contain duplicates, 'coo0' is\n    ## \"incomplete\" in the sense that it does not contain the nonzero data\n    ## that should have been repeated according to the duplicates in the\n    ## subscripts (see IMPORTANT NOTE above).\n    ans0 <- as.array(coo0)\n    ## We \"complete\" 'ans0' by repeating the nonzero data according to the\n    ## duplicates present in 'index'. Note that this is easy and cheap to\n    ## do now because 'ans0' uses a dense representation (it's an ordinary\n    ## array). This would be harder to do **natively** on the\n    ## COO_SparseArray form (i.e. without converting to dense first\n    ## then back to sparse).\n    sm_index <- lapply(index,\n        function(i) {\n            if (is.null(i))\n                return(NULL)\n            sm <- match(i, i)\n            if (isSequence(sm))\n                return(NULL)\n            sm\n        })\n    if (all(S4Vectors:::sapply_isNULL(sm_index)))\n        return(ans0)\n    S4Arrays:::subset_by_Nindex(ans0, sm_index)\n}\nsetMethod(\"extract_array\", \"COO_SparseArray\",\n    .extract_array_from_COO_SparseArray\n)\n\n",
        "SparseArray-summarization.R": "### =========================================================================\n### Summarization methods for SparseArray objects\n### -------------------------------------------------------------------------\n###\n### Summarization methods:\n###   - anyNA()\n###   - 'Summary' group: any(), all(), min(), max(), range(), sum(), prod()\n###   - mean()\n###   - Unary var(), sd()\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Workhorse behind all the summarization methods for SVT_SparseArray\n### and NaArray objects\n###\n\n### 'center' ignored by all ops except \"centered_X2_sum\".\n### Returns an integer or numeric vector of length 1 or 2.\nsummarize_SVT <- function(op, x, na.rm=FALSE, center=NULL)\n{\n    stopifnot(isSingleString(op), is(x, \"SVT_SparseArray\") || is(x, \"NaArray\"))\n    check_svt_version(x)\n\n    ## Check 'na.rm'.\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n\n    ## Check and normalize 'center'.\n    if (is.null(center)) {\n        center <- NA_real_\n    } else {\n        if (!isSingleNumberOrNA(center))\n            stop(wmsg(\"'center' must be NULL, or a single number\"))\n        if (!is.double(center))\n            center <- as.double(center)\n    }\n\n    if (is(x, \"NaArray\")) {\n        SparseArray.Call(\"C_summarize_SVT\",\n                         x@dim, x@type, x@NaSVT, TRUE, op, na.rm, center)\n    } else {\n        SparseArray.Call(\"C_summarize_SVT\",\n                         x@dim, x@type, x@SVT, FALSE, op, na.rm, center)\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### anyNA(), countNAs()\n###\n\n.anyNA_SparseArray <- function(x, recursive=FALSE)\n{\n    if (!identical(recursive, FALSE))\n        stop(wmsg(\"the anyNA() method for SparseArray objects \",\n                  \"does not support the 'recursive' argument\"))\n\n    if (is(x, \"COO_SparseArray\"))\n        return(anyNA(x@nzdata))\n\n    if (is(x, \"SVT_SparseArray\"))\n        return(summarize_SVT(\"anyNA\", x))\n\n    stop(wmsg(class(x)[[1L]], \" objects are not supported\"))\n}\nsetMethod(\"anyNA\", \"SparseArray\", .anyNA_SparseArray)\n\n### NOT USED! There's no countNAs() generic yet!\n### TODO: Define the countNAs() in BiocGenerics, and the colCountNAs() and\n### rowCountNAs() generics in MatrixGenerics.\n.countNAs_SparseArray <- function(x, recursive=FALSE)\n{\n    if (!identical(recursive, FALSE))\n        stop(wmsg(\"the countNAs() method for SparseArray objects \",\n                  \"does not support the 'recursive' argument\"))\n\n    if (is(x, \"COO_SparseArray\"))\n        return(sum(is.na(x@nzdata)))  # or do 'countNAs(x@nzdata)' when it\n                                      # becomes available\n\n    if (is(x, \"SVT_SparseArray\"))\n        return(summarize_SVT(\"countNAs\", x))\n\n    stop(wmsg(class(x)[[1L]], \" objects are not supported\"))\n}\n#setMethod(\"countNAs\", \"SparseArray\", .countNAs_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### 'Summary' group\n###\n\n.summarize_COO <- function(op, x, na.rm=FALSE)\n{\n    stopifnot(isSingleString(op), is(x, \"COO_SparseArray\"))\n    GENERIC <- match.fun(op)\n    ## Whether 'x' contains zeros or not doesn't make a difference for\n    ## sum() and any().\n    if (op %in% c(\"sum\", \"any\"))\n        return(GENERIC(x@nzdata, na.rm=na.rm))\n    ## Of course a typical COO_SparseArray object \"contains\" zeros\n    ## (i.e. it would contain zeros if we converted it to a dense\n    ## representation with as.array()). However, this is not guaranteed\n    ## so we need to make sure to properly handle the case where it\n    ## doesn't (admittedly unusual and definitely an inefficient way\n    ## to represent dense data!)\n    x_has_zeros <- length(x@nzdata) < length(x)\n    if (!x_has_zeros)\n        return(GENERIC(x@nzdata, na.rm=na.rm))\n    x_type <- typeof(x@nzdata)\n    if (op == \"all\") {\n        ## Mimic what 'all(as.array(x))' would do.\n        if (x_type == \"double\")\n            warning(\"coercing argument of type 'double' to logical\")\n        return(FALSE)\n    }\n    zero <- vector_of_zeros(x_type, length=1L)\n    GENERIC(zero, x@nzdata, na.rm=na.rm)\n}\n\nsetMethod(\"Summary\", \"COO_SparseArray\",\n    function(x, ..., na.rm=FALSE)\n    {\n        if (length(list(...)) != 0L)\n            stop(wmsg(\"the \", .Generic, \"() method for COO_SparseArray \",\n                      \"objects only accepts a single object\"))\n        .summarize_COO(.Generic, x, na.rm=na.rm)\n    }\n)\n\nsetMethod(\"Summary\", \"SVT_SparseArray\",\n    function(x, ..., na.rm=FALSE)\n    {\n        if (length(list(...)) != 0L)\n            stop(wmsg(\"the \", .Generic, \"() method for SVT_SparseArray \",\n                      \"objects only accepts a single object\"))\n        summarize_SVT(.Generic, x, na.rm=na.rm)\n    }\n)\n\n### We override the range() methods defined via the Summary() methods\n### above because we want to support the 'finite' argument like S3 method\n### base::range.default() does. One might wonder why base::range.default()\n### supports the 'finite' argument but min() and max() don't. Or more\n### precisely, they seem to take it but they don't do exactly the same thing\n### with it:\n###\n###     > max(c(0, -Inf), finite=TRUE)\n###     [1] 1\n###\n### Another story for another day...\n\n### S3/S4 combo for range.COO_SparseArray\nrange.COO_SparseArray <- function(..., na.rm=FALSE, finite=FALSE)\n{\n    objects <- list(...)\n    if (length(objects) != 1L)\n        stop(wmsg(\"the range() method for COO_SparseArray objects \",\n                  \"only accepts a single object\"))\n    x <- objects[[1L]]\n    x_has_zeros <- length(x@nzdata) < length(x)\n    if (!x_has_zeros)\n        return(range(x@nzdata, na.rm=na.rm, finite=finite))\n    zero <- vector_of_zeros(typeof(x@nzdata), length=1L)\n    range(zero, x@nzdata, na.rm=na.rm, finite=finite)\n}\n### The signature of all the members in the 'Summary' group generic is\n### 'x, ..., na.rm' (see getGeneric(\"range\")) which means that methods\n### cannot add arguments after 'na.rm'. So we add the 'finite' argument\n### before.\nsetMethod(\"range\", \"COO_SparseArray\",\n    function(x, ..., finite=FALSE, na.rm=FALSE)\n        range.COO_SparseArray(x, ..., na.rm=na.rm, finite=finite)\n\n)\n\n### S3/S4 combo for range.SVT_SparseArray\nrange.SVT_SparseArray <- function(..., na.rm=FALSE, finite=FALSE)\n{\n    if (!identical(finite, FALSE))\n        stop(wmsg(\"the range() method for SVT_SparseArray objects \",\n                  \"does not support the 'finite' argument\"))\n    objects <- list(...)\n    if (length(objects) != 1L)\n        stop(wmsg(\"the range() method for SVT_SparseArray objects \",\n                  \"only accepts a single object\"))\n    x <- objects[[1L]]\n    summarize_SVT(\"range\", x, na.rm=na.rm)\n}\n### The signature of all the members in the 'Summary' group generic is\n### 'x, ..., na.rm' (see getGeneric(\"range\")) which means that methods\n### cannot add arguments after 'na.rm'. So we add the 'finite' argument\n### before.\nsetMethod(\"range\", \"SVT_SparseArray\",\n    function(x, ..., finite=FALSE, na.rm=FALSE)\n        range.SVT_SparseArray(x, ..., na.rm=na.rm, finite=finite)\n\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### mean()\n###\n\n.mean_SparseArray <- function(x, na.rm=FALSE)\n{\n    summarize_SVT(\"mean\", x, na.rm=na.rm)\n}\n\n### S3/S4 combo for mean.SparseArray\nmean.SparseArray <- function(x, na.rm=FALSE, ...)\n    .mean_SparseArray(x, na.rm=na.rm, ...)\nsetMethod(\"mean\", \"SparseArray\", .mean_SparseArray)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### var(), sd()\n###\n\nsetMethod(\"var\", c(\"SparseArray\", \"ANY\"),\n    function(x, y=NULL, na.rm=FALSE, use)\n    {\n        if (!is.null(y))\n            stop(wmsg(\"the var() method for SparseArray objects \",\n                      \"does not support the 'y' argument\"))\n        if (!missing(use))\n            stop(wmsg(\"the var() method for SparseArray objects \",\n                      \"does not support the 'use' argument\"))\n        summarize_SVT(\"var1\", x, na.rm=na.rm)\n    }\n)\n\nsetMethod(\"sd\", \"SparseArray\",\n    function(x, na.rm=FALSE) summarize_SVT(\"sd1\", x, na.rm=na.rm)\n)\n\n",
        "SparseMatrix-mult.R": "### =========================================================================\n### SparseMatrix crossprod(), tcrossprod(), and %*%\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### crossprod()\n###\n\n### Only input types \"double\" and \"integer\" are supported at the moment.\n### TODO: Add \"complex\" and \"logical\" later.\n.check_crossprod_input_type <- function(type)\n{\n    #supported_types <- c(\"double\", \"integer\", \"complex\", \"logical\")\n    supported_types <- c(\"double\", \"integer\")\n    if (!(type %in% supported_types))\n        stop(wmsg(\"input objects must be of type() \\\"double\\\" or \\\"integer\\\"\"))\n                  #\"\\\"integer\\\", \\\"complex\\\", or \\\"logical\\\"\"))\n}\n\n.crossprod2_SparseMatrix_matrix <- function(x, y, transpose.y=FALSE)\n{\n    if (is(x, \"SVT_SparseMatrix\")) {\n        check_svt_version(x)\n    } else {\n        x <- as(x, \"SVT_SparseMatrix\")\n    }\n    stopifnot(is.matrix(y), isTRUEorFALSE(transpose.y))\n    if (transpose.y) {\n        if (nrow(x) != ncol(y))\n            stop(wmsg(\"non-conformable arguments\"))\n        ans_dim <- c(ncol(x), nrow(y))\n        ans_dimnames <- list(colnames(x), rownames(y))\n    } else {\n        if (nrow(x) != nrow(y))\n            stop(wmsg(\"non-conformable arguments\"))\n        ans_dim <- c(ncol(x), ncol(y))\n        ans_dimnames <- list(colnames(x), colnames(y))\n    }\n    if (type(x) == type(y)) {\n        .check_crossprod_input_type(type(x))\n    } else {\n        xy_type <- type(c(vector(type(x)), vector(type(y))))\n        .check_crossprod_input_type(xy_type)\n        type(x) <- type(y) <- xy_type\n    }\n    ans_type <- \"double\"\n    ans_dimnames <- S4Arrays:::simplify_NULL_dimnames(ans_dimnames)\n    SparseArray.Call(\"C_crossprod2_SVT_mat\",\n                     x@dim, x@type, x@SVT, y, transpose.y,\n                     ans_type, ans_dimnames)\n}\n\n.crossprod2_matrix_SparseMatrix <- function(x, y, transpose.x=FALSE)\n{\n    if (is(y, \"SVT_SparseMatrix\")) {\n        check_svt_version(y)\n    } else {\n        y <- as(y, \"SVT_SparseMatrix\")\n    }\n    stopifnot(is.matrix(x), isTRUEorFALSE(transpose.x))\n    if (transpose.x) {\n        if (ncol(x) != nrow(y))\n            stop(wmsg(\"non-conformable arguments\"))\n        ans_dim <- c(nrow(x), ncol(y))\n        ans_dimnames <- list(rownames(x), colnames(y))\n    } else {\n        if (nrow(x) != nrow(y))\n            stop(wmsg(\"non-conformable arguments\"))\n        ans_dim <- c(ncol(x), ncol(y))\n        ans_dimnames <- list(colnames(x), colnames(y))\n    }\n    if (type(x) == type(y)) {\n        .check_crossprod_input_type(type(x))\n    } else {\n        xy_type <- type(c(vector(type(x)), vector(type(y))))\n        .check_crossprod_input_type(xy_type)\n        type(x) <- type(y) <- xy_type\n    }\n    ans_type <- \"double\"\n    ans_dimnames <- S4Arrays:::simplify_NULL_dimnames(ans_dimnames)\n    SparseArray.Call(\"C_crossprod2_mat_SVT\",\n                     x, y@dim, y@type, y@SVT, transpose.x,\n                     ans_type, ans_dimnames)\n}\n\n.crossprod2_SparseMatrix_SparseMatrix <- function(x, y=NULL)\n{\n    if (is(x, \"SVT_SparseMatrix\")) {\n        check_svt_version(x)\n    } else {\n        x <- as(x, \"SVT_SparseMatrix\")\n    }\n    if (is(y, \"SVT_SparseMatrix\")) {\n        check_svt_version(y)\n    } else {\n        y <- as(y, \"SVT_SparseMatrix\")\n    }\n    if (nrow(x) != nrow(y))\n        stop(wmsg(\"non-conformable arguments\"))\n    ans_dim <- c(ncol(x), ncol(y))\n    if (type(x) == type(y)) {\n        .check_crossprod_input_type(type(x))\n    } else {\n        xy_type <- type(c(vector(type(x)), vector(type(y))))\n        .check_crossprod_input_type(xy_type)\n        type(x) <- type(y) <- xy_type\n    }\n    ans_type <- \"double\"\n    ans_dimnames <- list(colnames(x), colnames(y))\n    ans_dimnames <- S4Arrays:::simplify_NULL_dimnames(ans_dimnames)\n    SparseArray.Call(\"C_crossprod2_SVT_SVT\",\n                     x@dim, x@type, x@SVT, y@dim, y@type, y@SVT,\n                     ans_type, ans_dimnames)\n}\n\n.crossprod1_SparseMatrix <- function(x, y=NULL)\n{\n    if (is(x, \"SVT_SparseMatrix\")) {\n        check_svt_version(x)\n    } else {\n        x <- as(x, \"SVT_SparseMatrix\")\n    }\n    stopifnot(is.null(y))\n    ans_dim <- c(ncol(x), ncol(x))\n    .check_crossprod_input_type(type(x))\n    ans_type <- \"double\"\n    ans_dimnames <- list(colnames(x), colnames(x))\n    ans_dimnames <- S4Arrays:::simplify_NULL_dimnames(ans_dimnames)\n    SparseArray.Call(\"C_crossprod1_SVT\",\n                     x@dim, x@type, x@SVT,\n                     ans_type, ans_dimnames)\n}\n\nsetMethod(\"crossprod\", c(\"SparseMatrix\", \"matrix\"),\n    .crossprod2_SparseMatrix_matrix\n)\n\nsetMethod(\"crossprod\", c(\"matrix\", \"SparseMatrix\"),\n    .crossprod2_matrix_SparseMatrix\n)\n\nsetMethod(\"crossprod\", c(\"SparseMatrix\", \"SparseMatrix\"),\n    .crossprod2_SparseMatrix_SparseMatrix\n)\n\nsetMethod(\"crossprod\", c(\"SparseMatrix\", \"ANY\"),\n    function(x, y=NULL)\n    {\n        if (is.atomic(y) && is.vector(y)) {\n            ## Returns a 1-col ordinary matrix (like base::crossprod() does).\n            y <- cbind(y, deparse.level=0)\n            .crossprod2_SparseMatrix_matrix(x, y)\n        } else {\n            .crossprod2_SparseMatrix_SparseMatrix(x, y)\n        }\n    }\n)\n\nsetMethod(\"crossprod\", c(\"ANY\", \"SparseMatrix\"),\n    function(x, y=NULL)\n    {\n        if (is.atomic(x) && is.vector(x)) {\n            ## Returns a 1-row ordinary matrix (like base::crossprod() does).\n            x <- cbind(x, deparse.level=0)\n            .crossprod2_matrix_SparseMatrix(x, y)\n        } else {\n            .crossprod2_SparseMatrix_SparseMatrix(x, y)\n        }\n    }\n)\n\nsetMethod(\"crossprod\", c(\"SparseMatrix\", \"missing\"),\n    .crossprod1_SparseMatrix\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### tcrossprod()\n###\n\nsetMethod(\"tcrossprod\", c(\"SparseMatrix\", \"matrix\"),\n    function(x, y=NULL) .crossprod2_SparseMatrix_matrix(t(x), y,\n                                                        transpose.y=TRUE)\n)\n\nsetMethod(\"tcrossprod\", c(\"matrix\", \"SparseMatrix\"),\n    function(x, y=NULL) .crossprod2_matrix_SparseMatrix(x, t(y),\n                                                        transpose.x=TRUE)\n)\n\nsetMethod(\"tcrossprod\", c(\"SparseMatrix\", \"SparseMatrix\"),\n    function(x, y=NULL) .crossprod2_SparseMatrix_SparseMatrix(t(x), t(y))\n)\n\nsetMethod(\"tcrossprod\", c(\"SparseMatrix\", \"ANY\"),\n    function(x, y=NULL)\n    {\n        if (is.atomic(y) && is.vector(y)) {\n            ## Returns a 1-col ordinary matrix (like base::tcrossprod() does).\n            y <- cbind(y, deparse.level=0)\n            .crossprod2_SparseMatrix_matrix(t(x), y)\n        } else {\n            .crossprod2_SparseMatrix_SparseMatrix(t(x), t(y))\n        }\n    }\n)\n\nsetMethod(\"tcrossprod\", c(\"ANY\", \"SparseMatrix\"),\n    function(x, y=NULL)\n    {\n        if (is.atomic(x) && is.vector(x)) {\n            ## Returns a 1-row ordinary matrix (like base::tcrossprod() does).\n            x <- cbind(x, deparse.level=0)\n            .crossprod2_matrix_SparseMatrix(x, t(y))\n        } else {\n            .crossprod2_SparseMatrix_SparseMatrix(t(x), t(y))\n        }\n    }\n)\n\nsetMethod(\"tcrossprod\", c(\"SparseMatrix\", \"missing\"),\n    function(x, y=NULL) .crossprod1_SparseMatrix(t(x))\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Matrix multiplication\n###\n\nsetMethod(\"%*%\", c(\"SparseMatrix\", \"matrix\"),\n    function(x, y) .crossprod2_SparseMatrix_matrix(t(x), y)\n)\n\nsetMethod(\"%*%\", c(\"matrix\", \"SparseMatrix\"),\n    function(x, y) .crossprod2_matrix_SparseMatrix(x, y, transpose.x=TRUE)\n)\n\nsetMethod(\"%*%\", c(\"SparseMatrix\", \"SparseMatrix\"),\n    function(x, y) .crossprod2_SparseMatrix_SparseMatrix(t(x), y)\n)\n\nsetMethod(\"%*%\", c(\"SparseMatrix\", \"ANY\"),\n    function(x, y)\n    {\n        if (is.atomic(y) && is.vector(y)) {\n            ## Returns a 1-col ordinary matrix (like base::`%*%` does).\n            y <- cbind(y, deparse.level=0)\n            .crossprod2_SparseMatrix_matrix(t(x), y)\n        } else {\n            .crossprod2_SparseMatrix_SparseMatrix(t(x), y)\n        }\n    }\n)\n\nsetMethod(\"%*%\", c(\"ANY\", \"SparseMatrix\"),\n    function(x, y)\n    {\n        if (is.atomic(x) && is.vector(x)) {\n            ## Returns a 1-row ordinary matrix (like base::`%*%` does).\n            x <- rbind(x, deparse.level=0)\n            .crossprod2_matrix_SparseMatrix(x, y, transpose.x=TRUE)\n        } else {\n            .crossprod2_SparseMatrix_SparseMatrix(t(x), y)\n        }\n    }\n)\n\n",
        "extract_sparse_array.R": "### =========================================================================\n### extract_sparse_array()\n### -------------------------------------------------------------------------\n###\n\n\n### Similar to S4Arrays:::.contact_author_msg1().\n.contact_author_msg2 <- function(.Generic, x_class)\n{\n    msg <- c(\"Please contact the authors/maintainers of the \",\n             x_class, \" class\")\n    class_package <- attr(x_class, \"package\")\n    if (!is.null(class_package))\n        msg <- c(msg, \" (defined in the \", class_package, \" package)\")\n    c(msg, \" about this, and point them to the man page for the \",\n           .Generic, \"() generic function defined in the SparseArray \",\n           \"package ('?SparseArray::\", .Generic, \"').\")\n}\n\ncheck_returned_SparseArray <- function(ans, expected_dim, .Generic, x_class)\n{\n    if (!is(ans, \"SparseArray\"))\n        stop(wmsg(\"The \", .Generic, \"() method for \", x_class, \" \",\n                  \"objects didn't return a SparseArray object. \",\n                  .Generic, \"() methods should **always** return a \",\n                  \"SparseArray object. \",\n                  .contact_author_msg2(.Generic, x_class)))\n    if (!identical(dim(ans), expected_dim))\n        stop(wmsg(\"The \", .Generic, \"() method for \", x_class, \" objects \",\n                  \"returned a SparseArray object with incorrect \",\n                  \"dimensions. \", .contact_author_msg2(.Generic, x_class)))\n    ans\n}\n\n### extract_sparse_array() is the workhorse behind read_block_as_sparse(),\n### and, more generally, behind efficient subsetting of sparse array objects.\n### Similar to S4Arrays::extract_array(), except that:\n###   (1) The extracted array data must be returned as a SparseArray object.\n###       Methods should always operate on the sparse representation of the\n###       data and never \"expand\" it, that is, never turn it into a dense\n###       representation, e.g. with as.array(), as this would defeat the\n###       purpose of read_block_as_sparse().\n###   (2) It should **always** be called on an array-like object 'x' for\n###       which 'is_sparse(x)' is TRUE.\n###   (3) The subscripts in 'index' should NOT contain duplicates.\n### IMPORTANT NOTE: For the sake of efficiency, (2) and (3) are NOT checked\n### and are the responsibility of the user. We'll refer to (2) and (3) as\n### the \"extract_sparse_array() contract\".\n\nsetGeneric(\"extract_sparse_array\", signature=\"x\",\n    function(x, index)\n    {\n        x_dim <- dim(x)\n        if (is.null(x_dim))\n            stop(wmsg(\"first argument to extract_sparse_array() \",\n                      \"must be an array-like object\"))\n        ans <- standardGeneric(\"extract_sparse_array\")\n        expected_dim <- S4Arrays:::get_Nindex_lengths(index, x_dim)\n        check_returned_SparseArray(ans, expected_dim,\n                                   \"extract_sparse_array\", class(x))\n    }\n)\n\n### S4Arrays:::subset_by_Nindex() uses `[` internally to perform the\n### subsetting, so this default extract_sparse_array() method will work\n### on any object 'x' that supports `[` and coercion to SparseArray.\nsetMethod(\"extract_sparse_array\", \"ANY\",\n    function(x, index)\n    {\n        slice <- S4Arrays:::subset_by_Nindex(x, index)\n        as(slice, \"SparseArray\")\n    }\n)\n\n",
        "is_nonna.R": "### =========================================================================\n### The nna*() functions\n### -------------------------------------------------------------------------\n###\n### A set of generic functions for direct manipulation of the non-NA\n### elements of an array-like object.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_nonna()\n###\n### Returns an array-like object of type \"logical\".\n\nsetGeneric(\"is_nonna\", function(x) standardGeneric(\"is_nonna\"))\n\n### Works on any vector-like or array-like object that supports is.na().\nsetMethod(\"is_nonna\", \"ANY\", function(x) !is.na(x))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nnacount()\n###\n### Returns the number of non-NA array elements in 'x'.\n\nsetGeneric(\"nnacount\", function(x) standardGeneric(\"nnacount\"))\n\nsetMethod(\"nnacount\", \"ANY\", function(x) sum(is_nonna(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nnawhich()\n###\n### Returns the indices of the non-NA array elements in 'x', either as\n### an L-index (if 'arr.ind=FALSE') or as an M-index (if 'arr.ind=TRUE').\n### The indices must be returned sorted in strictly ascending order.\n### Note that using 'arr.ind=TRUE' won't work if 'nnacount(x)' is >= 2^31.\n\nsetGeneric(\"nnawhich\", signature=\"x\",\n    function(x, arr.ind=FALSE) standardGeneric(\"nnawhich\")\n)\n\n.default_nnawhich <- function(x, arr.ind=FALSE)\n{\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    which(is_nonna(x), arr.ind=arr.ind, useNames=FALSE)\n}\n\nsetMethod(\"nnawhich\", \"ANY\", .default_nnawhich)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nnavals()\n###\n### Extract the non-NA values from 'x'. The non-NA values are returned\n### in a vector of the same type() as 'x' and parallel to nnawhich(x).\n### Equivalent to 'x[nnawhich(x)]' (and that's what the default method\n### below does). However, specialized methods have the potential to make\n### this dramatically faster.\n\nsetGeneric(\"nnavals\", function(x) standardGeneric(\"nnavals\"))\n\n### Assumes that array-like object 'x' supports subsetting by a linear\n### numeric subscript (L-index).\n### Notes:\n### - Subsetting by an M-index i.e. subsetting by 'nnawhich(x, arr.ind=TRUE)'\n###   instead of 'nnawhich(x)' would work too but only when 'nnacount(x)'\n###   is < 2^31.\n### - The call to as.vector() should not be necessary since the result of\n###   subsetting 'x' by an L- or M-index should already be a vector (atomic\n###   or list). However, in the case of a 1D ordinary array, it's not!\n###   For example, 'array(11:15)[matrix(3:1)]' is a 1D array.\n###   Consider this a bug in base::`[`.\n### TODO: Maybe change this to 'x[is_nonna(x)]'? But do some timings first.\nsetMethod(\"nnavals\", \"ANY\", function(x) as.vector(x[nnawhich(x)]))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### `nnavals<-`()\n###\n### Replace the values of the non-NA array elements in 'x'.\n### Equivalent to 'x[nnawhich(x)] <- value' (and that's what the default\n### method below does). However specialized methods have the potential to\n### make this dramatically faster.\n### Notes:\n### - 'nnavals(x) <- nnavals(x)' should **always** be a no-op.\n### - 'nnavals(x) <- NA' will wipe out all non-NA values from 'x'.\n\nsetGeneric(\"nnavals<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"nnavals<-\")\n)\n\n### TODO: Maybe change this to 'x[is_nonna(x)] <- value'? But do some\n### timings first.\nsetReplaceMethod(\"nnavals\", \"ANY\",\n    function(x, value)\n    {\n        if (!is.vector(value))\n            stop(wmsg(\"replacement value must be a vector\"))\n        x[nnawhich(x)] <- value\n        x\n    }\n)\n\n",
        "is_nonzero.R": "### =========================================================================\n### The is_nonzero() and nz*() functions\n### -------------------------------------------------------------------------\n###\n### A set of generic functions for direct manipulation of the nonzero\n### elements of an array-like object.\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### is_nonzero()\n###\n### Returns an array-like object of type \"logical\".\n\nsetGeneric(\"is_nonzero\", function(x) standardGeneric(\"is_nonzero\"))\n\n### Works on any vector-like or array-like object 'x' that supports 'type(x)'\n### and comparison with zero ('x != zero'). One notable exception are\n### ngRMatrix objects from the Matrix package because 'x != FALSE' is\n### broken on these objects.\n.default_is_nonzero <- function(x)\n{\n    ## Make sure to use 'type()' and not 'typeof()'.\n    zero <- vector_of_zeros(type(x), length=1L)\n    is_nonzero <- x != zero  # broken on ngRMatrix objects!\n    is_nonzero | is.na(is_nonzero)\n}\n\nsetMethod(\"is_nonzero\", \"ANY\", .default_is_nonzero)\n\n### IMPORTANT NOTE: Surprisingly, and unfortunately, [d|l]gCMatrix objects\n### are allowed to have zeros in their '@x' slot.\n### For example, with Matrix 1.3-4:\n###\n###   dgcm <- as(matrix(c(11:13, 0, 0, 21:25), ncol=2), \"dgCMatrix\")\n###\n### In an lgCMatrix object:\n###\n###   lgcm <- dgcm >= 13\n###   lgcm\n###   # 5 x 2 sparse Matrix of class \"lgCMatrix\"\n###   # [1,] : |\n###   # [2,] : |\n###   # [3,] | |\n###   # [4,] . |\n###   # [5,] . |\n###   lgcm@x\n###   [1] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n###\n### In a dgCMatrix object:\n###\n###   dgcm[cbind(3:4, 2)] <- 0\n###   dgcm\n###   # 5 x 2 sparse Matrix of class \"dgCMatrix\"\n###   # [1,] 11 21\n###   # [2,] 12 22\n###   # [3,] 13  0\n###   # [4,]  .  0\n###   # [5,]  . 25\n###   dgcm@x\n###   # [1] 11 12 13 21 22  0  0 25\n###\n### This is still considered a valid dgCMatrix object:\n###\n###   validObject(dgcm)\n###   # [1] TRUE\n###\n### Interestingly this doesn't happen when using a linear index in the\n### subassignment:\n###\n###   dgcm[1:2] <- 0\n###   dgcm@x\n###   # [1] 13 21 22 25\n###\n### A consequence of this is that the method below is not 100% reliable\n### on a [d|l]gCMatrix object because 'as(x, \"nMatrix\")' will report\n### nonzero elements based on the pattern represented by the '@i' and '@p'\n### slots of the input object, and regardless of what the corresponding\n### values in its '@x' slot is. In other words, this method can return\n### false positives on a [d|l]gCMatrix object.\nsetMethod(\"is_nonzero\", \"sparseMatrix\", function(x) as(x, \"nMatrix\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nzcount()\n###\n### Returns the number of nonzero array elements in 'x'.\n\nsetGeneric(\"nzcount\", function(x) standardGeneric(\"nzcount\"))\n\nsetMethod(\"nzcount\", \"ANY\", function(x) sum(is_nonzero(x)))\n\n### Not 100% reliable because [C|R|T]sparseMatrix objects are allowed to\n### have zeros in their '@x' slot! See IMPORTANT NOTE above in this file.\n### On such objects 'length(x@i)' (or 'length(x@j)') will report more nonzero\n### elements than there really are (false positives). However, nzcount() and\n### is_nonzero() are guaranteed to be consistent, which is what matters most.\nsetMethod(\"nzcount\", \"CsparseMatrix\", function(x) length(x@i))\nsetMethod(\"nzcount\", \"RsparseMatrix\", function(x) length(x@j))\nsetMethod(\"nzcount\", \"TsparseMatrix\", function(x) length(x@i)) # == length(x@j)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nzwhich()\n###\n### Returns the indices of the nonzero array elements in 'x', either as\n### an L-index (if 'arr.ind=FALSE') or as an M-index (if 'arr.ind=TRUE').\n### The indices must be returned sorted in strictly ascending order.\n### Note that using 'arr.ind=TRUE' won't work if 'nzcount(x)' is >= 2^31.\n\nsetGeneric(\"nzwhich\", signature=\"x\",\n    function(x, arr.ind=FALSE) standardGeneric(\"nzwhich\")\n)\n\ndefault_nzwhich <- function(x, arr.ind=FALSE)\n{\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    which(is_nonzero(x), arr.ind=arr.ind, useNames=FALSE)\n}\n\nsetMethod(\"nzwhich\", \"ANY\", default_nzwhich)\n\n### default_nzwhich() above works fine on [C|R]sparseMatrix derivatives\n### (except on ngRMatrix objects) but nzwhich_CsparseMatrix() and\n### nzwhich_RsparseMatrix() below are more efficient:\n### - nzwhich_CsparseMatrix() is typically 10x to 50x faster than\n###   default_nzwhich() on big CsparseMatrix objects;\n### - nzwhich_RsparseMatrix() is only slightly faster than default_nzwhich()\n###   but is provided mostly to make nzwhich() work on ngRMatrix objects\n###   (default_nzwhich() doesn't work on these objects, see above).\n### NOTE: nzwhich_CsparseMatrix() and nzwhich_RsparseMatrix() use a shortcut\n### that is **NOT** 100% reliable on [d|l]gCMatrix or [d|l]gRMatrix objects\n### because these objects are allowed to have zeros in their '@x' slot (see\n### IMPORTANT NOTE above in this file). So in this case the functions will\n### produce a result that contains some false positives. However, nzwhich()\n### is guaranteed to be consistent with nzcount() and is_nonzero(), which is\n### what matters most.\nnzwhich_CsparseMatrix <- function(x, arr.ind=FALSE)\n{\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    ## If 'x' is a \"long object\" (i.e. length(x) >= 2^31) then we'll get\n    ## an integer overflow in 'x_nrow * (seq_len(x_ncol) - 1L)' below.\n    ## Coercing 'x_nrow' to double avoids that.\n    if (is.double(length(x)))\n        x_nrow <- as.double(x_nrow)\n    offsets <- rep.int(x_nrow * (seq_len(x_ncol) - 1L), diff(x@p))\n    ans <- x@i + offsets + 1L\n    if (!arr.ind)\n        return(ans)\n    Lindex2Mindex(ans, dim(x))\n}\n\nnzwhich_RsparseMatrix <- function(x, arr.ind=FALSE)\n{\n    if (!isTRUEorFALSE(arr.ind))\n        stop(wmsg(\"'arr.ind' must be TRUE or FALSE\"))\n    x_nrow <- nrow(x)\n    x_ncol <- ncol(x)\n    if (is.double(length(x)))\n        x_ncol <- as.double(x_ncol)  # see nzwhich_CsparseMatrix() above\n    offsets <- rep.int(x_ncol * (seq_len(x_nrow) - 1L), diff(x@p))\n    transposed_nzwhich <- x@j + offsets + 1L\n    transposed_arr_ind <- Lindex2Mindex(transposed_nzwhich, rev(dim(x)))\n    transposed_arr_ind1 <- transposed_arr_ind[ , 1L]\n    transposed_arr_ind2 <- transposed_arr_ind[ , 2L]\n    oo <- order(transposed_arr_ind1, transposed_arr_ind2)\n    arr_ind1 <- transposed_arr_ind2[oo]\n    arr_ind2 <- transposed_arr_ind1[oo]\n    arr_ind <- cbind(arr_ind1, arr_ind2, deparse.level=0)\n    if (arr.ind)\n        return(arr_ind)\n    Mindex2Lindex(arr_ind, dim(x))\n}\n\nsetMethod(\"nzwhich\", \"CsparseMatrix\", nzwhich_CsparseMatrix)\nsetMethod(\"nzwhich\", \"RsparseMatrix\", nzwhich_RsparseMatrix)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### nzvals()\n###\n### Extracts the nonzero values from 'x'. The nonzero values are returned\n### in a vector of the same type() as 'x' and parallel to nzwhich(x).\n### Equivalent to 'x[nzwhich(x)]' (and that's what the default method\n### below does). However, specialized methods have the potential to make\n### this dramatically faster.\n\nsetGeneric(\"nzvals\", function(x) standardGeneric(\"nzvals\"))\n\n### Assumes that array-like object 'x' supports subsetting by a linear\n### numeric subscript (L-index).\n### Notes:\n### - Subsetting by an M-index i.e. subsetting by 'nzwhich(x, arr.ind=TRUE)'\n###   instead of 'nzwhich(x)' would work too but only when 'nzcount(x)'\n###   is < 2^31.\n### - The call to as.vector() should not be necessary since the result of\n###   subsetting 'x' by an L- or M-index should already be a vector (atomic\n###   or list). However, in the case of a 1D ordinary array, it's not!\n###   For example, 'array(11:15)[matrix(3:1)]' is a 1D array.\n###   Consider this a bug in base::`[`.\n### TODO: Maybe change this to 'x[is_nonzero(x)]'? But do some timings first.\nsetMethod(\"nzvals\", \"ANY\", function(x) as.vector(x[nzwhich(x)]))\n\n### Not 100% reliable because [d|l]gCMatrix objects can have zeros in\n### their '@x' slot (see IMPORTANT NOTE above in this file), but consistent\n### with nzwhich(), nzcount(), and is_nonzero() on these objects.\nsetMethod(\"nzvals\", \"dgCMatrix\", function(x) x@x)\nsetMethod(\"nzvals\", \"lgCMatrix\", function(x) x@x)\n\nsetMethod(\"nzvals\", \"nMatrix\", function(x) rep.int(TRUE, nzcount(x)))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### `nzvals<-`()\n###\n### Replaces the values of the nonzero array elements in 'x'.\n### Equivalent to 'x[nzwhich(x)] <- value' (and that's what the default\n### method below does). However specialized methods have the potential to\n### make this dramatically faster.\n### Notes:\n### - 'nzvals(x) <- nzvals(x)' should **always** be a no-op.\n### - 'nzvals(x) <- 0L' will wipe out all nonzero values from 'x'.\n\nsetGeneric(\"nzvals<-\", signature=\"x\",\n    function(x, value) standardGeneric(\"nzvals<-\")\n)\n\n### TODO: Maybe change this to 'x[is_nonzero(x)] <- value'? But do some\n### timings first.\nsetReplaceMethod(\"nzvals\", \"ANY\",\n    function(x, value)\n    {\n        if (!is.vector(value))\n            stop(wmsg(\"replacement value must be a vector\"))\n        x[nzwhich(x)] <- value\n        x\n    }\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### sparsity()\n###\n\nsparsity <- function(x) { 1 - nzcount(x) / length(x) }\n\n",
        "options.R": "### =========================================================================\n### Handle SparseArray options\n### -------------------------------------------------------------------------\n###\n### Nothing in this file is exported.\n###\n\n### Must return a named list.\n.get_SparseArray_options <- function()\n{\n    SparseArray_options <- getOption(\"SparseArray\")\n    if (is.null(SparseArray_options))\n        return(setNames(list(), character(0)))\n    if (!is.list(SparseArray_options) || is.null(names(SparseArray_options)))\n        stop(wmsg(\"invalid 'getOption(\\\"SparseArray\\\")' \",\n                  \"(should be a named list)\"))\n    SparseArray_options\n}\n\nget_SparseArray_option <- function(name, default=NULL)\n{\n    stopifnot(isSingleString(name))\n    SparseArray_options <- .get_SparseArray_options()\n    if (name %in% names(SparseArray_options))\n        return(SparseArray_options[[name]])\n    default\n}\n\nset_SparseArray_option <- function(name, value)\n{\n    stopifnot(isSingleString(name))\n    SparseArray_options <- .get_SparseArray_options()\n    prev_value <- SparseArray_options[[name]]\n    SparseArray_options[name] <- list(value)\n    options(SparseArray=SparseArray_options)\n    invisible(prev_value)\n}\n\nSparseArray_option_is_set <- function(name)\n{\n    stopifnot(isSingleString(name))\n    SparseArray_options <- .get_SparseArray_options()\n    name %in% names(SparseArray_options)\n}\n\n",
        "randomSparseArray.R": "### =========================================================================\n### randomSparseArray() and poissonSparseArray()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### randomSparseArray()\n###\n\n### Returns an SVT_SparseArray object of type \"double\".\nrandomSparseArray <- function(dim, density=0.05, dimnames=NULL)\n{\n    if (!is.numeric(dim))\n        stop(wmsg(\"'dim' must be an integer vector\"))\n    if (!is.integer(dim))\n        dim <- as.integer(dim)\n    if (!isSingleNumber(density) || density < 0 || density > 1)\n        stop(wmsg(\"'density' must be a number >= 0 and <= 1\"))\n\n    ## Start with an empty sparse array.\n    ans <- new_SVT_SparseArray(dim, dimnames=dimnames, type=\"double\")\n\n    ## Add the nonzero values to it.\n    ans_len <- length(ans)\n    nzcount <- as.integer(ans_len * density)\n    Lindex <- sample.int(ans_len, nzcount)\n    nzvals <- signif(rnorm(nzcount), 2)\n    if (nzcount <= .Machine$integer.max) {\n        ## Using an Mindex seems to be slightly faster (4%-5%) than using an\n        ## Lindex but we can only do this when the resulting Mindex matrix\n        ## has < 2^31 rows.\n        ans[Lindex2Mindex(Lindex, dim(ans))] <- nzvals\n    } else {\n        ans[Lindex] <- nzvals\n    }\n\n    ans\n}\n\nrandomSparseMatrix <- function(nrow=1L, ncol=1L, density=0.05, dimnames=NULL)\n{\n    if (!isSingleNumber(nrow) || !isSingleNumber(ncol))\n        stop(wmsg(\"'nrow' and 'ncol' must be single integers\"))\n    randomSparseArray(c(nrow, ncol), density=density, dimnames=dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### poissonSparseArray()\n###\n\n### Like stats::rpois() but slightly faster and implementation is much\n### simpler. Only for 0 <= 'lambda' <= 4.\n### NOT exported.\nsimple_rpois <- function(n, lambda)\n    SparseArray.Call(\"C_simple_rpois\", n, lambda)\n\n### Returns an SVT_SparseArray object of type \"integer\".\n### Density of the returned object is expected to be about '1 - exp(-lambda)'.\n### Default for 'lambda' is set to -log(0.95) which should produce an object\n### with an expected density of 0.05.\npoissonSparseArray <- function(dim, lambda=-log(0.95), density=NA,\n                               dimnames=NULL)\n{\n    dim <- S4Arrays:::normarg_dim(dim)\n\n    if (!missing(lambda) && !identical(density, NA))\n        stop(wmsg(\"only one of 'lambda' and 'density' can be specified\"))\n    if (!missing(lambda)) {\n        if (!isSingleNumber(lambda) || lambda < 0)\n            stop(wmsg(\"'lambda' must be a non-negative number\"))\n    } else if (!identical(density, NA)) {\n        if (!isSingleNumber(density) || density < 0 || density >= 1)\n            stop(wmsg(\"'density' must be a number >= 0 and < 1\"))\n        lambda <- -log(1 - density)\n    }\n\n    ans_SVT <- SparseArray.Call(\"C_poissonSparseArray\", dim, lambda)\n    new_SVT_SparseArray(dim, dimnames=dimnames, type=\"integer\", SVT=ans_SVT,\n                        check=FALSE)\n}\n\n### Replacement for rpois() when 'n' is big and 'lambda' is small.\n### For example:\n###     .sparse_rpois(3e9, 0.005)  # takes about 1 min. and uses < 1G of RAM\n###     rpois(3e9, 0.005)          # takes about 55 sec. and uses 12G of RAM\n.sparse_rpois <- function(n, lambda, chunksize=5e6L)\n{\n    if (n == 0L)\n        return(list(integer(0), integer(0)))\n    nzidx_env <- new.env(parent=emptyenv())\n    nzvals_env <- new.env(parent=emptyenv())\n    offset <- 0  # double to avoid integer overflow when n >= 2^31\n    k <- 1L\n    while (offset < n) {\n        nn <- n - offset\n        if (nn > chunksize)\n            nn <- chunksize\n        vals <- rpois(nn, lambda)\n        nzidx <- nzwhich(vals)\n        key <- sprintf(\"%04d\", k)\n        assign(key, offset + nzidx, envir=nzidx_env)\n        assign(key, vals[nzidx], envir=nzvals_env)\n        offset <- offset + nn\n        k <- k + 1L\n    }\n    nzidx <- as.list(nzidx_env, all.names=TRUE, sorted=TRUE)\n    nzidx <- unlist(nzidx, recursive=FALSE, use.names=FALSE)\n    nzvals <- as.list(nzvals_env, all.names=TRUE, sorted=TRUE)\n    nzvals <- unlist(nzvals, recursive=FALSE, use.names=FALSE)\n    list(nzidx, nzvals)\n}\n\n### Solution based on .sparse_rpois(). Equivalent to poissonSparseArray()\n### but slower and uses more memory e.g.\n###\n###     poissonSparseArray2(c(1e5, 2e4), density=0.02)\n###\n### is about 3x slower uses about 2.5x more memory than\n###\n###     poissonSparseArray(c(1e5, 2e4), density=0.02)\n###\n### NOT exported\npoissonSparseArray2 <- function(dim, lambda=-log(0.95), density=NA)\n{\n    dim <- S4Arrays:::normarg_dim(dim)\n\n    if (!missing(lambda) && !identical(density, NA))\n        stop(wmsg(\"only one of 'lambda' and 'density' can be specified\"))\n    if (!missing(lambda)) {\n        if (!isSingleNumber(lambda) || lambda < 0)\n            stop(wmsg(\"'lambda' must be a non-negative number\"))\n    } else {\n        if (!isSingleNumber(density) || density < 0 || density >= 1)\n            stop(wmsg(\"'density' must be a number >= 0 and < 1\"))\n        lambda <- -log(1 - density)\n    }\n\n    ## Start with an empty sparse array.\n    ans <- new_SVT_SparseArray(dim, type=\"integer\")\n\n    ## Add the nonzero values to it.\n    ans_len <- length(ans)\n    srp <- .sparse_rpois(ans_len, lambda)\n    ans[srp[[1L]]] <- srp[[2L]]\n\n    ans\n}\n\npoissonSparseMatrix <- function(nrow=1L, ncol=1L, lambda=-log(0.95), density=NA,\n                                dimnames=NULL)\n{\n    if (!isSingleNumber(nrow) || !isSingleNumber(ncol))\n        stop(wmsg(\"'nrow' and 'ncol' must be single integers\"))\n    if (missing(lambda)) {\n        poissonSparseArray(c(nrow, ncol), density=density,\n                           dimnames=dimnames)\n    } else {\n        poissonSparseArray(c(nrow, ncol), lambda=lambda, density=density,\n                           dimnames=dimnames)\n    }\n}\n\n",
        "readSparseCSV.R": "### =========================================================================\n### readSparseCSV() and writeSparseCSV()\n### -------------------------------------------------------------------------\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### writeSparseCSV()\n###\n\n.write_csv_line <- function(rowname, vals, filepath, sep, write.zeros)\n{\n    if (write.zeros) {\n        line <- as.character(vals)\n    } else {\n        nzidx <- default_nzwhich(vals)\n        line <- character(length(vals))\n        line[nzidx] <- as.character(vals[nzidx])\n    }\n    cat(rowname, paste0(sep, line), \"\\n\", file=filepath, sep=\"\", append=TRUE)\n}\n\n.write_csv_block <- function(rownames, block, filepath, sep, write.zeros)\n{\n    stopifnot(is.matrix(block))\n    ## Write 'block' row by row. Not very efficient!\n    for (i in seq_len(nrow(block))) {\n        vals <- as.integer(block[i, ])\n        .write_csv_line(rownames[[i]], vals, filepath, sep, write.zeros)\n    }\n}\n\n### TODO: Maybe use a block-processing approach that is RealizationSink-based\n### i.e. it would use:\n### - A dedicated RealizationSink object for CSV files e.g. CSVRealizationSink\n###   (to be implemented) and its required methods. See\n###   DelayedArray/R/write_block.R in the DelayedArray package.\n### - DelayedArray::BLOCK_write_to_sink()\n### - See writeTENxMatrix() in the HDF5Array package for the details.\n###   Note that writeHDF5Array() in the same package also uses a\n###   RealizationSink-based approach.\n### Major difference with writeTENxMatrix(): BLOCK_write_to_sink() must use\n### a **row-oriented** grid obtained with rowAutoGrid(..., nrow=chunknrow).\n### I'm not sure BLOCK_write_to_sink() will be able to handle the case\n### when 'transpose' is TRUE case out-of-the-box though. Might require some\n### tweaks, hopefully nothing really complicated.\nwriteSparseCSV <- function(x, filepath, sep=\",\", transpose=FALSE,\n                              write.zeros=FALSE, chunknrow=250)\n{\n    ## Check 'x'.\n    x_dim <- dim(x)\n    if (length(x_dim) != 2L)\n        stop(\"'x' must be a matrix-like object\")\n    x_rownames <- rownames(x)\n    x_colnames <- colnames(x)\n    if (is.null(x_rownames) || is.null(x_colnames))\n        stop(\"'x' must have rownames and colnames\")\n    x_type <- type(x)\n    if (!(x_type %in% c(\"logical\", \"integer\", \"double\", \"raw\")))\n        stop(wmsg(\"'x' must be of type \\\"integer\\\" (types \\\"logical\\\", \",\n                  \"\\\"double\\\", and \\\"raw\\\" are also supported via \",\n                  \"coercion to \\\"integer\\\")\"))\n\n    ## Check 'filepath', 'sep', 'transpose', and 'write.zeros'.\n    if (!isSingleString(filepath))\n        stop(wmsg(\"'filepath' must be a single string\"))\n    if (!(isSingleString(sep) && nchar(sep) == 1L))\n        stop(wmsg(\"'sep' must be a single character\"))\n    if (!isTRUEorFALSE(transpose))\n        stop(wmsg(\"'transpose' must be TRUE or FALSE\"))\n    if (!isTRUEorFALSE(write.zeros))\n        stop(wmsg(\"'write.zeros' must be TRUE or FALSE\"))\n\n    x_nrow <- x_dim[[1L]]\n    x_ncol <- x_dim[[2L]]\n\n    if (transpose) {\n        chunks <- breakInChunks(x_ncol, chunksize=chunknrow)\n        cat(paste0(sep, x_rownames), \"\\n\", file=filepath, sep=\"\")\n        ## Note that walking on the columns of a SVT_SparseMatrix should be\n        ## slightly more efficient than walking on its rows.\n        for (chunk_id in seq_along(chunks)) {\n            idx <- chunks[[chunk_id]]\n            block <- t(as.matrix(x[ , idx, drop=FALSE]))\n            .write_csv_block(x_colnames[idx], block, filepath, sep,\n                             write.zeros)\n        }\n    } else {\n        chunks <- breakInChunks(x_nrow, chunksize=chunknrow)\n        cat(paste0(sep, x_colnames), \"\\n\", file=filepath, sep=\"\")\n        for (chunk_id in seq_along(chunks)) {\n            idx <- chunks[[chunk_id]]\n            block <- as.matrix(x[idx, , drop=FALSE])\n            .write_csv_block(x_rownames[idx], block, filepath, sep,\n                             write.zeros)\n        }\n    }\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### readSparseCSV()\n###\n\n.scan_first_two_lines <- function(filepath, sep=\",\")\n{\n    con <- file(filepath, \"r\")\n    on.exit(close(con))\n    line1 <- scan(con, what=character(), sep=sep, nlines=1L, quiet=TRUE)\n    line2 <- scan(con, what=character(), sep=sep, nlines=1L, quiet=TRUE)\n    list(line1, line2)\n}\n\n.looks_like_a_name <- function(x)\n    nzchar(x) & is.na(suppressWarnings(as.numeric(x)))\n\n### Guess by looking at the first 2 lines in the file.\n### Not ready (this is a mess!)\n.guess_dimnames_and_ncol <- function(line1, line2, rownames=NA, colnames=NA)\n{\n    if (!(is.logical(rownames) && length(rownames) == 1L))\n        stop(wmsg(\"'rownames' must be a single logical value\"))\n    if (!(is.logical(colnames) && length(colnames) == 1L))\n        stop(wmsg(\"'colnames' must be a single logical value\"))\n    n1 <- length(line1)\n    n2 <- length(line2)\n    if (n2 == 0L) {\n        if (n1 == 0L)\n            stop(wmsg(\"invalid file: first two lines are empty\"))\n        if (isTRUE(rownames) && isTRUE(colnames))\n            stop(wmsg(\"file does not seem to contain both rownames and \",\n                      \"colnames (2nd line is empty)\"))\n        if (isTRUE(rownames))\n            return(list(c(TRUE, FALSE), n1 - 1L))\n        if (isTRUE(colnames))\n            return(list(c(FALSE, TRUE), n1))\n        return(list(c(FALSE, FALSE), n1))\n    }\n    if (n1 == n2 - 1L) {\n        if (isFALSE(rownames) || isFALSE(colnames))\n            stop(wmsg(\"file seems to contain both rownames and colnames \",\n                      \"(1st line contains one less item than 2nd line)\"))\n        return(list(c(TRUE, TRUE), n1))\n    }\n    if (n1 != n2)\n        stop(wmsg(\"invalid file: nb of items in 2nd line is not equal to \",\n                  \"n2 or to n2-1 where n2 is the nb of items in 1st line\"))\n    item1_looks_like_a_name <- .looks_like_a_name(line1[[1L]])\n    if (!item1_looks_like_a_name) {\n        if (is.na(colnames))\n            colnames <- any(.looks_like_a_name(line1[-1L]))\n        if (is.na(rownames))\n            rownames <- .looks_like_a_name(line2[[1L]])\n        return(list(c(rownames, colnames), n2))\n    }\n    ## File contains either rownames or colnames, but not both.\n    if (isTRUE(rownames) && isTRUE(colnames))\n        stop(wmsg(\"file does not seem to contain both rownames and colnames \",\n                  \"(1st item in the file looks like a name)\"))\n    if (isFALSE(rownames) && isFALSE(colnames))\n        stop(wmsg(\"file seems to contain either rownames or colnames \",\n                  \"(1st item in the file looks like a name)\"))\n    if (!is.na(rownames))\n        return(c(rownames, !rownames))\n    if (!is.na(colnames))\n        return(c(!colnames, colnames))\n    if (.looks_like_a_name(line2[[1L]]))\n        return(c(TRUE, FALSE))\n    if (any(.looks_like_a_name(line1[-1L])))\n        return(c(FALSE, TRUE))\n    ## Maybe file is more likely to have rownames than colnames but who knows,\n    ## this is just a random guess.\n    c(TRUE, FALSE)\n}\n\n.readSparseCSV_as_SVT_SparseMatrix <- function(con, sep, csv_colnames,\n                                               transpose=FALSE)\n{\n    tmpenv <- new.env(parent=emptyenv())\n    C_ans <- SparseArray.Call(\"C_readSparseCSV_as_SVT_SparseMatrix\",\n                              con, sep, transpose, length(csv_colnames), tmpenv)\n    rm(tmpenv)\n\n    ## Construct SVT_SparseMatrix object.\n    csv_rownames <- C_ans[[1L]]\n    ans_SVT <- C_ans[[2L]]\n    if (transpose) {\n        ans_rownames <- csv_colnames\n        ans_colnames <- csv_rownames\n    } else {\n        ans_rownames <- csv_rownames\n        ans_colnames <- csv_colnames\n    }\n    ans_dim <- c(length(ans_rownames), length(ans_colnames))\n    ans_dimnames <- list(ans_rownames, ans_colnames)\n    ans_type <- \"integer\"\n    new_SVT_SparseArray(ans_dim, ans_dimnames, ans_type, ans_SVT, check=FALSE)\n}\n\n### Returns an SVT_SparseMatrix object by default.\nreadSparseCSV <- function(filepath, sep=\",\", transpose=FALSE)\n{\n    ## Check 'filepath', 'sep', and 'transpose'.\n    if (!isSingleString(filepath))\n        stop(wmsg(\"'filepath' must be a single string\"))\n    if (!(isSingleString(sep) && nchar(sep) == 1L))\n        stop(wmsg(\"'sep' must be a single character\"))\n    if (!isTRUEorFALSE(transpose))\n        stop(wmsg(\"'transpose' must be TRUE or FALSE\"))\n\n    first_two_lines <- .scan_first_two_lines(filepath, sep=sep)\n    line1 <- first_two_lines[[1L]]\n    line2 <- first_two_lines[[2L]]\n    n1 <- length(line1)\n    n2 <- length(line2)\n    if (n1 < 2L)\n        stop(wmsg(\"first line in the file must contain \",\n                  \"at least 2 items (found \", n1, \")\"))\n    if (n1 != n2)\n        stop(wmsg(\"first two lines in the file must contain \",\n                  \"the same number of items\"))\n    #dimnames_and_ncol <- .guess_dimnames_and_ncol(line1, line2,\n    #                                              rownames, colnames)\n    #rownames <- dimnames_and_ncol[[1L]][1L]\n    #colnames <- dimnames_and_ncol[[1L]][2L]\n    #ncol <- dimnames_and_ncol[[2L]]\n\n    #filexp <- open_input_files(filepath)[[1L]]\n    con <- file(filepath, \"r\")\n    on.exit(close(con))\n    .readSparseCSV_as_SVT_SparseMatrix(con, sep, line1[-1L],\n                                       transpose=transpose)\n}\n\nreadSparseTable <- function(...)\n{\n    .Deprecated(\"readSparseCSV\")\n    readSparseCSV(...)\n}\n\n### Reproduces the mysterious \"segfault from C stack overflow\" error that\n### we use to get when readSparseCSV() was called in the context of creating\n### the vignette with 'R CMD build', but with C code that is much simpler.\n### See src/test.c for more information.\n### NOT exported.\ntest <- function() .Call2(\"C_test\", PACKAGE=\"SparseArray\")\n\n",
        "read_block_as_sparse.R": "### =========================================================================\n### read_block_as_sparse()\n### -------------------------------------------------------------------------\n###\n\n### Like read_block_as_dense() in S4Arrays, read_block_as_sparse() is\n### not meant to be called directly by the end user. They should call\n### higher-level user-facing S4Arrays::read_block() function instead,\n### with the 'as.sparse' argument set to TRUE.\n### Also, like extract_sparse_array() that it is based on,\n### read_block_as_sparse() should **always** be called on an array-like\n### object 'x' for which 'is_sparse(x)' is TRUE. This is considered\n### responsibility of the caller and we trust the caller to do the right\n### thing, so, for the sake of efficiency, individual read_block_as_sparse()\n### methods don't need to check this again. See extract_sparse_array.R\n### for more information.\n### Must also return a SparseArray object, like extract_sparse_array().\n### Note that the S4Arrays::read_block() wrapper will take care of\n### propagating the dimnames, so, for the sake of efficiency, individual\n### methods should not try to do it.\n\nsetGeneric(\"read_block_as_sparse\", signature=\"x\",\n    function(x, viewport) standardGeneric(\"read_block_as_sparse\")\n)\n\n### Does NOT propagate the dimnames.\nsetMethod(\"read_block_as_sparse\", \"ANY\",\n    function(x, viewport)\n    {\n        Nindex <- makeNindexFromArrayViewport(viewport, expand.RangeNSBS=TRUE)\n        extract_sparse_array(x, Nindex)\n    }\n)\n\n",
        "rowsum-methods.R": "### =========================================================================\n### rowsum()/colsum() methods for SparseMatrix and dgCMatrix objects\n### -------------------------------------------------------------------------\n###\n\n\n.rowsum_method <- function(x, group, reorder=TRUE, na.rm=FALSE)\n{\n    stopifnot(is(x, \"SparseMatrix\") || is(x, \"dgCMatrix\"))\n    ugroup <- S4Arrays:::compute_ugroup(group, nrow(x), reorder)\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    group <- match(group, ugroup)\n    if (is(x, \"SparseMatrix\")) {\n        if (is(x, \"SVT_SparseMatrix\")) {\n            check_svt_version(x)\n        } else {\n            x <- as(x, \"SVT_SparseMatrix\")\n        }\n        ans <- SparseArray.Call(\"C_rowsum_SVT\", x@dim, x@type, x@SVT,\n                                group, length(ugroup), na.rm)\n    } else {\n        ans <- SparseArray.Call(\"C_rowsum_dgCMatrix\", x,\n                                group, length(ugroup), na.rm)\n    }\n    S4Arrays:::set_dimnames(ans, list(as.character(ugroup), colnames(x)))\n}\n\n.colsum_method <- function(x, group, reorder=TRUE, na.rm=FALSE)\n{\n    stopifnot(is(x, \"SparseMatrix\") || is(x, \"dgCMatrix\"))\n    ugroup <- S4Arrays:::compute_ugroup(group, ncol(x), reorder)\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    group <- match(group, ugroup)\n    if (is(x, \"SparseMatrix\")) {\n        if (is(x, \"SVT_SparseMatrix\")) {\n            check_svt_version(x)\n        } else {\n            x <- as(x, \"SVT_SparseMatrix\")\n        }\n        ans <- SparseArray.Call(\"C_colsum_SVT\", x@dim, x@type, x@SVT,\n                                group, length(ugroup), na.rm)\n    } else {\n        ans <- SparseArray.Call(\"C_colsum_dgCMatrix\", x,\n                                group, length(ugroup), na.rm)\n    }\n    S4Arrays:::set_dimnames(ans, list(rownames(x), as.character(ugroup)))\n}\n\n### S3/S4 combo for rowsum.SparseMatrix\nrowsum.SparseMatrix <-\n    function(x, group, reorder=TRUE, na.rm=FALSE, ...)\n        .rowsum_method(x, group, reorder=reorder, na.rm=na.rm, ...)\nsetMethod(\"rowsum\", \"SparseMatrix\",\n    function(x, group, reorder=TRUE, ...)\n        .rowsum_method(x, group, reorder=reorder, ...)\n)\n\n### S3/S4 combo for rowsum.dgCMatrix\nrowsum.dgCMatrix <- rowsum.SparseMatrix\nsetMethod(\"rowsum\", \"dgCMatrix\",\n    function(x, group, reorder=TRUE, ...)\n        .rowsum_method(x, group, reorder=reorder, ...)\n)\n\nsetMethod(\"colsum\", \"SparseMatrix\",\n    function(x, group, reorder=TRUE, ...)\n        .colsum_method(x, group, reorder=reorder, ...)\n)\n\nsetMethod(\"colsum\", \"dgCMatrix\",\n    function(x, group, reorder=TRUE, ...)\n        .colsum_method(x, group, reorder=reorder, ...)\n)\n\n",
        "sparseMatrix-utils.R": "### =========================================================================\n### Low-level manipulation of sparseMatrix derivatives (from Matrix package)\n### -------------------------------------------------------------------------\n###\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Low-level [C|R|T]sparseMatrix constructors\n###\n### WARNING: They take **0-based** row/column indices!\n###\n### NOT exported\n###\n\n### Returns \"double\" or \"logical\".\n.infer_sparseMatrix_type_from_input_type <- function(input_type)\n{\n    switch(input_type, 'double'=, 'integer'=, 'raw'=\"double\",\n                       'logical'=\"logical\",\n           stop(wmsg(\"unsupported input type: \", input_type)))\n}\n\n### 'i' must be an integer vector containing 0-based row indices.\n### Returns a dgCMatrix, lgCMatrix, or ngCMatrix (depends on 'typeof(x)').\nnew_CsparseMatrix <- function(dim, p, i, x=NULL, dimnames=NULL)\n{\n    stopifnot(is.integer(dim), length(dim) == 2L)\n    ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    if (is.null(x))\n        return(new(\"ngCMatrix\", Dim=dim, p=p, i=i, Dimnames=ans_dimnames))\n    x_type <- typeof(x)\n    ans_type <- .infer_sparseMatrix_type_from_input_type(x_type)\n    ans_class <- if (ans_type == \"double\") \"dgCMatrix\" else \"lgCMatrix\"\n    if (ans_type != x_type)\n        storage.mode(x) <- ans_type\n    new(ans_class, Dim=dim, p=p, i=i, x=x, Dimnames=ans_dimnames)\n}\n\n### 'j' must be an integer vector containing 0-based column indices.\n### Returns a dgRMatrix, lgRMatrix, or ngRMatrix (depends on 'typeof(x)').\nnew_RsparseMatrix <- function(dim, p, j, x=NULL, dimnames=NULL)\n{\n    stopifnot(is.integer(dim), length(dim) == 2L)\n    ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    if (is.null(x))\n        return(new(\"ngRMatrix\", Dim=dim, p=p, j=j, Dimnames=ans_dimnames))\n    x_type <- typeof(x)\n    ans_type <- .infer_sparseMatrix_type_from_input_type(x_type)\n    ans_class <- if (ans_type == \"double\") \"dgRMatrix\" else \"lgRMatrix\"\n    if (ans_type != x_type)\n        storage.mode(x) <- ans_type\n    new(ans_class, Dim=dim, p=p, j=j, x=x, Dimnames=ans_dimnames)\n}\n\n### 'i' and 'j' must be **parallel** integer vectors containing 0-based row\n### and column indices, respectively.\n### Returns a dgTMatrix, lgTMatrix, or ngTMatrix (depends on 'typeof(x)').\nnew_TsparseMatrix <- function(dim, i, j, x=NULL, dimnames=NULL)\n{\n    stopifnot(is.integer(dim), length(dim) == 2L)\n    ans_dimnames <- S4Arrays:::normarg_dimnames(dimnames, dim)\n    if (is.null(x))\n        return(new(\"ngTMatrix\", Dim=dim, i=i, j=j, Dimnames=ans_dimnames))\n    x_type <- typeof(x)\n    ans_type <- .infer_sparseMatrix_type_from_input_type(x_type)\n    ans_class <- if (ans_type == \"double\") \"dgTMatrix\" else \"lgTMatrix\"\n    if (ans_type != x_type)\n        storage.mode(x) <- ans_type\n    new(ans_class, Dim=dim, i=i, j=j, x=x, Dimnames=ans_dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### High-level [C|R|T]sparseMatrix constructors\n###\n### For the 3 constructors:\n### - 'i' and 'j' must be **parallel** integer vectors that contain 1-based\n###   row and column indices, respectively.\n### - 'nzdata' must be NULL or an atomic vector **parallel** to 'i' and 'j'.\n###   Its type must be \"double\", \"integer\", \"raw\", or \"logical\". It should\n###   not contain zeros (NAs are ok) but this is not checked.\n### - Each constructor takes care of removing triplets with duplicated (i,j)\n###   coordinates from the supplied (i,j,nzdata) triplets.\n###\n### NOT exported\n###\n\n.check_i_j_nzdata <- function(i, j, nzdata)\n{\n    stopifnot(is.integer(i), is.integer(j), length(i) == length(j))\n    if (!is.null(nzdata))\n        stopifnot(is.atomic(nzdata), length(nzdata) == length(i))\n}\n\n.drop_triplets_with_dup_i_j_pairs <- function(i, j, nzdata=NULL)\n{\n    .check_i_j_nzdata(i, j, nzdata)\n    dup_idx <- which(duplicatedIntegerPairs(i, j, fromLast=TRUE))\n    if (length(dup_idx) != 0L) {\n        i <- i[-dup_idx]\n        j <- j[-dup_idx]\n        if (!is.null(nzdata))\n            nzdata <- nzdata[-dup_idx]\n    }\n    list(i, j, nzdata)\n}\n\n### Note that this is a simplified version of Matrix::sparseMatrix() that\n### will typically be 50%-60% faster and more memory efficient.\nCsparseMatrix <- function(dim, i, j, nzdata=NULL, dimnames=NULL)\n{\n    stopifnot(is.integer(dim), length(dim) == 2L)\n    triplets <- .drop_triplets_with_dup_i_j_pairs(i, j, nzdata=nzdata)\n    i <- triplets[[1L]]\n    j <- triplets[[2L]]\n    nzdata <- triplets[[3L]]\n    oo <- orderIntegerPairs(j, i)\n    ans_p <- c(0L, cumsum(tabulate(j[oo], nbins=dim[[2L]])))\n    ans_i <- i[oo] - 1L  # new_CsparseMatrix() wants this 0-based\n    ans_x <- if (is.null(nzdata)) NULL else nzdata[oo]\n    new_CsparseMatrix(dim, ans_p, ans_i, x=ans_x, dimnames=dimnames)\n}\n\nRsparseMatrix <- function(dim, i, j, nzdata=NULL, dimnames=NULL)\n{\n    stopifnot(is.integer(dim), length(dim) == 2L)\n    triplets <- .drop_triplets_with_dup_i_j_pairs(i, j, nzdata=nzdata)\n    i <- triplets[[1L]]\n    j <- triplets[[2L]]\n    nzdata <- triplets[[3L]]\n    oo <- orderIntegerPairs(i, j)\n    ans_p <- c(0L, cumsum(tabulate(i[oo], nbins=dim[[1L]])))\n    ans_j <- j[oo] - 1L  # new_RsparseMatrix() wants this 0-based\n    ans_x <- if (is.null(nzdata)) NULL else nzdata[oo]\n    new_RsparseMatrix(dim, ans_p, ans_j, x=ans_x, dimnames=dimnames)\n}\n\n### Besides optional removal of the triplets with duplicated (i,j) coordinates,\n### the supplied (i,j,nzdata) triplets are stored as-is in the returned\n### TsparseMatrix object, that is, their original order is preserved.\nTsparseMatrix <- function(dim, i, j, nzdata=NULL, dimnames=NULL, drop.dups=TRUE)\n{\n    stopifnot(is.integer(dim), length(dim) == 2L, isTRUEorFALSE(drop.dups))\n    if (drop.dups) {\n        triplets <- .drop_triplets_with_dup_i_j_pairs(i, j, nzdata=nzdata)\n        i <- triplets[[1L]]\n        j <- triplets[[2L]]\n        nzdata <- triplets[[3L]]\n    } else {\n        .check_i_j_nzdata(i, j, nzdata)\n    }\n    new_TsparseMatrix(dim, i - 1L, j - 1L, x=nzdata, dimnames=dimnames)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Critically endangered coercions from/to sparseMatrix derivatives\n###\n### This simply brings back some basic coercion methods originally defined\n### in the Matrix package but that the lazy Matrix maintainers have decided\n### to eradicate from the surface of Earth in a shocking attempt at making\n### their users lives miserable.\n###\n\n### --- from ordinary matrix to [d|l|n]gCMatrix and [d|l|n]gRMatrix ---\n\n### Not deprecated yet. Cold feet maybe?\n#setAs(\"matrix\", \"dgCMatrix\",\n#    function(from)\n#        as(as(as(from, \"dMatrix\"), \"generalMatrix\"), \"CsparseMatrix\")\n#)\n\n### Deprecated in Matrix 1.7-0\nsetAs(\"matrix\", \"dgRMatrix\",\n    function(from)\n        as(as(as(from, \"dMatrix\"), \"generalMatrix\"), \"RsparseMatrix\")\n)\n\n### Deprecated in Matrix 1.7-0\nsetAs(\"matrix\", \"lgCMatrix\",\n    function(from)\n        as(as(as(from, \"lMatrix\"), \"generalMatrix\"), \"CsparseMatrix\")\n)\n\n### Never supported by Matrix?\nsetAs(\"matrix\", \"lgRMatrix\",\n    function(from)\n        as(as(as(from, \"lMatrix\"), \"generalMatrix\"), \"RsparseMatrix\")\n)\n\n### Deprecated in Matrix 1.7-0\nsetAs(\"matrix\", \"ngCMatrix\",\n    function(from)\n        as(as(as(from, \"nMatrix\"), \"generalMatrix\"), \"CsparseMatrix\")\n)\n\n### Never supported by Matrix?\nsetAs(\"matrix\", \"ngRMatrix\",\n    function(from)\n        as(as(as(from, \"nMatrix\"), \"generalMatrix\"), \"RsparseMatrix\")\n)\n\n### --- other useful coercions ---\n\n### Deprecated in Matrix 1.7-0\nsetAs(\"dgCMatrix\", \"ngCMatrix\", function(from) as(from, \"nMatrix\"))\n\n### Never supported by Matrix?\nsetAs(\"CsparseMatrix\", \"ngCMatrix\", function(from) as(from, \"nMatrix\"))\nsetAs(\"RsparseMatrix\", \"ngRMatrix\", function(from) as(from, \"nMatrix\"))\nsetAs(\"TsparseMatrix\", \"ngTMatrix\", function(from) as(from, \"nMatrix\"))\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Coercion from Array derivative to sparseMatrix derivative\n###\n\n### These coercions will work out-of-the-box on any Array derivative that\n### supports coercion to SparseMatrix.\n.from_Array_to_sparseMatrix <- function(from, to)\n{\n    ## If 'from' is a SparseMatrix derivative then 'as(from, \"SparseMatrix\")'\n    ## will be a no-op. Therefore doing 'as(as(from, \"SparseMatrix\"), to)'\n    ## below will lead to an infinite recursion. We explicitly guard against\n    ## this.\n    if (is(from, \"SparseMatrix\"))\n        stop(wmsg(\"coercion from \", class(from), \" to \",\n                  to, \" is not supported\"))\n    ## Early nzcount check:\n    ## Note that we use two successive coercions below, and, if the object\n    ## to coerce has >= 2^31 nonzero values, then only the 2nd coercion will\n    ## fail. The idea of the early nzcount check is to fail before the\n    ## possibly costly coercion to SparseMatrix (1st coercion) rather than\n    ## after it. However, we want to do this only if the object is sparse,\n    ## because if it's not, then nzcount() is not guaranteed to be efficient.\n    ## [A few days later...]\n    ## Well, not such a good idea after all, because nzcount() can be quite\n    ## costly **even** if the object to coerce is sparse. For example, on\n    ## a sparse DelayedMatrix, object nzcount() will typically trigger block\n    ## processing, and that will be **way more costly** than the coercion to\n    ## SparseMatrix (1st coercion).\n    ## Also note that we shouldn't even waste our time doing the early nzcount\n    ## check if 'from' is not matrix-like (i.e. if it doesn't have exactly\n    ## 2 dimensions). Instead we should fail immediately.\n    #if (is_sparse(from)) {\n    #    from_nzcount <- nzcount(from)\n    #    if (from_nzcount > .Machine$integer.max)\n    #        stop(wmsg(class(from)[[1L]], \" object contains too many \",\n    #                  \"nonzero values (\", from_nzcount, \") to \\\"fit\\\" in \",\n    #                  \"a \" , to, \" object\"))\n    #}\n    as(as(from, \"SparseMatrix\"), to)\n}\n\nsetAs(\"Array\", \"dgCMatrix\",\n    function(from) .from_Array_to_sparseMatrix(from, \"dgCMatrix\")\n)\nsetAs(\"Array\", \"dgRMatrix\",\n    function(from) .from_Array_to_sparseMatrix(from, \"dgRMatrix\")\n)\nsetAs(\"Array\", \"lgCMatrix\",\n    function(from) .from_Array_to_sparseMatrix(from, \"lgCMatrix\")\n)\nsetAs(\"Array\", \"lgRMatrix\",\n    function(from) .from_Array_to_sparseMatrix(from, \"lgRMatrix\")\n)\nsetAs(\"Array\", \"ngCMatrix\",\n    function(from) .from_Array_to_sparseMatrix(from, \"ngCMatrix\")\n)\nsetAs(\"Array\", \"ngRMatrix\",\n    function(from) .from_Array_to_sparseMatrix(from, \"ngRMatrix\")\n)\n\n### These coercions will work out-of-the-box on any Array derivative that\n### supports type() and coercion to [d|l]gCMatrix, [d|l]gRMatrix, and\n### [d|l]gTMatrix, respectively.\nsetAs(\"Array\", \"CsparseMatrix\",\n    function(from)\n    {\n        ans_type <- .infer_sparseMatrix_type_from_input_type(type(from))\n        ans_class <- if (ans_type == \"double\") \"dgCMatrix\" else \"lgCMatrix\"\n        as(from, ans_class)\n    }\n)\nsetAs(\"Array\", \"RsparseMatrix\",\n    function(from)\n    {\n        ans_type <- .infer_sparseMatrix_type_from_input_type(type(from))\n        ans_class <- if (ans_type == \"double\") \"dgRMatrix\" else \"lgRMatrix\"\n        as(from, ans_class)\n    }\n)\nsetAs(\"Array\", \"TsparseMatrix\",\n    function(from)\n    {\n        ans_type <- .infer_sparseMatrix_type_from_input_type(type(from))\n        ans_class <- if (ans_type == \"double\") \"dgTMatrix\" else \"lgTMatrix\"\n        as(from, ans_class)\n    }\n)\n\n### We give the preference to the CsparseMatrix representation (compressed\n### column-oriented form).\nsetAs(\"Array\", \"sparseMatrix\",\n    function(from) as(from, \"CsparseMatrix\")\n)\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### colMins_dgCMatrix()\n### colMaxs_dgCMatrix()\n### colRanges_dgCMatrix()\n### colVars_dgCMatrix()\n###\n### NOT exported\n###\n### IMPORTANT NOTE: The functions below precede the sparseMatrixStats package\n### so we probaby don't need them anymore. Do NOT turn them into formal S4\n### methods for dgCMatrix objects to avoid conflicts with the methods defined\n### in the sparseMatrixStats package!\n### They do NOT propagate the colnames. The corresponding methods defined in\n### matrixStats didn't either at the time this was implemented.\n\ncolMins_dgCMatrix <- function (x, na.rm=FALSE)\n{\n    stopifnot(is(x, \"dgCMatrix\"))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    SparseArray.Call(\"C_colMins_dgCMatrix\", x, na.rm)\n}\n\ncolMaxs_dgCMatrix <- function (x, na.rm=FALSE)\n{\n    stopifnot(is(x, \"dgCMatrix\"))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    SparseArray.Call(\"C_colMaxs_dgCMatrix\", x, na.rm)\n}\n\n### About 2x faster than the method for dgCMatrix objects defined\n### in sparseMatrixStats.\ncolRanges_dgCMatrix <- function (x, na.rm=FALSE)\n{\n    stopifnot(is(x, \"dgCMatrix\"))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    SparseArray.Call(\"C_colRanges_dgCMatrix\", x, na.rm)\n}\n\n### About 2.5x faster than the method for dgCMatrix objects defined\n### in sparseMatrixStats.\ncolVars_dgCMatrix <- function(x, na.rm=FALSE)\n{\n    stopifnot(is(x, \"dgCMatrix\"))\n    if (!isTRUEorFALSE(na.rm))\n        stop(wmsg(\"'na.rm' must be TRUE or FALSE\"))\n    SparseArray.Call(\"C_colVars_dgCMatrix\", x, na.rm)\n}\n\n",
        "thread-control.R": "### =========================================================================\n### OpenMP thread control\n### -------------------------------------------------------------------------\n###\n\n\n.normarg_nthread <- function(nthread)\n{\n    if (!isSingleNumber(nthread))\n        stop(wmsg(\"'nthread' must be a single number\"))\n    if (!is.integer(nthread))\n        nthread <- as.integer(nthread)\n    nthread\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### R wrappers to OpenMP thread control functions\n###\n\n### Wrapper to omp_get_num_procs().\n### Returns 0 if OpenMP is not available (e.g. on macOS).\n.get_num_procs <- function()\n    .Call2(\"C_get_num_procs\", PACKAGE=\"SparseArray\")\n\n### Wrapper to omp_get_max_threads().\n### Default is controlled by environment variable OMP_NUM_THREADS.\n### Returns 0 if OpenMP is not available (e.g. on macOS).\n.get_max_threads <- function()\n    .Call2(\"C_get_max_threads\", PACKAGE=\"SparseArray\")\n\n### Wrapper to omp_set_num_threads().\n### No-op if OpenMP is not available (e.g. on macOS).\n### Returns previous omp_get_max_threads() value.\n.set_max_threads <- function(nthread)\n{\n    nthread <- .normarg_nthread(nthread)\n    .Call2(\"C_set_max_threads\", nthread, PACKAGE=\"SparseArray\")\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### Get/set SparseArray option \"nthread\"\n###\n\n.default_SparseArray_nthread <- function()\n{\n    nthread <- .get_max_threads()\n    if (nthread == 0L)\n        return(nthread)\n    n <- .get_num_procs() %/% 3L\n    if (nthread > n)\n        nthread <- n\n    if (nthread == 0L)\n        nthread <- 1L\n    nthread\n}\n\nget_SparseArray_nthread <- function()\n{\n    default <- .default_SparseArray_nthread()\n    nthread <- get_SparseArray_option(\"nthread\", default=default)\n    if (!isSingleNumber(nthread) || nthread < 0L)\n        warning(wmsg(\"invalid 'getOption(\\\"SparseArray\\\")$nthread'\"))\n    nthread\n}\n\nset_SparseArray_nthread <- function(nthread=NULL)\n{\n    if (.get_max_threads() == 0L) {\n        nthread <- 0L\n    } else if (is.null(nthread)) {\n        nthread <- .default_SparseArray_nthread()\n    } else {\n        nthread <- .normarg_nthread(nthread)\n        if (nthread < 1L)\n            stop(wmsg(\"'nthread' must be >= 1\"))\n    }\n    set_SparseArray_option(\"nthread\", nthread)\n}\n\n\n### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n### SparseArray.Call()\n###\n\nSparseArray.Call <- function(.NAME, ...)\n{\n    prev_max_threads <- .set_max_threads(get_SparseArray_nthread())\n    on.exit(.set_max_threads(prev_max_threads))\n    .Call2(.NAME, ..., PACKAGE=\"SparseArray\")\n}\n\n",
        "utils.R": "\n### A silly trick used only to trigger an error when the function is called\n### with no arguments.\ncheck_unused_arguments <- function() NULL\n\nvector_of_zeros <- function(mode=\"logical\", length=0L)\n{\n    vector(mode=mode, length=length)\n}\n\nvector_of_ones <- function(mode=\"logical\", length=0L)\n{\n    as.fun <- base::get(paste0(\"as.\", mode), envir=asNamespace(\"base\"),\n                        mode=\"function\")\n    rep.int(as.fun(1L), length)\n}\n\ncoercion_can_introduce_zeros <- function(from_type, to_type)\n{\n    if (!isSingleString(from_type))\n        stop(wmsg(\"'from_type' must be a single string\"))\n    if (!isSingleString(to_type))\n        stop(wmsg(\"'to_type' must be a single string\"))\n    if (!(to_type %in% c(\"double\", \"logical\")))\n        stop(wmsg(\"'to_type' must be \\\"double\\\" or \\\"logical\\\"\"))\n    .Call2(\"C_coercion_can_introduce_zeros\", from_type, to_type,\n                                             PACKAGE=\"SparseArray\")\n}\n\ncoercion_can_introduce_NAs <- function(from_type, to_type)\n{\n    if (!isSingleString(from_type))\n        stop(wmsg(\"'from_type' must be a single string\"))\n    if (!isSingleString(to_type))\n        stop(wmsg(\"'to_type' must be a single string\"))\n    .Call2(\"C_coercion_can_introduce_NAs\", from_type, to_type,\n                                           PACKAGE=\"SparseArray\")\n}\n\n",
        "zzz.R": ".onLoad <- function(libname, pkgname)\n{\n    if (!SparseArray_option_is_set(\"nthread\"))\n        set_SparseArray_nthread()\n}\n\n.onUnload <- function(libpath)\n{\n    library.dynam.unload(\"SparseArray\", libpath)\n}\n\n"
    }
}